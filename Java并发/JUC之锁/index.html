<!DOCTYPE html>
<html lang=en>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>JUC之锁 | Blog Of TheMasterplan</title>
  <meta name="description" content="OverView锁相关类关系图：  锁概述乐观锁与悲观锁乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。 悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。 乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁">
<meta property="og:type" content="article">
<meta property="og:title" content="JUC之锁">
<meta property="og:url" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/index.html">
<meta property="og:site_name" content="TheMasterplan">
<meta property="og:description" content="OverView锁相关类关系图：  锁概述乐观锁与悲观锁乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。 悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。 乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/java-thread-x-juc-overview-lock.png">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/juc_locks.png">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/AQS_UML.png">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/template_method.png">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/AQS.png">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/ReentrantLock_UML.png">
<meta property="og:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/ReentrantReadWriteLock_UML.png">
<meta property="article:published_time" content="2020-09-21T05:25:08.000Z">
<meta property="article:modified_time" content="2020-10-11T13:11:55.998Z">
<meta property="article:author" content="LSJ">
<meta property="article:tag" content="Java并发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/java-thread-x-juc-overview-lock.png">
  <!-- Canonical links -->
  <link rel="canonical" href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/index.html">
  
    <link rel="alternate" href="/atom.xml" title="TheMasterplan" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
    <link href="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.css" rel="stylesheet">
  
  
<meta name="generator" content="Hexo 4.2.1"></head>


<body class="main-center theme-white" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/Laishiji" target="_blank">
          <img class="img-circle img-rotate" src="/images/avatar.jpg" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">TheMasterplan</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">Java Developer</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="Search" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="Type something..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">Home</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">Archives</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">Categories</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">Repository</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-about">
          <a href="/about">
            
            <i class="icon icon-cup-fill"></i>
            
            <span class="menu-title">About</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Laishiji" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">Board</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎访问~</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">Categories</h3>
    <div class="widget-body">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JVM/">JVM</a><span class="category-list-count">4</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaWeb/">JavaWeb</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%9F%BA%E7%A1%80/">Java基础</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%AE%B9%E5%99%A8/">Java容器</a><span class="category-list-count">8</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a><span class="category-list-count">12</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Java%E6%A1%86%E6%9E%B6/">Java框架</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Linux/">Linux</a><span class="category-list-count">9</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/Others/">Others</a><span class="category-list-count">5</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/">数据结构与算法</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/">软件工程</a><span class="category-list-count">3</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/">面试刷题</a><span class="category-list-count">7</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/">项目优化</a><span class="category-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/CentOS7/" style="font-size: 13.89px;">CentOS7</a> <a href="/tags/Git/" style="font-size: 13px;">Git</a> <a href="/tags/JVM/" style="font-size: 13.33px;">JVM</a> <a href="/tags/JavaWeb/" style="font-size: 13.67px;">JavaWeb</a> <a href="/tags/Java%E5%9F%BA%E7%A1%80/" style="font-size: 13.67px;">Java基础</a> <a href="/tags/Java%E5%AE%B9%E5%99%A8/" style="font-size: 13.78px;">Java容器</a> <a href="/tags/Java%E5%B9%B6%E5%8F%91/" style="font-size: 14px;">Java并发</a> <a href="/tags/Maven/" style="font-size: 13px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 13.11px;">MyBatis</a> <a href="/tags/Others/" style="font-size: 13.33px;">Others</a> <a href="/tags/Spring/" style="font-size: 13.44px;">Spring</a> <a href="/tags/SpringBoot/" style="font-size: 13px;">SpringBoot</a> <a href="/tags/leetcode/" style="font-size: 13.56px;">leetcode</a> <a href="/tags/lintcode/" style="font-size: 13px;">lintcode</a> <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/" style="font-size: 13.11px;">数据结构与算法</a> <a href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/" style="font-size: 13px;">设计模式</a> <a href="/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/" style="font-size: 13.11px;">软件工程</a> <a href="/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/" style="font-size: 13.22px;">项目优化</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">Archive</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/11/">November 2020</a><span class="archive-list-count">4</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/10/">October 2020</a><span class="archive-list-count">11</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/09/">September 2020</a><span class="archive-list-count">24</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/08/">August 2020</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/04/">April 2020</a><span class="archive-list-count">12</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/03/">March 2020</a><span class="archive-list-count">7</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/02/">February 2020</a><span class="archive-list-count">6</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/12/">December 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/11/">November 2019</a><span class="archive-list-count">10</span></li></ul>
    </div>
  </div>


    
  </div>
</aside>

  
  
<aside class="sidebar sidebar-toc collapse" id="collapseToc" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    <nav id="toc" class="article-toc">
      <h3 class="toc-title">Catalogue</h3>
      <ol class="toc"><li class="toc-item toc-level-3"><a class="toc-link" href="#OverView"><span class="toc-number">1.</span> <span class="toc-text">OverView</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#锁概述"><span class="toc-number">2.</span> <span class="toc-text">锁概述</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#乐观锁与悲观锁"><span class="toc-number">2.1.</span> <span class="toc-text">乐观锁与悲观锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#公平锁与非公平锁"><span class="toc-number">2.2.</span> <span class="toc-text">公平锁与非公平锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#独占锁与共享锁"><span class="toc-number">2.3.</span> <span class="toc-text">独占锁与共享锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#可重入锁"><span class="toc-number">2.4.</span> <span class="toc-text">可重入锁</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#自旋锁"><span class="toc-number">2.5.</span> <span class="toc-text">自旋锁</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LockSupport"><span class="toc-number">3.</span> <span class="toc-text">LockSupport</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#Unsafe的park和unpark方法"><span class="toc-number">3.1.</span> <span class="toc-text">Unsafe的park和unpark方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park"><span class="toc-number">3.2.</span> <span class="toc-text">park()</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#park-Object-blocker"><span class="toc-number">3.3.</span> <span class="toc-text">park(Object blocker)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parkNanos-long-nanos"><span class="toc-number">3.4.</span> <span class="toc-text">parkNanos(long nanos)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#parkUntil-Object-blocker-long-deadline"><span class="toc-number">3.5.</span> <span class="toc-text">parkUntil(Object blocker, long deadline)</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#unpark-Thread-thread"><span class="toc-number">3.6.</span> <span class="toc-text">unpark(Thread thread)</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#AQS"><span class="toc-number">4.</span> <span class="toc-text">AQS</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类图结构"><span class="toc-number">4.1.</span> <span class="toc-text">类图结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#AQS概述"><span class="toc-number">4.2.</span> <span class="toc-text">AQS概述</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#队列"><span class="toc-number">4.2.1.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#state变量"><span class="toc-number">4.2.2.</span> <span class="toc-text">state变量</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#锁的底层支持"><span class="toc-number">4.3.</span> <span class="toc-text">锁的底层支持</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#AbstractOwnableSynchronizer"><span class="toc-number">4.3.1.</span> <span class="toc-text">AbstractOwnableSynchronizer</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#独占锁-ReentrantLock与WriteLock"><span class="toc-number">4.3.2.</span> <span class="toc-text">独占锁-ReentrantLock与WriteLock</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#共享锁-ReadLock"><span class="toc-number">4.3.3.</span> <span class="toc-text">共享锁-ReadLock</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#条件变量ConditionObejct"><span class="toc-number">4.4.</span> <span class="toc-text">条件变量ConditionObejct</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantLock详解"><span class="toc-number">5.</span> <span class="toc-text">ReentrantLock详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类图结构-1"><span class="toc-number">5.1.</span> <span class="toc-text">类图结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#获取锁"><span class="toc-number">5.2.</span> <span class="toc-text">获取锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#void-lock-方法"><span class="toc-number">5.2.1.</span> <span class="toc-text">void lock()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#void-lockInterruptibly-方法"><span class="toc-number">5.2.2.</span> <span class="toc-text">void lockInterruptibly()方法</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#boolean-tryLock-方法"><span class="toc-number">5.2.3.</span> <span class="toc-text">boolean tryLock()方法</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#释放锁"><span class="toc-number">5.3.</span> <span class="toc-text">释放锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#void-unlock-方法"><span class="toc-number">5.3.1.</span> <span class="toc-text">void unlock()方法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ReentrantReadWriteLock详解"><span class="toc-number">6.</span> <span class="toc-text">ReentrantReadWriteLock详解</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类图结构-2"><span class="toc-number">6.1.</span> <span class="toc-text">类图结构</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#写锁"><span class="toc-number">6.2.</span> <span class="toc-text">写锁</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#下面只介绍tryAcquire方法"><span class="toc-number">6.2.1.</span> <span class="toc-text">下面只介绍tryAcquire方法</span></a></li></ol></li></ol></li></ol>
    </nav>
  </div>
</aside>

<main class="main" role="main">
  <div class="content">
  <article id="post-JUC之锁" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      JUC之锁
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/" class="article-date">
	  <time datetime="2020-09-21T05:25:08.000Z" itemprop="datePublished">2020-09-21</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/Java%E5%B9%B6%E5%8F%91/">Java并发</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link" href="/tags/Java%E5%B9%B6%E5%8F%91/" rel="tag">Java并发</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/#comments" class="article-comment-link">Comments</a></span>
        
	
		<span class="post-wordcount hidden-xs" itemprop="wordCount">Word Count: 4.7k(words)</span>
	
	

      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>锁相关类关系图：</p>
<p><img src="java-thread-x-juc-overview-lock.png" alt=""></p>
<h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。</p>
<p>悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。</p>
<p>乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁，在事务提交时才检测是否存在冲突。乐观锁的实现一般是在表中添加version字段或者使用业务状态。</p>
<h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>公平锁表示线程获取锁的顺序是按照线程请求锁的时间顺序来决定，而非公平锁则按调度策略决定。在没有公平性需求的前提下尽量使用非公平锁，因为公平锁开销较大。</p>
<p>ReentrantLock提供了公平锁和非公平锁。</p>
<p>公平锁：<code>ReentrantLock pairLock = new ReentrantLock(true);</code></p>
<p>非公平锁：<code>ReentrantLock pairLock = new ReentrantLock(false);</code>。如果构造函数不传递参数，则默认为false。</p>
<h4 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h4><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。</p>
<p>独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是独占锁。独占锁是一种悲观锁，由于读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，因此限制了并发性。</p>
<p>共享锁则可以同时多个线程持有，例如ReadWriteLock。共享锁是一种乐观锁，它允许多个线程同时进行读操作。</p>
<h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>一个线程再次获取它自己已经获取的锁时不会被阻塞，那么该锁就是可重入锁。synchronized锁和ReentrantLock均为可重入锁。</p>
<p>可重入锁的原理是在锁内部维护一个线程标识和一个计数器。计数器初始值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁，计数器值+1。当获取了该锁的线程再次获取锁时发现线程标识是自己，计数器值再+1。释放一次锁则计数器值-1。当计数器值为0时，线程标识置null，阻塞线程被唤醒竞争该锁。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁的思想是<strong>让一个线程在请求一个共享数据的锁时执行忙循环</strong>（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。可以通过<code>-XX:PreBlockSpinsh</code>设置尝试次数，默认为10次。</p>
<p>JDK层面的锁由java.util.concurrent.locks包提供，其接口和类如下图所示：</p>
<p><img src="juc_locks.png" alt=""></p>
<h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport类是个工具类，其主要作用是挂起和唤醒线程，它是创建锁和其他同步类的基础。</p>
<p>LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport的方法的线程是<strong>不</strong>持有许可证的。该类是使用Unsafe类实现的。</p>
<p>LockSupport的构造方法为私有构造方法，无法被实例化，其方法基本为静态方法。</p>
<h4 id="Unsafe的park和unpark方法"><a href="#Unsafe的park和unpark方法" class="headerlink" title="Unsafe的park和unpark方法"></a>Unsafe的park和unpark方法</h4><p>因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br></pre></td></tr></table></figure>
<p>对两个函数的说明如下:</p>
<ul>
<li>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，给予该线程许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li>
<li>unpark函数，给予线程许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li>
</ul>
<h4 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h4><p>初次调用该方法后，当前线程挂起。</p>
<p>由于可能存在虚假唤醒的情况，所以调用时最好也使用循环条件判断方式。</p>
<p>如当前线程被其他线程中断，不会抛出InterruptedException。</p>
<h4 id="park-Object-blocker"><a href="#park-Object-blocker" class="headerlink" title="park(Object blocker)"></a>park(Object blocker)</h4><p>Thread类中有个变量<code>volatile Object parkBlocker</code>，用于存放该方法传递的blocker对象，也就是把blocker变量存放到了调用该方法的线程成员变量中。</p>
<p>使用该类的好处是，方便使用诊断工具查看阻塞原因。</p>
<h4 id="parkNanos-long-nanos"><a href="#parkNanos-long-nanos" class="headerlink" title="parkNanos(long nanos)"></a>parkNanos(long nanos)</h4><p>与park()的不同仅在于会在nanos时间之后自动返回。</p>
<h4 id="parkUntil-Object-blocker-long-deadline"><a href="#parkUntil-Object-blocker-long-deadline" class="headerlink" title="parkUntil(Object blocker, long deadline)"></a>parkUntil(Object blocker, long deadline)</h4><p>在指定的时间内阻塞线程。deadline单位是ms，表示从1970到未来某个时刻的总毫秒数。</p>
<h4 id="unpark-Thread-thread"><a href="#unpark-Thread-thread" class="headerlink" title="unpark(Thread thread)"></a>unpark(Thread thread)</h4><p>调用该方法后，如果线程没有持有与LockSupport关联的许可证，则使shi线程持有。如果线程已经因park()而挂起，则唤醒线程。若unpark()调用前未调用过park()，那么由于线程持有许可证，再次调用park()后线程不会挂起并失去许可证。</p>
<p>注意：park()方法不会释放锁，ConditionObject的await()会释放锁，并且该await()方法挂起线程就是使用park()实现的。</p>
<h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称抽象队列同步器(AbstractQueuedSynchronizer)，它是实现JDK层面锁的基础组件，locks包ReentrantLock和ReentrantReadWriteLock均由AQS实现，同时CountDownLatch与Semaphore也是由AQS实现。</p>
<h4 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="AQS_UML.png" alt=""></p>
<p>由该图可知AQS继承自AbstractOwnableSynchronizer，并有内部类ConditionObject和Node。AQS的核心是<strong>state变量</strong>与<strong>队列</strong>，它的所有实现类都是围绕着对此二者的操作来进行的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure>
<h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>AQS是一个FIFO的双向队列，该队列用于<strong>存放竞争资源失败的线程</strong>，队列元素为Node。Node中的thread变量用来存放进入AQS队列的线程，<strong>SHARED</strong>用于<strong>标记线程是获取共享资源时失败而放入AQS队列</strong>的，<strong>EXCLUSIVE</strong>则用于<strong>标记线程是获取独占资源时失败而放入AQS队列的</strong>，<strong>waitStatus</strong>记录<strong>线程等待状态</strong>，可以取如下值：</p>
<ol>
<li><strong>SIGNAL=-1</strong>：线程需要被唤醒。</li>
<li><strong>CONDITION=-2</strong>：线程在条件队列(ConditionObject)中等待，而非AQS队列。</li>
<li><strong>CANCELLED=1</strong>：线程被取消了。</li>
<li><strong>PROPAGATE=-3</strong>：释放共享资源时需要通知其他节点。</li>
<li>0：线程新加入队列。</li>
</ol>
<h5 id="state变量"><a href="#state变量" class="headerlink" title="state变量"></a>state变量</h5><p>在AQS中维持了一个状态值state变量，<strong>AQS的不同实现中对state含义的定义均不同</strong>。JUC中的实现主要如下：</p>
<ol>
<li>ReentrantLock：state为0表示没有线程获取锁，大于1的整数表示线程获取锁的可重入次数。</li>
<li>ReentrantReadWriteLock：state的高16位表示读锁的的个数，低16位表示线程获取写锁的可重入次数。</li>
<li>Semaphore：state表示当前可用信号的个数。</li>
<li>CountDownLatch：state表示计数器当前的值。</li>
</ol>
<p>操作state的方式分为<strong>独占方式</strong>和<strong>共享方式</strong>，两种方式获取和释放资源使用的方法分别为：</p>
<ul>
<li>独占：void acquire(int arg);  void acquireInterruptibly(int arg);  boolean release(int arg)。</li>
<li>共享：void acquireShared(int arg);  void acquireSharedInterruptibly(int arg);  boolean release(int arg)。</li>
</ul>
<p>在上述方法中调用了一系列<strong>需要实现类自己实现的模板方法</strong>，一共有以下五个：</p>
<p><img src="template_method.png" alt=""></p>
<h4 id="锁的底层支持"><a href="#锁的底层支持" class="headerlink" title="锁的底层支持"></a>锁的底层支持</h4><h5 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h5><p>该抽象类中定义了一个变量</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure>
<p>表示<strong>独占模式下当前占有锁和资源的线程</strong>。</p>
<h5 id="独占锁-ReentrantLock与WriteLock"><a href="#独占锁-ReentrantLock与WriteLock" class="headerlink" title="独占锁-ReentrantLock与WriteLock"></a>独占锁-ReentrantLock与WriteLock</h5><p>对于AQS独占锁，当多个线程同时调用lock.lock()获取锁，只有一个线程获取到锁，其他线程会被转换为Node节点插入到lock锁对应的AQS队列中，并做自旋CAS尝试获取锁，尝试失败后阻塞。“自旋CAS/阻塞”的操作在acquireQueued()和doAcquire*()系列方法中实现。</p>
<p>线程通过调用acquire(int arg)获取独占资源，<strong>void acquire(int arg)源码</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tryAcquire()尝试CAS修改state值获取锁，若成功则表达式<code>!tryAcquire(arg)</code>为false，&amp;&amp;后的表达式无需继续执行，方法直接结束；若失败，则addWaiter()将当前线程封装为类型为NODE.EXCLUSIVE的Node节点插入AQS队列末尾，acquireQueued()方法中节点自旋CAS尝试获取锁，失败则阻塞。</p>
<p><strong>addWaiter方法源码</strong>如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//判断尾节点是否为null</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//通过CAS完成“tail = node”操作</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果tail为null, 说明当前节点为AQS队列第一个节点，再调用enq入AQS队列</span></span><br><span class="line">    <span class="comment">//或CAS设置tail失败，调用enq方法重新入队</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>enq方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//tail为空则设置当前节点为头(尾)节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//addWaiter中CAS设置tail失败，说明有其他线程竞争进入AQS队列</span></span><br><span class="line">                <span class="comment">//由for循环知，该方法会不断自旋直到当前节点入队成功</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>acquireQueued方法源码</strong>如下:</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//只有当前节点是队列中第二个节点时才重新tryAcquire</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">//满足一定条件则阻塞当前线程，停止自旋</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//获取前驱节点的等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//只有当前驱节点等待状态为SIGNAL时才能阻塞当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//取消前驱节点，跳过</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">            <span class="comment">//设置前驱节点的等待状态为SIGNAL，下一次当前节点线程就会阻塞，说明只会自旋一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//shouldParkAfterFailedAcquire返回true，阻塞当前线程，停止自旋，被唤醒后继续执行for循环</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>接下来讲release方法，该方法释放独占方式获取的锁和资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">//释放成功并且头节点不为空，头节点等待状态不为0</span></span><br><span class="line">            <span class="comment">//则唤醒后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h5 id="共享锁-ReadLock"><a href="#共享锁-ReadLock" class="headerlink" title="共享锁-ReadLock"></a>共享锁-ReadLock</h5><p>线程通过调用acquireShared方法获取共享资源：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，共享方式与独占方式实现类似。tryAcquireShared成功则直接返回，失败则入AQS阻塞队列尾部，自旋一次后阻塞挂起自己。releaseShared源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>释放锁成功则调用doReleaseShared唤醒阻塞队列的<strong>所有</strong>线程。</p>
<h4 id="条件变量ConditionObejct"><a href="#条件变量ConditionObejct" class="headerlink" title="条件变量ConditionObejct"></a>条件变量ConditionObejct</h4><p>ConditionObject实现了Condition接口，是AQS的内部类，其含义是<strong>条件变量</strong>，用于<strong>结合锁实现同步</strong>。</p>
<p>ConditionObject通过AQS锁对象的newCondition()创建(该方法是Lock接口的方法，需要实现类实现)，它可以直接访问AQS对象内部的变量，比如state值和队列。<strong>每个ConditionObject对应一个条件队列</strong>（单向链表队列），用于<strong>存放调用await()方法后被阻塞的线程</strong>，而signal()/signalAll()方法用于唤醒条件队列中阻塞的线程并将节点加入AQS队列。条件队列的队头、尾分别为firstWaiter和lastWaiter。</p>
<p>与synchronized内置锁不同，synchronized只能与一个共享变量的wait()或notify()方法实现同步，而AQS实现的<strong>一个锁可以创建多个ConditionObject</strong>。与wait()和notify()类似，<strong>调用条件变量的await()和signal()之前，必须先获取条件变量对应的锁</strong>，否则也会抛出IllegalMonitorStateException。条件变量使用示例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"begin wait"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">"end wait"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"begin signal"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(<span class="string">"end signal"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin wait</span><br><span class="line">begin signal</span><br><span class="line">end signal</span><br><span class="line">end wait</span><br></pre></td></tr></table></figure>
<p>注意，<strong>await()方法会释放锁</strong>，而<strong>signal()方法不会释放锁</strong>，<strong>必须手动调用锁对象的unlock()方法</strong>释放锁。await()源码如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//创建类型为Node.CONDITION的节点并加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放当前线程的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode =</span><br><span class="line">             checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//线程被唤醒后在AQS队列中，自旋CAS尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用await()后，在内部会构造一个类型为Node.CONDITION的节点并插入条件队列末尾，之后当前线程会释放锁（修改state的值），然后通过LockSupport阻塞当前线程。另一个线程调用signal()后，<strong>条件队列队头节点出队放入AQS队列的队尾，然后唤醒线程</strong>，该线程继续执行await()方法中<code>LockSupport.park(this)</code>之后的代码，调用acquireQueued()方法<strong>自旋CAS尝试获取锁</strong>。</p>
<p>最后总结如下图：一个锁对应一个AQS队列，对应多个条件变量，每个条件变量有自己的一个条件队列。</p>
<p><img src="AQS.png" alt=""></p>
<h3 id="ReentrantLock详解"><a href="#ReentrantLock详解" class="headerlink" title="ReentrantLock详解"></a>ReentrantLock详解</h3><h4 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ReentrantLock_UML.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由构造方法可知，默认是创建非公平锁。</p>
<h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><h5 id="void-lock-方法"><a href="#void-lock-方法" class="headerlink" title="void lock()方法"></a>void lock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.lock();&#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁成功则设置当前线程为独占线程，失败则调用AQS的acquire方法</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非公平锁的体现：如果state为0，不考虑是否有前驱节点，直接CAS获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="comment">//state不为0，但是当前线程是独占线程，则仅仅+1</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;acquire(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//公平锁体现：先检测是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="void-lockInterruptibly-方法"><a href="#void-lockInterruptibly-方法" class="headerlink" title="void lockInterruptibly()方法"></a>void lockInterruptibly()方法</h5><p>该方法对中断进行响应，也即当前线程调用该方法时，如果其他线程调用了当前线程的interrupt方法，则当前线程会抛出InterruptedException异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;sync.acquireInterruptibly(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="boolean-tryLock-方法"><a href="#boolean-tryLock-方法" class="headerlink" title="boolean tryLock()方法"></a>boolean tryLock()方法</h5><p>尝试获取锁。若该方法失败当前线程不会入AQS队列，也不会阻塞。</p>
<h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><h5 id="void-unlock-方法"><a href="#void-unlock-方法" class="headerlink" title="void unlock()方法"></a>void unlock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ReentrantReadWriteLock详解"><a href="#ReentrantReadWriteLock详解" class="headerlink" title="ReentrantReadWriteLock详解"></a>ReentrantReadWriteLock详解</h3><p>ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，来满足实际中写少读多的场景。</p>
<h4 id="类图结构-2"><a href="#类图结构-2" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ReentrantReadWriteLock_UML.png" alt=""></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由构造方法可知，默认创建非公平锁。</p>
<p>读写锁的内部维护了一个<em>ReadLock</em>和一个<em>WriteLock</em>，它们依赖继承自AQS的Sync实现具体功能。读写锁使用state的高16位表示读状态，也即读锁线程个数；低16位表示写锁的可重入次数。Sync类源码表现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;<span class="comment">//偏移值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//低16位为0，第17位为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁线程最大个数65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//低15位为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号右移16位，低16位变为原高16位值，原高16位填0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位与运算使高17位为0，低15位不变</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由源码可知，通过<strong>无符号右移</strong>获取读锁线程个数，通过<strong>与掩码按位与</strong>获取写锁可重入次数。</p>
<h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><h5 id="下面只介绍tryAcquire方法"><a href="#下面只介绍tryAcquire方法" class="headerlink" title="下面只介绍tryAcquire方法"></a>下面只介绍tryAcquire方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);<span class="comment">//获取写锁可重入次数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;<span class="comment">//说明读锁或写锁已被某线程获取</span></span><br><span class="line">        <span class="comment">//w=0说明有线程获取了读锁，w!=0并且当前线程不是写锁拥有者则返回</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//说明当前线程获取了写锁，判断可重入次数是否超过最大值</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">         setState(c + acquires);<span class="comment">//state+1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//c=0则根据writerShouldBlock的返回值判断是否执行CAS获取写锁</span></span><br><span class="line">     <span class="keyword">if</span> (writerShouldBlock() ||!compareAndSetState(c, c + acquires))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     setExclusiveOwnerThread(current);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于writerShouldBlock，非公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//判断是否有前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：ReentrantReadWriteLock在采用非公平锁并且在读多写少的情况下，容易导致写线程饥饿。可以使用公平锁或者采用<em>StampedLock</em>。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/" title="JUC之锁" target="_blank" rel="external">Blog of TheMasterplan</a>
    </li>

    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/Laishiji" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/avatar.jpg" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/Laishiji" target="_blank"><span class="text-dark">TheMasterplan</span><small class="ml-1x">Java Developer</small></a></h3>
        <div>練習時長兩年半のCV戰士</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
      <div id="lv-container" data-id="city" data-uid="MTAyMC80NzU5OS8yNDA5OQ==">
        <noscript> 为正常使用来必力评论功能请激活JavaScript</noscript>
      </div>    
    
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/" title="JUC容器之CopyOnWriteArrayList"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;Newer</span></a>
    </li>
    
    
    <li class="next">
      <a href="/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/" title="JUC之原子包"><span>Older&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
    <li class="toggle-toc">
      <a class="toggle-btn collapsed" data-toggle="collapse" href="#collapseToc" aria-expanded="false" title="Catalogue" role="button">
        <span>[&nbsp;</span><span>Catalogue</span>
        <i class="text-collapsed icon icon-anchor"></i>
        <i class="text-in icon icon-close"></i>
        <span>]</span>
      </a>
    </li>
    
  </ul>
  
  
  
  <div class="bar-right">
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/Laishiji" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
        <li><a href="/atom.xml" target="_blank" title="Rss" data-toggle=tooltip data-placement=top><i class="icon icon-rss"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        &copy; 2020 LSJ
        
    </div>
</footer>

  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: 'Posts',
            PAGES: 'Pages',
            CATEGORIES: 'Categories',
            TAGS: 'Tags',
            UNTITLED: '(Untitled)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   
    
<script defer type="text/javascript">
  (function(d, s) {
    var j, e = d.getElementsByTagName(s)[0];

    if (typeof LivereTower === 'function') { return; }

    j = d.createElement(s);
    j.src = 'https://cdn-city.livere.com/js/embed.dist.js';
    j.async = true;

    e.parentNode.insertBefore(j, e);
  })(document, 'script');
</script>




  <script src="//cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.3.5/dist/jquery.fancybox.min.js"></script>
  <script>
  //利用 FancyBox 实现点击图片放大
  $(document).ready(function() {
    $('article img').not('[hidden]').not('.panel-body img').each(function() {
      var $image = $(this);
      var imageCaption = $image.attr('alt');
      var $imageWrapLink = $image.parent('a');
      if ($imageWrapLink.length < 1) {
        var src = this.getAttribute('src');
        var idx = src.lastIndexOf('?');
        if (idx != -1) {
          src = src.substring(0, idx);
        }
        $imageWrapLink = $image.wrap('<a href="' + src + '"></a>').parent('a');
      }
      $imageWrapLink.attr('data-fancybox', 'images');
      if (imageCaption) {
        $imageWrapLink.attr('data-caption', imageCaption);
      }
    });
    $().fancybox({
      selector: '[data-fancybox="images"]',
      hash: false,
      loop: false,
    });
  });
  </script>





<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        tex2jax: {
            inlineMath: [ ["$","$"], ["\\(","\\)"] ],
            skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code'],
            processEscapes: true
        }
    });
    MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax();
        for (var i = 0; i < all.length; ++i)
            all[i].SourceElement().parentNode.className += ' has-jax';
    });
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-MML-AM_CHTML"></script>
<!-- <script src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script> -->

</body>
</html>