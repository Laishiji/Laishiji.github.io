{"meta":{"title":"TheMasterplan","subtitle":"TheMasterplan","description":"","author":"LSJ","url":"http://thmasterplan.cn","root":"/"},"pages":[{"title":"关于","date":"2020-09-09T05:18:01.539Z","updated":"2020-09-09T05:18:01.539Z","comments":false,"path":"about/index.html","permalink":"http://thmasterplan.cn/about/index.html","excerpt":"","text":"常用站点DocJavaEE7 Doc：https://docs.oracle.com/javaee/7/api/toc.htm JavaSE8 Doc：https://docs.oracle.com/javase/8/docs/api/index.html Spring Doc：https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/ BlogJava全栈：https://www.pdai.tech/md/java/basic/java-basic-oop.html JavaGuide：https://snailclimb.gitee.io/javaguide/#/ CS-Notes: https://cyc2018.github.io/CS-Notes/#/ JULY（算法）： https://blog.csdn.net/v_JULY_v/article/list/3 xieyuooo：https://blog.csdn.net/xieyuooo 兰亭风雨：https://blog.csdn.net/ns_code?viewmode=list 赵伊凡: http://irfen.me/ SiteStack Overflow：https://stackoverflow.com/ 联系方式Mail：laishiji86@gmail.com QQ：991327409"},{"title":"分类","date":"2019-11-18T06:42:54.196Z","updated":"2019-11-18T06:42:54.196Z","comments":false,"path":"categories/index.html","permalink":"http://thmasterplan.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-03T15:20:27.746Z","updated":"2020-04-08T10:56:53.574Z","comments":true,"path":"links/index.html","permalink":"http://thmasterplan.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-05T13:38:03.477Z","updated":"2019-11-18T05:58:22.890Z","comments":false,"path":"repository/index.html","permalink":"http://thmasterplan.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-05T13:38:09.506Z","updated":"2019-11-18T06:43:04.379Z","comments":false,"path":"tags/index.html","permalink":"http://thmasterplan.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"24大设计模式","slug":"设计模式","date":"2020-10-13T07:23:48.000Z","updated":"2020-10-14T05:45:45.744Z","comments":true,"path":"软件工程/设计模式/","link":"","permalink":"http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"创建型单例（Singleton）* 简单工厂（Simple Factory）* 工厂方法（Factory Method）* 抽象工厂（Abstract Factory）* 生成器（Builder）原型（Prototype）结构型外观（Facade）适配器（Adapter）* 桥接（Bridge）组合（Composite）装饰（Decorator）* 享元（Flyweight）代理（Proxy）* 行为型责任链（Chain Of Responsibility）策略（Strategy）* 模板方法（Template Method）* 命令（Commmand）观察者（Observer）* 访问者（Visitor）状态（State）解释器（Interpreter）迭代器（Iterator）* 中介（Mediator）备忘录（Memento）","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"开发原则","slug":"开发原则","date":"2020-10-13T07:23:38.000Z","updated":"2020-10-14T06:44:08.664Z","comments":true,"path":"软件工程/开发原则/","link":"","permalink":"http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/","excerpt":"","text":"在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式， 不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。 面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有 迪米特法则和合成复用原则。 S：单一职责原则（Single-Responsibility Principle）定义一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 原则分析 一个类(或者大到模块，小到方法)承担的职责越多，它被复用的可能性越小；如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 类的职责主要包括两个方面: 数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 例子单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否合理，但是“职责”和“变化原因”都是没有具体标准的，一个类到底要负责那些职责? 这些职责怎么细化? 细化后是否都要有一个接口或类? 这些都需从实际的情况考虑。因项目而异，因环境而异。 例：SpringMVC 中Entity, DAO, Service, Controller, Util等的分离。 O：开闭原则（Open - Closed Principle）定义一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭。 原则分析 当软件实体因需求要变化时, 尽量通过扩展已有软件实体，可以提供新的行为，以满足对软件的新的需求，而不是修改已有的代码，使变化中的软件有一定的适应性和灵活性 。已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性。 实现开闭原则的关键就是抽象化：在开闭原则中，不允许修改抽象类或者接口，允许扩展的是具体的实现类。抽象类和接口在开闭原则中扮演着极其重要的角色，既要预知可能变化的需求，又要预见所有可能已知的扩展，所以在这里”抽象化”是关键! 可变性的封闭原则：找到系统的可变因素，将它封装起来。 不要把可变因素放在多个类中，或者散落在程序的各个角落，应该将可变因素封装起来，并且切忌不要把所用的可变因素封装在一起，应该分块封装可变因素。 例子设计模式中模板方法模式和观察者模式都是开闭原则的极好体现。 L：里氏替换原则（Liskov Substitution Principle）定义 所有引用父类的地方必须能透明地替换为其子类的对象。 原则分析 讲的是基类和子类的关系，只有这种关系存在时，里氏替换原则才存在。正方形是长方形是理解里氏替换原则的经典例子。 里氏替换原则可以通俗表述为： 在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反之不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。 里氏替换原则是实现开闭原则的重要方式之一【抽象类和接口（不允许修改）看作基类，实现类（允许扩展）看作子类）】，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 I：接口隔离原则（Interface Segregation Principle）定义客户端不应该依赖那些它不需要的接口。 另一种定义方法：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。 注意，在该定义中的接口指的是所定义的方法。例如调用某个类的public方法。这个方法对外就是接口。 原则分析 使用多个专门的接口，而不使用单一的总接口。 使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。 D：依赖倒置原则（Dependency-Inversion Principle）定义高层模块不应该依赖（使用）低层模块，它们都应该依赖抽象。抽象不应该依赖（使用）具体，具体应该依赖（使用）抽象。 原则分析如果说开闭原则是面向对象设计的目标，依赖倒置原则则是手段。依赖倒置原则也是里氏替换原则的补充。 例子依赖倒置原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。 例：Spring中的依赖注入。 组合/聚合复用原则（Composite/Aggregate Reuse Principle）定义尽量使用对象组合，而不是继承来达到复用的目的。 原则分析 组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用。 其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 迪米特法则（Law of Demeter）系统中的类尽量不要与其他类互相作用，以减少类之间的耦合度。又叫最少知识原则(Least Knowledge Principle)。 目标：实现高内聚、低耦合。 例子设计模式Facade模式、Mediator模式。","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件开发过程模型","slug":"软件开发过程模型","date":"2020-10-13T07:23:02.000Z","updated":"2020-10-14T05:18:35.129Z","comments":true,"path":"软件工程/软件开发过程模型/","link":"","permalink":"http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"软件开发过程模型瀑布模型（Waterfall Model）瀑布模型（经典生命模型）提出了软件开发的系统化的、顺序的方法。其流程从用户需求规格说明开始，通过策划、建模、构建和部署过程，最终提供一个完整的软件并提供持续的技术支持。 模型特点 必须等前一阶段的工作完成之后，才能开始后一段的工作。 每一阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。 前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能得到正确的结果。 每个阶段结束前都要对所完成的文档进行评审，以便及早发现问题，改正错误。事实上越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正错误所需付出的代价也越高。因此，及时审查，是保证软件质量，降低软件成本的重要措施。 模型优点 强调了开发的阶段性，各阶段具有顺序性和依赖性 强调早期调研和需求分析，推迟编码实现的观点 提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。 模型局限 瀑布模型是一种线性模型，要求项目严格按规程推进，必须等到所有开发工作全部完成以后才能获得可以交付的软件产品。不能对软件系统进行快速创建，对于一些急于交付的软件系统的开发很不方便。 瀑布模型适合于需求明确，且无大的需求变更的软件开发（编译系统、操作系统等）。而对于分析初期需求模糊的项目，瀑布模型也并不适合。 适用场景适用于需求确定，无大的需求变更，工作能够采用线性的方式完成的软件。 演化模型（Evolutionary Model）快速原型（Rapid Prototype）软件开发过程中，开发初期很难得到一个完整的、准确的需求规格说明，开发者往往对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。为了适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）开发方法。 模型特点 快速原型是用来获取用户需求的，或是用来试探设计是否有效的。一旦需求或设计确定下来了，原型就将被抛弃。因此，快速原型要求快速构件、容易修改，以节约原型创建的成本、加快开发速度。 快速原型是暂时适用使用的，因此并不要求完整。它往往针对某个局部问题建立专门原型，如界面原型、工作流原型等。 快速原型不能贯穿软件的整个生命周期，它需要和其他的过程模型相结合才能产生作用。例如，在瀑布模型中应用快速原型，以解决瀑布模型在需求分析时期存在的不足。 模型优点 能渐进地启发客户提出新的要求或任务，促使开发人员和用户达成共识。 减少了开发风险，避免了因为需求不确定而在开发过程中浪费了大量的资源。 模型局限 没有考虑到软件的整体和长期的可维护性。 可能由于达不到质量要求而导致产品被抛弃，从而采用新的模型重新设计。 适用场景原型方法比较适用于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。 原型进化（ Prototype Evolution）原型进化对开发过程的考虑是，针对有待开发的软件系统，先开发一个原型系统给用户使用，然后根据用户使用情况的意见反馈，对原型系统不断修改，使它逐步接近并最终到达开发目标。跟快速原型不同的是，快速原型在完成需求定义后将被抛弃，而原型进化所要创建的原型则是一个今后将要投入应用的系统，只是所创建的原型系统在功能、性能等方面还有许多不 足，还没有达到最终开发目标，需要不断改进。 原型进化的工作流程如图 2-3 所示。 从图中可以看到，它具有以下两个特点： 原型进化模型将软件的需求细部定义、产品开发和有效性验证放在同一个工作进程中交替或并行运作。因此，在获得了软件需求框架以后，例如软件的基本功能被确定以后，就可以直接进入到对软件的开发中。 原型进化模型是通过不断发布新的软件版本而使软件逐步完善的，因此，这种开发模式特别适合于那些用户急需的软件产品开发。它能够快速地向用户交付可以投入实际运行的软件成果，并能够很好地适应软件用户对需求规格的变更。 原型进化模型能够适应软件需求的中途变更，但在应用的时候，以下问题需要得到足够的重视： 原型进化模型虽说使开发进程加快了，但不能像瀑布模型那样提供明确的里程碑管理，随着开发过程中版本的快速更新，项目管理、软件配置管理会变得复杂起来，管理者难以把握开发进度。因此，对于大型软件项目，原型进化模型缺乏有效的管理规程。 开发过程中软件版本的快速变更，还可能损伤软件的内部结构，使其缺乏整体性和稳定性。另外，用于反映软件版本变更的文档也有可能跟不上软件的变更速度。这些问题必将影响到今后软件的维护。 增量模型（Incremental Model）增量模型融合了瀑布模型的基本成分和原型进化模型的迭代特征，它对软件过程的考虑是：在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际开发中，则将软件系统按功能分解为许多增减构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完成，并都被集成到系统之中交付用户使用。 模型特点 当使用增量模型时，第一个增量往往是核心的产品。 客户对每个增量的使用和评估都作为下一个增量发布的新特性和功能。 该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。 模型优点 第一个可交付版本所需要的成本和时间很少。 开发由增量表示的小系统所承担的风险不大。 由于很快发布了第一个版本，因此可以减少用户需求的变更。 运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。 模型局限 管理发生的成本、进度和配置的复杂性可能会超出组织的能力。 如果没有对用户的变更要求进行规划，那么产生的出事增量可能会造成后来增量的不稳定。 如果需求不想早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。 适用场景项目在既定的商业要求期限之前不可能找到足够的开发人员的情况。 螺旋模型（Spiral Model）对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。 螺旋线中的每个回路都被分成为四个步骤： 制定计划：确定软件的目标，选定实施方案，明确项目开发的限制条件； 风险评估：分析所选的方案，识别风险，消除风险； 实施工程：实施软件开发，验证阶段性产品； 用户评估：评价开发工作，提出修正建议，建立下一个周期的开发计划。 模型特点 与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便。 使用螺旋模型进行软件开发，需要开发人员具有相当丰富的风险评估经验和专门知识。 模型优点 关注软件的重用。 关注早期错误的消除。 将质量目标放在首位。 将开发阶段与维护阶段结合在一起。 模型局限 开发人员需要有较强的风险评估的经验。 契约开发通常需要事先指定过程模型和发布产品。 适用场景螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型适合用于庞大、复杂并且具有高风险的系统。 喷泉模型（Water Fountain Model）喷泉模型是专门针对面向对象软件开发方法而提出的。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性。 无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限，由于对象概念的引入，表达分析、设计、实现等活动只用对象类和关系，从而可以较为容易地实现活动的迭代和无间隙，使其开发自然地包括复用。 在面向对象方法中，对象既是对现实问题中实体的抽象，也是构造软件系统的基本元素。 因此，建立对象模型在面向对象方法中，既可以用于分析，也可以用于设计，而且分析阶段所获得的对象框架模型可以无缝过渡到设计阶段，以作为软件实现的依据。 开发步骤： 第一阶段软件开发的目标可以是软件的基本功能； 第二阶段可以是在第一阶段建立的软件 的基础上，对软件进行进一步的完善，并实现软件的主要功能； 第三阶段则是在第二阶段的基 础上，对软件进行更加完整的开发，并以实现软件全部功能作为创建目标。 应该说，喷泉模型能够较有效地平衡软件系统的近期需求与远期规划，因此能够较好地满足用户在软件应用上的发展需要。 模型优点喷泉模型不像瀑布模型那样，需要分析活动结束后才开始设计活动，设计活动结束后才开始编码活动。该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。其优点是可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。 模型局限由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，因此不利于项目的管理。此外这种模型要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。 基于构件的开发模型（Component-based Development Model）基于构件的开发方法是指利用预先包装的构件来构造应用系统。构件可以是组织内部开发的构件，也可以是商品化成品构件。基于构件的开发模型具有许多螺旋模型的特点，它本质上是演化模型，需要以迭代方式构件软件。其不同之处在于，基于构件的开发模型采用预先打包的软件构件开发应用。 具体开发流程参考类似于螺旋模型，结合了瀑布模型和演化模型。 本文参考： https://www.cnblogs.com/jojop/p/11801241.html https://www.cnblogs.com/youcong/p/9498489.html","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"阿里Java开发规范","slug":"阿里Java开发规范","date":"2020-10-02T08:42:19.000Z","updated":"2020-10-13T07:22:16.195Z","comments":true,"path":"Others/阿里Java开发规范/","link":"","permalink":"http://thmasterplan.cn/Others/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/","excerpt":"","text":"本文转载自：https://github.com/mysterin/alibaba-java-specification 阿里巴巴 Java 开发手册 v1.2.0前言《阿里巴巴 Java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、MySQL 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。 本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率。 《阿里巴巴 Java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。 目录 编程规范 命名风格 常量定义 代码格式 OOP 规约 集合处理 并发处理 控制语句 注释规约 其他 异常日志 异常处理 日志规约 MYSQL 数据库 建表规约 索引规约 SQL 语句 ORM 映射 工程结构 应用分层 二方库依赖 服务器 安全规约 附 1：版本历史 附 2：本手册专有名词 编程规范命名风格 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例： _name / __name / $Object / name_ / name$ / Object$ 【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX_STOCK_COUNT反例： MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】中括号是数组类型的一部分，数组定义如下：String[] args。反例： 使用 String args[] 的方式来定义。 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。反例： 定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考 spring 的框架结构） 【强制】杜绝完全不规范的缩写，避免望文不知义。反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。正例： public class OrderFactory; public class LoginProxy; public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。正例： 接口方法签名：void f(); 接口基础常量表示：`String COMPANY = &quot;alibaba&quot;;` 反例： 接口方法定义：public abstract void f();说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 接口和实现类的命名有两套规则：1） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。 **正例：** `CacheServiceImpl` 实现 `CacheService` 接口。 2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。 **正例：** `AbstractTranslator` 实现 `Translatable`。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例： 枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 【参考】各层命名规约： Service/DAO 层方法命名规约1） 获取单个对象的方法用 get 做前缀。2） 获取多个对象的方法用 list 做前缀。3） 获取统计值的方法用 count 做前缀。4） 插入的方法用 save（推荐）或 insert 做前缀。5） 删除的方法用 remove（推荐）或 delete 做前缀。6） 修改的方法用 update 做前缀。 领域模型命名规约1） 数据对象：xxxDO，xxx 即为数据表名。2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。3） 展示对象：xxxVO，xxx 一般为网页名称。4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 常量定义 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。反例： String key = &quot;Id#taobao_&quot; + tradeId; cache.put(key, value); 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。 **反例：** 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量： 类 A 中：public static final String YES = &quot;yes&quot;; 类 B 中：public static final String YES = &quot;y&quot;; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。 3） 子工程内部共享常量：即在当前子工程的 constant 目录下。4） 包内共享常量：即在当前包下单独的 constant 目录下。5） 类内共享常量：直接在类内部 private static final 定义。 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。正例： public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);} 代码格式 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：1） 左大括号前不换行。2） 左大括号后换行。3） 右大括号前换行。4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。 反例： if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。 【强制】任何二目、三目运算符的左右两边都需要加一个空格。说明： 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 【强制】缩进采用 4 个空格，禁止使用 tab 字符。说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。正例： （涉及 1-5 点） public static void main(String[] args) { // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) { System.out.println(&quot;world&quot;); // 右大括号前换行，右大括号后有 else，不用换行 } else { System.out.println(&quot;ok&quot;); // 在右大括号后直接结束，则必须换行 } } 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。2） 运算符与下文一起换行。3） 方法调用的点符号与下文一起换行。4） 在多个参数超长，在逗号后换行。5） 在括号前不要换行，见反例。 正例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;); 反例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append (&quot;huang&quot;); //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。正例： 下例中实参的”a”,后边必须要有一个空格。method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。正例： int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明： 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。说明： 没有必要插入多个空行进行隔开。 OOP 规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 【强制】所有的覆写方法，必须加@Override 注解。说明： getObject() 与 get0bject() 的问题。一个是字母的 O，一个是数字的 0，加 @Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。说明： 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）正例： public User getUsers(String type, Integer... ids) {...} 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。说明： java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。正例： &quot;test&quot;.equals(object);反例： object.equals(&quot;test&quot;);说明： 推荐使用 java.util.Objects#equals （JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 关于基本数据类型与包装数据类型的使用标准如下：1） 【强制】所有的 POJO 类属性必须使用包装数据类型。2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。3） 【推荐】所有的局部变量使用基本数据类型。说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例： 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。反例： POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。说明： 注意 serialVersionUID 不一致会抛出序列化运行时异常。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。说明： String str = &quot;a,b,c,,&quot;; String[] ary = str.split(&quot;,&quot;); //预期大于 3，结果是 3 System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方法。说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。反例： public Integer getData() { if (true) { return this.data + 100; } else { return this.data - 100; } } 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。说明： 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。反例： String str = &quot;start&quot;; for (int i = 0; i &lt; 100; i++) { str = str + &quot;hello&quot;; } 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：1） 不允许被继承的类，如：String 类。2） 不允许修改引用的域对象，如：POJO 类的域变量。3） 不允许被重写的方法，如：POJO 类的 setter 方法。4） 不允许运行过程中重新赋值的局部变量。5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。 【推荐】慎用 Object 的 clone 方法来拷贝对象。说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 【推荐】类成员与方法访问控制从严：1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。2） 工具类不允许有 public 或 default 构造方法。3） 类非 static 成员变量并且与子类共享，必须是 protected。4） 类非 static 成员变量并且仅在本类使用，必须是 private。5） 类 static 成员变量如果仅在本类使用，必须是 private。6） 若是 static 成员变量，必须考虑是否为 final。7） 类成员方法只供类内部调用，必须是 private。8） 类成员方法只对继承类公开，那么限制为 protected。说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。 集合处理 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：1） 只要重写 equals，就必须重写 hashCode。2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;说明： subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。说明： 使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 正例： List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;); list.add(&quot;bao&quot;); String[] array = new String[list.size()]; array = list.toArray(array); 反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] { &quot;a&quot;, &quot;b&quot; }; List list = Arrays.asList(str); 第一种情况：list.add(&quot;c&quot;); 运行时异常。 第二种情况：str[0] = &quot;gujin&quot;; 那么 list.get(0)也会随之修改。 【强制】泛型通配符 &lt;? extends T&gt; 来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 &lt;? super T&gt; 不能使用 get 方法，做为接口调用赋值时易出错。说明： 扩展说一下 PECS(Producer Extends Consumer Super) 原则：1）频繁往外读取内容的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。正例： Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) { String temp = it.next(); if (删除元素的条件) { it.remove(); } } 反例： List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;); a.add(&quot;2&quot;); for (String temp : a) { if (&quot;1&quot;.equals(temp)) { a.remove(temp); } } 说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？ 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。说明：1） x，y 的比较结果和 y，x 的比较结果相反。2） x&gt;y，y&gt;z，则 x&gt;z。3） x=y，则 x，z 比较结果和 y，z 比较结果相同。反例： 下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return o1.getId() &gt; o2.getId() ? 1 : -1; } }; 【推荐】集合初始化时，指定集合初始值大小。说明： HashMap 使用 HashMap(int initialCapacity) 初始化，正例： initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。正例： values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象；entrySet() 返回的是 K-V 值组合集合。 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格： | 集合类 | Key | Value | Super | 说明 || :———————— | :—————— | :—————— | :————— | :————- || HashTable | 不允许为 null | 不允许为 null | Dictionary | 线程安全 || ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 分段锁技术 || TreeMap | 不允许为 null | 允许为 null | AbstractMap | 线程不安全 || HashMap | 允许为 null | 允许为 null | AbstractMap | 线程不安全 | 反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。说明： 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如： ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。 并发处理 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。说明： 资源驱动类、工具类、单例工厂类都需要注意。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。正例： public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName(&quot;TimerTaskThread&quot;); ... } } 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下： FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。正例： 注意线程安全，使用 DateUtils。亦推荐如下处理： private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); } }; 说明： 如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strongimmutable thread-safe。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。说明： 线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。说明： Random 实例包括 java.util.Random 的实例或者 Math.random() 的方式。正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例。 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。反例： class Foo { private Helper helper = null; public Helper getHelper() { if (helper == null) synchronized(this) { if (helper == null) helper = new Helper(); } return helper; } // other functions and members... } 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。 【参考】 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。 控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements; 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成： if (condition) { ... return obj; } // 接着写 else 的业务逻辑代码; 说明： 如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。正例： 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下： public void today() { if (isBusy()) { System.out.println(“change time.”); return; } if (isFree()) { System.out.println(“go to travel.”); return; } System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”); return; } 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 正例： //伪代码如下 final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) { ... } 反例： if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) { ... } 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。 【参考】下列情形，需要进行参数校验：1） 调用频次低的方法。2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。3） 需要极高稳定性和可用性的方法。4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。5） 敏感权限入口。 【参考】下列情形，不需要进行参数校验：1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。 注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。说明： 在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。说明： 对子类的实现要求，或者调用注意事项，请一并说明。 【强制】所有的类都必须添加创建者和创建日期。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/ /注释，注意与代码对齐。 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。反例： “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。说明： 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。反例： // put elephant into fridge put(elephant, fridge); 方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 其他 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。说明： 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();说明： 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。 【推荐】不要在视图模板中加入任何复杂的逻辑。说明： 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。 异常日志异常处理 【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： IndexOutOfBoundsException ， NullPointerException 等等。说明： 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catchNumberFormatException 来实现。正例： if (obj != null) {...}反例： try { obj.method() } catch (NullPointerException e) {...} 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。说明： 如果 JDK7 及以上，可以使用 try-with-resources 方式。 【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。说明： 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 **反例：** `public int f() { return Integer 对象}`， 如果为 null，自动解箱抛 NPE。 2） 数据库的查询结果可能为 null。3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。正例： 使用 JDK8 的 Optional 类来防止 NPE 问题。 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。说明： 关于 RPC 方法返回方式使用 Result 方式的理由：1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {...} 日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。正例： mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log说明： 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。说明： logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 正例： （条件） if (logger.isDebugEnabled()) { logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol); } 正例： （占位符） logger.debug(&quot;Processing trade with id: {} symbol : {} &quot;, id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。正例： &lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。正例： logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e); 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。 MYSQL 数据库建表规约 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。说明： 任何字段如果为非负数，必须是 unsigned。正例： 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。正例： getter_admin，task_config，level3_name反例： GetterAdmin，taskConfig，level_3_name 【强制】表名不使用复数名词。说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。 【强制】小数类型为 decimal，禁止使用 float 和 double。说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 【强制】表必备三字段：id, gmt_create, gmt_modified。说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。 【推荐】表的命名最好是加上“业务名称_表的作用”。正例： tiger_task / tiger_reader / mpp_config 【推荐】库名与应用名称尽量一致。 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：1）不是频繁修改的字段。2）不是 varchar 超长字段，更不能是 text 字段。正例： 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 | 对象 | 年龄区间 | 类型 | 表示范围 || :———- | :————- | :———————— | :——————————————- || 人 | 150 岁之内 | unsigned tinyint | 无符号值：0 到 255 || 龟 | 数百岁 | unsigned smallint | 无符号值：0 到 65535 || 恐龙化石 | 数千万年 | unsigned int | 无符号值：0 到约 42.9 亿 || 太阳 | 约 50 亿年 | unsigned bigint | 无符号值：0 到约 10 的 19 次方 | 索引规约 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。说明： 即使双表 join 也要注意表索引、SQL 性能。 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。说明： 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。说明： 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。正例： where a=? and b=? order by c; 索引：a_b_c反例： 索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。 【推荐】利用覆盖索引来进行查询操作，避免回表。说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例： 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。 【推荐】利用延迟关联或者子查询优化超多分页场景。说明： MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。正例： 先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例： explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 【推荐】建组合索引的时候，区分度最高的在最左边。正例： 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;?and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 【参考】创建索引时避免有如下极端误解：1）宁滥勿缺。误认为一个查询就需要建一个索引。2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 SQL 语句 【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。正例： 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。说明： 1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 2） NULL=NULL 的返回结果是 NULL，而不是 true。 3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。 【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明： （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。说明： SELECT LENGTH(“轻松工作”)； 返回为 12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4 如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 ORM 映射 【强制】在表查询中，一律不要使用 作为查询的字段列表，需要哪些字段必须明确写明。*说明： 1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。说明： 参见定义 POJO 类以及数据库字段定义规定，在中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。说明： 配置映射关系，使字段与 DO 类解耦，方便维护。 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。 【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。说明： 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取 start,size 的子集合。正例： Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;start&quot;, start); map.put(&quot;size&quot;, size); 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。说明： resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。 【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。 【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 【参考】中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；表示不为空且不为 null 时执行；表示不为 null 值时执行。 工程结构应用分层 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推： 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。 Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 Service 层：相对具体的业务逻辑服务层。 Manager 层：通用业务处理层，它有如下特征： 对第三方平台封装的层，预处理返回结果及转化异常信息； 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理； 与 DAO 层交互，对多个 DAO 的组合复用。 DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。 【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。 【参考】分层领域模型规约： DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 DTO（Data Transfer Object）：数据传输对象，Service 和 Manager 向外传输的对象。 BO（Business Object）：业务对象。可以由 Service 层输出的封装业务逻辑的对象。 Query：数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。 VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。 二方库依赖 【强制】定义 GAV 遵从以下规则：1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。说明： {公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。正例： com.taobao.jstorm 或 com.alibaba.dubbo.register2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。正例： dubbo-client / fastjson-api / jstorm-tool3） Version：详细规定参考下方。 【强制】二方库版本号命名方式：主版本号.次版本号.修订号1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。说明： 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0 【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。说明： 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。 【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行排除 jar 包。 【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。 【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。 【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。 【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在语句块中。说明：里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而所有声明在主 pom 的里的依赖都会自动引入，并默认被所有的子项目继承。 【推荐】二方库不要有配置项，最低限度不要再增加配置项。 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。 服务器 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。正例： 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout = 30 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。说明： 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。 【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出dump 信息。说明： OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。 【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。 安全规约 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。说明： 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。说明： 查看个人手机号码会显示成:158**9119，隐藏中间 4 位，防止隐私泄露。 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 【强制】用户请求传入的任何参数必须做有效性验证。说明： 忽略参数校验可能导致： page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS 说明： Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。说明： CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。 附 1：版本历史 版本号 更新日期 备注 1.0.0 2017.2.9 阿里巴巴集团正式对外发布 1.0.1 2017.2.13 1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。 1.0.2 2017.2.20 1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final 描述。5）去除 Comparator 部分描述。 1.1.0 2017.2.27 1）增加前言。2）增加&lt;? extends T&gt;描述和说明。3）增加版本历史。4）增加专有名词解释。 1.1.1 2017.3.31 修正页码总数和部分示例 1.2.0 2017.5.20 1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加 final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为 is_deleted 附 2：本手册专有名词 POJO（Plain Ordinary Java Object）：在本手册中，POJO 专指只有 setter / getter/ toString 的简单类，包括 DO/DTO/BO/VO 等。 DO（Data Object）：本手册指数据库表一一对应的 POJO 类。 GAV（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。 OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。 ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 iBATIS, mybatis 等框架。 NPE（java.lang.NullPointerException）: 空指针异常。 SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。 一方库：本工程内部子项目模块依赖的库（jar 包）。 二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。 三方库：公司之外的开源库（jar 包）。","categories":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/tags/Others/"}]},{"title":"JUC之常见工具类","slug":"JUC之常见工具类","date":"2020-09-30T07:57:37.000Z","updated":"2020-10-12T13:29:07.049Z","comments":true,"path":"Java并发/JUC之常见工具类/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"CountDownLatch在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。在CountDownLatch出现之前一般都使用线程的join方法来实现这一点，但是在使用ExecutorService时我们就没办法了。 使用案例12345678910111213141516171819202122232425262728293031public class CountDownLatchTest&#123; private static CountDownLatch countDownLatch = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(() -&gt; &#123; try &#123; Thread.sleep(1000); System.out.println(\"child threadOne over!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125;); executorService.submit(()-&gt;&#123; try &#123; Thread.sleep(1000); System.out.println(\"child threadTwo over!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125;); System.out.println(\"mainThread wait for all childThread over\"); countDownLatch.await(); System.out.println(\"all childThread over\"); executorService.shutdown(); &#125;&#125; 12345输出结果如下：mainThread wait for all childThread overchild threadTwo over!child threadOne over!all childThread over 在如上代码中，因为有两个子线程所以构造函数传入参数为2。主线程调用CountDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使内部计数器(state)减1，所有子线程执行完毕后计数器为0，此时主线程的await方法才会返回。 实现原理CountDownLatch基于AQS实现。 构造方法1234567891011private final Sync sync;public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count);&#125;//内部类Sync继承自AQS，其构造方法如下Sync(int count) &#123; setState(count);&#125; 由构造方法可知CountDownLatch的计数器实际就是AQS的state。 void await()调用await后当前线程被阻塞，只有当计数器值为0或者被中断该方法才会返回。 123456789101112131415public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted())//被中断则抛异常 throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0)//查看计数器是否为0，不是则进入AQS阻塞队列 doAcquireSharedInterruptibly(arg);&#125;//sync实现的AQS的模板方法protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; boolean await(long timeout, TimeUnit unit)相比void await()多了一个超时设置，设置的timeout时间到了，因为超时而返回false。 void countDown()线程调用该方法后，计数器值减1，减1后若计数器为0则唤醒所有因调用await方法而被阻塞的线程。 123456789101112131415161718192021222324public void countDown() &#123; sync.releaseShared(1);&#125;public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared();//唤醒AQS中所有阻塞的线程 return true; &#125; return false;&#125;//sync实现的AQS的模板方法protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; //CAS更新state if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; long getCount()获取state的值，该方法一般用于测试。 CyclicBarrierCountDownLatch的计数器是一次性的，当计数器值为0后，再调用await和countdown方法均会立即返回。为了满足计数器可以重置的需要，这才有了CyclicBarrier（回环屏障）。屏障的含义是：当线程调用await方法就会被阻塞，这个阻塞点就称为屏障点，当所有线程都调用了await方法后，线程就会冲破屏障，所有线程被唤醒继续向下执行（注意：最后一个调用await的线程不会被阻塞）。回环的含义是：所有线程到达屏障点后，CyclicBarrier的状态会被重置，因此它可以被重用。 使用案例下面的例子实现的是：使用两个线程执行一个被分解的任务，两个线程并发执行任务的两个步骤后再由CyclicBarrier汇总。 12345678910111213141516171819202122232425262728293031323334public class CyclicBarrierTest&#123; private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \": task merge result\"); &#125; &#125;); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": task step-1\"); System.out.println(Thread.currentThread().getName() + \": enter in barrier\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": out from barrier\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": task step-2\"); System.out.println(Thread.currentThread().getName() + \": enter in barrier\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": out from barrier\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdown(); &#125;&#125; 1234567pool-1-thread-1: task step-1pool-1-thread-1: enter in barrierpool-1-thread-2: task step-2pool-1-thread-2: enter in barrierpool-1-thread-2: task merge resultpool-1-thread-1: out from barrierpool-1-thread-2: out from barrier CyclicBarrier的构造方法参数列表中，第一个参数是计数器的初始值，第二个参数Runnable是当计数器值为0时由CyclicBarrier执行的任务。 在线程中CyclicBarrier对象调用await方法后，其计数器值-1，若此时计数器值不为0，当前线程被阻塞；若计数器值为0，则执行CyclicBarrier构造方法中传入的任务，然后唤醒条件队列中所有阻塞线程，重置计数器并新建Generation（重置broken标志）。 以下例子体现了CyclicBarrier的可复用性（所谓回环）： 以下任务被分为三个阶段，由两个线程并发执行该任务，只有当两个线程都完成了step1后才能进入step2，只有当两个线程都完成了step2才能进入step3。 12345678910111213141516171819202122232425262728293031public class CyclicBarrierTest2&#123; private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": step-1\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-2\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-3\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": step-1\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-2\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-3\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdown(); &#125;&#125; 123456pool-1-thread-1: step-1pool-1-thread-2: step-1pool-1-thread-2: step-2pool-1-thread-1: step-2pool-1-thread-1: step-3pool-1-thread-2: step-3 实现原理CyclicBarrier基于ReentrantLock实现。 parties用于记录线程个数，当parties个线程都调用await方法后所有线程才会冲破屏障点。count才是真正的计数器，一开始等于parties，每当有线程调用await方法后就-1，当count==0时所有线程都到了屏障点，此时会重置count的值为parties。 独占锁lock首先保证了更新计数器count的原子性，另外使用lock的条件变量trip支持线程间同步操作。 最后，在Generation对象内部有一个变量broken，用于记录当前屏障是否被打破。 构造方法12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; int await()12345678public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; boolean await(long timeout, TimeUnit unit)123456public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125; 超时返回。 int dowait(boolean timed, long nanos)12345678910111213141516171819202122232425262728293031323334353637383940414243private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; ... int index = --count; //index==0说明所有线程都到达了屏障点 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; //执行任务 if (command != null) command.run(); ranAction = true; //激活其他因调用await而被阻塞的线程，并重置CyclicBarrier nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; //index!=0则阻塞当前线程（进入条件队列） for (;;) &#123; try &#123; if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; ... &#125; ... &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 1234567private void nextGeneration() &#123; //所有线程节点进入AQS队列并唤醒所有线程 trip.signalAll(); //重置CyclicBarrier count = parties; generation = new Generation();&#125; SemaphoreSemaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。 使用案例Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控，代码如下： 1234567891011121314151617181920212223242526public class SemaphoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors .newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; s.acquire(); //存储到数据库操作 s.release(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 实现原理Semaphore基于AQS实现。 构造方法12345678910111213141516171819public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125;Sync(int permits) &#123; setState(permits);&#125;NonfairSync(int permits) &#123; super(permits);&#125;FairSync(int permits) &#123; super(permits);&#125; 构造方法传入许可证数量，许可证数量对应于AQS中的state，默认采用非公平策略。 acquire在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减1，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。 该方法可被中断。 acquire(int permits)在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减permits，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。 该方法可被中断。 release许可证个数加1，并根据公平策略在AQS阻塞队列中选择一个“许可证个数可以被满足”的线程唤醒。 release(int permits)许可证个数加permits。 PhaserPhaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。 ExchangerExchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC之线程池","slug":"JUC之线程池","date":"2020-09-30T07:52:36.000Z","updated":"2020-10-12T14:06:02.031Z","comments":true,"path":"Java并发/JUC之线程池/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"FutureTask概述FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。若任务尚未完成，获取任务执行结果时主线程将会阻塞。 FutureTask 的线程安全由CAS来保证。 类图结构 以上几个接口的源码如下： 123456789101112131415161718@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123;V call() throws Exception;&#125;@FunctionalInterfacepublic interface Runnable &#123;public abstract void run();&#125;public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; FutureTask构造方法如下： 123456789101112public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; &#125;public FutureTask(Runnable runnable, V result) &#123; //把传入的Runnable封装成一个Callable对象，若任务执行成功返回传入的result this.callable = Executors.callable(runnable, result); this.state = NEW;&#125; 由类图和构造方法可知，FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。 ThreadPoolExecutor线程池的好处 提供较好的性能：线程池中的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。 统一分配和管理：比如可以限制线程的个数、动态新增线程等。 类图结构 以上类图中主要接口的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839public interface Executor &#123;void execute(Runnable command);&#125;public interface ExecutorService extends Executor &#123; void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;public interface ScheduledExecutorService extends ExecutorService &#123; public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit); public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay, TimeUnit unit); public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit); public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit);&#125; ThreadPoolExecutor原理概述JDK实现的线程池核心主要为两大部分：一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务时，该任务将先被放入workQueue中，workerSet中的线程会不断从workQueue中获取线程然后执行，当workQueue中没有任务时，worker就会阻塞，直至队列中又有任务了。 部分属性123456789101112131415161718192021222324252627//存放任务的阻塞队列private final BlockingQueue&lt;Runnable&gt; workQueue;//工作线程集合private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();//历史达到的worker数最大值private int largestPoolSize;//创建线程的工厂private volatile ThreadFactory threadFactory;//饱和策略：当workQueue满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略private volatile RejectedExecutionHandler handler;//线程池中超出corePoolSize的闲置状态的worker的存活时间，单位为纳秒private volatile long keepAliveTime;//核心worker数量private volatile int corePoolSize;//最大worker的数量,一般当workQueue满了才会用到这个参数private volatile int maximumPoolSize;//控制新增worker线程操作的原子性private final ReentrantLock mainLock = new ReentrantLock();//条件队列，在线程调用awaitTermination时用于存放阻塞的线程private final Condition termination = mainLock.newCondition();//记录线程池状态与线程个数//对于int是32位的平台，高3位表示线程池状态,低29位记录worker数量//默认是RUNNING状态private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 线程池状态1234567891011121314151617181920212223private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//线程数量掩码位数：对于int是32位的平台，该值是29private static final int COUNT_BITS = Integer.SIZE - 3;//线程最大数量：000111...111private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;//接受新任务并处理阻塞队列中的任务：高3位111private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//拒绝新任务但是处理阻塞队列中的任务：高3位000private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务：高3位001private static final int STOP = 1 &lt;&lt; COUNT_BITS;//所有任务（含阻塞队列中的）都执行完后当前活动线程为0，将要调用terminated方法：高3位010private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//terminated执行完成后的状态：高3位011private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//获取运行状态：高3位private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;//获取线程数量：低29位private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//计算ctl新值private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 线程池状态转换图如下： 线程池类型ThreadPoolExecutor核心构造方法如下： 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; Executors工厂类提供创建的线程池类型如下： newFixedThreadPool：创建一个corePoolSize和maximunPoolSize都为nThreads的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime为0说明只要有多于corePoolSize的空闲线程则回收。由于使用了无界队列，因此饱和策略失效。 1234567public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()); &#125;//使用自定义线程工厂public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory); &#125; newSingleThreadExecutor：创建一个corePoolSize和maximunPoolSize都为1的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime为0。 123456789public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory)); &#125; newCachedThreadPool：创建一个按需自动创建线程的线程池，corePoolSize为0，maximunPoolSize为Integer.MAX_VALUE，阻塞队列为SynchronousQueue。keepAliveTime为60纳秒。 该类型的特殊之处在于使用了同步阻塞队列，加入队列的任务会马上执行，同步队列中最多只能有一个任务。 1234567public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;()); &#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;(),threadFactory); &#125; execute方法execute方法的作用是提交Runnable实例到线程池执行。 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; //Runnable实例为null则抛出NPE if (command == null) throw new NullPointerException(); //获取线程池状态和线程数量 int c = ctl.get(); //判断当前线程池线程个数是否小于corePoolSize，小于则新增worker if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return;//新增成功后直接返回 c = ctl.get();//新增失败则重新获取ctl &#125; //若线程池状态为RUNNING，则任务进入阻塞队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //二次检查：添加任务时线程池状态可能已变化 int recheck = ctl.get(); //不是RUNNING则从阻塞队列删除任务，并执行拒绝策略 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //worker数量为0则添加一个worker else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //阻塞队列满则新增worker，新增失败则执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; ThreadPoolExecutor的内部类Worker源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125; 由源码可知，Worker继承自AQS并实现了Runnable接口，是具体承载任务的对象。Worker类实现了简单的不可重入独占锁，state=0表示锁未被获取状态，state=1表示锁已经被获取，state=-1是创建Worker实例默认的状态。 addWorker与runWorker方法源码分析（有空再看）。 sumbit方法sumbit方法在ThreadPoolExecutor的父抽象类AbstractExecutorService中实现，Runnable或Callable对象被封装为FutureTask对象传入execute方法，最终执行的是FutureTask的run方法。 123456789101112131415161718192021222324252627public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; shutdown与shutdownNow shutdown方法：调用后线程池状态变为SHUTDOWN，此时拒绝新任务但是处理阻塞队列中的任务。 shutdownNow方法：调用后线程池状态变为STOP，此时拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务。 awaitTermination方法当线程调用该方法后会被阻塞，直到线程池状态变为TERMINATED才返回，或者等待时间超时才返回。 为什么不建议使用Executors创建线程池？阿里巴巴Java开发手册并发处理部分中，不允许使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 的构造方法，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 newFixedThreadPool和newSingleThreadExecutor: 阻塞队列允许的长度为Integer.MAX_VALUE，可能会堆积大量请求，从而导致OOM。 newCachedThreadPool和newScheduledThreadPool: maximunPoolSize是Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor内部使用DelayQueue来存放任务。 schedule1234public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123;&#125; public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay,TimeUnit unit)&#123;&#125; 该方法的作用是提交一个延迟执行的任务。从提交时间算起，delay时间后开始执行任务，unit为delay的时间单位。任务只执行一次。 scheduleWithFixedDelay1public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit) &#123;&#125; 该方法的作用是，当任务执行完毕后，让其延迟固定时间后再次运行(fixed-delay任务)。 initialDelay表示提交任务后延迟多少时间开始执行任务command，delay表示当任务初次执行完毕后延迟多少时间后再次运行command任务，unit是initialDelay和delay的时间单位。任务会一直重复运行，直到任务运行抛出异常、被取消了、或者关闭了线程池。 scheduleAtFixedRate1public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) &#123;&#125; fixed-rate任务的执行规则为：从提交时间算起，在时间点为initialDealy+n*period(n = 0, 1, 2, 3…)的时刻执行任务。若前一次任务还没执行完毕，下一次任务的执行时刻就到了，则下次任务要等到前一次任务执行完毕后才执行。 具体执行流程为：当任务提交后，initialDelay时间后执行command，然后在initialDelay+period时刻再次执行，而后在initialDelay+2*period时刻再次执行，循环往复，直到抛出异常、调用了任务的cancel方法取消了任务或关闭了线程池。 Fork/JoinFork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。 待后续补充。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC容器之并发队列","slug":"JUC容器之并发队列","date":"2020-09-27T02:30:32.000Z","updated":"2020-10-01T09:48:09.289Z","comments":true,"path":"Java并发/JUC容器之并发队列/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/","excerpt":"","text":"JUC提供了一系列场景的并发安全队列，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，后者使用CAS非阻塞算法实现。 非阻塞队列ConcurrentLinkedQueueConcurrentLinkedQueue是线程安全的无界非阻塞队列，其底层使用单向链表实现，对于入队和出队操作使用CAS来实现线程安全，因此执行该队列的方法失败不会导致线程阻塞。 类图结构 底层实现1234//默认头尾节点都是指向item为null的哨兵节点public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125; 123456789101112131415161718192021222324252627private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail;private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);&#125;private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);&#125;// Unsafe mechanicsprivate static final sun.misc.Unsafe UNSAFE;private static final long headOffset;private static final long tailOffset;static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = ConcurrentLinkedQueue.class; headOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"head\")); tailOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"tail\")); &#125; catch (Exception e) &#123; throw new Error(e); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; Node(E item) &#123; UNSAFE.putObject(this, itemOffset, item); &#125; boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125;// Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"item\")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"next\")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 常用方法 offer：通过CAS操作来控制某时只有一个线程可以添加元素到队列末尾，进行CAS竞争失败的线程会不断自旋，直至成功，其余出入队操作均是如此。相比阻塞算法，这是使用CPU资源换取阻塞所带来的开销。 add：调用offer方法。 poll：该方法在移除队首元素时，只是简单地使用CAS操作把节点的item值设置为null，然后重新设置head到下一个节点。移除的对象会在GC时被回收。 peek：peek方法的实现与poll类似，只是没有删除步骤。另外，在第一次调用peek操作时，会删除哨兵节点，并让head指向队列的第一个元素或者null。 size：该方法遍历链表计数，由于无锁策略，并发环境下结果并不准确。问：为什么不使用一个原子变量count来记录元素个数？因为这需要保证“入队操作+(count++)”或者“出队操作+(count—)”是原子操作，而ConcurrentLinkedQueue采用CAS无阻塞算法无法做到这一点。 remove：删除遍历时第一个匹配的元素。 contains：遍历链表查找元素，由于无锁策略，该方法并发环境下不准确。 延迟更新策略通过对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为： tail更新触发时机：tail的下一个节点不为null时，定位真正的队尾，找到队尾节点并完成插入之后才会通过casTail进行tail更新；当tail的下一个节点为null时，只插入节点不更新tail。 head更新触发时机：当head的item域为null时，定位真正的队头，找到队头节点并完成删除之后才会通过updateHead进行head更新；当head的item域不为null时，只删除节点不更新head。 在高并发写（大量出队入队）的情景下，通过延迟更新head和tail，减少了head和tail更新（CAS自旋）带来的CPU损耗。 适用场景ConcurrentLinkedQueue通过无锁做到了更高的并发量，在并发量特别大的情况下，是个不错的选择，性能上好很多。 阻塞队列BlockingQueueBlockingQueue通常用于生产者消费者场景。 一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。 BlockingQueue常见方法BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下: 四组不同的行为方式解释: 抛异常: 如果试图的操作无法立即执行，抛一个异常。 特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。 阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。 超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 另外，BlockingQueue不接受null值，插入null会导致NullPointerException。 BlockingDequeBlockingDeque是一个双端队列，我们可以从队列两端进行入队和出队操作。该接口继承自BlockingQueue接口。 在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。 BlockingDeque常见方法 BlockingQueue实现类LinkedBlockingQueue LinkedBlockingQueue是一个有界链表，创建时可指定容量，默认上限为Integer.MAX_VALUE（没指定就是无界），由原子变量计数器count计数。其内部以 FIFO的顺序对元素进行存储。 如下图所示： LinkedBlockingQueue对头、尾节点的操作分别使用了单独的独占锁从而保证了并发下出入队的正确性，竞争锁失败的线程进入相应的AQS阻塞队列。头尾节点的独占锁都有一个自己的条件队列，用于存放队列空(满)时执行take(put)操作的被阻塞的线程。另外，有两个独占锁意味着该队列可以同时进行出入队操作，因此count必须要使用原子变量。 注意：LinkedBlockingQueue的remove方法执行时会同时获取takeLock和putLock。 ArrayBlockingQueue ArrayBlockingQueue是一个有界数组，创建时必须指定容量，并且一旦指定容量便不能更改。其内部以 FIFO的顺序对元素进行存储。 如下图所示： ArrayBlockingQueue只有一个独占锁，这个锁的粒度较大，只要是对数组更改就必须加锁，因此不能同时进行入队出队操作。其中offer和poll操作通过简单的加锁实现，而put和take则使用锁加条件变量实现。另外，ArrayBlockingQueue的size方法相比LinkedBlockingQueue则是完全精确的，因为计算前加了全局锁。 PriorityBlockingQueue PriorityBlockingQueue是一个无界二叉堆（数组实现），每次出队的元素都是堆的根节点，保证返回的是优先级最高(低)的元素。 默认使用对象的compareTo方法提供比较规则，因此入队元素必须实现Comparable接口。如果需要自定义比较规则，也可在创建队列时传入Comparator比较器。 PriorityBlockingQueue的数组是可自动扩容的，其默认初始容量为11。当当前元素个数&gt;=容量时会通过CAS算法扩容。allocationSpinLock是个自旋锁，其使用volatile修饰和CAS操作来保证同时只有一个线程可以扩容队列，状态为0表示当前没有进行扩容，状态为1表示正在进行扩容。 如下图所示： PriorityBlockingQueue只有一个条件变量notEmpty，存放take操作时因队列空而阻塞的线程，因为该队列是无界队列，所以可以一直put，没有notFull条件变量。 使用案例： 1234567891011121314151617181920212223242526272829303132333435public class PriorityBlockingQueueTest &#123; static class Task implements Comparable&lt;Task&gt;&#123; private int priority; private String taskName; public Task(int priority, String taskName) &#123; this.priority = priority; this.taskName = taskName; &#125; @Override public int compareTo(Task o) &#123; if(this.priority &gt;= o.priority) return 1; else return -1; &#125; public void printTask()&#123; System.out.println(taskName + \":\" + priority); &#125; &#125; public static void main(String[] args) &#123; PriorityBlockingQueue&lt;Task&gt; priorityBlockingQueue = new PriorityBlockingQueue&lt;Task&gt;(); Random random = new Random(); for (int i = 0; i &lt; 10; i++) &#123; Task task = new Task(random.nextInt(10), \"taskName\"+i); priorityBlockingQueue.offer(task); &#125; while(!priorityBlockingQueue.isEmpty())&#123; priorityBlockingQueue.poll().printTask(); &#125; &#125;&#125; 输出为： 12345678910taskName1:1taskName7:2taskName4:3taskName0:3taskName9:4taskName5:7taskName2:8taskName6:9taskName8:9taskName3:9 DelayQueue DelayQueue是一个无界阻塞延迟队列，队列中的每个元素都有一个过期时间，每个元素都必须实现java.util.concurrent.Delayed接口： 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125; 出队时判断元素是否过期，只有过期元素才会出队列，队列头元素是最快要过期的元素。 由类图知，DelayQueue内部使用PriorityQueue存放数据。 SynchronousQueueSynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 BlockingDeque实现类LinkedBlockingDequeBlockingDeque唯一的一个实现类。LinkedBlockingDeque是一个有界链表双端队列，默认容量为Integer.MAX_VALUE。但与LinkedBlockingQueue不同的是，该队列不能同时进行出入队操作，因为只有一个独占锁。并且count计数器不是原子变量，size方法会在调用count时加锁，因此该方法返回值是精确的。 BlockingQueue实现生产者消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Test&#123; static BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10); static class Producer implements Runnable&#123; BlockingQueue&lt;Integer&gt; blockingQueue; public Producer(BlockingQueue&lt;Integer&gt; blockingQueue)&#123; this.blockingQueue = blockingQueue; &#125; @Override public void run() &#123; while(!Thread.interrupted())&#123; try &#123; blockingQueue.put(0); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"生产了\"+0); &#125; &#125; &#125; static class Consumer implements Runnable&#123; BlockingQueue&lt;Integer&gt; blockingQueue; public Consumer(BlockingQueue&lt;Integer&gt; blockingQueue)&#123; this.blockingQueue = blockingQueue; &#125; @Override public void run() &#123; while(!Thread.interrupted())&#123; Integer integer = null; try &#123; integer = blockingQueue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"消费了\" + integer); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Producer producer1 = new Producer(blockingQueue); Consumer consumer1 = new Consumer(blockingQueue); Consumer consumer2 = new Consumer(blockingQueue); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(producer1); executorService.execute(consumer1); executorService.execute(consumer2); Thread.sleep(1000); executorService.shutdownNow(); &#125;&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC容器之ConcurrentHashMap","slug":"JUC容器之ConcurrentHashMap","date":"2020-09-26T09:10:01.000Z","updated":"2020-10-13T06:34:12.038Z","comments":true,"path":"Java并发/JUC容器之ConcurrentHashMap/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap详解","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC容器之CopyOnWriteArrayList","slug":"JUC容器之CopyOnWriteArrayList","date":"2020-09-26T07:50:39.000Z","updated":"2020-09-27T02:41:51.293Z","comments":true,"path":"Java并发/JUC容器之CopyOnWriteArrayList/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/","excerpt":"","text":"概述CopyOnWriteArrayList是一个线程安全的ArrayList，底层采用private transient volatile Object[] array;存储数据，使用独占锁ReentrantLock保证同时只有一个线程对array进行修改。另外，该类采用了写时复制策略，也即对array的修改操作都是在一个复制的数组上进行的。 源码剖析构造方法1234567891011121314151617181920//默认构造创建大小为0的Object数组public CopyOnWriteArrayList() &#123;setArray(new Object[0]);&#125;//使用传入数组的拷贝public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125;//使用集合元素的拷贝public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements,elements.length, Object[].class); &#125; setArray(elements); &#125; add方法12345678910111213141516171819202122public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//获取独占锁 lock.lock(); try &#123; Object[] elements = getArray();//获取array int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//复制一个新数组 newElements[len] = e;//在新数组中添加 setArray(newElements);//将引用指向新数组，旧数组等待GC return true; &#125; finally &#123; lock.unlock(); &#125;&#125;final Object[] getArray() &#123; return array;&#125;final void setArray(Object[] a) &#123; array = a;&#125; get方法123456public E get(int index) &#123; return get(getArray(), index);&#125;private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 由于采用写时复制策略，即使我们在调用get方法时没有进行同步，也不会导致获取到错误的值。因为删除操作是在复制的数组上进行的，最后才会将array指向复制的数组。 set方法123456789101112131415161718192021public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; //在新数组上修改指定位置的元素值并设置新数组到array int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; remove方法12345678910111213141516171819202122232425public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; //如果要删除的是最后一个元素 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; //复制前半段 System.arraycopy(elements, 0, newElements, 0, index); //复制后半段 System.arraycopy(elements, index + 1, newElements, index, numMoved); //设置新数组到array setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 弱一致性的迭代器迭代器的弱一致性是指：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。该容器迭代器源码如下： 123456789101112131415161718192021222324public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot;//array的快照 private int cursor;//数组下标 private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; //其他方法&#125; 由源码可知，迭代器的snapshot引用指向旧数组，在迭代的过程中如果有其他线程进行增删改，都是在新创建的数组中进行的，它们操作的是不同的两个数组。 CopyOnWriteArraySet该容器底层使用CopyOnWriteArrayList实现： 1234567891011121314151617private final CopyOnWriteArrayList&lt;E&gt; al;public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();&#125;public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c) &#123; if (c.getClass() == CopyOnWriteArraySet.class) &#123; CopyOnWriteArraySet&lt;E&gt; cc = (CopyOnWriteArraySet&lt;E&gt;)c; al = new CopyOnWriteArrayList&lt;E&gt;(cc.al); &#125; else &#123; al = new CopyOnWriteArrayList&lt;E&gt;(); al.addAllAbsent(c); &#125;&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC之锁","slug":"JUC之锁","date":"2020-09-21T05:25:08.000Z","updated":"2020-10-11T13:11:55.998Z","comments":true,"path":"Java并发/JUC之锁/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/","excerpt":"","text":"OverView锁相关类关系图： 锁概述乐观锁与悲观锁乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。 悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。 乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁，在事务提交时才检测是否存在冲突。乐观锁的实现一般是在表中添加version字段或者使用业务状态。 公平锁与非公平锁公平锁表示线程获取锁的顺序是按照线程请求锁的时间顺序来决定，而非公平锁则按调度策略决定。在没有公平性需求的前提下尽量使用非公平锁，因为公平锁开销较大。 ReentrantLock提供了公平锁和非公平锁。 公平锁：ReentrantLock pairLock = new ReentrantLock(true); 非公平锁：ReentrantLock pairLock = new ReentrantLock(false);。如果构造函数不传递参数，则默认为false。 独占锁与共享锁根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。 独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是独占锁。独占锁是一种悲观锁，由于读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，因此限制了并发性。 共享锁则可以同时多个线程持有，例如ReadWriteLock。共享锁是一种乐观锁，它允许多个线程同时进行读操作。 可重入锁一个线程再次获取它自己已经获取的锁时不会被阻塞，那么该锁就是可重入锁。synchronized锁和ReentrantLock均为可重入锁。 可重入锁的原理是在锁内部维护一个线程标识和一个计数器。计数器初始值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁，计数器值+1。当获取了该锁的线程再次获取锁时发现线程标识是自己，计数器值再+1。释放一次锁则计数器值-1。当计数器值为0时，线程标识置null，阻塞线程被唤醒竞争该锁。 自旋锁自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。可以通过-XX:PreBlockSpinsh设置尝试次数，默认为10次。 JDK层面的锁由java.util.concurrent.locks包提供，其接口和类如下图所示： LockSupportLockSupport类是个工具类，其主要作用是挂起和唤醒线程，它是创建锁和其他同步类的基础。 LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport的方法的线程是不持有许可证的。该类是使用Unsafe类实现的。 LockSupport的构造方法为私有构造方法，无法被实例化，其方法基本为静态方法。 Unsafe的park和unpark方法因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义: 12public native void park(boolean isAbsolute, long time);public native void unpark(Thread thread); 对两个函数的说明如下: park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，给予该线程许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。 unpark函数，给予线程许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。 park()初次调用该方法后，当前线程挂起。 由于可能存在虚假唤醒的情况，所以调用时最好也使用循环条件判断方式。 如当前线程被其他线程中断，不会抛出InterruptedException。 park(Object blocker)Thread类中有个变量volatile Object parkBlocker，用于存放该方法传递的blocker对象，也就是把blocker变量存放到了调用该方法的线程成员变量中。 使用该类的好处是，方便使用诊断工具查看阻塞原因。 parkNanos(long nanos)与park()的不同仅在于会在nanos时间之后自动返回。 parkUntil(Object blocker, long deadline)在指定的时间内阻塞线程。deadline单位是ms，表示从1970到未来某个时刻的总毫秒数。 unpark(Thread thread)调用该方法后，如果线程没有持有与LockSupport关联的许可证，则使shi线程持有。如果线程已经因park()而挂起，则唤醒线程。若unpark()调用前未调用过park()，那么由于线程持有许可证，再次调用park()后线程不会挂起并失去许可证。 注意：park()方法不会释放锁，ConditionObject的await()会释放锁，并且该await()方法挂起线程就是使用park()实现的。 AQSAQS全称抽象队列同步器(AbstractQueuedSynchronizer)，它是实现JDK层面锁的基础组件，locks包ReentrantLock和ReentrantReadWriteLock均由AQS实现，同时CountDownLatch与Semaphore也是由AQS实现。 类图结构 由该图可知AQS继承自AbstractOwnableSynchronizer，并有内部类ConditionObject和Node。AQS的核心是state变量与队列，它的所有实现类都是围绕着对此二者的操作来进行的。 12345private transient volatile Node head;private transient volatile Node tail;private volatile int state; AQS概述队列AQS是一个FIFO的双向队列，该队列用于存放竞争资源失败的线程，队列元素为Node。Node中的thread变量用来存放进入AQS队列的线程，SHARED用于标记线程是获取共享资源时失败而放入AQS队列的，EXCLUSIVE则用于标记线程是获取独占资源时失败而放入AQS队列的，waitStatus记录线程等待状态，可以取如下值： SIGNAL=-1：线程需要被唤醒。 CONDITION=-2：线程在条件队列(ConditionObject)中等待，而非AQS队列。 CANCELLED=1：线程被取消了。 PROPAGATE=-3：释放共享资源时需要通知其他节点。 0：线程新加入队列。 state变量在AQS中维持了一个状态值state变量，AQS的不同实现中对state含义的定义均不同。JUC中的实现主要如下： ReentrantLock：state为0表示没有线程获取锁，大于1的整数表示线程获取锁的可重入次数。 ReentrantReadWriteLock：state的高16位表示读锁的的个数，低16位表示线程获取写锁的可重入次数。 Semaphore：state表示当前可用信号的个数。 CountDownLatch：state表示计数器当前的值。 操作state的方式分为独占方式和共享方式，两种方式获取和释放资源使用的方法分别为： 独占：void acquire(int arg); void acquireInterruptibly(int arg); boolean release(int arg)。 共享：void acquireShared(int arg); void acquireSharedInterruptibly(int arg); boolean release(int arg)。 在上述方法中调用了一系列需要实现类自己实现的模板方法，一共有以下五个： 锁的底层支持AbstractOwnableSynchronizer该抽象类中定义了一个变量 1private transient Thread exclusiveOwnerThread; 表示独占模式下当前占有锁和资源的线程。 独占锁-ReentrantLock与WriteLock对于AQS独占锁，当多个线程同时调用lock.lock()获取锁，只有一个线程获取到锁，其他线程会被转换为Node节点插入到lock锁对应的AQS队列中，并做自旋CAS尝试获取锁，尝试失败后阻塞。“自旋CAS/阻塞”的操作在acquireQueued()和doAcquire*()系列方法中实现。 线程通过调用acquire(int arg)获取独占资源，void acquire(int arg)源码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire()尝试CAS修改state值获取锁，若成功则表达式!tryAcquire(arg)为false，&amp;&amp;后的表达式无需继续执行，方法直接结束；若失败，则addWaiter()将当前线程封装为类型为NODE.EXCLUSIVE的Node节点插入AQS队列末尾，acquireQueued()方法中节点自旋CAS尝试获取锁，失败则阻塞。 addWaiter方法源码如下： 1234567891011121314151617private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); //判断尾节点是否为null Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; //通过CAS完成“tail = node”操作 pred.next = node; return node; &#125; &#125; //如果tail为null, 说明当前节点为AQS队列第一个节点，再调用enq入AQS队列 //或CAS设置tail失败，调用enq方法重新入队 enq(node); return node; &#125; enq方法源码如下： 123456789101112131415161718private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //tail为空则设置当前节点为头(尾)节点 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //addWaiter中CAS设置tail失败，说明有其他线程竞争进入AQS队列 //由for循环知，该方法会不断自旋直到当前节点入队成功 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; acquireQueued方法源码如下: 123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取当前节点的前驱节点 final Node p = node.predecessor(); //只有当前节点是队列中第二个节点时才重新tryAcquire if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //满足一定条件则阻塞当前线程，停止自旋 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法源码如下： 12345678910111213141516171819202122232425262728293031323334private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus;//获取前驱节点的等待状态 if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true;//只有当前驱节点等待状态为SIGNAL时才能阻塞当前线程 if (ws &gt; 0) &#123;//取消前驱节点，跳过 /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); //设置前驱节点的等待状态为SIGNAL，下一次当前节点线程就会阻塞，说明只会自旋一次 &#125; return false; &#125;private final boolean parkAndCheckInterrupt() &#123; //shouldParkAfterFailedAcquire返回true，阻塞当前线程，停止自旋，被唤醒后继续执行for循环 LockSupport.park(this); return Thread.interrupted(); &#125; 接下来讲release方法，该方法释放独占方式获取的锁和资源： 1234567891011public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; //释放成功并且头节点不为空，头节点等待状态不为0 //则唤醒后继节点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; 共享锁-ReadLock线程通过调用acquireShared方法获取共享资源： 12345678910111213141516171819202122232425262728293031public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125;private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 由源码可知，共享方式与独占方式实现类似。tryAcquireShared成功则直接返回，失败则入AQS阻塞队列尾部，自旋一次后阻塞挂起自己。releaseShared源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; 释放锁成功则调用doReleaseShared唤醒阻塞队列的所有线程。 条件变量ConditionObejctConditionObject实现了Condition接口，是AQS的内部类，其含义是条件变量，用于结合锁实现同步。 ConditionObject通过AQS锁对象的newCondition()创建(该方法是Lock接口的方法，需要实现类实现)，它可以直接访问AQS对象内部的变量，比如state值和队列。每个ConditionObject对应一个条件队列（单向链表队列），用于存放调用await()方法后被阻塞的线程，而signal()/signalAll()方法用于唤醒条件队列中阻塞的线程并将节点加入AQS队列。条件队列的队头、尾分别为firstWaiter和lastWaiter。 与synchronized内置锁不同，synchronized只能与一个共享变量的wait()或notify()方法实现同步，而AQS实现的一个锁可以创建多个ConditionObject。与wait()和notify()类似，调用条件变量的await()和signal()之前，必须先获取条件变量对应的锁，否则也会抛出IllegalMonitorStateException。条件变量使用示例： 1234567891011121314151617181920212223242526public static void main(String[] args)&#123; ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(()-&gt;&#123; lock.lock(); try &#123; System.out.println(\"begin wait\"); condition.await(); System.out.println(\"end wait\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;).start(); new Thread(()-&gt;&#123; lock.lock(); System.out.println(\"begin signal\"); condition.signal(); System.out.println(\"end signal\"); lock.unlock(); &#125;).start(); &#125; 运行结果： 1234begin waitbegin signalend signalend wait 注意，await()方法会释放锁，而signal()方法不会释放锁，必须手动调用锁对象的unlock()方法释放锁。await()源码如下： 1234567891011121314151617181920212223public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); //创建类型为Node.CONDITION的节点并加入条件队列 Node node = addConditionWaiter(); //释放当前线程的锁 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //阻塞当前线程 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //线程被唤醒后在AQS队列中，自旋CAS尝试获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 调用await()后，在内部会构造一个类型为Node.CONDITION的节点并插入条件队列末尾，之后当前线程会释放锁（修改state的值），然后通过LockSupport阻塞当前线程。另一个线程调用signal()后，条件队列队头节点出队放入AQS队列的队尾，然后唤醒线程，该线程继续执行await()方法中LockSupport.park(this)之后的代码，调用acquireQueued()方法自旋CAS尝试获取锁。 最后总结如下图：一个锁对应一个AQS队列，对应多个条件变量，每个条件变量有自己的一个条件队列。 ReentrantLock详解类图结构 123456public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 由构造方法可知，默认是创建非公平锁。 获取锁void lock()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void lock() &#123;sync.lock();&#125;//非公平锁final void lock() &#123; //获取锁成功则设置当前线程为独占线程，失败则调用AQS的acquire方法 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125;public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState();//获取state if (c == 0) &#123; //非公平锁的体现：如果state为0，不考虑是否有前驱节点，直接CAS获取锁 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; //state不为0，但是当前线程是独占线程，则仅仅+1 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125;//公平锁final void lock() &#123;acquire(1);&#125;protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //公平锁体现：先检测是否有前驱节点 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; void lockInterruptibly()方法该方法对中断进行响应，也即当前线程调用该方法时，如果其他线程调用了当前线程的interrupt方法，则当前线程会抛出InterruptedException异常。 1234567891011public void lockInterruptibly() throws InterruptedException&#123;sync.acquireInterruptibly(1);&#125;public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; boolean tryLock()方法尝试获取锁。若该方法失败当前线程不会入AQS队列，也不会阻塞。 释放锁void unlock()方法12345678910111213141516public void unlock() &#123; sync.release(1);&#125;protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; ReentrantReadWriteLock详解ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，来满足实际中写少读多的场景。 类图结构 123456789public ReentrantReadWriteLock() &#123; this(false);&#125;public ReentrantReadWriteLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this);&#125; 由构造方法可知，默认创建非公平锁。 读写锁的内部维护了一个ReadLock和一个WriteLock，它们依赖继承自AQS的Sync实现具体功能。读写锁使用state的高16位表示读状态，也即读锁线程个数；低16位表示写锁的可重入次数。Sync类源码表现如下： 123456789101112131415161718static final int SHARED_SHIFT = 16;//偏移值//低16位为0，第17位为1static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);//读锁线程最大个数65535static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;//低15位为1static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;//无符号右移16位，低16位变为原高16位值，原高16位填0static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;//按位与运算使高17位为0，低15位不变static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 由源码可知，通过无符号右移获取读锁线程个数，通过与掩码按位与获取写锁可重入次数。 写锁下面只介绍tryAcquire方法1234567891011121314151617181920212223242526272829protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState();//获取state int w = exclusiveCount(c);//获取写锁可重入次数 if (c != 0) &#123;//说明读锁或写锁已被某线程获取 //w=0说明有线程获取了读锁，w!=0并且当前线程不是写锁拥有者则返回 if (w == 0 || current != getExclusiveOwnerThread()) return false; //说明当前线程获取了写锁，判断可重入次数是否超过最大值 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); setState(c + acquires);//state+1 return true; &#125; //c=0则根据writerShouldBlock的返回值判断是否执行CAS获取写锁 if (writerShouldBlock() ||!compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true;&#125;//对于writerShouldBlock，非公平锁实现final boolean writerShouldBlock() &#123; return false; // writers can always barge&#125;//公平锁实现final boolean writerShouldBlock() &#123; return hasQueuedPredecessors();//判断是否有前驱节点&#125; 注意：ReentrantReadWriteLock在采用非公平锁并且在读多写少的情况下，容易导致写线程饥饿。可以使用公平锁或者采用StampedLock。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC之原子包","slug":"JUC之原子包","date":"2020-09-19T11:56:16.000Z","updated":"2020-09-27T02:52:28.747Z","comments":true,"path":"Java并发/JUC之原子包/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/","excerpt":"","text":"CAS操作CAS（Compare-And-Swap）比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，只有当 V 的值等于旧值A，才将 V 的值更新为 B。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。 CAS使用示例：AtomicIntegerjava.util.concurrent.atomic包中的整数原子类AtomicInteger，其中的修改变量值的方法都采用了Unsafe类的CAS方法。以下代码使用了AtomicInteger执行了自增的操作： 12345private AtomicInteger count = new AtomicInteger();public void add0()&#123;count.incrementAndGet();&#125;public void add1()&#123;count.getAndIncrement();&#125; 以下代码是AtomicInteger中上述两个自增方法的源码： 1234567public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 它们均调用了Unsafe类的getAndAddInt()，其源码如下： 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 参数的含义分别是：var1指示对象的起始内存地址，var2指示该字段相对对象内存地址的偏移，var1和var2决定了对象在内存中的位置。var4指示需要加的值，此处为1。 通过 getIntVolatile(var1, var2) 得到对象的旧值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5(即没有被改变)，那么就更新内存地址为 var1+var2 的变量为 var5+var4。其中 compareAndSwapInt() 方法在Unsafe类中是native方法。我们注意到该方法在while循环中不断执行，对应的逻辑就是“如果发生冲突则不断尝试执行CAS操作”，这就是基于冲突检测的乐观并发策略。 最后需要注意的是，getAndAddInt()方法返回了var5，该值是旧值。其实add0和add1方法的执行效果是一样的，都是整数原子对象的值+1，由于incrementAndGet()和getAndIncrement()的返回值是整型，而前者的返回值比后者大1，因此容易误会。注意整数原子对象的值+1与它们的返回值无关，它的值是通过CAS操作直接修改的！ CAS的问题ABA问题如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？ 如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类AtomicStampedReference。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。 若自旋时间过长则开销大如果自旋CAS长时间不成功，那么它会一直占用CPU资源。 只能保证单个共享变量的原子操作如果要保证对多个共享变量操作的原子性，可以将多个共享变量放入AtomicReference对象中，来保证原子性。 Unsafe类JDK中的rt.jar中sun.misc包中的Unsafe类提供了硬件级别的原子性操作，Unsafe类中的方法绝大部分都是native方法，它们使用JNI访问本地C++实现库。 Unsafe类主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。因此JDK开发组限制了开发人员通过一般方式使用Unsafe类，比如如下代码会报异常： 1priavte static final Unsafe unsafe = Unsafe.getUnsafe(); J.U.C中原子类获取Unsafe对象就是如此，Unsafe类提供静态方法getUnsafe()返回Unsafe对象，但是如果在用户程序中这样写就会报异常。原因在于getUnsafe()方法源码： 123456789101112public static Unsafe getUnsafe() &#123; //获取调用该方法的类的Class对象 Class var0 = Reflection.getCallerClass(); //判断是不是BootstrapClassLoader加载的该类 if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(\"Unsafe\"); &#125; else &#123; return theUnsafe; &#125;&#125;//sun.misc包下的VM类public static boolean isSystemDomainLoader(ClassLoader var0)&#123;return var0 == null;&#125; 显然由于用户类是由AppClassLoader加载的，因此会报异常。 要想使用Unsafe类，可以使用反射来获取unsafe对象： 123456789static final Unsafe unsafe;static &#123; Field field = Unsafe.class.getDeclaredField(\"thUnsafe\"); field.setAccessible(true); unsafe = (Unsafe) field.get(null);&#125; Unsafe类总体功能如下： 其中原子操作只支持如下三个方法： 12345public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3); 其余关于CAS的常用方法有：getAndAddInt, getAndAddLong, getAndSetInt, getAndSetLong, getAndSetObject。 原子包原子包即java.util.concurrent.atomic包，它包含了一系列的原子性操作类，这些类都是使用非阻塞算法CAS实现的。一共有如下类： AtomicInteger依旧以AtomicInteger为例，其余原子类原理类似。 常用方法public final int get()：获取当前值public final int getAndSet(int newValue)：获取当前值，并设置新值public final int getAndIncrement()：获取当前值，并自增public final int getAndDecrement()：获取当前值，并自减public final int getAndAdd(int delta)：获取当前值，并加上预期的值void lazySet(int newValue): 最终会设置成newValue, 使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 源码分析以下为部分源码： 1234567891011121314151617181920212223public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; //用于获取value字段相对当前对象的“起始地址”的偏移量 valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; //返回当前值 public final int get() &#123; return value; &#125; //递增加detla public final int getAndAdd(int delta) &#123; //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。 return unsafe.getAndAddInt(this, valueOffset, delta); &#125;&#125; 由源码可知：使用volatile修饰变量，保证了变量的可见性与有序性；使用CAS操作变量，保证了操作的原子性。因此最终效果与使用synchronized一致。 原子更新基本类型 AtomicBoolean AtomicInteger AtomicLong 上述三个原子类类似。 原子更新数组使更新数组的某个元素满足原子性 AtomicIntegerArray: 原子更新整型数组里的元素。 AtomicLongArray: 原子更新长整型数组里的元素。 AtomicReferenceArray: 原子更新引用类型数组里的元素。 原子更新引用类型 AtomicReference: 原子更新引用类型。 AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。 AtomicMarkableReference: 原子更新带有标记位的引用类型。 原子更新Field AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。 AtomicLongFieldUpdater: 原子更新长整型字段的更新器。 AtomicReferenceFieldUpdater: 原子更新引用类型字段的更新器。 这三个类均为抽象类，使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步: 第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。 第二步，更新类的字段必须使用public volatile修饰。 JDK8新增的原子操作类LongAdder和DoubleAdder使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，那么就会由大量线程因为不断自旋而浪费CPU资源。因此JDK8新增了LongAdder用于克服在高并发下使用AtomicLong的缺点，提升性能。 如图所示，使用AtomicLong时，是多个线程同时竞争同一个原子变量： 而使用LongAdder时，则为： LongAdder维护了一个Cell数组，每个Cell里有一个初始值为0L的long型变量，这样在同等并发量的情况下，争夺单个变量更新操作的线程减少。并且如果多个线程争夺同一个Cell原子变量失败了，它并不是在当前Cell变量上一直自旋CAS重试，而是尝试在其他Cell的变量上进行CAS，这个改变增加了当前线程重试CAS成功的可能性。最后，在获取LongAdder当前值时，把所有Cell变量的value累加再加上base返回。 Cell数组默认是null，只有在高并发的情况下才会创建它。在并发量少的时候所有的累加操作都是对base变量进行的，此时与AtomicLong类似。 Cell类使用了@sun.misc.Contended修饰进行字节填充，这是因为数组元素的内存地址连续，为了避免伪共享。 总结：LongAdder在AtomicLong的基础上将单个变量的更新压力分散到各Cell，在低并发的时候通过对base的直接更新可以很好的保障与AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。缺点是LongAdder在求和的时候如果有并发更新，可能导致统计的数据有误差。 DoubleAdder与LongAdder类似。 LongAccmulator和DoubleAccumulatorLongAdder可以看作是LongAccumulator的一个特例。LongAccumulator的构造方法如下： 123456789public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity)&#123; this.function = accumulatorFunction; base = this.identity = identity;&#125;public interface LongBinaryOperator&#123; //根据两个参数计算并返回一个值，具体的运算由用户自定义 long applyAsLong(long left, long right);&#125; 使用LongAdder其实就相当于如下使用LongAccumulator: 123456LongAccumulator accumulator = new LongAccumulator(new LongBinaryOperator()&#123; @Override public long applyAsLong(long left, long right)&#123; return left + right; &#125;&#125;, 0); LongAccumulator可以自定义双目运算规则（applyAsLong()的返回值就是要更新的值。在LongAdder中该值就是base+x，x为其add方法的参数），并且可以指定base的初始值，而LongAdder只能默认base为0。 如何实现AtomicByte/AtomicFloat/AtomicDouble?查看atomic包文档描述，结尾处写道：Additionally, classes are provided only for those types that are commonly useful in intended applications. For example, there is no atomic class for representing byte. In those infrequent cases where you would like to do so, you can use an AtomicInteger to hold byte values, and cast appropriately. You can also hold floats using Float.floatToRawIntBits(float) and Float.intBitsToFloat(int) conversions, and doubles using Double.doubleToRawLongBits(double) and Double.longBitsToDouble(long) conversions. 由文档描述可知，使用Float和Double的方法转换并包装AtomicInteger即可。 参考： 《Java并发编程之美》 《深入理解Java虚拟机》 https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC概述","slug":"JUC概述","date":"2020-09-19T10:05:19.000Z","updated":"2020-09-27T02:40:50.098Z","comments":true,"path":"Java并发/JUC概述/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E6%A6%82%E8%BF%B0/","excerpt":"","text":"OverView 原子包基础类型AtomicBoolean，AtomicInteger，AtomicLong 数组AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 引用AtomicReference，AtomicMarkableReference，AtomicStampedReference FieldUpdaterAtomicIntegerFieldUpdater, AtomicLongFieldUpdater，AtomicReferenceFieldUpdate Adder和AccumulatorLongAdder, DoubleAdder, LongAccmulator, DoubleAccumulator 锁和工具类 并发集合 线程池 多线程开发的良好习惯 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使用 BlockingQueue 实现生产者消费者问题。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 图片来源均为： https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"ThreadLocal源码剖析","slug":"ThreadLocal源码剖析","date":"2020-09-18T07:16:56.000Z","updated":"2020-09-27T02:58:05.701Z","comments":true,"path":"Java并发/ThreadLocal源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"基本使用ThreadLocal提供了线程本地变量，也即如果在类中创建了一个ThreadLocal变量，那么每个访问该变量的线程都会在线程中创建该变量的副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。从JMM的角度来看，主内存中并不会存储实值（无法在类中通过set方法或构造器赋初值），而线程中所有通过threadLocal引用的操作实际上都是操作线程自身工作内存中的副本，而非主内存中的ThreadLocal对象。 123456789101112131415161718192021222324252627282930313233public class Test &#123; //以下三个变量均存于主内存中 static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); static String stringA = new String(\"stringA\"); String stringB = new String(\"stringB\"); public static void main(String[] args) throws InterruptedException &#123; //主线程threadLocal值设置为threadLocalString, 实际上设置主线程工作内存中副本的值 threadLocal.set(\"threadLocalString\"); Test test = new Test(); //子线程修改三个值 new Thread(()-&gt;&#123; threadLocal.set(\"1\"); stringA = \"2\"; test.stringB = \"3\"; //子线程工作内存读取的值 System.out.println(threadLocal.get()); System.out.println(stringA); System.out.println(test.stringB); &#125;).start(); Thread.sleep(1000); //主线程工作内存中读取的值 System.out.println(threadLocal.get()); System.out.println(stringA); System.out.println(test.stringB); &#125;&#125; 输出结果为： 123threadLocalString23 由结果可知，类ThreadLocal变量不会像普通类实例变量和类静态变量那样，将线程中修改的值同步回主内存。 源码剖析首先来看ThreadLocal中的set()方法： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; Thread t = Thread.currentThread();：获取当前线程对象； ThreadLocalMap map = getMap(t); ：获取当前线程对象的ThreadLocalMap。 查看源码发现这是一个定制化的哈希表，其key为ThreadLocal对象引用，value就是我们设置的值。getMap()方法与Thread类的threadLocals变量如下： 123456//ThreadLocal成员方法ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;//Thread类成员变量ThreadLocal.ThreadLocalMap threadLocals = null; Thread中threadLocals被设计成map结构，那么显然一个线程可以关联多个ThreadLocal变量。 if-else：如果当前线程的threadLocals不为空，则以当前ThreadLocal对象为key设置键值对。否则调用createMap()方法创建哈希表。 1234void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 再来看get()和remove()方法： 1234567891011121314151617181920212223242526272829303132333435public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; T result = (T)e.value; return result; &#125; &#125; return setInitialValue();//若map为空则初始化并返回&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;//一般创建ThreadLocal时会重写该方法protected T initialValue() &#123; return null;&#125;public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) //由于Entry继承自WeakReference,该方法最终调用Reference的clear()方法清除对象引用 m.remove(this); &#125; 总结：每个线程内部都有一个threadLocals成员变量，该变量类型为定制化的哈希表结构，其key为ThreadLocal的this引用，value为我们设置的值。每个线程的本地变量存放在自己工作内存中的threadLocals中。ThreadLocal就是一个工具类，它提供的方法就是为了Thread中的threadLocals而服务。 ——————————————待补充———————————————————————- ThreadLocal造成内存泄漏由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除Entry对象的引用就会导致内存泄漏。 ThreadLocal使用场景数据库链接管理每个线程都会和一个Connection绑定，不会存在线程安全问题。 Session管理https://www.zhihu.com/search?type=content&amp;q=ThreadLocal InheritableThreadLocalInheritableThreadLocal继承自ThreadLocal，它可以让子线程访问在父线程中设置的本地变量。 源码剖析使用场景","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"Java并发基础总结","slug":"Java并发基础总结","date":"2020-09-13T09:07:19.000Z","updated":"2020-09-19T10:58:52.127Z","comments":true,"path":"Java并发/Java并发基础总结/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"线程的实现Thread类的所有关键方法都是声明为native的，也即Java线程的实现本质是使用平台的实现手段。 JDK1.2后，线程模型替换为基于操作系统原生线程模型来实现。 Java线程优先级Java一共设置了10个级别的线程优先级，在两个线程同时处于Ready状态时，优先级高的线程更容易被系统选择执行。 Java的线程优先级是通过映射到系统的原生线程上实现的，因此线程调度最终取决于操作系统，并且操作系统的优先级并不能与Java的优先级一一对应。例如Solaris中有2^32种优先级，Windows只有7种。Windows平台的JDK中使用了除THREAD_PRIORITY_IDLE之外的其余6种线程优先级，对应关系如下表： Java线程优先级 Window线程优先级 1（Thread.MIN_PRIORITY） THREAD_PRIORITY_LOWEST 2 THREAD_PRIORITY_LOWEST 3 THREAD_PRIORITY_BELOW_NORMAL 4 THREAD_PRIORITY_BELOW_NORMAL 5（Thread.NORM_PRIORITY） THREAD_PRIORITY_NORMAL 6 THREAD_PRIORITY_ABOVE_NORMAL 7 THREAD_PRIORITY_ABOVE_NORMAL 8 THREAD_PRIORITY_HIGHEST 9 THREAD_PRIORITY_HIGHEST 10（Thread.MAX_PRIORITY） THREAD_PRIORITY_CRITICAL 状态转换Java线程状态转换图如下： New：创建后尚未启动。 Runnable：包括了操作系统线程状态中的Ready和Runnning。 Waiting（无限期等待）：处于该状态的线程要等待被其他线程显式地唤醒。 Timed Waiting（限期等待）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 Blocked：等待获取一个排它锁。阻塞和等待的区别在于，阻塞是被动的，而等待线程是主动进入的。 使用线程有以下三种使用线程的方法，其中实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。 继承Thread1234567891011121314public class ThreadTest&#123; public static class MyThread extends Thread&#123; public void run() &#123; // ... &#125; &#125; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start(); &#125;&#125; 调用start()后该线程进入就绪态。 实现Runnable接口1234567891011public class MyRunnable implements Runnable &#123; @Override public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现Callable接口12345678910public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(new MyCallable()); new Thread(ft).start(); System.out.println(ft.get());&#125; 使用FutureTask任务有返回值。 实现接口与继承Thread选择？最好选择接口。 Java类不支持多继承，如果继承了Thread类就不能再继承其他类。而接口则可以多继承与多实现。 继承Thread，任务与线程代码没有分离，耦合度高，不符合软件工程“高内聚低耦合”的原则。 继承Thread整个类开销过大。 线程之间的协作wait()/notify()/notifyAll()以上三个方法均属于Object类而非Thread。 当一个线程调用一个共享变量的wait()方法时，该线程必须事先获取该共享变量的监视器锁，否则调用时会抛出IllegalMonitorStateException异常。调用wait()方法后，该线程会释放共享变量的监视器锁，然后挂起。以下事情可以唤醒该线程： 其他线程获取锁后执行任务完毕后，调用该共享变量的notify()或notifyAll()方法并且释放锁。如果有多个线程在等待，notify()会随机唤醒一个，而notifyAll()则唤醒所有，然后由这些线程来竞争监视器锁，这些线程会依次得到锁并释放锁。 其他线程调用该线程的interrupt()方法，该线程抛出InterruptedException异常返回。 一个线程获取共享变量的监视器锁有两种方式： 执行同步块代码，使用该共享变量作为参数： 1synchronized(/*共享变量*/)&#123;&#125; 调用该共享变量的同步方法： 1synchronized void method()&#123;&#125; 注意，一个线程可以从挂起态变为运行态，即使其他线程没有唤醒或中断该线程或这该线程等待超时，即所谓虚假唤醒。可以通过循环来防止虚假唤醒： 12345synchronized(obj)&#123; while(/*条件不满足则一直等待*/)&#123; obj.wait(); &#125;&#125; 以生产者消费者为例： 123456789//生产线程部分代码，异常在方法外处理synchronized(queue)&#123; //队列满则不需要再生产 while(queue.size() == MAX_SIZE)&#123; queue.wait();//挂起并释放queue的锁 &#125; queue.add(e); queue.notifyAll();&#125; 123456789//消费线程部分代码，异常在方法外处理synchronized(queue)&#123; //队列空则不能消费 while(queue.size() == 0)&#123; queue.wait();//挂起并释放queue的锁 &#125; queue.take(); queue.notifyAll();&#125; 关于调用wait()后释放锁，如果该线程持有多个对象的锁，那么调用了谁的wait，就只释放它的锁，并不会释放其他共享对象的锁。 await()/signal()/signalAll()J.U.C包中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 join()在线程A中调用线程B的join() 方法，线程A阻塞，直到线程B执行完毕。 interrupt()通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 线程中断interrupt()线程A运行时，线程B可以调用A的interrupt()方法来设置A的中断标志为true并立即返回。此时线程A实际并没有被中断，它会继续往下执行。但是如果A因为调用了wait()系列方法、join()方法、或者sleep()方法而被挂起，此时B若调用A的interrupt()方法，A会在调用这些方法的地方抛出InterruptedException异常而返回。 interrupted()/isInterrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 123456789101112131415161718public class InterruptExample &#123; private static class MyThread extends Thread &#123; @Override public void run() &#123; while (!Thread.interrupted()) &#123; // .. &#125; System.out.println(\"Thread end\"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new MyThread(); thread.start(); thread.interrupt(); &#125;&#125; 查看interrupted源码，发现其返回的是当前线程的中断标志，并且返回后将中断标志重置为false。这里需要注意的是假如在main方法中有这样一句: threadA.interrupted()，此时返回的不是threadA的中断标志而是主线程（main方法所在线程）的。而上述代码while循环中则返回的是MyThread的中断标志。 12345public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125;private native boolean isInterrupted(boolean ClearInterrupted); 而要获取某个具体线程对象的中断标志，则应该用isInterrupted()方法。 Thread其他常见方法join()项目中经常会遇到“等待其他几个线程执行完毕后才能继续往下执行”的场景，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。Thread的join()则可以满足该场景的需求。 join()的作用：在线程A中调用线程B的join() 方法，线程A进入waiting状态，直到线程B执行完毕。 sleep()sleep(long millis)是Thread类的static native方法，单位是毫秒。调用Thread.sleep(1000)并不会释放锁，进入timed waiting状态，1000毫秒过后该线程自动唤醒进入就绪态等待CPU调度。 yield()Thread类的静态方法。当一个线程调用yield方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU使用，但是线程调度器可以无条件忽略该暗示。 如果当前线程成功让出CPU使用权，会进入就绪态，甚至可能发生刚让出CPU使用权就又被调度到运行态的情况。 该方法可用于调试或测试时复现并发竞争条件导致的问题。 setDaemon(Boolean boolean)Java中线程分为daemon（守护）线程和user线程两类，其中守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，比如垃圾回收线程就是守护线程，而main方法所在的线程则是主线程。 当所有用户线程结束时，程序也就终止，同时会杀死所有守护线程。 通过在线程调用start()之前myThread.setDaemon(true);来设置该线程为守护线程。 总结：如果希望主线程结束后JVM进程马上结束，就将子线程设置为守护线程。 面试：wait()与sleep()区别？ wait()是Object的方法，sleep()是Thread的方法。 wait()会释放锁，sleep()不会。 线程死锁死锁产生必备四条件 互斥： 线程获取到的资源只能自己使用，其他请求该资源的线程只能等待。 请求并持有：线程请求被其他线程占有资源的同时，并不释放已经持有的资源。 不可剥夺：线程获取到的资源只能由线程使用完后自己释放。 环路：线程-资源形成闭环。 避免死锁只要破坏死锁产生必备的四个条件之一就可以避免死锁，但是目前只能通过避免形成环路来完成，也即可以使用资源申请的有序性原则。 synchronized关键字 同步代码块： 123456789101112131415public class A&#123; static Object obj = new Object(); public void func()&#123; synchronized(obj)&#123;&#125;//锁对象是obj &#125; public void func()&#123; synchronized(this)&#123;&#125;//锁对象是A的实例对象 &#125; public void func()&#123; synchronized(A.class)&#123;&#125;//锁对象是类Class对象 &#125;&#125; 同步方法：锁对象是实例对象。 1public synchronized void func()&#123;&#125; 静态同步方法：锁对象是类Class对象 1public static synchronized void func()&#123;&#125; volatile关键字volatile虽然保证了可见性和有序性，但是并不保证原子性，通过Java内存模型与Java规范的内存间交互操作我们知道，volatile关键字不满足原子性的原因就是，虽然其通过{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}满足了可见性，但是只要{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不是原子的，那么一个线程对一个变量的操作就不是原子的。比如多线程计时器程序： 12345678910public class Test &#123; static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; for(int i = 0; i &lt; 6; i++)&#123; new Thread(() -&gt; &#123;for(int j = 0; j &lt; 10000; j++) count++;&#125;).start(); &#125; Thread.sleep(1000); System.out.println(count); &#125;&#125; 使用volatile修饰count，显然在一个线程对一个变量进行{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}操作的时候，其他线程也可以进行这两个操作，这就导致了count的值最终一定会小于60000。而如果对内部for循环加synchronized块，那么它可以通过lock和unlock操作保证同步块中变量的修改一定满足{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不被其他线程打断。 volatile的使用场景使用条件：写入变量值不依赖当前值时。因为如果依赖当前值，则必须保证{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}满足原子性。 常见场景： 状态标志 一次性安全发布(one-time safe publication) 独立观察(independent observation) volatile bean 开销较低的读-写锁策略 双重检查(double-checked) 参考列表： 《Java并发编程之美》 https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"线程安全与锁优化","slug":"线程安全与锁优化","date":"2020-09-12T12:39:28.000Z","updated":"2020-09-21T12:11:40.100Z","comments":true,"path":"Java并发/线程安全与锁优化/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/","excerpt":"","text":"线程安全Java中的线程安全线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变不可变的对象一定是线程安全的，因此不需要再采取任何的线程安全保障措施。 不可变的类型： final修饰的基本数据类型 String 枚举类型 java.lang.Number的部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 绝对线程安全*不管运行环境如何，调用者都不需要任何额外的同步措施。Java API中标注自己是线程安全的类，大多都不是绝对的线程安全，经常需要其他的同步措施。 相对线程安全相对的线程安全才是我们通常意义上所讲的线程安全，它需要保证对这个对象是线程安全的，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段。Java中大部分都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。 线程对立*线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 线程安全互斥同步 同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。 互斥：互斥是实现同步的手段，主要有临界区、互斥量、信号量等方式。互斥是方法，同步是目的。 Java中实现同步的方式有synchronized关键字和J.U.C包的ReentrantLock。前者表现为原生语法层面的互斥锁，后者表现为API层面的互斥锁（lock()、unlock()配合try/finally语句来完成）。ReentrantLock增加了一些高级功能，主要有： 等待可中断：当持有锁的线程长期不释放锁的时候，等待的线程可选择放弃等待改为处理其他事情。 公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。ReentrantLock默认非公平，但可在构造方法中指定为true。 锁可以绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 CAS（Compare-And-Swap）比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，只有当 V 的值等于旧值A，才将 V 的值更新为 B。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。 ABA问题如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？ 如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类AtomicStampedReference。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。 无同步方案如果一个方法本就不涉及共享数据，那么它天生就是线程安全的。 可重入代码可重入代码一定是线程安全的。 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 线程本地存储可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。详解参照“ThreadLocal源码剖析”。 锁优化此处指JVM对synchronized的优化。 自旋锁与自适应自旋互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 锁消除虚拟机在JIT编译器运行时，对一些代码上要求同步，但是被检测出不可能存在共享数据竞争的锁进行消除。 锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去而被其他线程访问到，那就可以把它们当作栈上数据对待。 锁粗化如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。 轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 轻量级锁是相对于传统的重量级锁（synchronized）而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。 偏向锁偏向锁也是JDK1.6引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，甚至CAS也不需要。 偏向锁偏向于第一个获得它的线程，在接下来的执行过程中，如果该锁没有被其他线程获取，那么第一个线程访问同步块时则永远不需要同步。当其他线程获取该锁后，则结束偏向状态。 参考： 《深入理解Java虚拟机》 周志明 《Java并发编程之美》","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"Java内存模型","slug":"Java内存模型","date":"2020-09-12T12:39:07.000Z","updated":"2020-09-22T09:22:40.836Z","comments":true,"path":"Java并发/Java内存模型/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Java指令重排序Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。但是指令重排在多线程程序中可能会出问题。 主内存与工作内存Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。（C/C++直接使用物理硬件和操作系统的内存模型，因此可能会由于平台差异导致同一份代码无法正常运行。） JMM规定了所有的变量都存储在主内存中。注意： 此处的变量不包括局部变量与方法参数，因为它们是线程私有的。 此处的主内存与硬件的主内存不同，此处仅是JVM内存的一部分。 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存拷贝副本（如果是对象，不会拷贝整个对象，只会拷贝某些字段值）。 线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也无法访问对方的工作内存。JMM示意图如下： 这与硬件的缓存访问操作很相似： 内存间交互操作JMM定义了8种操作来完成主内存和工作内存之间的交互，这些操作是原子的、不可再分的。 lock: 作用于主内存，把一个变量标识为一条线程独占。 unlock: 作用于主内存，把一个锁定状态的变量释放。 read: 把一个变量的值从主内存传输到工作内存。 load: 把read操作得到的值放入工作内存的变量副本中。 use: 把工作内存变量的值传递给执行引擎。每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行此操作。 assign: 把执行引擎接收到的值赋给工作内存的变量。 store: 把工作内存的一个变量值传输到主内存。 write: 把store传的值放入主内存的变量中。 内存模型三大特征Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 原子性原子性的含义理解：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 由JMM直接保证的原子性变量操作包括read/load/use/assign/store/write。 如果应用场景需要一个更大范围的原子性保证，JMM还提供了lock和unlock来满足这种需求，对应的更高层次的字节码指令为monitorenter和monitorexit隐式使用这两个操作，反应到代码中就是synchronized关键字的使用，也即synchronized块的操作也具有原子性。也即lock-&gt;{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}-&gt;unlock保证了{}中一连串操作具有原子性。而volatile关键字不满足原子性的原因就是，虽然其通过{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}满足了可见性，但是只要{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不是原子的，那么一个线程对一个变量的操作就不是原子的。 synchronized关键字经过编译后，会在同步块前后分别形成monitorenter和moniterexit两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明锁对象（monitorenter含义：获得对象的锁；monitorexit含义：释放对象的锁），比如同步块的this/某个对象，或者synchronized方法对应的实例对象，以及静态synchronized方法对应的类Class对象。 Tip: 通过javap反编译发现，临界区代码后有两个monitorexit字节码指令，是因为如果出现异常退出也需要释放锁。 可见性可见性是指：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 JMM如何实现可见性？ 答：volatile，在变量修改后将新值同步回主内存{assign-&gt;store-&gt;write}，变量使用前从主内存刷新到工作内存{read-&gt;load-&gt;use}。 Java哪些关键字可以保证可见性？ volatile synchronized: 对一个变量执行lock操作后，从主内存刷新到工作内存{lock-&gt;read-&gt;load-&gt;use}；对一个变量执行unlock操作之前，必须先把变量值同步回主内存{assign-&gt;store-&gt;write-&gt;unlock}。 final: 被 final 修饰的字段在构造器中一旦初始化完成，那么其它线程就能看见 final 字段的值。 有序性有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序以及工作内存与主内存同步有延迟。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码（也即锁的作用），相当于是让线程顺序执行同步代码。 先行发生原则（Happens-Before规则）先行发生是JMM中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其含义是：B发生之前，A产生的影响能被B观察到。“影响”包括修改了内存中共享变量的、发送了消息、调用了方法等。 JMM中一些天然的先行发生关系如下： 程序次序规则（Program Order Rule）在一个线程内，在程序前面的操作先行发生于后面的操作。 管程锁定规则（Monitor Lock Rule）一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile变量规则（Volatile Variable Rule）对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则（Thread Start Rule）Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则（Thread Join Rule）Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则（Thread Interruption Rule）对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性（Transitivity）如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 伪共享缓存一致性（Cache Coherence）在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，如图所示： 当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那么在同步数据回主内存时该以谁的缓存数据为准呢？为了解决一致性问题，需要处理器访问缓存时都遵循一些协议，也即缓存一致性协议，在读写时根据协议来操作，这类协议有MSI，MESI，MOSI等等。 局部性原理局部性原理: CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。 时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。 伪共享伪共享：多线程下访问同一个Cache行中的多个不同变量时产生。 在Cache内部是按行存储的，其中每一行称为一个Cache行。Cache行是与主内存进行数据交换的单位，其大小一般为2的幂次数字节。 当CPU访问某个变量时，首先会检查CPUCache内是否有该变量，如果有则直接读取，否则就向下级缓存找，直到主内存。然后将找到的变量所在内存区域的一个Cache行大小的内存复制到Cache中。由于存放到Cache行的是内存块而不是单个变量，所以可能会把多个变量存放到一个Cache行中。 由程序运行的局部性原理可知，程序会把变量所在内存中大小为Cache行的内存（地址连续的内存）放入CPUCache中。当多个线程同时写入Cache行中不同的变量时，由于缓存一致性协议，此时只能有一个线程操作Cache行，所以相比将每个变量放到一个Cache行，性能会有所下降，这就是伪共享。以下图为例： 上图中变量x,y所在的内存区域同时被复制到了CPU1和CPU2的Cache行以及二级缓存中，当线程1使用CPU1对x进行更新时，首先修改CPU1Cache1变量x所在的缓存行，此时由于缓存一致性协议，CPU2中变量x对应的缓存行失效，那么线程2在写入变量y时就只能从二级缓存查找了。 在创建数组时，数组里的多个元素就会被放入同一个缓存行，对于单线程程序而言，如果顺序访问数组中的元素，就会充分利用程序运行的局部性原则，从而加速了程序的运行。 避免伪共享jdk1.8之前一般通过字节填充的方式来避免伪共享，也就是创建一个变量时使用无关字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同一个缓存行中。例如如下代码： 1234public final static class FilledLong&#123; public volatile long value = 0L; public long p1, p2, p3, p4, p5, p6;&#125; 使用CPU-Z查看发现我的电脑CPU一级缓存行大小为64Byte，由于一个长整型变量占8Byte，那么以上代码变量总共占了56个Byte，其中6个变量48Byte为填充字节，而类对象的字节码的对象头占用8Byte，所以一个FilledLong对象实际会占用64Byte。 jdk1.8提供了一个sun.misc.Contended注解来解决伪共享问题。将上面的代码修改如下： 1234@sun.misc.Contendedpublic final static class FilledLong&#123; public volatile long value = 0L;&#125; 需要注意的是，默认情况下，@Contended注解只用于Java核心类，比如rt包下的类。如果用户类路径下的类需要使用该注解，则需要添加JVM参数：-XX:-RestrictContended，填充的宽度默认为128，自定义宽度则可以设置-XX:ContendedPaddingWidth。 参考：《深入理解Java虚拟机》 周志明","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"数据结构复习","slug":"数据结构复习","date":"2020-09-10T03:05:44.000Z","updated":"2020-09-10T06:50:15.337Z","comments":true,"path":"数据结构与算法/数据结构复习/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"OverView 数据结构数组 优点：存取速度快。 缺点：a.事先必须知道数组的长度。b.需要大块连续的内存块。c.插入删除元素的效率低 Java中主要类似的实现为ArrayList，其他一些容器底层也几乎都会用数组存储数据。 链表 优点：插入删除元素快；无空间限制。 缺点：查找存取慢。 分类：单向链表；双向链表；循环链表 Java中主要类似的实现为LinkedList，其他一些容器底层也会用到链表。 哈希表 详情见HashMap源码剖析。 栈和队列 栈：LIFO 队列：FIFO Java中推荐使用ArrayDeque。 树基础二叉树最多有两棵子树的树。 满二叉树二叉树中所有非叶子节点的度都是2，且叶子节点都在同一层次上。 完全二叉树如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。 二叉搜索树（BST）二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树: 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 平衡二叉树（AVL）平衡二叉树是指一棵空树或者它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。并且它满足二叉查找树的性质。 红黑树（R-B Tree）B树B树是一种平衡多路查找树。 B+树B*树R树哈夫曼树图基础 定义 相关概念 类型 无向图 有向图 完全图 存储结构 邻接矩阵表示法 邻接表表示法 BFS和DFS最小生成树 相关概念 Kruskal算法 Prim算法 最短路径算法 Dijkstra算法 Floyd算法 拓扑排序AOE网与关键路径Blog推荐 基础：https://www.cnblogs.com/skywang12345/p/3603935.html 进阶：https://blog.csdn.net/v_JULY_v/article/list/3 参考：https://www.pdai.tech/md/algorithm/alg-basic-overview.html","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"LinkedHashMap源码剖析","slug":"LinkedHashMap源码剖析","date":"2020-09-09T07:13:05.000Z","updated":"2020-09-27T02:53:40.031Z","comments":true,"path":"Java集合框架/LinkedHashMap源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述LinkedHashMap是HashMap的一个子类，保存了键值对的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的键值对肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 LinkedHashMap的实现底层数据结构 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; 节点Entry继承自HashMap.Node，包含前置指针和后置指针。 123456//双向链表的头指针transient LinkedHashMap.Entry&lt;K,V&gt; head;//双向链表的尾指针transient LinkedHashMap.Entry&lt;K,V&gt; tail;//为false维护的是插入顺序；为true则是维护访问顺序。final boolean accessOrder; 由此可见LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了一个变量用于维护插入顺序或者访问顺序。 构造方法12345678910111213141516171819public LinkedHashMap(int initialCapacity, float loadFactor)&#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 由构造方法知LinkedHashMap默认维护的是插入顺序。 常用方法分析get()12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount;//get也会导致结构性更改 &#125; &#125; 由get方法可知，accessOrder为true，也即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get方法都会将当前节点移动至链表尾部。保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 put()查看源码发现LinkedHashMap并没有重写put方法，但是重写了newNode方法，因此put会调用重写的newNode方法。并且发现put方法最后调用了afterNodeAccess方法。 123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p);//新建节点连接于链表尾部 return p;&#125;// link at the end of listprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; removeEldestEntry()重写该方法可以删除最久未被使用的元素。 afterNodeInsertion()新增时判断是否需要删除最久未被使用的元素。 开启accessOrder的情况和最后这两个方法主要用于实现LRU缓存。 小结 LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了变量accessOrder用于维护插入顺序或者访问顺序。 accessOrder为true，即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get/put都会将当前节点移动至链表尾部。注意这意味着get也会导致modCount变化，迭代器会快速失败。","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"HashMap源码剖析","slug":"HashMap源码剖析","date":"2020-09-09T05:10:49.000Z","updated":"2020-09-27T02:38:11.979Z","comments":true,"path":"Java集合框架/HashMap源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述Map接口主要实现类有四个：HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图： 其中HashMap根据key的hashCode计算得到的哈希值存储数据，因此在访问数据时直接根据hash函数计算就可以得到数据在数组中的位置，访问速度很快，但是遍历顺序却是不确定的。 HashMap最多只允许一个节点的key为null，允许多个节点的value为null。 HashMap非线程安全。若要满足线程安全，可以使用Collections.synchronizedMap方法使HashMap具有线程安全的能力，或者直接使用ConcurrentHashMap。 HashMap的实现底层数据结构 如上图所示，HashMap使用链地址法来解决冲突问题。jdk8后HashMap使用数组+链表/红黑树实现。 1234567891011121314151617181920212223242526272829303132333435363738394041transient Node&lt;K,V&gt;[] table;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//用来定位数组索引位置 final K key;//final修饰，key不可变，否则根据hash函数计算所得的索引位置就变了 V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; HashMap成员变量的含义12345678910111213141516171819202122232425262728293031323334353637383940//数组默认初始容量16.数组容量必须是2的幂，定位索引时采用&amp;运算效率高。static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//数组最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;//当链表节点个数 &gt;= 8时，转换为红黑树，访问的时间复杂度由O(N)降为O(logN)static final int TREEIFY_THRESHOLD = 8;//当红黑树节点个数 &lt; 6时，退化为链表static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 只有当数组容量&gt;=64时，bin中的链表才会转换为红黑树； * 否则就算链表节点个数&gt;=8，也不会树化，而是对数组进行扩容。 */static final int MIN_TREEIFY_CAPACITY = 64;//等于capacity * load factor, 当哈希表中有threshold个bin有节点时，进行扩容int threshold; //记录HashMap发生结构性更改的次数，用于实现迭代器fail-fast机制transient int modCount;//负载因子,如果内存空间充足，可以在构造HashMap时适当减小负载因子和增大初 始容量，以此来提高HashMap效率；//相反，如果内存空间紧张而对时间效率要求不高，则可以适当调大负载因子final float loadFactor;//总节点个数transient int size;//用于entrySet()方法返回所有键值对transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; 哈希方法哈希函数用于确定节点在数组中的索引位置，其数学形式为index = hash(key)。jdk1.8实现源码如下： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 由源码可知，hash函数的返回值并不是数组索引，因为数组长度并没有参与运算。实际上，获取索引的最后一步操作在获取节点的方法中实现，比如getNode()方法中的代码片段tab[(n - 1) &amp; hash]，tab就是哈希数组，n为数组长度。 以上代码可分为三步： h = key.hashCode() 取key的hashCode值。 hash = h ^ (h &gt;&gt;&gt; 16) 无符号右移16bit(左边补0), 高位运算。高16位异或运算结果为hashCode原来的值，低16位运算结果则是hashCode值的高16位和低16位异或所得。这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销，并且减小了冲突的可能。 index = (n - 1) &amp; hash 相当于求模运算，但是效率比%更高。因为数组的大小永远是2的幂，所以n - 1是011..11（32位）的形式，任何非负整数（且 &lt;= n-1）和它按位&amp;都会等于其本身。 举个例子： 构造方法123456789101112131415161718192021222324252627//创建指定初始容量和负载因子的HashMappublic HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125;//创建指定初始容量和默认负载因子的HashMap public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125;public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 注意，构造方法中并没有创建哈希数组，初始化数组操作是通过resize()方法完成，而resize()方法是在放入键值对的时候才进行调用（初始化或者扩容2倍），比如putVal()方法。 构造方法中调用了tableSizeFor()来获取大于指定容量的最小的2的幂（在ArrayDeque中已分析），其源代码如下： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;//从左往右依次运算 &#125; 扩容机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//旧数组容量 int oldThr = threshold;//旧扩容阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//扩容前数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return oldTab;//直接返回旧数组不再扩容 &#125;//扩容两倍并检验是否超过最大容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // 阈值同样翻倍 &#125; else if (oldThr &gt; 0) //oldCap为0但是oldThr&gt;0，这是因为构造方法中并没有创建哈希数组，但是却通过tableSizeFor()为threshold赋了值 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //对应上面代码的第二种情形，计算新的threshold if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab;//创建新hash数组并赋值 if (oldTab != null) &#123; //以下代码块将每个bin都复制到新的数组中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//释放引用，避免内存泄漏 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode)//转为红黑树操作 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; //将该链表的冲突节点重新计算索引分配‘原索引’和‘原索引+oldCap’处 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; //e.hash与oldCap按位与只有两种结果，要么为0，要么为oldCap，因为oldCap的二进制形式为0...01000..0 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123;//原索引+oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bin if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bin if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 由注释知，resize()方法用于初始化哈希数组或者扩容2倍。注意，扩容后元素的位置要么是在原位置，要么是在原位置再移动单倍容量位移的位置。 常用方法分析put()该方法的流程图如下： 判断table是否为空，空则调用resize()创建数组 计算index，并判断该处是否为null，为null则直接创建节点，并转向6。 不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value 不一致则判断该链为红黑树。 该链为链表则遍历，遍历过程判断链表长度&gt;=8转红黑树处理；不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value 添加节点后判断是否超过阈值threshold，是则扩容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //1.判断table是否为空，空则调用resize()创建数组 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2.计算index，并判断该处是否为null if ((p = tab[i = (n - 1) &amp; hash]) == null) //为null则直接创建节点，并转向6 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //3.不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //4.判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //5.该链为链表则遍历 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //5.1 判断，链表长度&gt;=8转红黑树处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //5.2 不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value;//覆盖value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //6.添加节点后判断是否超过阈值threshold，是则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 其他常用方法： size()：获取总节点个数 isEmpty()：判断是否为空 containsKey()：判断是否包含指定key get()：获取指定key节点的value remove()：移除指定key的节点 keySet()：获取包含所有key的Set entrySet()：获取包含所有节点的Set 小结 扩容特别耗性能，所以在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 负载因子可以修改，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 JDK1.8引入红黑树大程度优化了HashMap的性能。 参考：https://zhuanlan.zhihu.com/p/21673805 ​ http://irfen.me/java1-8-hashmap/","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"PriorityQueue源码剖析","slug":"PriorityQueue源码剖析","date":"2020-09-08T10:40:43.000Z","updated":"2020-09-27T02:55:48.959Z","comments":true,"path":"Java集合框架/PriorityQueue源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述Java中优先级队列通过二叉小根堆（任意一个非叶子节点的权值都不大于其孩子节点的权值）实现，可以用一棵完全二叉树表示，这意味着数组可以作为PriorityQueue的底层实现。优先队列的作用是能保证每次取出的元素都是队列中权值最小的，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器。注意，PriorityQueue不允许放入null元素。 在完全二叉树中，假设某个节点的下标为Node，其左孩子下标为LNode、右孩子下标为RNode，那么有如下关系： Node == (LNode - 1)/2 == (RNode - 1)/2 LNode == 2*Node + 1 RNode == 2*Node + 2 通过上述三个公式，可以很容易计算出某个节点的父节点和孩子节点的下标。 PriorityQueue的实现底层数据结构1234567891011121314/** * Priority queue represented as a balanced binary heap: the two * children of queue[n] are queue[2*n+1] and queue[2*(n+1)]. The * priority queue is ordered by comparator, or by the elements' * natural ordering, if comparator is null: For each node n in the * heap and each descendant d of n, n &lt;= d. The element with the * lowest value is in queue[0], assuming the queue is nonempty. */ transient Object[] queue; // non-private to simplify nested class access /** * The number of elements in the priority queue. */ private int size = 0; 构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102private static final int DEFAULT_INITIAL_CAPACITY = 11;/** * The comparator, or null if priority queue uses elements' * natural ordering. */private final Comparator&lt;? super E&gt; comparator;public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null); &#125;//默认构造，默认容量，不使用比较器public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125;//指定初始容量，不使用比较器public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator); &#125;//指定比较器，使用默认容量public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125;//以上构造都使用this()调用了本构造方法/** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified collection. If the specified collection is an instance of * a &#123;@link SortedSet&#125; or is another &#123;@code PriorityQueue&#125;, this * priority queue will be ordered according to the same ordering. * Otherwise, this priority queue will be ordered according to the * &#123;@linkplain Comparable natural ordering&#125; of its elements. * * @param c the collection whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of the specified collection * cannot be compared to one another according to the priority * queue's ordering * @throws NullPointerException if the specified collection or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(Collection&lt;? extends E&gt; c) &#123; if (c instanceof SortedSet&lt;?&gt;) &#123; SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) ss.comparator(); initElementsFromCollection(ss); &#125; else if (c instanceof PriorityQueue&lt;?&gt;) &#123; PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) pq.comparator(); initFromPriorityQueue(pq); &#125; else &#123; this.comparator = null; initFromCollection(c); &#125; &#125; /** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified priority queue. This priority queue will be * ordered according to the same ordering as the given priority * queue. * * @param c the priority queue whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of &#123;@code c&#125; cannot be * compared to one another according to &#123;@code c&#125;'s * ordering * @throws NullPointerException if the specified priority queue or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123; this.comparator = (Comparator&lt;? super E&gt;) c.comparator(); initFromPriorityQueue(c); &#125; /** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified sorted set. This priority queue will be ordered * according to the same ordering as the given sorted set. * * @param c the sorted set whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of the specified sorted * set cannot be compared to one another according to the * sorted set's ordering * @throws NullPointerException if the specified sorted set or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(SortedSet&lt;? extends E&gt; c) &#123; this.comparator = (Comparator&lt;? super E&gt;) c.comparator(); initElementsFromCollection(c); &#125;","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"ArrayDeque源码剖析","slug":"ArrayDeque源码剖析","date":"2020-09-08T07:05:08.000Z","updated":"2020-09-27T02:35:13.721Z","comments":true,"path":"Java集合框架/ArrayDeque源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayDeque%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述Deque, 即“double ended queue”，表示双向队列，它既可以当作队列使用，也可以当作栈使用。ArrayDeque和LinkedList是Deque的两个通用实现，但是官方更推荐使用AarryDeque用作栈和队列。 ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，需要设置head指针和tail指针，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。也就是说ArrayDeque底层实现是一个循环数组（circular array），并且数组的任何一点都可能被看作起点或终点。 ArrayDeque是非线程安全的，另外该容器不允许放入null元素。 ArrayDeque实现底层数据机构123456789101112131415161718192021222324252627282930/** * The array in which the elements of the deque are stored. * The capacity of the deque is the length of this array, which is * always a power of two. The array is never allowed to become * full, except transiently within an addX method where it is * resized (see doubleCapacity) immediately upon becoming full, * thus avoiding head and tail wrapping around to equal each * other. We also guarantee that all array cells not holding * deque elements are always null. */ transient Object[] elements; // non-private to simplify nested class access /** * The index of the element at the head of the deque (which is the * element that would be removed by remove() or pop()); or an * arbitrary number equal to tail if the deque is empty. */ transient int head; /** * The index at which the next element would be added to the tail * of the deque (via addLast(E), add(E), or push(E)). */ transient int tail; /** * The minimum capacity that we'll use for a newly created deque. * Must be a power of 2. */ private static final int MIN_INITIAL_CAPACITY = 8; 由注释总结得出以下几点重要信息： 最小初始容量为8，并且自动扩容后数组的大小永远是2的幂。 数组永远不能满，以避免head和tail指针相等。 数组元素不能为null。 构造函数1234567891011121314151617181920212223242526272829303132333435 public ArrayDeque() &#123; elements = new Object[16]; &#125; public ArrayDeque(int numElements) &#123; allocateElements(numElements); &#125; public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); addAll(c); &#125;private void allocateElements(int numElements) &#123; elements = new Object[calculateSize(numElements)]; &#125;private static int calculateSize(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests \"&lt;=\" because arrays aren't kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; return initialCapacity; &#125; 由源码可知： 如果不指定容量创建ArrayDeque，默认数组大小为16。 如果指定容量大小，构造方法会调用static int calculateSize(int numElements)计算最合适的2的幂来创建数组。若指定容量小于MIN_INITIAL_CAPACITY8，则直接创建大小为8的数组；若指定容量大于等于8，则会通过以下代码块来获得大于指定容量的最小2的次幂数。 1234567initialCapacity = numElements;initialCapacity |= (initialCapacity &gt;&gt;&gt; 1);initialCapacity |= (initialCapacity &gt;&gt;&gt; 2);initialCapacity |= (initialCapacity &gt;&gt;&gt; 4);initialCapacity |= (initialCapacity &gt;&gt;&gt; 8);initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);initialCapacity++; &gt;&gt;&gt;为无符号右移运算，以8为例，其二进制数为000…01000共32位，后面简写为1000。8 &gt;&gt;&gt; 1后则为0100，相当于除以2的1次幂；8 &gt;&gt;&gt; 2后则为0010，相当于除以2的2次幂… |为按位或，两数按位或，对应位只要有一个1该为结果即为1。 那么以initialCapacity等于8为例： 12345ini &gt;&gt;&gt; 1, 得0100；1000 | 0100 得 ini &#x3D;1100ini &gt;&gt;&gt; 2, 得0011；1100 | 0011 得 ini &#x3D;1111ini &gt;&gt;&gt; 4, 得0000；1111 | 0000 得 ini &#x3D;1111ini &gt;&gt;&gt; 8, 得0000；1111 | 0000 得 ini &#x3D;1111ini &gt;&gt;&gt; 16, 得0000；1111 | 0000 得 ini &#x3D;1111 最后结果为16。 12345initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 1);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 2);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 4);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 8);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 16); 实际上，以上代码块的作用是将initialCapacity 的最高位1的所有低位全部变为1，如下图所示： 5次操作后再进行自加，就会得到大于initialCapacity的最小2的次幂数。 有一个特殊情况需要处理，即initialCapacity的最高位1是在第31位上： 01XXXXXX XXXXXXXX XXXXXXXX XXXXXXXX 这样在进行所有操作后initialCapacity会变为： 10000000 00000000 00000000 00000000 最高位为1，实际上就上溢为一个负数(-2^31)(32位整型范围为-2^31 ~ 2^31 - 1)。为了处理这种情况，会将initialCapacity右移一位，这样它就变为了一个很大的整数（2的30次幂）。 参考：https://blog.csdn.net/liubin119712/article/details/51075861 使用集合元素创建ArrayDeque调用的addAll()方法实际上继承自父抽象类AbstractCollection的，因为ArrayDeque没有重写该方法。 1234567public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; 然后addAll中的add方法为ArrayDeque重写的add方法。 扩容：doubleCapacity方法ArrayDeque的自动扩容发生在head == tail的情况下，此时直接扩容为原来的两倍。int newCapacity = n &lt;&lt; 1;。 12345678910111213141516171819/** * Doubles the capacity of this deque. Call only when full, i.e., * when head and tail have wrapped around to become equal. */ private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素个数 int newCapacity = n &lt;&lt; 1;//扩容为原空间2倍 if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制head右半部分 System.arraycopy(elements, 0, a, r, p);//复制head左半部分 elements = a; head = 0; tail = n; &#125; addFirst() 1234567public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); &#125; 因为tail指针总是指向下一个可插入的空位，也即在进行任何添加元素的操作时，总会有空位，所以不需要考虑空间问题。 head = (head - 1) &amp; (elements.length - 1)：这段代码在head不为0时，相当于求模运算，但是效率比使用%高。因为数组的大小永远是2的幂，所以elements.length - 1是011..11（32位）的形式，任何非负整数（且 &lt;= len-1）和它按位与都会等于其本身；而在head为0时，head-1则为-1，其二进制源码为1000...01（32位），由于计算机运算使用补码，-1的补码则为除符号位外全部取反后+1，为1111...11（32位），那么它和elements.length - 1按位与的结果就是elements.length - 1本身，也就是在数组末尾插入。 addLast()1234567public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; (tail = (tail + 1) &amp; (elements.length - 1)相当于求模运算。 pollFirst()1234567891011public E pollFirst() &#123; int h = head; @SuppressWarnings(\"unchecked\") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // 让GC回收 head = (h + 1) &amp; (elements.length - 1);//求模 return result; &#125; pollLast()12345678910public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(\"unchecked\") E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result; &#125; peekFirst()1234public E peekFirst() &#123; // elements[head] is null if deque empty return (E) elements[head]; &#125; peekLast()123public E peekLast() &#123; return (E) elements[(tail - 1) &amp; (elements.length - 1)]; &#125; 参考：https://www.pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"LinkedList源码剖析","slug":"LinkedList源码剖析","date":"2020-09-07T12:11:21.000Z","updated":"2020-09-27T02:55:09.282Z","comments":true,"path":"Java集合框架/LinkedList源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述LinkedList同时实现了List, Queue和Deque三个接口，因此它既可以看作一个顺序容器，又可以看作一个队列，也可以看作一个栈。由于Java官方已经不建议使用Vector和Stack，因此LinkedList是一个选择。关于栈和队列，现在的首选是ArrayDeque，它 没有容量限制，可根据需求自动进行扩容。由于ArrayDeque的底层实现为数组，其作为队列或数组时效率相较于基于双向链表的 LinkedList也要更好一些。注意，ArrayDeque 不支持为 null 的元素，LinkedList支持null。 LinkedList实现底层数据结构LinkedList底层通过双向链表实现，这决定了它所有与下标有关的操作都是线性时间，而在首尾插入删除元素只需要常数时间。为了追求效率LinkedList没有实现同步，如果需要并发访问，可以采用Collections.synchronizedList()方法进行包装。 123456789101112131415161718transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;//节点内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 构造方法1234567891011121314public LinkedList() &#123;&#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; getFirst(), getLast()获取list的第一个元素和最后一个元素 12345678910111213public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; removeFirst(), removeLast(), remove(e), remove(index)删除第一个节点 123456789101112131415161718192021public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++;//fast-fail return element; &#125; 删除最后一个节点 12345678910111213141516171819202122public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; 删除第一次出现的指定元素，若没有则返回false。注意LinkedList允许null元素，因此分为两种情况遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 删除指定index的节点，使用index &lt; (size &gt;&gt; 1判断index在前半段还是后半段，以此来决定从头部还是尾部开始遍历，可以一定程度提高效率。 1234567891011121314151617181920public E remove(int index) &#123; checkElementIndex(index);//检查是否越界 return unlink(node(index)); &#125;//返回指定index的节点Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; add(), addAll()末尾添加节点 12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true; &#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; 指定index添加元素。通过node(index)找到index处的节点，将element插入到该节点之前。 123456789101112131415161718192021public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; 末尾添加集合里所有元素 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; 指定index添加集合元素。添加到指定元素之前。 1234567891011121314151617181920212223242526272829303132333435363738public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; clear()清空链表 12345678910111213141516public void clear() &#123; // Clearing all of the links between nodes is \"unnecessary\", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++; &#125; set(), get()123456789101112public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; indexOf(), lastIndexOf()查找第一次出现指定元素的下标和最后一次出现指定元素的下标，找不到则返回-1。 1234567891011121314151617181920212223242526272829303132333435public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; Queue接口的方法peek(): 获取第一个元素。null不会抛异常。 element(): 获取第一个元素，如果为null会抛异常。 poll(): 获取并删除第一个元素。 offer(): 末尾添加元素。 参考：https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"ArrayList源码剖析","slug":"ArrayList源码剖析","date":"2020-09-07T09:18:35.000Z","updated":"2020-09-27T02:36:26.212Z","comments":true,"path":"Java集合框架/ArrayList源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述​ ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。 ​ 每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。 ​ size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 ​ 为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，可使用Vector替代。ArrayList除未实现同步外，其余跟Vector大致相同。 ArrayList的实现ArrayList中的常量12345678910111213141516/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 底层数据结构1234567891011121314/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 三种构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 扩容机制​ 每当向数组中添加元素时，都要检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行自动扩容。 ​ 数组扩容通过公开方法ensureCapacity(int minCapacity)实现。当需要使用ArrayList存储较多数据时，我们最好手动使用该方法进行扩容，以减少每次1.5倍自动扩容产生的复制数组元素的开销。因为ArrayList的初始容量只有10。 ​ 注意以下源码中，grow()方法中的int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);，可见每次扩容是在现有容量的基础上增加0.5倍容量。由于每次扩容老数组的元素会复制到新数组中，可见自动扩容机制的开销非常大。我们在实际使用ArrayList的时候，在可预知要保存多少个元素的情况下，应该在new ArrayList时指定容量大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add(), addAll()​ 添加元素之前，调用ensureCapacityInternal(size + 1);检查当前数组元素个数是否已达容量上限，是则进行grow操作。 1234567891011121314151617181920212223242526272829303132333435/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; add(int index, E element)操作的时间复杂度与插入元素的位置相关。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 与add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 set(), get()12345678910111213141516171819202122public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index]; &#125;public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; remove()remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。注意，根据可达性分析算法，必须将数组中最后一个位置的引用清除掉，堆中的对象才会被回收，也就是显式的为最后一个位置赋null值。 123456789101112131415161718192021222324252627282930313233343536373839public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125;public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; trimToSize()将底层数组的容量调整为当前列表保存的实际元素的大小。 12345678910111213/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; indexOf(), lastIndexOf()获取元素第一次出现的index: 12345678910111213141516171819/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 获取元素最后一次出现的index: （倒序遍历数组） 12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 快速失败机制ArrayList的Fail-Fast机制通过记录modCount的值来实现。该变量在ArrayList的父抽象类AbastractList定义，其含义是容器发生结构性修改的次数。详细介绍在迭代器篇。 Arrays.copyof()和System.arraycopy()Arrays的copyof()方法有很多重载方法，以下为ArrayList中使用的重载版本。 12345678910111213public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass()); &#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 第二个方法最后一个参数表示最后返回的数组元素数据类型，也就是新数组的数据元素类型。该方法在内部创建了了一个长度为newLength的新数组，又调用了System.arraycopy()方法将老数组的元素复制到新数组。 查看java.lang.System发现，System.arraycopy()为本地方法，最终调用了C语言的函数来实现复制。 1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 参考：https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html ​ https://blog.csdn.net/ns_code/article/details/35568011","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"集合知识体系结构","slug":"集合知识体系结构","date":"2020-09-07T09:17:52.000Z","updated":"2020-09-10T15:25:02.002Z","comments":true,"path":"Java集合框架/集合知识体系结构/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"集合知识体系结构 CollectionListArrayList 基于动态数组实现，支持随机访问。 Vector 和 ArrayList 类似，但它是线程安全的。 StackLinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 QueueLinkedList 同上 PriorityQueue 基于小根堆实现，可以用它来实现优先队列。 Deque&lt;&gt;ArrayDeque 基于循环数组实现的队列，比LinkedList性能更好。 SetHashSet 基于HashMap实现（适配器模式），支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 继承自HashSet，具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 MapHashMap 基于哈希表实现。 LinkedHashMap 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。 HashTable 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 TreeMap 基于红黑树实现。 Collections工具类","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"比较器与迭代器","slug":"比较器与迭代器","date":"2020-09-07T09:17:29.000Z","updated":"2020-09-07T11:36:53.302Z","comments":true,"path":"Java集合框架/比较器与迭代器/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"比较器Comparable java.lang.Comparable源码： 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; Comparable的实现类，其实例化对象和同类型对象比较。 其compareTo方法只有一个参数，一个和自己比较的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。 对于容器来说，在容器内部实现compareTo方法。 Comparator java.util.Comparator源码主要部分： 1234public interface Comparator&lt;T&gt;&#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; Comparator的实现类，其实例化对象作为裁判。 其compare方法是两个参数，裁判来比较传入的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。 对于容器来说，在容器外部实现compare方法。 二者的选择 排序规则固定，Comparable接口。排序规则经常变化，Comparator接口。 迭代器概述​ 由于各种容器的底层实现结构（数组，链表，哈希表等）不同，把容器元素的访问逻辑从不同类型容器中抽取出来，从而避免暴露容器的内部结构，使用户对容器元素的操作更简单，即迭代器模式。 Iterable java.lang.Iteable源码： 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action)&#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; Collection接口继承自Iterable接口，Iterable的作用是： 使得其所有实现成为foreach语句的目标 其iterator()方法返回一个标准的Iterator实现 Iterator java.util.Iterator源码： 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext();&#x2F;&#x2F;判断是否存在下一个元素 E next();&#x2F;&#x2F;获取下一个元素 default void remove() &#123; throw new UnsupportedOperationException(&quot;remove&quot;); &#125;&#x2F;&#x2F;移除元素 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; Iterator遍历时禁止对容器进行增删的问题 ​ 使用Iterator或者foreach（foreach底层实现为Iterator）时，禁止对所遍历的容器进行改变其大小结构的操作，也即不能使用容器的add/remove方法，否则会报ConcurrentModificationException。 ​ ArrayList中Iterator实现源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F;ArrayList的内部类private class Itr implements Iterator&lt;E&gt; &#123; int cursor; &#x2F;&#x2F; index of next element to return int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such int expectedModCount &#x3D; modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor !&#x3D; size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i &#x3D; cursor; if (i &gt;&#x3D; size) throw new NoSuchElementException(); Object[] elementData &#x3D; ArrayList.this.elementData; if (i &gt;&#x3D; elementData.length) throw new ConcurrentModificationException(); cursor &#x3D; i + 1; return (E) elementData[lastRet &#x3D; i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor &#x3D; lastRet; lastRet &#x3D; -1; expectedModCount &#x3D; modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;&#x2F;&#x2F;省略 &#125; final void checkForComodification() &#123; if (modCount !&#x3D; expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; ​ 由源码可知，检查并抛出异常的是checkForComodification方法，其判断条件为modCount != expectedModCount。expectedModCount是迭代器类Itr的成员变量，在迭代器对象创建时赋初值为modCount。那么modCount是什么呢？ ​ 找遍ArrayList类也没有发现modCount，那么向上找，发现其是ArrayList的父抽象类AbstractList的成员变量，其注释如下图 ​ 由注释可知，modCount的含义是list被结构性修改的次数。 ​ 由此可知，当ArrayList调用其add/remove方法时，modCount会自加，而此时迭代器中的expectedModCount未同步，因此才会导致再次调用next方法时抛出异常。如若使用ArrayList迭代器自带的remove方法，迭代器会同步更新expectedModCount的值，因此再次调用next不会报异常。 ​ 使用该机制的主要目的是为了实现ArrayList中的快速失败机制（fail-fast），在Java集合中较大一部分集合是存在快速失败机制的。 ​ 快速失败机制产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。 所以要保证在使用Iterator遍历集合的时候不出错误，就应该保证在遍历集合的过程中不会对集合产生结构上的修改。 总结：在使用迭代器时，ArrayList不能调用自身的add/remove方法。 ​ 但可以使用ArrayList的迭代器的remove方法，该方法移除迭代器返回的最后一个元素，且每调用一次next方法才能调用一次该remove方法（一对一）。 ​ 还可以使用ListIterator，它是一个更加强大的Iterator的子类型，可以使用add/remove方法。 ​ 参考：https://www.cnblogs.com/zyuze/p/7726582.html","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"Java泛型","slug":"Java泛型","date":"2020-09-04T11:06:21.000Z","updated":"2020-09-07T11:39:01.507Z","comments":true,"path":"Java基础/Java泛型/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"概述 在创建接口、类、方法时，为了代码复用和类型安全，使用泛型来作为类型。泛型可以看作形式参数，用于接受数据类型，当创建对象、实现接口、调用方法时才指定具体的类型。例如 123class List&lt;T&gt;&#123; private T element; &#125; 12345678class TestList&#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new List&lt;&gt;(); List&lt;Integer&gt; list = new List&lt;&gt;(); List&lt;Double&gt; list = new List&lt;&gt;(); //使用类时才指定List中元素具体的类型 &#125;&#125; Java泛型从JDK1.5引入，为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但在编译阶段会进行“类型擦除（Type Erasure）”，将所有的泛型表示都替换为具体的类型。 为什么引入泛型 为了代码复用：适用于多种数据类型执行相同的代码，例如 123private static &lt;T extends Number&gt; double add(T a, T b) &#123; return a.doubleValue() + b.doubleValue();&#125; 如果没有泛型，则对于int、float、double等类型都需要重载一个add方法。 为了类型安全：泛型类型在使用时指定，同时也就限定了集合中只能存储某一种具体类型的数据。以ArrayList为例： 12345678910111213public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;transient Object[] elementData;//ArrayList源码中定义的元素类型为Objectpublic E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index];//强制类型转换，由Object向下转型 &#125;&#125; 由源码可知，当调用get方法获取ArrayList元素时，get方法调用elementData方法，其return时由ArrayList完成强制类型转换（向下转型）。 如若ArrayList没有泛型机制会怎么样呢？ 那么，get方法只能返回Object类型的数据，好处是程序员可以使用ArrayList存储多种类型的数据。但是坏处也显而易见，当程序员使用ArrayList存储”String”、”Integer”、”Double”等各种类型的数据时，调用get方法得到的是Object类型，此时若程序员对这些数据向下转型为某种类型（比如String，String s = (String) obj），编译期不会报错，运行期才会报ClassCastException（因为Integer、Double不能强制转换为String），也就是类型不安全。 泛型的基本使用泛型类 使用泛型类 1234567891011121314151617class A&lt;T&gt;&#123; private T element; public T getElement()&#123; retruen element; &#125; public void setElement(T elem)&#123; this.element = elem; &#125;&#125;public class TestA&#123; public static void main(String[] args)&#123; A&lt;String&gt; a = new A&lt;&gt;(); a.setElement(\"test string...\"); System.out.println(a.getElement().length()); &#125;&#125; 多元泛型 123456789101112131415class B&lt;K, V&gt;&#123; private K key; private V value; //set,get方法。。。&#125;public class TestB&#123; public static void main(String[] args)&#123; B&lt;String, Integer&gt; b = new B&lt;&gt;(); b.setKey(\"小明\"); b.setValue(\"18\"); System.out.println(\"姓名：\"+b.getKey()); System.out.println(\"年龄：\"+b.getValue()); &#125;&#125; 泛型接口1234567891011121314interface C&lt;T&gt;&#123; public T getElem();&#125;class CImpl&lt;T&gt; implements C&lt;T&gt;&#123; //....&#125;//也可在接口的实现类这一步指定具体的类型public class TestC&#123; public static void main(String[] args)&#123; C&lt;String&gt; c = new CImpl&lt;&gt;(); //... &#125;&#125; 泛型方法 格式：修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){ //方法体 }。泛型方法在调用方法时确定数据类型。 1234567891011121314class GenericMethod&#123; public &lt;T&gt; void method&lt;T t&gt;&#123; System.out.println(t); &#125;&#125;public class TestGenericMethod&#123; public static void main(String[] args)&#123; GenericMethod gm = new GenericMethod(); gm.method(\"123\"); gm.method(123); //传递什么类型的参数，泛型就是什么类型 &#125;&#125; 泛型的上下限 有时候我们希望泛型只接收某些类型，而不是所有类型，那么我们就需要限定泛型的接收范围。 &lt;?&gt;：无限制通配符，表示任意类型。 &lt;? extends E&gt;： 表示只接收E类型，或者E类型的子类。 &lt;? super E&gt;： 表示只接收E类型，或者E类型的父类。 例如：以下代码表示T类型只能是Number类或者其子类，在限定了接收类型的同时，还可以使用Number类的方法和成员变量。 123private static &lt;T extends Number&gt; double add(T a, T b) &#123; return a.doubleValue() + b.doubleValue();&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"虚拟机类加载机制","slug":"虚拟机类加载机制","date":"2020-09-03T09:22:40.000Z","updated":"2020-09-20T10:32:29.706Z","comments":true,"path":"JVM/虚拟机类加载机制/","link":"","permalink":"http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"类加载过程 一个Java类从编写完成到被卸载的过程：X.java -&gt; X.class（编译为磁盘中的二进制文件）-&gt; 加载（ClassLoader将X.class加载到虚拟机内存）-&gt; 连接 （确定类与类之间的关系，包含验证、准备、解析三步） -&gt; 初始化 -&gt; 使用 -&gt; 卸载。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。类加载过程如下图： 加载：加载是类加载的一个阶段，注意不要混淆。 加载阶段完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时数据结构。 在内存中生成一个代表该类的java.lang.Class对象，作为方法区该类的各种数据的访问入口。 二进制字节流的获取方式有： 从ZIP包读取，成为 JAR、EAR、WAR 格式的基础。 从网络获取，典型应用为Applet 运行时计算生成，比如动态代理技术，在java.lang.reflect.Proxy中使用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。 由其他文件生成，比如由JSP文件生成对应的Class类。 从数据库读取。 连接 验证：这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备：在方法区中，为类的静态变量分配内存，并将其初始化为默认值（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型为null…），但是对于final修饰的常量则直接赋指定值。注意：实例变量（即未被static修饰的变量）不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，也就是类加载完成之后了。 解析：将class文件常量池的符号引用替换为直接引用的过程。 符号引用：与虚拟机的内存布局无关。可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用：与虚拟机实现的内存布局相关。可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。 初始化：为类的静态变量赋予正确的初始值（此时才赋予程序员设定的值），并执行静态代码块。 Java程序对类的使用方式可分为两种：主动引用与被动引用。每个类（接口）只有被Java程序“首次主动引用”时才初始化。包括： 使用new实例化该类对象。 读取或设置一个类（接口）的静态字段，以及调用一个类（接口）的静态方法。注：被final修饰的静态字段除外。 使用java.lang.reflect包的方法对类进行反射调用。 初始化某类的子类（先初始化父类）。 带main方法的类。 JDK1.7开始提供的动态语言支持 *。 被动引用例子： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value);&#x2F;&#x2F;value字段在SuperClass中为静态字段 通过数组定义来引用类，不会触发被引用类的初始化。但是该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] array &#x3D; new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类加载器 类与类加载器：加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作在虚拟机外部实现，由类加载器实现。我们可以通过自定义类加载器去控制字节流的获取方式。注意：数组类不通过类加载器创建，它由JVM直接创建。 HotSpot VM内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :面向用户的加载器，负责加载当前应用classpath下的所有jar包和类。 双亲委派模型：每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候： 系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。 当父类加载器无法处理时，才由自己来处理。当父类加载器为null(null代表启动类加载器)时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。 以上的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 使用如下代码来验证双亲委派模型： 1234567public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; System.out.println(\"ClassLodarDemo's ClassLoader is \" + ClassLoaderDemo.class.getClassLoader()); System.out.println(\"The Parent of ClassLodarDemo's ClassLoader is \" + ClassLoaderDemo.class.getClassLoader().getParent()); System.out.println(\"The GrandParent of ClassLodarDemo's ClassLoader is \" + ClassLoaderDemo.class.getClassLoader().getParent().getParent()); &#125;&#125; 控制台输出为： 123ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586The GrandParent of ClassLodarDemo&#39;s ClassLoader is null 双亲委派模型的好处：双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。 破坏双亲委派模型：自定义类加载器，需要继承ClassLoader。如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载；如果想打破双亲委派模型则需要重写 loadClass() 方法。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"GC与内存分配策略","slug":"GC与内存分配策略","date":"2020-09-02T07:17:43.000Z","updated":"2020-09-07T11:39:12.560Z","comments":true,"path":"JVM/GC与内存分配策略/","link":"","permalink":"http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"","text":"对象已死吗（GC回收的前提是判断对象已死） 概述：对于程序计数器、虚拟机栈、本地方法栈，其内存区域和回收都具备确定性，方法结束或线程结束时，其内存自然就回收了。GC主要关注堆和方法区的分配与回收。 引用计数算法（不常用）：给对象添加一个引用计数器，每当被引用时，计数器值+1；引用失效（引用不再指向该对象）时，计数器值-1。任何时刻计数器为0的对象就是不可能再被使用的。缺点：难以解决对象之间相互循环使用的问题。（比如对象A中的引用指向B，对象B中的引用指向A，对象A、B计数器永远为1） 可达性分析算法（主流实现）：通过一系列的称为“GC Roots”的对象作为起始点向下搜索，搜索走过的路径称为“引用链”，当一个对象到“GC Roots”没有任何引用链相连，即证明对象不可达。 可作为GC Roots的对象包括： 虚拟机栈：栈帧中局部变量表中引用的对象 方法区： 类静态变量引用的对象 常量引用的对象 本地方法栈：JNI引用的对象 再谈引用：JDK1.2之后，引用概念分为以下4种，强度依次减弱 强引用：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。 软引用：描述有用但非必须的对象，当系统将要发生OOM异常时，软引用指向的对象才被真正回收。通过SoftReference类实现。 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。 虚引用：为一个对象设置虚引用关联的唯一目的时能在对象被回收时收到一个系统通知。通过PhantomReference类实现。 生存还是死亡：即使在可达性分析算法中不可达的对象，在该对象的finalize()方法中也有一次自救的方法，即重新与引用链上的任何一个对象建立关联即可，譬如把this赋值给某个类变量或者对象的成员变量。但是，建议使用try-finally语法而尽量不使用finally()方法。 回收方法区：主要回收废弃常量和无用的类。废弃常量的回收与堆中的对象类似，而无用类的判定则要复杂的多，需要满足： 堆中不存在该类的实例 ClassLoader已被回收 Class对象没有被引用，且无法在任何地方通过反射访问该类的方法。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息。 注：对于大量使用反射、动态代理、CGLib等ByteCode框架的场景，要注意方法区的类卸载。 垃圾收集算法 标记-清除算法：标记回收对象，标记完成后统一回收。 缺点：标记和清除效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 标记-整理算法：标记回收对象，让所有存活的对象向一端移动，然后直接清理掉对象所在的连续内存后的所有内存。 特点：适用于老年代的算法，不会产生内存碎片。 复制算法：对于现在的商业虚拟机，堆内存被划分为三块，一块较大的Eden空间、两块较小的Survivor空间。 当Eden空间满时，第一次Minor-GC（针对新生代的GC）将Eden还存活的对象全部复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden； 当Eden满时，第二次Minor-GC将Eden和Survivor-0中还存活的对象复制到Survivor-1中，存活对象“寿命计数器”+1，清理Eden和Survivor-0； 当Eden满时，第三次Minor-GC将Eden和Survivor-1中还存活的对象复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden和Survivor-1； ……. 如此往复，当某个Survivor满或者对象“寿命计数器”值达到阈值，则将对象复制到老年代中。 当老年代和新生代都满时，会进行一次Full-GC。 HotSpot虚拟机的Eden和Survivor大小默认比例为8:1，保证了内存利用率达到90%。 分代收集算法：现在的商业虚拟机采用分代收集算法。 新生代：由于每次GC时都有绝大部分对象死去，只有少量对象存活，故采用复制算法，因为只需要付出少量存活对象的复制成本。 老年代：由于老年代对象存活率高且没有额外空间对它分配担保，故采用标记-整理算法或标记-清除算法。 垃圾收集器 以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器之间可以搭配使用。 Serial收集器：单线程；简单高效，拥有最高的单线程收集效率；Client场景下的默认新生代收集器。 ParNew收集器：Serial的多线程版本；Server场景下默认的新生代收集器；唯一能与CMS收集器配合使用的收集器。 Parallel Scavenge收集器：多线程，吞吐量（CPU运行用户代码的时间除以CPU总消耗时间）优先的收集器。 Serial Old收集器：Serial的老年代版本，Client场景使用。 Parallel Old收集器：Parallel Scavenge的老年代版本 CMS(Concurrent Mark Sweep)收集器：以获取最短回收停顿时间为目标，基于标记-清除算法。分为四个阶段： 初始标记：只标记与GC Roots直接关联的对象，需要Stop The World。 并发标记：进行 GC Roots Tracing，耗时最长，不需要停顿。 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要Stop The World。 并发清除：不需要停顿。 缺点明显： CPU资源敏感：CMS默认启动的回收线程数是（CPU数+3）/4，当CPU数较少时，吞吐量很低。 无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能下一次GC清除。 标记-清除算法会产生大量空间碎片。 总体上来说，CMS的垃圾回收过程是与用户线程一起并发执行的。 G1(Garbage First)收集器：面向服务端应用。 使用G1时，Java堆内存布局与以往不同，它将整个Java堆划分为多个大小相等的独立Region，新生代与老年代是一部分不连续Region的集合，如图： G1通过记录每个Region垃圾回收时间和回收所得空间（这两个值通过过去回收的经验计算），并维护一个优先列表，每次根据用户允许的收集时间，优先回收价值最大的Region。使用Region划分内存空间，有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的收集效率。 每个Region都维护一个Remembered Set，用于记录Region之间的对象引用，来避免GC时的全堆扫描。（其他收集器新生代与老年代之间的对象引用也是使用Remembered Set，避免Minor-GC时全堆扫描）。 如不计算维护Remembered Set的操作，G1的运作可划分如下： 初始标记：停顿。 并发标记 最终标记：停顿。为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。 筛选回收：根据用户允许的收集时间和优先列表来回收。 总结G1的特点如下： 并行与并发：G1在多CPU和大内存的硬件优势下能有效缩短Stop-The-World的时间。 分代收集：新生代和老年代可以一起回收。 空间整合：整体上看基于“标记-整理”算法，局部上看基于“复制”算法。不会产生内存碎片。 可预测的停顿：能让用户自定义在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。 垃圾收集器参数总结 内存分配与回收策略 对象优先在Eden分配 大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 通过参数-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 长期存活的对象将进入老年代：通过参数-XX:MaxTenuringThreshold用来定义年龄的阈值。 动态对象年龄判定：虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 GC的触发条件 对于Minor GC，其触发条件为Eden区满时。而对于Full GC: 调用System.gc()。 老年代空间不足。 空间分配担保失败。 Concurrent Mode Failure。 减少Full GC的方法： 尽量不要创建大对象和数组。 通过-Xmn调大新生代大小。 通过-XX:MaxTenuringThreshold调大进入老年代的阈值。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"Java内存区域与内存溢出异常","slug":"Java内存区域与内存溢出异常","date":"2020-08-23T03:24:45.000Z","updated":"2020-10-11T07:17:30.267Z","comments":true,"path":"JVM/Java内存区域与内存溢出异常/","link":"","permalink":"http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"","text":"运行时数据区域​ 线程私有：与线程生命周期相同 程序计数器（Program Counter Register）：记住下一条JVM字节码指令的地址。每条线程都有一个独立的PCR。此内存区域是唯一一个在JVM规范中没有任何OOM情况的区域。 Java虚拟机栈：描述Java方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈等。每个方法从调用到执行完毕，对应一个栈帧从入栈到出栈的过程。 局部变量表存放编译期可知的各种基本数据类型和引用。 JVM规范定义了该区域两种异常情况： 线程请求的栈深度大于VM允许的深度，将抛出StackOverflowError异常。 若虚拟机栈可动态扩展，且扩展时无法申请到足够的内存，将抛出OOM异常。 本地方法栈：与虚拟机栈的区别在于，虚拟机栈为VM执行Java方法服务，而本地方法栈为VM使用到的本地方法服务。 异常情况同虚拟机栈。 线程共享：VM启动时创建 堆：用于存放对象实例和数组。 Java堆是GC管理的主要区域。 扩：随着JIT（Just in Time）技术与逃逸分析技术逐渐成熟，所有对象都分配在堆上并不绝对了。 ​ 热代码：频繁调用的字节码。 ​ [https://developer.ibm.com/zh/articles/j-lo-just-in-time/#] 方法区：存储已被VM加载的类信息（变量和方法数据，方法和构造器的字节码等）、运行时常量池、JIT编译后的机器码等。 许多主流框架都会用到CGLib或者JDK动态代理，动态生成大量Class容易导致方法区OOM异常。 三种常量池区分 class文件常量池：编译阶段，存放编译期生成的字面量（常量值）和符号引用，其中符号引用包括类名、方法名、参数类型等信息。javap -v Main.class反编译如下代码： 12345678public class Main &#123; final String stest &#x3D; &quot;String Test ...&quot;; public static void main(String[] args) &#123; System.out.println(&quot;helloworld&quot;); &#125; &#125; 结果如下： 字符串常量池-StringTable: 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（可理解为内存地址，而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。注意：对于new的String对象，若在类中new，则其引用变量存于方法区；若在方法中new，则其引用在虚拟机栈的栈帧的局部变量表中。 运行时常量池：类加载完成之后，编译期生成的非字符串类型常量和符号引用进入运行时常量池，由符号引用翻译而来的直接引用也会存入运行时常量池。 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也会频繁使用，可能导致OOM异常。 JDK1.4中加入了NIO类（New Input/Output），引入了一种基于Channel与Buffer的I/O方式，它可以使用本地函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 常见的VM堆栈参数 -Xms: 设置堆的最小值，如-Xms20m -Xmx: 设置堆的最大值，如-Xmx20m -Xmn: 设置堆新生代值 -Xss: 设置虚拟机栈容量 -Xoss: 设置本地方法栈容量（HotSpot的虚拟机栈和本地方法栈仅由-Xss决定） -XX:Permsize=10M: 设置方法区大小为10M -XX:MaxDirectMemorySize=10M: 设置本机直接内存大小为10M 常见的OOM原因 堆堆内存没有足够空间存放新创建的对象。常见异常：java.lang.OutOfMemoryError:Javaheap space; java.lang.OutOfMemoryError:GC overhead limit exceeded 常见原因： 创建了一个超大对象，比如大数组 超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。 过度使用终结器（Finalizer），该对象没有立即被 GC。重写了finalize()方法的对象不会被立即GC。 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。 解决方案：针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理： 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。 如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。 方法区常见原因：对象数组和类型数组所关联的class太多。 解决方案： 修改 -XX:MaxPermSize 启动参数，调大永久代空间。 设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class。 JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），调整 Metaspace 空间大小的启动参数为 -XX:MaxMetaspaceSize。 其他OOM原因参考：https://zhuanlan.zhihu.com/p/79355050","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"SpringAOP","slug":"SpringAOP","date":"2020-04-23T08:36:02.000Z","updated":"2020-09-07T11:37:24.361Z","comments":true,"path":"uncategorized/SpringAOP/","link":"","permalink":"http://thmasterplan.cn/uncategorized/SpringAOP/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringIOC","slug":"SpringIOC","date":"2020-04-14T13:36:18.000Z","updated":"2020-09-27T13:43:51.438Z","comments":true,"path":"Java框架/SpringIOC/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringIOC/","excerpt":"","text":"Spring概述Spring以IOC(Inversion of Control)和AOP(Aspect Oriented Programming)为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。 耦合度概念模块（类）之间的关联、依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。耦合的程度依赖于以下几个因素： 模块间的调用 模块间传递的数据量 一个模块施加到另一个模块的控制的多少 模块间接口的复杂程度 从高到低耦合可分为 内容耦合：一个模块直接修改或操作另一个模块的数据，或者直接转入另一个模块时，就发生了内容耦合。例如，类与类之间直接调用或继承关系都属于这种耦合。 公共耦合：多个模块共同引用一个全局数据项。 控制耦合：一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。 标记耦合：模块间通过参数传递复杂的内部数据结构。 数据耦合：模块间通过参数传递基本类型的数据。 需要低耦合的原因在耦合度很高的情况下，维护代码时修改一个地方会牵连到很多地方，难以厘清，可谓是牵一发而动全身。 降低耦合度的方法 少用继承，多用接口。 模块的功能划分尽可能的单一（高内聚）。 遵循一个定义只在一个地方出现。 少使用全局变量。 类成员变量和方法少用public，多用private。 多使用设计模式，比如使用MVC设计模式就可以降低界面与业务逻辑的耦合度。 如果模块间必须存在耦合，尽量使用数据耦合。例如使用配置文件或注解传递参数，使用反射创建对象等都属于数据耦合。 工厂模式解耦例子持久层123456&#x2F;** * 账户的持久层接口 *&#x2F;public interface IAccountDao &#123; void saveAccount();&#125; 12345678&#x2F;** * 持久层实现类 *&#x2F;public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(&quot;账户已经保存！&quot;); &#125;&#125; 业务层123456789&#x2F;** * 账户业务层的接口 *&#x2F;public interface IAccountService &#123; &#x2F;** * 模拟保存账户 *&#x2F; void saveAccount();&#125; 1234567891011&#x2F;** * 业务层实现类 *&#x2F;public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao &#x3D; (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;); public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 表现层123456789&#x2F;** * 模拟表现层调用业务层，实际开发中类似Servlet *&#x2F;public class Client &#123; public static void main(String[] args) &#123; IAccountService as &#x3D; (IAccountService) BeanFactory.getBean(&quot;accountService&quot;); as.saveAccount(); &#125;&#125; bean.properties配置文件12accountService&#x3D;com.itheima.service.impl.AccountServiceImplaccountDao&#x3D;com.itheima.dao.impl.AccountDaoImpl BeanFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;** * 一个创建Bean对象的工厂 * Bean: 可重用组件，例如在Java中JavaBean有实体类、service和dao对象等 * * 工厂模式解耦：使用配置文件或注解传递参数，使用反射创建对象。 *&#x2F;public class BeanFactory &#123; &#x2F;&#x2F;定义一个Properties对象 private static Properties props; &#x2F;&#x2F;定义Map存储bean对象，避免多实例降低效率（即避免每次调用getBean方法都要重新创建对象） private static Map&lt;String, Object&gt; beansMap; &#x2F;&#x2F;初始化 static&#123; props &#x3D; new Properties(); try &#123; &#x2F;&#x2F;获取properties文件的流对象并加载 props.load(BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;); &#125; beansMap &#x3D; new HashMap&lt;&gt;(); Enumeration keys &#x3D; props.keys(); &#x2F;&#x2F;遍历properties中的每个key，创建对应的实例并存入beansMap中 while(keys.hasMoreElements())&#123; String beanName &#x3D; keys.nextElement().toString(); String beanPath &#x3D; props.getProperty(beanName); Object bean &#x3D; null; try &#123; bean &#x3D; Class.forName(beanPath).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; beansMap.put(beanName, bean); &#125; &#125; &#x2F;** * 根据bean的名称获取bean对象 * @param beanName * @return bean对象 *&#x2F; public static Object getBean(String beanName)&#123; return beansMap.get(beanName); &#125;&#125; 控制反转Inversion of Control(IOC)概念与作用控制反转把创建对象的权力交给框架，它包括Dependency Injection与Dependency Lookup两部分。其作用在于降低程序的耦合度。 基于XML的IoC配置 bean.xml示例 12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!--将对象的创建交给spring管理--&gt; &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; ApplicationContext的三个常用实现类 ClassPathXmlApplicationContext：加载类路径下的配置文件 FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件 AnnotationConfigApplicationContext：读取注解 核心容器的两个接口引发的问题 ApplicationContext（常用）：单例对象适用。创建核心容器时，创建对象的策略为立即加载。只要一读取完配置文件就立马创建bean对象。 BeanFactory（ApplicationContext父接口的父接口）：多例对象适用。创建核心容器时，创建对象的策略为延迟加载。也即，何时调用获取bean对象的方法，那时才创建对象。 Spring对bean对象的管理细节 创建bean对象的三种方式 使用默认构造函数创建：在spring的xml配置文件中使用bean标签，配置id和class属性后，且没有其他属性和标签时，采用的是默认构造函数创建bean对象(反射中的newInstance方法使用默认构造创建对象)，如果类没有默认构造函数则无法创建对象。 使用普通类(工厂)中的方法创建对象并存入spring容器(比如jar包中的类)： 12345public class InstanceFactory&#123; public IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 1234&lt;!--创建实例工厂对象--&gt;&lt;bean id&#x3D;&quot;instanceFactory&quot; class&#x3D;&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;&#x2F;bean&gt; &lt;!--通过指定实例工厂对象的方法，创建指定对象--&gt;&lt;bean id&#x3D;&quot;accountService&quot; factory-bean&#x3D;&quot;instanceFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt; 使用工厂中的静态方法创建对象并存入容器(比如jar包中的类)： 12345public class StaticFactory&#123; public static IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 12&lt;!--通过指定工厂类的静态方法创建对象--&gt;&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.factory.StaticFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt; bean对象的作用范围调整：bean标签scope属性，取值为以下 singleton：单例（默认的，不管new多少次，内存中只有一个实例对象） prototype：多例 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），若不是集群环境，则效果与session相同 bean对象的生命周期 单例对象：单例对象的生命周期与容器相同，容器创建则对象创建，容器销毁时对象销毁，可在bean标签中指定init-method与destroy-method属性来执行bean对象中的init方法和destroy方法。 多例对象：使用对象时才创建对象，spring不能销毁，只能通过GC回收，因此无论如何都不会执行bean对象中的destroy方法。 依赖注入（Dependency Injection）：当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例，但在IoC中，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。要实现IoC，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过【构造器/方法/注解】注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。 注入的数据类型 基本数据类型和String bean 复杂类型/集合类型 注入的方式有 构造器：通过bean标签中的constructor-arg标签配置实现 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;读取xml，通过反射创建bean对象；依赖查找 ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); &#x2F;&#x2F; IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;); IAccountService as &#x3D; ac.getBean(&quot;accountService&quot;, IAccountService.class);&#x2F;&#x2F;两种方式获取bean对象 as.saveAccount(); &#x2F;** 使用BeanFactory * BeanFactory beanFactory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;bean.xml&quot;)); * IAccountService as &#x3D; (IAccountService) beanFactory.getBean(&quot;accountService&quot;); *&#x2F; &#125;&#125; 1234567891011public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public AccountServiceImpl(IAccountDao accountDao) &#123; this.accountDao &#x3D; accountDao; &#125; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 12345&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;!--value属性用于注入基本类型和String类型，ref属性则为bean类型--&gt; &lt;constructor-arg name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDaoImpl&quot;&gt;&lt;&#x2F;constructor-arg&gt; &lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;accountDaoImpl&quot; class&#x3D;&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;&#x2F;bean&gt; set方法：property标签，name属性指定方法名，value属性用于注入基本类型和String类型，ref属性则为bean类型。bean类需要设置set方法。 集合类型的注入：使用set,list,arroCay,map,props等子标签 注解：@Autowired 基于注解的IoC配置 首先配置context 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--指定spring在创建容器时要扫描的包--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;&lt;&#x2F;beans&gt; 创建bean对象的注解 @Component：被注解的类由spring创建并存入IoC容器 @Controller：用于表现层 @Service：用于业务层 @Repository：用于持久层 后三个注解的作用与属性都与@Component相同 依赖注入的注解 @Resource：在需要注入依赖的变量上标记，并在其实现类上标记@Component（或其余三种）注解。通过name属性匹配实现类。 123456789@Component(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123; @Resource(name&#x3D;&quot;accountDao&quot;) private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 123456@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(&quot;Your Account has been saved!&quot;); &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;); as.saveAccount(); &#125;&#125; @Autowired：@Qualifier需要与@Autowired一起使用。 以上的注解只能用于bean类型的注入，集合类型的注入只能通过xml配置文件实现。 @Value：用于注入基本类型与String类型数据。 改变作用范围的注解：@Scope，value属性常用取值为singleton，prototype 与生命周期相关的注解 @PreDestroy：指定销毁方法 @PostConstruct：指定初始化方法 基于注解的IoC配置（不再需要xml文件） @Configuration：创建一个代替bean.xml的配置类SpringConfig后，使用该注解标记该类为配置类 @Import：标记主配置类，用于导入其他的从配置类。属性：Class&lt;?&gt;[] value;。使用该注解后可不再使用@Configuration注解。 @ComponentScan：指定spring在创建容器时需要扫描的包 @Bean：标记一个方法，将该方法的返回值作为bean对象存入IoC容器。其属性name用于指定bean对象的id，默认值为方法名。 @PropertySource：指定properties配置文件的位置。用于配置数据库等字符串信息。 使用new AnnotationConfigApplicationContext(SpringConfig.class);获取容器。 IoC案例 使用xml配置，注解结合xml配置，纯注解配置三种方式 Use “Sourcegraph” to view the code：https://github.com/Laishiji/SpringLearningDemo Spring整合Junit 导入依赖spring-test 使用Junit提供的@RunWith替换Runner(替换main方法) 使用@ContextConfiguration告知Spring的运行器，spring容器的创建是基于xml还是注解，并说明位置 123456789101112131415161718&#x2F;** * 单元测试,Spring整合Junit *&#x2F;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes &#x3D; SpringConfig.class)public class AccountServiceTest &#123; @Autowired IAccountService as; @Test public void testFindAll()&#123; List&lt;Account&gt; accounts &#x3D; as.findAllAccount(); for (Account a : accounts) &#123; System.out.println(a); &#125; &#125;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"检索技巧","slug":"检索技巧","date":"2020-04-09T09:00:06.000Z","updated":"2020-09-07T11:35:36.764Z","comments":true,"path":"Others/检索技巧/","link":"","permalink":"http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Github搜索 in:name example：项目名中包含”example“ in:readme example：readme.md中包含”example“ in:description example：描述中包含”example“ stars:&gt;1000：项目 star数大于1000 forks:&gt;1000：项目fork数大于1000 pushed:&gt;2020-03-05：项目在该日期后有更新 language:java：项目用Java编写 以上条件可组合使用 搜索引擎检索 &quot;example&quot;：完全匹配 example site:www.xxx.com：站点内搜索 example -csdn.net：排除关键字","categories":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/tags/Others/"}]},{"title":"Java基础","slug":"Java基础","date":"2020-04-08T14:47:15.000Z","updated":"2020-10-11T07:40:35.132Z","comments":true,"path":"Java基础/Java基础/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"面向对象三大特性继承 Java类是单继承的，不允许子类继承多个父类的原因在于，编译器无法确定使用哪个父类方法。 在父子类的继承关系中，创建父或子类对象，访问成员方法的规则：优先使用创建的对象的方法，没有则向上找。 继承关系中，父子构造方法访问的特点 子类构造方法有一个默认隐含的super()调用，因此一定是先调用的父类构造，后执行子类构造。 子类构造可以通过显示使用super()来调用父类重载构造，并且必须是子类构造的第一条语句。 重载与重写 重写：子类重写方法与父类方法名相同，参数列表相同。 重载：一个类中有多个相同的方法名，但参数列表不同。 多态 概念：父类（接口）引用指向子类对象。 多态代码中 成员重写方法的访问规则：先在子类对象中找，没有则向上找。 成员变量访问规则：直接使用父类成员变量。 向上转型即多态：父类引用指向子类对象；引用无法调用原本子类特有的方法。 向下转型，例如Anaimal a = new Cat();Cat cat = (Cat) a;，这个过程将父类变量还原为子类类型，使其又可以访问子类特有的方法。 多态的作用？ Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations. 封装 封装通过将类属性定义为私有，对外提供类属性的setters/getters方法来修改和获取属性值实现。 封装可以减少耦合，防止类数据被外部类定义的代码随机访问。 权限修饰符作用范围 外部类只有public和default两种权限。 private：只能修饰类方法和类变量，类内部才能访问。 default：无论对于类、类变量还是类方法，只能同一包内才能访问。 protected：修饰类变量和类方法，同一包内的类和该类的子类可访问。 关键字static 修饰成员变量或成员方法：不需要创建对象就可通过类名调用，它们均属于类，而非某个对象 修饰内部类（不允许修饰普通类） 12345678910111213141516171819public class StaticTest &#123; public static class Inner&#123; static&#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类静态代码块&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; Inner() &#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类构造方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; public void innerMethod()&#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类普通方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; &#125; public static void main(String[] args) &#123; Inner inner &#x3D; new Inner(); inner.innerMethod(); &#125;&#125; 输出：====静态内部类静态代码块==== ====静态内部类构造方法==== ====静态内部类普通方法==== 结论：想要在普通类中创建内部类实例，可以用static修饰内部类。 静态代码块 第一次使用类时，类的静态代码块执行唯一的一次。（类加载的初始化阶段执行静态代码块） 静态代码块先于构造方法执行。 Tips: 静态不能直接访问非静态 静态方法中不能用this, this代表当前对象。 final 修饰类：当前类不能有子类。 修饰方法：该方法不能被子类重写。（显然对于类、方法来说，abstract和final无法同时使用） 修饰数据：对于基本数据类型，其值不能再改变；对于引用数据类型，不能再改为存储其他对象的地址或引用（对象自身是可以改变的）。对于类变量，必须赋初始值或在构造方法中赋值。 修饰数组：数组的引用不能再指向其他数组，当数组内容可变。 instanceof instanceof 的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean类型。 native 使用native关键字修饰方法，说明这个方法是本地函数，也就是这个方法是用C/C++语言（或者其他语言）实现的，并且被编译成了DLL，由JVM调用。 native修饰的方法没有方法体。 transient 实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中，该属性的将只会存在于内存中。常见的应用有密码、银行卡号等敏感信息。 transient关键字只能修饰变量。 接口与抽象类抽象类 public abstract class Name{}；抽象类是描述一个对象是什么，它可以包含成员变量、成员方法、构造方法等，与普通类不同的点只在于：它可能包含抽象方法；它必须要被非抽象子类继承才能实例化，并且非抽象子类必须实现抽象方法（假如父类有抽象方法的话）。 单继承。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；抽象方法没有方法体。 抽象类使用： 创建子类继承抽象父类。 子类重写父类抽象方法，去掉abstract关键字，实现方法体。 接口 public interface IName{}；接口是多个类的公共规范。 接口可以继承多个接口，实现类可以实现多个接口。（多继承，多实现） 接口的成员变量默认都是public static final的：假如两个接口有相同的成员变量，一个类实现了这两个接口，那么实现类只能通过接口名.变量名来调用以避免歧义，因此必须为static。声明为final的原因是实现类不能够修改接口成员变量的值。 Java7：常量，抽象方法 Java8：新增了默认方法(default修饰)，静态方法。 增加默认方法的原因：Java升级后的兼容性问题。如果想在老版本接口中添加某个功能，在添加抽象方法的情况下，所有的老版本实现类都需要修改代码；而通过增加default方法来增加功能就不会有这种问题。 考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法。解决方案：重写方法，并使用接口名.super.方法名()调用指定接口的方法。 12345 public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;vehicle...&quot;); &#125;&#125; 12345 public interface FourWheeler &#123; default void print()&#123; System.out.println(&quot;fourWheeler...&quot;); &#125;&#125; 12345678910111213public class Car implements Vehicle, FourWheeler &#123; @Override public void print() &#123; FourWheeler.super.print(); Vehicle.super.print(); &#125; public static void main(String[] args) &#123; Vehicle car &#x3D; new Car(); car.print(); &#125;&#125; ​ 输出：fourWheeler… ​ vehicle… Java9：新增了私有方法，私有静态方法 面向接口编程？ 内部类成员内部类 三种方法使用成员内部类 在外部类的方法中创建内部类实例 main方法中：Inner inner = new Outer.new Inner(); main方法中直接new，前提是静态内部类 在内部类中访问重名的外部类变量 1234567891011121314151617181920public class Outer &#123; private int num &#x3D; 10;&#x2F;&#x2F;外部类私有变量，内部类也可访问 class Inner&#123; private int num &#x3D; 20; public void innerMethod()&#123; int num &#x3D; 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125; public static void main(String[] args) &#123; Inner inner &#x3D; new Outer().new Inner(); inner.innerMethod(); &#125;&#125; 局部内部类 该类定义在方法内部，只有在该方法内部才能使用。 局部内部类中的匿名内部类 如果接口的实现类（或者父类的子类）只需要使用一次，那么这种情况下可以省略掉该类的定义，而使用匿名内部类。 最常见的使用：通过将Runnable接口的实现类的实例对象作为参数传给Thread，创建线程。不仅省略了类定义，同时完成了向上转型。 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;...&quot;); &#125; &#125;).start(); 包装类 包装类通过将基本数据类型封装起来，在类中提供一些方法，便于操作这些基本数据类型。 Java自jdk5后提供自动装箱与自动拆箱机制。 基本类型与字符串的转换 基本类型 -&gt; String：基本类型值+”” String -&gt; 基本类型：使用包装类的静态方法parseXXX(&quot;str&quot;) Integer：static int parseInt(String s) Double：static double parseDouble(String s) 值传递与引用传递 实参与形参： 形式参数：定义函数时使用的参数，用来接收实际参数。 实际参数：调用有参函数时，传入的内容。 值类型与引用类型 值类型（基本数据类型）：直接存储值。 引用类型：存储的是对象的地址。对象在堆中。 求值策略（Evaluation Strategy）：值传递与引用传递，属于函数调用时参数的求值策略，是对调用函数时求值和传值的方式的描述，而非传递的内容的类型。（内容的类型是指：值类型还是引用类型。）值类型与引用类型，用于区分两种内存分配方式，值类型在虚拟机栈上分配，引用类型在堆上分配。 值传递概念：调用函数时，将实际参数拷贝一份传递给函数。In call by value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (frequently by copying the value into a new memory region). Java uses call by value evaluate function arguments left-to-right 引用传递概念：调用函数时，将实际参数的地址传递给函数。Call by reference (or pass by reference) is an evaluation strategy where a function receives an implicit reference to a variable used as argument, rather than a copy of its value. 总结-“Java中只有值传递，值传递与引用传递的区别重点在于是否拷贝”：对于基本数据类型，传递的是基本数据类型的值的拷贝；对于引用类型，传递的是对象的地址值的拷贝，形参与实参都保存的是堆内存中同一个对象的地址。 参考：https://en.wikipedia.org/wiki/Evaluation_strategy Deep Copy, Shallow CopyShallow Copy B对A的浅拷贝：创建新对象B，将A的字段值复制到B。 如果该字段值是对对象（例如，存储器地址）的引用，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。 如果该字段值是基本数据类型，则复制值。 Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法，then B = (A) new A().clone(); Deep Copy B对A的深拷贝：创建新对象B，对于A的引用类型，在B中创建该引用对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。 参考：https://en.wikipedia.org/wiki/Object_copying#Methods_of_copying Java四种引用类型 JDK1.2之后，引用概念分为以下4种，强度依次减弱 强引用：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。 软引用：描述有用但非必须的对象，当系统将要发生OOM异常时，软引用指向的对象才被真正回收。通过SoftReference类实现。 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。 虚引用：为一个对象设置虚引用关联的唯一目的时能在对象被回收时收到一个系统通知。通过PhantomReference类实现。 集合的三种遍历方式 for 形式：for(初始化;结束条件;自增操作等) 需要知道集合的大小和元素类型，使用索引。 foreach 形式：for(T element : colletion) 需要知道集合元素的类型，不需要索引。 iterator 形式：Iterator it = collection.iterator();while(it.hasNext()){ object o =it.next(); ...} 集合的大小和类型都无需知道，也无需索引。 Tips: foreach是iterator的语法糖，底层使用iterator实现。 使用for循环进行remove操作时，每一次操作完成后索引需要自减。 iterator/foreach遍历集合时的add/remove操作见“Java集合框架”。 异常 Java异常图解 Throwable类中定义了一些查看异常的方法： public String getMessage()：获取异常的描述信息。 public String toString()：获取异常的类型和异常描述信息。 void printStackTrace()：打印异常的跟踪栈信息。最常用。 捕获异常 1234567891011121314try&#123; &#x2F;&#x2F;可能产生异常的代码&#125;catch(异常类型1 e)&#123; &#x2F;&#x2F;异常的处理逻辑；一般会记录到日志中&#125;... catch(异常类型n e)&#123; &#125;finally&#123; &#x2F;&#x2F;无论是否出现异常都会执行，常用于资源释放 &#125;&#x2F;&#x2F;jdk1.8之后支持try with resource写法try(需要释放资源的代码)&#123;&#125;catch(Exception e)&#123;&#125; 自定义异常类 1234567891011public class XXXException extends Exception&#123; &#x2F;&#x2F;添加一个空参构造 public XXXException()&#123; super(); &#125; &#x2F;&#x2F;添加一个带异常信息的构造 public XXXException(String message)&#123; super(message);&#x2F;&#x2F;所有的子类异常都交给父类处理 &#125;&#125; 自定义异常类一般以命名Exception结尾，必须继承Exception类或者RuntimeException类： 继承自Exception：自定义异常为编译期异常，必须处理。 继承自RuntimeException：运行期异常无需处理。 字符串String String类是final的，因此不能被继承。源码是一个final修饰的字符数组，因此一旦创建就是一个不可变的字符串。 1private final char value[]; 字符串的拼接：由于String不可变，两个String类型拼接需要新开辟一块内存空间，效率低下。建议使用StringBuffer或StringBuilder，这两者的区别稍后讲解。 String常用方法 比较 equals(Object obj)：如果比较双方一个常量一个变量，应把常量写在前面，如&quot;abc&quot;.equals(str)。因为如使用str.equals(&quot;abc&quot;)，假如str为空会导致空指针异常。 equalsIgnoreCase(String str)：忽略大小写。 endsWith(String suffix)：比较suffix是否为串的后缀。 获取 length()：获取长度。 concat(String str)：获取拼接后的串。 charAt(int index)：获取指定索引字符。 public int indexOf(String str)：查找参数串在本串中首次出现的索引位置，如无匹配结果返回-1。可用于字符串匹配。 截取 subString(int index)：截取从参数位置开始后的子串。 subString(int begin, int end)：截取[begin, end)子串。 trim()：去除字符串的前后空格。 转换 toCharArray()：串转换为字符数组 getBytes()：串转换为底层的字节数组 toUpperCase()和toLowerCase()：大小写转换。 replaceAll(String regex, String replacement)：使用给定的replacement替换所有符合regex规则的子串。 分割：split(String regex)：按照参数规则分割字符串为若干子串。 StringBuffer与StringBuilder 都由final修饰，不能被继承。 都继承于AbstractStringBuilder，底层使用的字符数组没有final修饰。StringBuffer和StringBuilder的默认构造中，char数组默认大小为16，在调用append方法拼接字符串时，先判断拼接后的长度是否超出当前数组大小，若超出则自动扩容（将当前字符数组复制到新容量的数组中），若不超出则直接将要拼接的字符串复制到数组中。源码如下： 1234567891011121314151617public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是 synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。 StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。 jdk1.9后String/StringBuffer/StringBuilder均不再使用字符数组，而是直接使用字节数组byte[] value。 判断字符串是否相等12345678910111213141516171819202122232425262728293031323334public static void main(String[] args) &#123; String s1 = \"a\"; String s2 = \"b\"; final String s3 = \"a\"; final String s4 = \"b\"; String s5 = \"a\"; System.out.println(s1 == s3); //true System.out.println(s1 == s5); //true String s6 = \"a\" + \"b\";//编译期优化，该拼接操作直接在编译期完成而不是运行期，s6与s9指向同一\"ab\" //对于编译期不能确定的字符串变量的拼接操作(s1和s2的值可能在运行期变化)， // 编译期会转化为新建StringBuilder的相关操作的字节码 String s7 = s1 + s2; //new StringBuilder().append(s1).append(s2).toString() String s8 = s3 + s4;//常量的拼接是确定值 String s9 = \"ab\"; //将s7放入StringTable并返回，由于StringTable是一个哈希表， //此时s10和s6均作为key,而value存储堆中对象\"ab\"的内存地址 //另外，由于StringTable中已有“ab”,则s7放入StringTable失败，但会返回已有\"ab\"的地址，因而s7不等于s6， //如果s7调用intern()之前常量池中没有“ab”，则放入成功，此时再判断s7==\"ab\"会为true String s10 = s7.intern(); //只要是new的String则一定是运行期在堆中创建,不在StringTable中 //只要出现了双引号引用的字符串，则其一定会被放入StringTable(重复则不再放入) String s11 = new String(\"a\") + \"b\"; String str1 = new String(\"a\"); String str2 = new String(\"a\"); System.out.println(s6 == s7); //false System.out.println(s6 == s8); //true System.out.println(s6 == s9); //true System.out.println(s6 == s10); //true System.out.println(s6 == s11); //false System.out.println(str1 == str2); //false &#125; Arrays常用方法 static List&lt;T&gt; asList&lt;T... a&gt;：返回参数列表的List，例List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;); binarySearch()：有多个重载的方法，二分查找 static String toString(数组)：将参数数组变成字符串，默认格式为[元素1, 元素2, 元素3….] sort(数组)：按照默认升序对数组元素排序；自定义类型需要实现Comparator接口。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaIO","slug":"JavaIO","date":"2020-04-08T14:23:56.000Z","updated":"2020-10-13T07:10:45.135Z","comments":true,"path":"Java基础/JavaIO/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/","excerpt":"","text":"Java IO/NIO/AIO - Overview Java IO分类按传输数据类型分类 按数据操作分类 JavaIO常见类使用 BIO/NIO/AIO简介 BIO传统的BIO NIO基础 多路复用 AIO异步IO NettyNetty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JDK动态代理","slug":"JDK动态代理","date":"2020-04-05T08:53:39.000Z","updated":"2020-09-07T11:38:33.732Z","comments":true,"path":"JavaWeb/JDK动态代理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"一个小需求引入静态代理 假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？ 12345678910public class Calculator&#123; public int add(int a, int b)&#123; return a+b; &#125; public int subtract(int a, int b)&#123; return a-b; &#125; &#x2F;&#x2F;其余算数运算方法。。。&#125; 方案：直接在Calculator类每个方法前后插入日志代码。缺点： 直接修改源码，不符合开闭原则。应该对扩展开放，对修改关闭。 如果Calculator类有许多方法，修改量太大。 重复代码太多。 日志代码硬编码在代理类中，不利于后期维护。 静态代理实现日志打印 代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于在目标实现的基础上增加额外的功能操作，以满足自身的业务需求。 静态代理的实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。 静态代理实现日志打印： 将Calculator抽取为接口 1234public interface Calculator &#123; int add(int a, int b); int subtract(int a, int b);&#125; 目标对象实现类 1234567891011public class CalculatorImpl implements Calculator &#123; public int add(int a, int b) &#123; return a + b; &#125; public int subtract(int a, int b) &#123; return a - b; &#125; &#x2F;&#x2F;其余算数运算方法。。。&#125; 代理对象实现类 1234567891011121314151617181920212223242526272829public class CalculatorProxy implements Calculator &#123; &#x2F;&#x2F;代理对象内部维护一个目标对象引用 private Calculator target; &#x2F;&#x2F;构造方法，传入目标对象 public CalculatorProxy(Calculator target) &#123; this.target &#x3D; target; &#125; &#x2F;&#x2F;调用目标对象的add，并在前后打印日志 @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法开始...&quot;); int result &#x3D; target.add(a, b); System.out.println(&quot;add方法结束...&quot;); return result; &#125; &#x2F;&#x2F;调用目标对象的subtract，并在前后打印日志 @Override public int subtract(int a, int b) &#123; System.out.println(&quot;subtract方法开始...&quot;); int result &#x3D; target.subtract(a, b); System.out.println(&quot;subtract方法结束...&quot;); return result; &#125; &#x2F;&#x2F;其余算数运算方法。。。&#125; 使用代理对象实现计算器并打印日志 1234567public class Test &#123; public static void main(String[] args) &#123; Calculator calculator &#x3D; new CalculatorProxy(new CalculatorImpl()); calculator.add(1, 2); calculator.subtract(2, 1); &#125;&#125; 静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。 静态代理的缺点： 代理者与委托者一一对应，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。 如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。 动态代理 我们的目标只是为了实现增强功能，如何才能不编写代理类，只提供接口和目标对象就直接得到代理对象呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。 Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了JVM动态生成的代理类的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。实际开发中采用newProxyInstance方法，直接返回代理对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; &#x2F;** * 测试 * @param args * @throws Exception *&#x2F; public static void main(String[] args) throws Exception &#123; Calculator calculatorProxy &#x3D;(Calculator) getProxy(new CalculatorImpl()); calculatorProxy.add(1, 2); calculatorProxy.subtract(3, 2); &#125; &#x2F;** * 传入目标对象，得到代理对象 * @param targetObj * @throws Exception *&#x2F; private static Object getProxy(final Object targetObj) throws Exception &#123; &#x2F;&#x2F;传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口 &#x2F;&#x2F;proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象 Class&lt;?&gt; proxyClass &#x3D; Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces()); &#x2F;&#x2F;得到代理类（com.sun.proxy.$Proxy0）的构造器 Constructor&lt;?&gt; constructor &#x3D; proxyClass.getConstructor(InvocationHandler.class); &#x2F;&#x2F;通过构造器创建代理对象 Object proxyObj &#x3D; constructor.newInstance(new InvocationHandler()&#123; &#x2F;&#x2F;在重写invoke方法中编写增强功能代码 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码 Object result &#x3D; method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; private static Object getProxy1(final Object targetObj) throws Exception &#123; Object proxyObj &#x3D; Proxy.getProxyClass( targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces() ) .getConstructor(InvocationHandler.class) .newInstance(new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码 Object result &#x3D; method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; &#x2F;** * 实际使用的方法newProxyInstance * @param target * @return * @throws Exception *&#x2F; public static Object getProxy2(final Object target) throws Exception &#123; Object proxy &#x3D; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码 Object result &#x3D; method.invoke(target,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码 return result; &#125; &#125;); return proxy; &#125;&#125; 使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。 mybatis Mapper以及springAOP都是通过动态代理实现。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"mybatisHelloWorld","slug":"mybatisHelloWorld","date":"2020-04-05T08:39:41.000Z","updated":"2020-09-07T11:37:45.843Z","comments":true,"path":"Java框架/mybatisHelloWorld/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/","excerpt":"","text":"概述 mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务），而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 MybatisHelloWorld 工程文件结构如图 创建Maven工程，配置pom.xml，插入： 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.48&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建实体类和DAO接口 实体类 1234567public class User &#123; private Integer id;&#x2F;&#x2F;包装类默认为null private String lastName; private String email; private String gender; &#x2F;&#x2F;getters and setters, toString...&#125; DAO接口 123public interface UserMapper &#123; public User getUserById(Integer id);&#125; 创建sql映射文件：UserMapper.xml 12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;&lt;mapper namespace&#x3D;&quot;com.laishiji.mybatis.dao.UserMapper&quot;&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt; &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt; &lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;com.laishiji.mybatis.bean.User&quot;&gt; select id, last_name lastName, gender,email from user where id &#x3D; #&#123;id&#125; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：mybatisConfig.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;admin&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; mysql中建表 12345678910111213drop database if exists mybatis;create database mybatis default character set utf8;create table user( id int(11) primary key auto_increment, last_name varchar(255), gender char(1), email varchar(255))engine&#x3D;innodb default charset&#x3D;utf8;insert into user(id,last_name,gender,email) values (1,&#39;Tom&#39;,&#39;男&#39;,&#39;123@qq.com&#39;), (2,&#39;Jim&#39;,&#39;男&#39;,&#39;234@qq.com&#39;), (3,&#39;Lisa&#39;,&#39;女&#39;,&#39;324@qq.com&#39;); 创建测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.laishiji.mybatis;import com.laishiji.mybatis.bean.User;import com.laishiji.mybatis.dao.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;&#x2F;** * SqlSession代表和数据库的一次会话，用完必须关闭； * SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量； * mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。 *&#x2F;public class MybatisTest &#123; @Test public void test() throws IOException &#123; String resource &#x3D; &quot;mybatisConfig.xml&quot;; InputStream inputStream &#x3D; Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); SqlSession session &#x3D; sqlSessionFactory.openSession(); User user &#x3D; session.selectOne(&quot;com.laishiji.mybatis.dao.UserMapper.getUserById&quot;,1); System.out.println(user); session.close(); &#125; &#x2F;** * 接口式编程： * 原生：DAO类 ---&gt; DAOImpl实现类 * mybatis：xxxMapper接口 ---&gt; xxxMapper.xml * @throws IOException *&#x2F; @Test public void test2() throws IOException &#123; String resource &#x3D; &quot;mybatisConfig.xml&quot;; InputStream inputStream &#x3D; Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); SqlSession openSession &#x3D; sqlSessionFactory.openSession(); &#x2F;&#x2F;通过反射+动态代理获取接口的实现类对象 UserMapper mapper &#x3D; openSession.getMapper(UserMapper.class); User user &#x3D; mapper.getUserById(1); System.out.println(user); openSession.close(); &#125;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://thmasterplan.cn/tags/Mybatis/"}]},{"title":"Maven入门","slug":"Maven入门","date":"2020-04-05T03:18:27.000Z","updated":"2020-09-07T11:38:15.279Z","comments":true,"path":"Java框架/Maven入门/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/","excerpt":"","text":"Maven配置踩坑 修改本地仓库路径：找到conf目录下的settings.xml，添加&lt;localRepository&gt;PATH&lt;/localRepository&gt;，PATH即为仓库路径。 修改Maven云仓库为国内镜像站：同样在conf目录下的settings.xml下，找到&lt;mirrors&gt;标签，添加 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;&#x2F;id&gt; &lt;name&gt;aliyun maven&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;!-- 改为阿里云镜像 --&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;&#x2F;mirror&gt; 修改默认jdk版本1.5为期望的版本：同样在conf目录下的settings.xml下，找到&lt;profiles&gt;标签，添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; idea中Maven项目执行两次的问题：找到maven设置项Runner，取消勾选Delegate IDE build/run actions to Maven。 Maven项目目录结构 项目对象模型（POM） POM详解：https://www.runoob.com/maven/maven-pom.html。 POM是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。 groupId：公司或者组织的唯一标志。 artifactId：项目的唯一ID。 Maven构建生命周期 clean -&gt; default(build) {validate -&gt; compile -&gt; test -&gt; package -&gt; verify -&gt; install -&gt; deploy } -&gt; site 依赖管理模型 Maven 通过读取项目文件（pom.xml），找出库文件之间的依赖关系并从仓库自动下载。 引入外部依赖：先在 src 文件夹下添加 lib 文件夹，然后将工程需要的 jar 文件复制到 lib 文件夹下。然后添加以下依赖到pom.xml： 1234567&lt;dependency&gt; &lt;groupId&gt;xxx&lt;&#x2F;groupId&gt; &lt;artifactId&gt;xxx&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;scope&gt;system&lt;&#x2F;scope&gt; &lt;!--作用域--&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\yyy.jar&lt;&#x2F;systemPath&gt; &lt;&#x2F;dependency&gt;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://thmasterplan.cn/tags/Maven/"}]},{"title":"Filter_Listener","slug":"Filter-Listener","date":"2020-04-03T07:52:10.000Z","updated":"2020-09-07T11:39:18.455Z","comments":true,"path":"JavaWeb/Filter-Listener/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Filter-Listener/","excerpt":"","text":"Filter（过滤器） 概念：客户端访问服务器资源时，filter拦截请求，作特殊处理：登录验证、统一编码处理、敏感字符过滤等。 使用 实现javax.servlet.Filter接口 覆写init()/doFilter()/destroy()方法 doFilter()放行代码：filterChain.doFilter(servletRequest, servletResponse); 配置拦截路径 注解配置：@WebFilter(&quot;/path&quot;) web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;filterClassName&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;path&lt;&#x2F;url-pattern&gt; &lt;!-- 拦截路径 --&gt;&lt;&#x2F;filter-mapping&gt; filter的执行流程 客户端请求 -&gt; 经过filter -&gt; 执行doFilter()： 对request对象请求消息处理 -&gt; 放行 -&gt; (服务器servlet执行后响应) 对response对象的响应消息处理 filter的生命周期 init()：服务器启动后，创建filter对象，调用init()方法，只执行一次。用于加载资源。 doFilter()：每一次请求被拦截资源时，都会执行。 destroy()：服务器关闭，filter对象被销毁。正常关闭情况下，会执行destroy()方法。用于释放资源。 拦截方式配置，设置dispatcherTypes属性 注解方式 DispatcherType.REQUEST：默认值。浏览器直接请求资源时，才会执行filter。 DispatcherType.FORWARD：转发访问资源。 DispatcherType.INCLUDE：包含访问资源。 DispatcherType.ERROR：错误跳转资源。 DispatcherType.ASYNC：异步访问资源。 web.xml方式 添加&lt;dispatcher&gt; &lt;/dispatcher&gt;标签，标签中文本取上述取值即可。 过滤器链的执行顺序：filter1 -&gt; filter2… -&gt; 资源执行 -&gt;…filter2 -&gt; filter1。 注解配置：按照类名的字符串比较规则比较，值小的先执行。例如filterA与filterB，则filterA先执行。 web.xml配置：按照&lt;filter-mapping&gt;的定义顺序执行。 Listener(监听器) 概念：监听器就是一个实现了特定接口的普通Java程序，这个程序专门用于监听另一个Java对象的方法调用或者属性改变（事件）。当被监听对象发生上述事件后，监听器某个方法将立即被执行。 常用的监听器”6 + 2”： 6个常规监听器，对应JavaWeb三大域对象 ServletContext ServletContextListener(生命周期监听)，项目启动时，ServletContext创建后创建该接口的实现类对象。注：Spring框架的ContextLoaderListener类实现了该接口。 ServletContextAttributeListener(属性监听) HttpSession HttpSessionListener(生命周期监听)，只有在servlet中调用了request.getSession()方法且根据JSESSIONID找不到对应的session时才会创建新的session对象，触发监听。 HttpSessionAttributeListener(属性监听) ServletRequest ServletRequestListener(生命周期监听)，每一次请求都会创建request对象并触发监听，每一次请求结束都会销毁request对象并触发监听。 ServletRequestAttributeListener(属性监听) 生命周期监听：每当tomcat创建或销毁三大域对象时，都会被其对应的Listener察觉并调用其特定的方法。 属性监听：每当调用域对象的setAttribute()或getAttribute()，都会被对应的属性监听器察觉并调用其特定的方法。 2个感知监听 HttpSessionBindingListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口，其有两个方法valueBound()/valueUnbound，当该对象被绑定(存储)时，触发该对象的valueBound()方法；当该对象被session解绑时session.removeAttribute(&quot;key&quot;);时触发该对象的valueUnbound()方法。 HttpSessionActivationListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口。当该session即将被钝化(序列化)时，触发该监听器的sessionWillPassivate()方法；当该session活化时，触发该监听器的sessionDidActivate方法。 设计模式：观察者模式（待补充） javax.servlet.ServletContextListener接口：用于监听ServletContext对象的销毁与创建 void contextDestroyed(ServletContextEvent sce)：ServletContext对象被销毁之前会调用该方法。 void contextInitialized(ServletContextEvent sce)：ServletContext对象创建后会调用该方法，服务器启动后自动调用。 使用：实现接口 -&gt; 覆写方法 -&gt; 配置 web.xml配置 123&lt;listener&gt; &lt;listener-class&gt;监听器类名&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt; 注解配置：@WebListener","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Cookie_Session","slug":"Cookie-Session","date":"2020-04-01T12:55:36.000Z","updated":"2020-09-07T11:39:26.811Z","comments":true,"path":"JavaWeb/Cookie-Session/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Cookie-Session/","excerpt":"","text":"会话 会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一标识一个用户并记录其状态。由于HTTP协议是无状态的，也就是说浏览器的每一次请求都是独立的，服务器并不知道这个浏览器之前是否请求过，这才有了会话机制。 Cookie 概念：客户端会话技术，将数据保存到客户端。javax.servlet.http.Cookie(类)。 主要作用：避免多次登录验证，一次登录后服务器便使用cookie验证身份。cookie的作用就像是身份凭证。 使用 创建Cookie对象，绑定数据：new Cookie(String name, String value) 发送Cookie对象到客户端：response.addCookie(Cookie cookie) 获取Cookie，拿到数据： 12345678Cookie[] cookies &#x3D; request.getCookies();if(cookies !&#x3D; null)&#123; for(Cookie c : cookies)&#123; String name &#x3D; c.getName(); String val &#x3D; c.getValue(); &#x2F;&#x2F;.......... &#125;&#125; 原理 客户端发送请求-&gt; 服务器创建Cookie并发送到客户端 -&gt; http响应头增加Set-Cookie：name=value字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证 Tips 一次可以创建多个Cookie并发送 Cookie在浏览器中存活时间 默认情况下，浏览器关闭后Cookie数据销毁 持久化存储：cookie.setMaxAge(int seconds) 正数：将cookie数据写到硬盘的文件中，seconds时间之后文件被删除。 负数：默认值 0：删除已经存在于客户端的cookie数据 Tomcat8之后Cookie支持中文 Cookie共享问题 假设在一个Tomcat服务器中部署了多个web项目： 默认情况下不同web项目的cookie不能共享 cookie.setPath(String path)：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，可将path设置为”/“。 服务器集群共享Cookie： setDomain(String path)：设置一级域名 例如setDomain(&quot;.baidu.com&quot;)，则tieba.baidu.com和news.baidu.com中cookie可以共享 Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。javax.servlet.http.HttpSession（接口）。 主要作用 用于存储一次会话的多次请求的数据 可以存储任意类型、任意大小的数据 使用 获取session对象：HttpSession session = request.getSession(); 存储数据：session.setAttribute(&quot;name&quot;, Object); 获取数据：session.getAttribute(&quot;name&quot;); 原理：Session的实现依赖于Cookie，服务器通过Cookie确保多次请求获取的Session对象为同一个。 客户端发送请求-&gt; 创建Session对象，若没有Cookie，则http响应头增加Set-Cookie：JSESSIONID=sessionID字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证sessionID Tips 浏览器关闭，服务器不关闭，浏览器重启，两次获取的session对象是否相同？ 默认情况下不是。 为避免这种情况，可手动设置持久化存储JSESSIONID 123Cookie cookie &#x3D; new Cookie(&quot;JSESSIONID&quot;, session.getId());cookie.setMaxAge(60*60);&#x2F;&#x2F;持久化存储cookieresponse.addCookie(cookie); 浏览器不关闭，服务器关闭，服务器开启，两次获取的session对象是否相同？ 新对象地址与原对象不同 为避免服务器重启数据丢失，采用session的钝化和活化技术。 session钝化：在服务器正常关闭前，将session对象序列化到硬盘上 session活化：服务器启动后，将session文件转化为内存中的session对象，删除文件 Tomcat已经集成了钝化与活化技术，正常关闭tomcat后，会在work工作目录的项目文件夹下生成一个SESSIONS.ser文件 session钝化与活化不仅仅是服务器关闭时发生，当在线用户过多时，大量session对象存在于服务器内存中。为减轻服务器内存负担，当一个session长时间没有被访问，也会被序列号到磁盘上（注意session中存储的对象所在的类必须要实现序列化接口）。可在tomcat的conf/context.xml中配置。 session何时被销毁？ 服务器关闭 session对象调用invalidate()方法 session默认失效时间为30分钟(可在tomcat的conf/web.xml中配置) 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Servlet","slug":"Servlet","date":"2020-04-01T08:10:10.000Z","updated":"2020-09-07T11:37:38.668Z","comments":true,"path":"JavaWeb/Servlet/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Servlet/","excerpt":"","text":"Servlet(Server applet) 用于处理请求与业务逻辑。 调用流程： 用户访问html页面，表单提交 xml文件url-pattern与url匹配，若符合Tomcat则加载servlet-class对应的class文件进内存（反射） 实例化Servlet（class.newInstance()）得到一个Servlet对象 调用service()方法，根据表单的method，在该方法中调用doGet或doPost方法 request对象获取参数，response对象返回数据 服务器通过http协议返回数据 Servlet生命周期： 实例化：无论访问多少次该Servlet，构造方法只执行一次，只存在一个对象（单实例） 注：多个用户同时访问时，可能存在线程安全问题。因此尽量不要在Servlet中定义成员变量。 初始化：在构造方法执行后，执行init()方法，无论访问多少次该Servlet，init()方法只执行一次。init()方法的参数ServletConfig对象实例，通过解析web.xml文件创建。 提供服务：tomcat创建req和resp对象，将这两个对象作为参数传递给service()，执行service()方法，在该方法中判断执行doGet()还是doPost() 销毁：当在server.xml的Context字段中配置了reloadable=”true”时，表示web应用有任何类型的更新都会自动重启，重启就会调用destroy()方法；tomcat服务器关闭时destroy()方法会被调用。 被回收：等待下一次GC回收 自启动：假如需要在tomacat一启动就执行一些初始化的代码，比如校验数据库的完整性。但是Servlet的生命周期是在用户访问对应路径开始的，这就需要Servlet自启动，执行init()方法中的业务代码：在web.xml中增加&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;，取值范围是1-99，数字表示启动顺序，数字越小启动的优先级越高。 注解配置（Servlet3.0后支持，不再需要web.xml配置文件） Servlet类上使用@WebServlet(&quot;/URI&quot;)配置 页面跳转： 服务端跳转forward(转发)：request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);,服务器内部访问success.html，并将其发送给浏览器。客户端只请求一次，服务器内部跳转。 客户端跳转redirect(重定向)：response.sendRedirect(&quot;fail.html&quot;);，发送一条消息给浏览器让其访问fail.html，浏览器访问，服务器获取fail.html发送给浏览器。客户端一共请求了两次。 Servlet映射器(Mapper)：每一个请求，对应的URL要交给哪一个Servlet处理，由Tomcat中的映射器Mapper类处理。 request对象：封装请求消息数据 获取参数： request.getParameter()：用于获取单值的参数request.getParameterValues()：用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap()：用于遍历所有的参数，并返回Map类型。 获取头信息： request.getHeader()：获取浏览器传递过来的头信息。request.getHeaderNames()：获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 服务端传参：request.setAttribute()与request.getAttribute() 设置编码：request.setCharacterEncoding(&quot;UTF-8&quot;); 常见方法： request.getRequestURL()：浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI()：浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString()：请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr()：浏览器所处于的客户机的IP地址request.getRemoteHost()：浏览器所处于的客户机的主机名request.getRemotePort()：浏览器所处于的客户机使用的网络端口request.getLocalAddr()：服务器的IP地址request.getLocalName()：服务器的主机名request.getMethod()：得到客户机请求方式，一般是GET或者POST response对象：通过response对象设置响应消息数据 设置响应内容：response.getWriter()获取PrintWriter对象，使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。 设置响应格式与编码：response.setContentType(&quot;text/html;charset=utf-8&quot;)或response.setCharacterEncoding(&quot;UTF-8&quot;) ServletContext对象：服务器启动后自动创建，在整个Web应用的动态资源（Servlet/JSP…）之间共享数据，与servlet容器通信，服务器关闭时销毁。 通过request.getServletContext()或this.getServletContext()获取 获取MIME(text/html, image/jpeg…)类型数据：getMimeType(String file) 作为域对象共享数据：setAttribute() getAttribute() removeAttribute()，共享所有用户请求的数据 获取文件的真实路径：getRealPath(String file) ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序（对称） ServletContext -&gt; ServletContextListener -&gt; Filter -&gt; 自启动Servlet -&gt; 浏览器请求访问普通Servlet -&gt; 销毁自启动Servlet -&gt; 销毁Filter-&gt; 销毁ServletContextListener -&gt; 销毁ServletContext Listener, Filter, Servlet的实现类对象均是服务器通过反射创建。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"JSON","slug":"JSON","date":"2020-04-01T08:09:57.000Z","updated":"2020-09-07T11:38:27.081Z","comments":true,"path":"JavaWeb/JSON/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JSON/","excerpt":"","text":"JSON简介 概念：JavaScript对象表示法(JavaScript Object Notation)。 作用：JSON是存储和交换文本信息的语法，常用于信息传输，比XML更小、更快、更易解析。 语法 基本语法： 数据由键值对构成，值的取值类型有： 整数或浮点数 字符串：&quot;string&quot; 布尔值：true/false 数组：[] 对象：{name:&quot;Tom&quot;,age:23,gender:&quot;male&quot;} null 数据由,分隔 {}保存对象，同时也定义了JSON格式 []保存数组 获取数据方式：JSON对象.键名；JSON对象[“键名”]；数组对象[索引]。 JSON在Java中的解析 Java常用的JSON解析类库：GSON, FastJson, Jackson；以Jackson为例。 Java对象转JSON 123456789101112131415161718192021222324252627public class Person&#123; private String name; private int age; private String gender; &#x2F;&#x2F;getter and setter&#125;public class JacksonTest&#123; &#x2F;&#x2F;创建Java对象 Person p &#x3D; new Person(); p.setName(&quot;Tom&quot;); p.setAge(23); p.setGender(&quot;男&quot;); &#x2F;&#x2F;创建Jackson对象 ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;转换方法： &#x2F;* writeValue(args, obj): args: File:将obj对象转换为JSON字符串，并保存到指定文件； Writer:转换，并将json数据填充到字符输出流 OutputStream:转换，并将json数据填充到字节输出流 writeValueAsString(obj):将对象转换为json字符串 *&#x2F; String json &#x3D; mapper.writeValueAsString(p); &#125; 注解： @JsonIgnore：排除属性（该注解置于要忽略的属性上），指定属性不会被转换 @JsonFormat：属性值格式化（该注解置于要格式化的属性上），例@JsonFormat(pattern=&quot;yyyy-MM-dd&quot;) JSON转Java对象 123String json &#x3D; &quot;&#123;name:\\&quot;Tom\\&quot;,age:23&#125;&quot;;ObjectMapper mapper &#x3D; new ObjectMapper();Person p &#x3D; mapper.readValue(json, Person.class);","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"XML","slug":"XML","date":"2020-03-30T14:00:41.000Z","updated":"2020-09-07T11:37:01.887Z","comments":true,"path":"JavaWeb/XML/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/XML/","excerpt":"","text":"概念扩展标记语言（Extensible Markup Language），标签可自定义。 功能 用于存储与传输数据 配置文件 在网络中传输 语法 基本语法： 第一行必须定义为文档声明，例如&lt;? xml version=&#39;1.0&#39; ?&gt;。 xml文档中有且仅有一个根标签 属性值必须用使用引号 标签必须正确关闭 标签名称严格区分大小写 例： 12345678910111213 &lt;?xml version&#x3D;&#39;1.0&#39; ?&gt; &lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name&gt;Tom&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;br&#x2F;&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;Lisa&lt;&#x2F;name&gt; &lt;age&gt;20&lt;&#x2F;age&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 组成部分： 文档声明：&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt; 标签：自定义标签 属性：id属性值唯一 文本 XML命名空间（XML Namespaces）：提供避免元素命名冲突的方法，比如不同的两个XML被同时使用，且他们有一个相同的标签时，可通过命名空间避免冲突。 XML命名空间属性被放置于元素的开始标签中，语法为xmlns:namespace-prefix=&#39;namespaceURI&#39; 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联 约束 约束：规定xml文档的书写规则。一般来说，框架提供约束，框架使用者按照约束来编写xml。 DTD：简单的约束技术，文件后缀为.dtd &lt;!ELEMENT &gt;定义标签，&lt;!ATTLIST &gt;定义属性，()定义子标签 约束内容例： 123456&lt;!ELEMENT students (student*)&gt;&lt;!ELEMENT student (name,age,sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 引入dtd文档到xml中 内部dtd：将约束规则定义在xml文档中 &lt;!DOCTYPE 根标签名 [约束内容] &gt; 外部dtd：将约束规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的绝对路径&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;URL路径&quot;&gt; Schema：复杂的约束技术，本质上就是xml，文件后缀为.xsd 可定义xml中文本的类型，文本取值的范围，标签出现的顺序等 引入.xsd约束文件到xml 引入无命名空间的.xsd 1234567&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation&#x3D;&quot;无命名空间XSD文件的URI&quot;&gt;&lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，通过xsi命名空间下的属性noNamespaceSchemaLocation指定XSD文件的URI--&gt;&lt;&#x2F;root&gt; 引入有命名空间的.xsd 1234567891011&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:ns1&#x3D;&quot;前缀ns1对应命名空间&quot; xmlns:ns2&#x3D;&quot;前缀ns2对应命名空间&quot; xsi:schemaLocation&#x3D;&quot;ns1前缀对应命名空间 前缀ns1对应命名空间XSD文件的URI ns2前缀对应命名空间 前缀ns2对应命名空间XSD文件的URI&quot;&gt; &lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，添加命名空间，可添加多个，但没有前缀的命名空间最多只能有1个 3.第三步，通过xsi命名空间下的属性schemaLocation指定每个命名空间XSD文件的URI，命名空间和相应URI一一对应，多个命名空间用空格分隔 --&gt; &lt;&#x2F;root&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"动态规划入门","slug":"动态规划入门","date":"2020-03-28T13:38:15.000Z","updated":"2020-09-07T11:36:11.707Z","comments":true,"path":"面试刷题/动态规划入门/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和为Sum 例：lintcode114 123456789101112131415161718192021public class Solution &#123; /** * @param m: positive integer (1 &lt;= m &lt;= 100) * @param n: positive integer (1 &lt;= n &lt;= 100) * @return: An integer */ public int uniquePaths(int m, int n) &#123; // write your code here int[][] dp = new int[m][n];//dp[i][j]表示机器人有多少种方式从左上角走到(i,j) //dp[i][j] = dp[i-1][j]+dp[i][j-1] for(int i = 0; i &lt; m; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == 0 || j == 0) dp[i][j] = 1;//第0行(列)的所有格子都只有一种方式到达 else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 求最值 从左上角走到右下角路径的最大数字和 最长上升序列长度 例：lintcode669 1234567891011121314151617181920212223242526public class Solution &#123; /** * @param coins: a list of integer * @param amount: a total amount of money amount * @return: the fewest number of coins that you need to make up */ public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount+1];//记录组成从0-amount分别需要的最少的硬币数 dp[0] = 0; for(int i = 1; i &lt;= amount; ++i)&#123; dp[i] = Integer.MAX_VALUE;//表示不存在组成i所需要的最少硬币数,同时看作min变量，储存dp[i-coins[j]]+1,j=1,2...中的最小值 for(int j = 0; j &lt; coins.length; ++j)&#123; if(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != Integer.MAX_VALUE &amp;&amp; dp[i-coins[j]]+1 &lt; dp[i])&#123; dp[i] = dp[i-coins[j]] + 1;//组成总数为i需要的最少的硬币数为：组成总数为i-coins[j],j=1,2...coins.length需要的最少硬币数中最小的一个,再加1 &#125; &#125; &#125; if(dp[amount] == Integer.MAX_VALUE) return -1; else return dp[amount]; &#125; &#125; 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和为Sum 例：lintcode116 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; /** * @param A: A list of integers * @return: A boolean */ //动态规划 public boolean canJump(int[] A)&#123; if(A == null || A.length == 0) return false; int len = A.length; boolean[] dp = new boolean[len]; dp[0] = true; //思路:最后一步A[len-1]可达，当且仅当前面某个下标i可达且i+A[i]&gt;=A[len-1]；推广到对任意j = 1,2,...len-1，i &lt; j都必须满足dp[i] &amp;&amp; i + A[i] &gt;= j for(int j = 1; j &lt; len; ++j)&#123; dp[j] = false; for(int i = 0; i &lt; j; ++i)&#123; if(dp[i] &amp;&amp; i + A[i] &gt;= j)&#123;//状态方程：能够到达i，并且i+A[i]&gt;=j即表示从i能到达j dp[j] = true; break; &#125; &#125; &#125; return dp[len-1]; &#125; //贪心算法 public boolean canJumpGreedy(int[] A) &#123; //[3,2,1,0,4] if(A == null || A.length == 0) return false; int farthest = A[0];//farthest变量记录当前能够到达的最远距离 for(int i = 1; i &lt; A.length; ++i)&#123; if(farthest &lt; i) return false;//farthest比i小，表示不能到达i，return false else farthest = i + A[i] &gt; farthest ? i + A[i] : farthest;//更新farthest &#125; return true; &#125;&#125; 动态规划组成部分 确定状态：创建数组，数组的每个元素代表什么？ 两个要点 最后一步 子问题 递归算法的问题：重复计算，效率低下 转移方程：根据子问题定义得到。将计算结果保存下来，并改变计算顺序，空间换时间 初始条件和边界情况 计算顺序：利用之前的计算结果 常见动态规划类型 坐标型 序列型 划分型 区间型 背包型 最长序列型 博弈型","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"lintcode","slug":"lintcode","permalink":"http://thmasterplan.cn/tags/lintcode/"}]},{"title":"反编译及助记符","slug":"反编译及助记符","date":"2020-03-26T06:11:57.000Z","updated":"2020-09-07T11:35:57.552Z","comments":true,"path":"JVM/反编译及助记符/","link":"","permalink":"http://thmasterplan.cn/JVM/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6/","excerpt":"","text":"JVM参数，均以-XX:开始，其中-XX:+&lt;option&gt;，表示开启option选项；-XX:-&lt;option&gt;，表示关闭option选项；-XX:&lt;option&gt;=&lt;value&gt;，表示将option选项的值设置为value。 -XX:+TraceClassLoading，用于追踪类的加载信息并打印。 反编译.class文件：javap -c 全类名 反编译代码助记符： getstatic：获取类的静态字段 ldc：表示将int, float或是String类型的常量值从常量池推送至栈顶 bipush：表示将单字节（-128-127）的常量值从常量池推送至栈顶 sipush：表示将一个短整型（-32768—32767）常量值推送至栈顶 iconst_1：表示将int类型的1推送至栈顶（iconst_0 - iconst_5） anewarray：创建一个引用类型数组，并将其引用值压入栈顶 newarray：创建一个基本类型的数组，并将其引用值压入栈顶 数组创建本质：new一个数组，对于数组实例来说，其类型是由JVM在运行期间动态生成的，动态生成的类型其父类为Object。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"贪心","slug":"贪心","date":"2020-03-26T06:11:35.000Z","updated":"2020-09-07T11:34:54.269Z","comments":true,"path":"面试刷题/贪心/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心算法 解决贪心问题的步骤： 将原问题分解为子问题 找出贪心策略（寻找局部最优解） 得到每一个子问题的最优解 将所有局部最优解的集合构成称为原问题的一个解 leetcode455：分发饼干 123456789101112131415class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; int child = 0; int cookie = 0; Arrays.sort(g); //先将饼干 和 孩子所需大小都进行排序 Arrays.sort(s); while (child &lt; g.length &amp;&amp; cookie &lt; s.length )&#123; //当其中一个遍历就结束 if (g[child] &lt;= s[cookie])&#123; //当用当前饼干可以满足当前孩子的需求，可以满足的孩子数量+1 child++; &#125; cookie++; // 饼干只可以用一次，因为饼干如果小的话，就是无法满足被抛弃，满足的话就是被用了 &#125; return child; &#125;&#125; leetcode435：无重叠区间 123456789101112131415161718192021222324class Solution &#123; //思路：按区间开始处升序排序后，尽量保留结尾小的 public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) return 0; Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] - o2[0]; &#125; &#125;);//按照区间开始升序排序 int prev = 0, count = 0;//变量prev保存遍历时的前一个区间 for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[prev][1] &gt; intervals[i][0]) &#123;//前一个区间的结尾&gt;后一个区间的开始，表明有重叠 if (intervals[prev][1] &gt; intervals[i][1]) prev = i;//前一个区间的结尾&gt;后一个区间的结尾，表明前一个区间覆盖后一个区间，删除结尾大的区间 count++; &#125; else prev = i;//无重叠 &#125; return count; &#125;&#125; leetcode452：用最少数量的箭引爆气球 1234567891011121314151617181920212223class Solution &#123; //类似于435，删除k个区间后便无重叠区间，则该题答案为n-k，n为总区间个数 public int findMinArrowShots(int[][] points) &#123; if(points.length == 0) return 0; Arrays.sort(points, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] point1, int[] point2)&#123; return point1[0] - point2[0]; &#125; &#125;);//升序排序 int prev = 0, count = 0; for(int i = 1; i &lt; points.length; i++)&#123; if(points[prev][1] &gt;= points[i][0] )&#123; if(points[prev][1] &gt; points[i][1]) prev = i; count++; &#125;else prev = i; &#125; return points.length - count; &#125;&#125; leetcode406：根据身高重建队列 123456789101112131415161718192021222324//将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。//按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。//直到完成为止。class Solution &#123; //1.排序：按高度降序排列；在同一高度的人中，按 k 值的升序排列。 //2.逐个地把它们放在输出队列中，索引等于它们的 k 值。 //3.返回输出队列 public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] == o2[0] ? o1[1] - o2[1]: o2[0] - o1[0]; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for(int[] p : people)&#123; list.add(p[1],p); &#125; return list.toArray(new int[people.length][2]); &#125;&#125; leetcode121：买卖股票的最佳时机 12345678910111213class Solution &#123; public int maxProfit(int prices[]) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, min = prices[0];//min记录前面的最小价格 for(int i = 1; i &lt; prices.length; i++)&#123; int profit = prices[i] - min;//利润等于当前价格减去最小价格 result = result &gt; profit ? result : profit;//更新最大利润 min = prices[i] &gt; min ? min : prices[i];//每一天更新最小价格 &#125; return result; &#125;&#125; leetcode122：买卖股票的最佳时机2 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, buy = prices[0]; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &lt; prices[i-1]) buy = prices[i];//股票降了，抄底买入 else&#123; result += prices[i] - buy;//股票涨的阶段，卖掉前一天的股票 buy = prices[i];//买入当天的股票，利润最大化 &#125; &#125; return result; &#125;&#125; leetcode605：种花问题 1234567891011121314public class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int i = 0; while (i &lt; flowerbed.length) &#123; if (flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) &#123;//数组元素为0，并且其左右两边均为0，或者该数组下标位于首（尾） flowerbed[i++] = 1; n--; &#125; if(n &lt;= 0) return true; i++; &#125; return false; &#125;&#125; leetcode392：判断子序列 1234567891011121314class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int sLen = s.length(); if(sLen == 0) return true; int j = 0; for(int i = 0; i &lt; t.length(); i++)&#123; if(j &lt; sLen &amp;&amp; t.charAt(i) == s.charAt(j)) j++; if(j == sLen) return true; &#125; return false; &#125;&#125; leetcode53：最大子数组和 1234567891011class Solution &#123; public int maxSubArray(int[] nums) &#123; int currMaxSum = nums[0], maxSum = nums[0]; for(int i = 1; i &lt; nums.length; ++i) &#123; currMaxSum = Math.max(nums[i], currMaxSum + nums[i]);//计算以当前元素nums[i]为终点的所有的子数组的最大和 maxSum = Math.max(maxSum, currMaxSum);//maxSum是所有currMaxSum中的最大值 &#125; return maxSum; &#125;&#125; leetcode763：划分字母区间 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; partitionLabels(String S) &#123; int[] last = new int[26];//定义一个大小为26的数组，用于存储每个字母最后一次出现的下标 for(int i = 0; i &lt; S.length(); ++i)&#123; last[S.charAt(i) - 'a'] = i;//遍历字符串，更新每个字符的下标 &#125; int start = 0, end = 0; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; S.length(); ++i)&#123; end = Math.max(end, last[S.charAt(i) - 'a']);//遍历字符串时扩展区间末端end if(i == end)&#123;//当前下标等于区间末端end时，为一次划分，更新start=end+1 res.add(end-start+1); start = end+1; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"注解","slug":"注解","date":"2020-03-25T09:58:33.000Z","updated":"2020-09-07T11:33:34.575Z","comments":true,"path":"Java基础/注解/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解 注解（Annotation），也叫元数据，JDK1.5后引入的特性，与类、接口、枚举在同一层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用于对这些元素进行说明。 定义注解 -&gt; 使用注解 -&gt;读取注解 作用分类 编写文档 ：命令行输入javadoc xxx.java，通过代码里标识的注解自动生成doc文档 代码分析：通过代码里标识的注解对代码进行分析（使用反射机制） 编译检查 ：编译器对代码进行编译检查 JDK预定义的注解 @Override：检测被注解的方法是否继承自父类（接口） @Deprecated：被注解的内容已过时，不建议使用 @SuppressWarnings：压制警告，一般传递参数all 自定义注解 注解通过@interface定义，例如public @interface MyAnnotation{} 本质是接口：public interface MyAnnotation extends java.lang.annotation.Annotation{} 注解的属性：接口中的抽象方法 属性的返回值类型 基本数据类型 String 枚举 注解 以上类型的数组 使用注解时，需要对属性赋值，例@SuppressWarning(&quot;all&quot;)；亦可以在定义注解时使用default设置默认值，使用时就不用赋值；如果只有一个属性需要赋值，且属性名为value，则value可以省略可直接赋值，上述压制警告就是这种情形。 123public @interface MyAnno&#123; int a() default 5; &#125; 元注解：可以注释到注解上的注解，一共有五种。 @Retention：描述注解被保留的阶段 12345public enum RetentionPolicy&#123; SOURCE,//注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视 CLASS,//注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 RUNTIME//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时才能获取到它们（常用）&#125; 使用示例： 123@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno&#123;&#125; @Documented：描述注解是否被抽取到doc文档中 @Target：当一个注解被 @Target 注解时，这个注解就被限定了运用的场景 ElementType.ANNOTATION_TYPE：可以给一个注解进行注解 ElementType.CONSTRUCTOR：可以给构造方法进行注解 ElementType.FIELD：可以给成员变量进行注解 ElementType.LOCAL_VARIABLE：可以给局部变量进行注解 ElementType.METHOD：可以给方法进行注解 ElementType.PACKAGE：可以给一个包进行注解 ElementType.PARAMETER：可以给一个方法内的参数进行注解 ElementType.TYPE：可以给一个类型进行注解，比如类、接口、枚举 @Inherited：描述注解是否被子类继承 @Repeatable 在程序中使用（解析）注解：获取注解中定义的属性值 例如在反射中的自定义框架，使用注解后便不需要使用配置文件传参数，通过更改注解的属性值即可实现创建不同的对象、使用对象的方法。 1234567891011121314151617package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 描述需要执行的类名和方法名 * */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String methodName();&#125; 12345678910111213141516171819202122232425262728293031package annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Method;@Pro(className = \"model.Person\",methodName=\"eat\")public class MyFrame2 &#123; public static void main(String[] args) throws Exception &#123; //1.获取注解对象 Class&lt;MyFrame2&gt; myFrame2Class = MyFrame2.class; Pro anno = myFrame2Class.getAnnotation(Pro.class);//在内存中生成了一个该注解接口的子类的实现对象 //2.调用注解对象中定义的抽象方法，获取返回值 String className = anno.className(); String methodName = anno.methodName(); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance(); Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125; 使用注解方式创建DBUtil工具类（降低耦合度） 1234567891011121314151617181920212223package anno;import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.ElementType.TYPE;import java.lang.annotation.Documented;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;METHOD,TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface JDBCConfig &#123; String ip(); int port() default 3306; String database(); String encoding(); String loginName(); String password(); &#125; 12345678910111213141516171819202122232425262728293031323334353637package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import anno.JDBCConfig;@JDBCConfig(ip = \"127.0.0.1\", database = \"test\", encoding = \"UTF-8\", loginName = \"root\", password = \"admin\")public class DBUtil &#123; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException &#123; JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);//通过反射获取DBUtil类上的注解对象 String ip = config.ip(); int port = config.port(); String database = config.database(); String encoding = config.encoding(); String loginName = config.loginName(); String password = config.password(); String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException &#123; Connection c = getConnection(); System.out.println(c); &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"反射","slug":"反射","date":"2020-03-24T09:08:10.000Z","updated":"2020-09-07T11:35:50.293Z","comments":true,"path":"Java基础/反射/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"概述反射概念 反射就是把Java类中的各个成分（成员变量、构造器、成员方法）映射成一个个的Java对象。 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个属性和方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。 反射的好处：解耦，提高程序的可扩展性。（例如Spring框架的依赖注入） Class类 Class类存在于JDK的java.lang包中，手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的信息，这个Class对象保存在同名.class的文件中。Class类的对象作用是运行时提供或获得某个对象的类型信息。 反射的使用获取Class类对象 Class对象中将类的成员变量封装到Field[]中，将类的构造方法封装到Constructor[]中，将类的方法封装到Method[]中。 三种方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。此种方式多用于配置文件，将类名定义在配置文件中，通过读取文件加载类。 类名.class：通过类名的class属性获取。多用于参数的传递。 对象.getClass() ：getClass()方法在Object类中定义。通过对象获取类的字节码。 注：不论使用哪种方式，同一个.class文件在一次程序运行中只会被加载一次，因此在一次运行中即使使用三种方式各获取一次，获取的都是同一个对象。 注：获取类的Class对象是Java程序对类的主动使用，会初始化该类（静态代码块，静态变量）。 注：静态synchronized方法的同步对象是：静态同步方法所在类的Class对象。 Class类的一些方法 getName(): 获取全类名 getSimpleName(): 获取类名 newInstance(): 创建实例化对象 Constructor Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。 通过类的Class对象的方法获取Constructor对象： Constructor&lt;?&gt; [] getConstructors(): 返回所有public修饰的Constructor对象的数组 Constructor&lt;?&gt; [] getDeclaredConstructors(): 返回所有的Constructor对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes): 返回指定参数类型、public修饰的Constructor对象 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes): 返回指定参数类型的所有Constructor对象 Constructor对象本身的方法 String getName(): 获取构造方法名称 T newInstance(): 创建实例化对象。Class对象的newInstance()方法也是调用构造器对象的该方法。 Field Field类提供有关类或接口的单个字段的信息，以及对它的动态访问权限。 通过类的Class对象的方法获取Field对象： Field[] getFields(): 只获取public修饰的Field字段, 包括继承自父类的字段 Field[] getDeclaredFields(): 获取类的所有字段，但是不包括继承自父类的 Field getField(String name): 获取指定的public修饰的字段，包括继承字段 Field getDeclaredFields(String name): 获取指定的字段，不包括继承字段 Field对象本身的方法 void set(Object obj, Object value): 设置指定对象上此字段的新值 Object get(Object obj): 返回指定对象上此字段的值 Class&lt;?&gt; getType(): 返回一个Class对象，它标识了此Field表示字段的声明类型 String getName(): 返回此Field对象表示的字段的名称 void setAccessible(boolean flag): 设置该字段是否可被访问。对于getDeclaredFields()和getDeclaredFields(String name)方法来说，若返回的Field中有由private修饰的字段，那么需要field.setAccessible(true)以表示其可以被访问。（暴力反射） Method Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。 通过类的Class对象的方法获取Method对象： Method[] getMethods(): 返回public修饰的方法对应Method的数组，包括继承自父类的 Method[] getDeclaredMethods(): 返回所有的方法对应Method的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt; …parameterTypes): 返回指定名称和参数列表的public修饰的方法对应Method Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes): 返回指定名称和参数列表的方法对应Method Method对象本身的方法 Object invoke(Object obj, Object… args): 对指定对象调用此Method表示的方法 Class&lt;?&gt; getReturnType(): 返回的Class对象描述了此Method表示方法的返回类型 String getName(): 返回Method 对象表示的方法名称，即返回方法的名称 练习写一个“框架”，可以创建任意类的对象，并能够执行其中任意方法 思路：使用反射，不需要更改框架的代码，只需更改配置文件的参数，就可以体现泛用性。（平时创建不同的对象是需要不同的代码的，比如 new Person(), new Student()） 步骤：1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中 ​ 2.在框架程序中读取配置文件 ​ 3.使用反射技术来加载要创建的对象的类文件进内存 ​ 4.创建对象（使用newInstance()方法） ​ 5.执行方法（使用invoke()方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package reflect;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;public class MyFrame &#123; public static void main(String[] args) throws Exception &#123; //1.加载配置文件 Properties properties = new Properties(); ClassLoader classLoader = MyFrame.class.getClassLoader(); InputStream iStream = classLoader.getResourceAsStream(\"pro.properties\"); properties.load(iStream); //2.获取配置文件中定义的数据 String className = properties.getProperty(\"className\"); String methodName = properties.getProperty(\"methodName\"); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance();本质仍然是调用Constructor对象的newInstance()方法 Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125;//Person类package model;public class Person &#123; public void eat() &#123; System.out.println(\"eating...\"); &#125;&#125;//pro.properties配置文件内容className=model.PersonmethodName=eat","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-03-07T08:01:05.000Z","updated":"2020-09-07T11:38:39.793Z","comments":true,"path":"Java基础/JDBC/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JDBC/","excerpt":"","text":"JDBC概念：官方定义的一套操作所有关系型数据库的接口，各个数据库厂商实现这套接口，提供数据库驱动jar包。 基础 初始化驱动类：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 建立与数据库的连接： 123456789static String ip = \"127.0.0.1\";static int port = 3306;static String database = \"tmall\";static String encoding = \"UTF-8\";static String loginName = \"root\";static String password = \"admin\";//mysql数据库url写法：jdbc:mysql://ip:端口号/数据库名称String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding);Connection connection = DriverManager.getConnection(url, loginName, password); 创建Statement并执行sql语句： 123Statement statement = connection.createStatement();String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\";statement.execute(sql); 使用try-with-resource自动关闭连接： 123456try (Connection connection = DriverManager.getConnection(url, loginName, password);Statement statement = c.createStatement();)&#123; String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\"; statement.execute(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; PreparedStatement 12345678910111213String sql = \"insert into hero values(null,?,?,?)\";try (Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\",\"root\", \"admin\"); // 根据sql语句创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql);) &#123; // 设置参数 ps.setString(1, \"提莫\"); ps.setFloat(2, 313.0f); ps.setInt(3, 50); // 执行 ps.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 使用预编译statement优点： 参数设置，可读性好，不需要进行字符串拼接 预编译机制性能比Statement好 可防止SQL注入攻击 execute/executeQuery/executeUpdate executeQuery: 返回一个结果集，这个方法用来执行select语句. 12345678ResultSet rs = statement.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt(\"id\");// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat(\"hp\"); int damage = rs.getInt(4); System.out.printf(\"%d\\t%s\\t%f\\t%d%n\", id, name, hp, damage); &#125; executeUpdate:用于执行insert，delete，update等SQL语句，executeupdate返回的值是一个整数，表示受影响的行数，对于create table等不操作行的语句，executeupdate的返回值为0。 execute: 可执行任何sql语句，其返回值为布尔类型，是true时，表示执行的是查询语句，可以通过getResultSet方法获取结果；返回值为false时，执行的是更新语句或DDL语句，getUpdateCount方法获取更新的记录数量 获取自增长ID：在执行完插入语句后，为获取新增记录的id 1234567// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id// JDBC通过getGeneratedKeys获取该idResultSet rs = prepareStatement.getGeneratedKeys();if (rs.next()) &#123; int id = rs.getInt(1); System.out.println(id);&#125; 使用事务：在mysql中，只有当表的类型是innodb时才支持事务 12345connection.setAutoCommit(false);//事务代码块connection.commit();//回滚事务:connection.rollback() ORM：Object Relationship Database Mapping，即对象与关系数据库的映射，对象中的各成员变量值与关系数据库里一条记录相对应。 DAO：Database Access Object，数据库访问对象，把对数据库某张表相关的操作都封装在这个类里面 数据库连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package jdbc; import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.ArrayList;import java.util.List; public class ConnectionPool &#123; List&lt;Connection&gt; cs = new ArrayList&lt;Connection&gt;(); int size; public ConnectionPool(int size) &#123; this.size = size; init(); &#125; public void init() &#123; //这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是\"活\"的，不要被自动关闭了 try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); for (int i = 0; i &lt; size; i++) &#123; Connection c = DriverManager .getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\", \"root\", \"admin\"); cs.add(c); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public synchronized Connection getConnection() &#123; while (cs.isEmpty()) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Connection c = cs.remove(0); return c; &#125; public synchronized void returnConnection(Connection c) &#123; cs.add(c); this.notifyAll(); &#125; &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"字符串","slug":"字符串","date":"2020-02-15T11:33:53.000Z","updated":"2020-09-07T11:33:25.825Z","comments":true,"path":"面试刷题/字符串/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"leetcode面试题01.09.字符串轮转： 给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。（同leetcode：796） 12345678910111213141516171819202122232425262728class Solution &#123; //只需要判断s2是否是s1s1的子串，并且s2.length == s1.length两个条件即可。 public boolean isFlipedString(String s1, String s2) &#123; if(s1.length() != s2.length()) return false;//长度不相等直接返回false else if(s1.length() == 0) return true;//长度相等但是都为空，返回true String s1s1 = s1+s1; if(isSubString(s1s1, s2)) return true;//判断s2是否为s1+s1的子串，是则为true return false; &#125; private boolean isSubString(String s1, String s2)&#123; int i = 0, j = 0; while(i &lt; s1.length())&#123; int k = i; while(k &lt; s1.length() &amp;&amp; j &lt; s2.length() &amp;&amp; s1.charAt(k) == s2.charAt(j) )&#123; k++; j++; &#125; if(j == s2.length()) return true; else j = 0; i++; &#125; return false; &#125;&#125;//一行代码版：//return s1.length() == s2.length &amp;&amp; (s1+s1).indexOf(s2) != -1; 面试题58 - ll左旋转字符串（类似于189.旋转数组）： 12输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出: &quot;cdefgab&quot; 1234567891011121314151617class Solution &#123; public String reverseLeftWords(String s, int n) &#123; char[] chars = s.toCharArray(); reverseString(chars, 0, n-1); reverseString(chars, n, chars.length-1); reverseString(chars, 0, chars.length-1); return new String(chars); &#125; private void reverseString(char[] s, int start, int end)&#123; while(start &lt; end)&#123; char temp = s[start]; s[start++] = s[end]; s[end--] = temp; &#125; &#125;&#125; 翻转字符串里的单词：151 12输入: &quot; a good example &quot;输出: &quot;example good a&quot; 123456789101112131415161718192021222324252627282930//翻转每个单词后再翻转整个字符串class Solution &#123; public String reverseWords(String s) &#123; s = s.trim();//去除首尾空格 s = s.replaceAll(\"\\\\s+\", \" \");//去除多余空格 char[] chars = s.toCharArray(); int i = 0, start = 0; while(i &lt; chars.length)&#123;//遇到空格即翻转每个单词 if(chars[i] == ' ')&#123; reverse(chars, start, i-1); start = i+1; &#125; i++; &#125; reverse(chars, start, --i);//翻转最后一个单词 reverse(chars, 0, i);//翻转整个字符串 return new String(chars); &#125; private void reverse(char[] c, int start, int end)&#123; while(start &lt; end)&#123; char temp = c[start]; c[start++] = c[end]; c[end--] = temp; &#125; &#125;&#125; 有效的字母异位词：242 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125; for(char c : t.toCharArray())&#123; if(!charFrequency.containsKey(c)) return false; else charFrequency.put(c, charFrequency.get(c)-1); &#125; for( char c : charFrequency.keySet())&#123; if(charFrequency.get(c) != 0) return false; &#125; return true; &#125; /* 用数组实现更快 public boolean isAnagram(String s, String t) &#123; int[] cnts = new int[26]; for (char c : s.toCharArray()) cnts[c - 'a']++; for (char c : t.toCharArray()) cnts[c - 'a']--; for (int cnt : cnts) if (cnt != 0) return false; return true; &#125; */&#125; 最长回文串：409 1234567891011121314151617181920212223242526272829303132class Solution &#123; //使用数组 public int longestPalindrome(String s) &#123; int[] charFrequency = new int[256]; for (char c : s.toCharArray()) charFrequency[c]++; int result = 0; for (int freq : charFrequency) result += (freq / 2) * 2; return result == s.length() ? result : result+1; &#125; &#125;/* 使用哈希表 public int longestPalindrome(String s) &#123; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125;//HashMap记录所有字母的频率 int result = 0; for(char c : charFrequency.keySet())&#123; int freq = charFrequency.get(c); result += (freq/2)*2;//为偶数则直接加，为奇数则-1 &#125; return result == s.length() ? result : result+1; &#125;*/ 同构字符串：205 123456789101112131415161718class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; return isIsomorphicSinglePass(s, t) &amp;&amp; isIsomorphicSinglePass(t, s); //必须双向验证 //例如\"bar\" -&gt; \" foo\"满足唯一映射，但是反之则不满足 &#125; //单方向判断s -&gt; t, s中的每个字母是否唯一映射t中的每个字母 private boolean isIsomorphicSinglePass(String s, String t)&#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; char charS = s.charAt(i); char charT = t.charAt(i); if(!map.containsKey(charS)) map.put(charS, charT); else if(map.get(charS) != charT) return false; &#125; return true; &#125;&#125; 回文数：9 1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x == 0) return true; if(x &lt; 0 || x % 10 == 0) return false; return x == reverse(x); &#125; //反转整数 private int reverse(int x)&#123; int result = 0; while(x &gt; 0)&#123; result = result*10; result += x%10; x = x/10; &#125; return result; &#125;&#125; 计数二进制子串：696 123输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 123456789101112131415161718class Solution &#123; //先统计连续的0和1分别有多少个，如：111100011000，得到4、3、2、3；在4323中的任意相邻两个数字，取小的一个加起来，就是3+2+2 = 7. public int countBinarySubstrings(String s) &#123; int res = 0; int i = 0, count = 1, precount = 0;//count记录相同数字连续子串的长度，precount记录前一个连续子串的长度 while(i &lt; s.length()-1)&#123; if(s.charAt(i) == s.charAt(i+1)) count++; else &#123; res += precount &gt; count ? count : precount;//取小的一个 precount = count; count = 1; &#125; i++; &#125; res += precount &gt; count ? count : precount; return res; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2020-02-14T14:43:29.000Z","updated":"2020-09-07T11:33:50.834Z","comments":true,"path":"面试刷题/栈与队列/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"用栈实现队列：232 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; stack; /** Initialize your data structure here. */ public MyQueue() &#123; stack = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; stack.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.pop(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Get the front element. */ public int peek() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.peek(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack.empty(); &#125;&#125; 用队列实现栈：225 1234567891011121314151617181920212223242526272829303132class MyStack &#123; private Queue&lt;Integer&gt; queue; /** Initialize your data structure here. */ public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; /** Push element x onto stack. */ public void push(int x) &#123; queue.offer(x); int size = queue.size(); while(size-- &gt; 1)&#123; queue.offer(queue.poll()); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; return queue.poll(); &#125; /** Get the top element. */ public int top() &#123; return queue.peek(); &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 最小栈：155 12345678910111213141516171819202122232425262728293031323334class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack;//minStack的栈顶元素即是当前stack的最小值 /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.empty())&#123; minStack.push(x); &#125;else&#123; if(x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; &#125; public void pop() &#123; int pop = stack.pop(); if(pop == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; 有效的括号：20 12345678910111213class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //遍历字符串，每遇到一种类型的左括号，则将其对应的右括号入栈；若不是左括号，且栈不为空，则出栈，出栈的有括号应与遍历到的右括号一致。 for(char c: s.toCharArray())&#123; if(c == '(') stack.push(')'); else if(c == '[') stack.push(']'); else if((c== '&#123;')) stack.push('&#125;'); else if(stack.empty() || c != stack.pop()) return false; &#125; return stack.empty(); &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"链表","slug":"链表","date":"2020-02-13T12:45:27.000Z","updated":"2020-09-07T11:35:23.245Z","comments":true,"path":"面试刷题/链表/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"找出两个链表的交点：160 1234567891011121314151617181920public class Solution &#123; /*设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。*/ public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while(pA != pB)&#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 反转链表：206 123456789101112131415//原地翻转三个主要变量，当前节点cur，前一个节点pre,后一个节点nextTempclass Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125;&#125; 合并两个有序链表：21 1234567891011121314151617181920212223class Solution &#123; //类似于归并排序中的merge过程 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode newList = new ListNode(0); ListNode cur = newList; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; cur.next = l1; cur = cur.next; l1 = l1.next; &#125;else&#123; cur.next = l2; cur = cur.next; l2 = l2.next; &#125; &#125; if(l1 == null) cur.next = l2;//任一链表为空，直接连接另一条链表 else cur.next = l1; return newList.next; &#125;&#125; 删除排序链表中的重复元素：83 123456789101112class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null &amp;&amp; cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125;else cur = cur.next; &#125; return head; &#125;&#125; 删除链表的倒数第N个节点：19 1234567891011121314151617class Solution &#123; //先使快指针移动n个节点，然后快慢指针同时移动直到快指针达到链表尾部，此时慢指针即指向要删除的节点的前一个节点 public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode first = head, second = head; for(int i = 0; i &lt; n; i++) second = second.next; if(second == null) return head.next;//若n等于链表节点数，直接返回head.next while(second.next != null)&#123; first = first.next; second = second.next; &#125; first.next = first.next.next; return head; &#125;&#125; 两两交换链表中的节点：24 123456789101112class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode firstNode = head, secondNode = head.next; firstNode.next = swapPairs(secondNode.next);//swapParis交换一对节点，并返回第二个节点 secondNode.next = firstNode; return secondNode; &#125;&#125; 两数相加：445 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; //两栈用于存储两个数，另一个栈存储和 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; first = new Stack&lt;&gt;(); Stack&lt;Integer&gt; second = new Stack&lt;&gt;(); while(l1 != null)&#123; first.push(l1.val); l1 = l1.next; &#125; while(l2 != null)&#123; second.push(l2.val); l2 = l2.next; &#125; Stack&lt;Integer&gt; sumStack = new Stack&lt;&gt;(); int carry = 0;//进位 while(!first.empty() &amp;&amp; !second.empty())&#123; int sum = first.pop() + second.pop() + carry; carry = 0;//进位用完归0 if(sum &gt;= 10)&#123; carry = 1; sum = sum % 10; &#125; sumStack.push(sum); &#125; while(!first.empty())&#123; if(carry == 1)&#123; int sum = first.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(first.pop()); &#125; while(!second.empty())&#123; if(carry == 1)&#123; int sum = second.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(second.pop()); &#125; if(carry == 1) sumStack.push(1);//和的第二位有进位的情况 ListNode sumList = new ListNode(sumStack.pop()); ListNode cur = sumList; while(!sumStack.empty())&#123; cur.next = new ListNode(sumStack.pop()); cur = cur.next; &#125; return sumList; &#125;&#125; 判断一个链表是否为回文链表：234（要求O（n）和O（1）） 1234567891011121314151617181920212223242526272829303132333435363738394041424344sclass Solution &#123; //该算法使用快慢指针找到链表中间节点，然后将链表切分，将后半部分翻转，再进行比较 public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) return true; ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125;//使用快慢指针使slow指针到达链表中间 if(fast != null) slow = slow.next;//链表节点个数为奇数，slow指针右移离开中间节点 ListNode cur = head; while(cur.next != slow)&#123; cur = cur.next; &#125; cur.next = null;//切分链表为两部分，后半部分第一个节点为slow return isEqual(head, reverseList(slow)); &#125; private ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125; private boolean isEqual(ListNode l1, ListNode l2) &#123; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; &#125; return true; &#125;&#125; 将链表奇数节点和偶数节点分别放在一起：328 （O（n）和O（1）） 1234567891011121314151617class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null) return head; ListNode odd = head, even = head.next; ListNode evenHead = even; while(even != null &amp;&amp; even.next != null)&#123; odd.next = even.next; odd = odd.next; even.next = odd.next; even = even.next; &#125; odd.next = evenHead; return head; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-02-12T07:23:45.000Z","updated":"2020-09-07T11:36:04.638Z","comments":true,"path":"面试刷题/二分查找/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"求开方：69 1234567891011121314151617class Solution &#123; public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int start = 1, end = x; while(start &lt;= end)&#123; int mid = start + (end - start)/2; int sqrt = x/mid;//不使用square与mid*mid判断是因为可能整型溢出 if(sqrt == mid) return mid; else if(sqrt &lt; mid) end = mid - 1; else start = mid + 1; &#125; return end; &#125;&#125; 寻找比目标字母大的最小字母：744 123456789101112131415161718class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; if(target &lt; letters[0] || target &gt;= letters[letters.length-1]) return letters[0]; int start = 0, end = letters.length - 2; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(letters[mid] == target)&#123; int i = mid+1; while(letters[i] == target) i++; return letters[i]; &#125; else if(letters[mid] &lt; target) start = mid + 1; else end = mid - 1; &#125; return letters[end+1]; &#125;&#125; 有序数组中的单一元素：540（时空复杂度要求为O（logn）和O(1)） 12345678910111213class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int start = 0, end = nums.length - 1; while(start &lt; end)&#123; int mid = start + (end - start)/2; if(mid%2 == 1) mid--;//只对偶数索引进行二分查找 //以[3,3,7,7,10,11,11]为例，只有当单一元素出现后，其后的数组部分，偶数索引mid处才不满足nums[mid] == nums[mid+1] if(nums[mid] == nums[mid+1]) start = mid + 2;//单一元素一定在mid后 else end = mid;//单一元素为mid或者在mid之前 &#125; return nums[start]; &#125;&#125; 寻找第一个错误的版本：278 1234567891011public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int low = 1, high = n; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(isBadVersion(mid)) high = mid;//第mid个版本错误，之后全是错的，向前继续找第一个错误的版本 else low = mid + 1;//第mid个版本正确，向后找 &#125; return low; &#125;&#125; 寻找旋转排序数组中的最小值：153 12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= nums[high]) high = mid; else low = mid+1; &#125; return nums[low]; &#125; /*时间复杂度O(n) public int findMin(int[] nums) &#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i+1]) return nums[i+1]; &#125; return nums[0]; &#125; */&#125; 在排序数组中查找元素的第一个和最后一个位置：34 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length == 0) return new int[]&#123;-1,-1&#125;; int firstIndex = findFirst(nums, target); if(nums[firstIndex] != target) return new int[]&#123;-1,-1&#125;; int lastIndex = findLast(nums,target); if(nums[nums.length-1] == target) return new int[]&#123;firstIndex,nums.length-1&#125;; return new int[]&#123;firstIndex, firstIndex &lt; lastIndex ? lastIndex : firstIndex&#125;; &#125; private static int findFirst(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &gt;= target) high = mid;//向左逼近，找左边界 else low = mid + 1; &#125; return low; &#125; private static int findLast(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= target) low = mid + 1;//向右逼近，找右边界，注意若最后一个数为target，则low不用-1 else high = mid; &#125; return low-1; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"排序","slug":"排序","date":"2020-02-11T08:07:19.000Z","updated":"2020-09-10T03:09:04.344Z","comments":true,"path":"数据结构与算法/排序/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"常见排序算法 排序的稳定性：排序过程中，具有相同关键字经过排序后，相对的顺序保持不变，则是稳定的；意义：在对象排序中，对其某个属性进行排序后，希望保持其他属性的顺序不发生改变，则需要稳定的排序算法。 选择排序从数组开始处遍历，找到剩余未遍历数组中的最小值，与本次遍历第一个数交换，重复此过程，每一次内层循环找到未遍历数组的最小值，外层循环中将一个最小值排好序。 1234567891011public static void sort(int[] nums)&#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; int minPostion = i; for(int j = i+1; j &lt; nums.length; j++)&#123; minPostion = nums[minPostion] &gt; nums[j] ? j :minPostion; &#125; swap(nums, minPostion, i); &#125; &#125; 冒泡排序内层循环两两比较，将大的数放在后面，最终结果是一次内层循环将一个最大的数排好顺序，与选择排序恰好相反。 1234567public static void sort(int[] nums)&#123; for(int i = nums.length-1; i &gt; 0; i--)&#123;//外层循环决定最大的数的位置 for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &gt; nums[j+1]) swap(nums, j, j+1); &#125; &#125; &#125; 插入排序外层循环遍历数组（选择某张牌），内层循环将外层循环选择的牌插入到前面已经排好序的牌中。 1234567public static void sort(int[] nums)&#123; for(int i = 1; i &lt; nums.length; i++)&#123; for(int j = i; j &gt; 0; j--)&#123; if(nums[j] &lt; nums[j-1]) swap(nums, j, j-1); &#125; &#125; &#125; 插入排序在样本较小且基本有序时效率较高。 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HeapSort &#123; //堆：满足“任一非叶子节点均大于（小于）等于其孩子节点”条件的完全二叉树，分为大根堆和小根堆 public static void main(String[] args) &#123; int[] test = &#123;3,2,5,6,4,7,0,1,10,9,8&#125;; sort(test); for(int num:test)&#123; System.out.print(\" \"+num); &#125; &#125; public static void sort(int[] tree)&#123; buildHeap(tree); for(int j = tree.length - 1; j &gt; 0; j--)&#123; swap(tree,0,j);//将堆顶元素与末尾元素进行交换 adjustHeap(tree,0,j);//重新对堆进行调整 &#125; &#125; /** * 创建大根堆 * @param tree */ public static void buildHeap(int[] tree) &#123; for(int i = tree.length/2 - 1; i &gt;= 0; i--)//从第一个非叶子结点（完全二叉树中必为n/2-1）从下至上，从右至左调整结构 adjustHeap(tree, i, tree.length); &#125; /** * 堆化操作，将第i个节点与其孩子节点进行比较，将最大值放在位置i上； * 递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 * @param tree * @param i * @param length */ public static void adjustHeap(int[] tree,int i,int length)&#123; if(i &gt;= length) return;//递归出口，孩子的下标大于等于数组长度返回 int leftChildIndex = 2*i + 1;//左孩子下标 int rightChildIndex = 2*i + 2;//右孩子下标 int maxIndex = i;//用一个变量来记录i, 2*i+1, 2*i+2三者中的最大值的下标 if(leftChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[leftChildIndex]) maxIndex = leftChildIndex; if(rightChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[rightChildIndex]) maxIndex = rightChildIndex; if(maxIndex != i)&#123; swap(tree, i, maxIndex); adjustHeap(tree, maxIndex, length);//递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 &#125; &#125; private static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 归并排序 Java对象排序使用，对象排序要求稳定性 12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 对数组的left至right这部分进行排序 * @param nums * @param left * @param right */public static void sort(int[] nums, int left, int right)&#123; if(left == right) return; int mid = left + (right - left)/2;//防止整型溢出 sort(nums, left, mid);//对数组的左半部分排序 sort(nums, mid+1, right);//对数组的右半部分排序 merge(nums, left, mid+1, right);//合并数组的两半部分&#125;/** * 合并数组的任意两半部分（均有序的情况下） * @param nums */private static void merge(int[] nums, int left, int mid, int right)&#123; int[] result = new int[right - left + 1]; int i = left, j = mid; int k = 0; while(i &lt; mid &amp;&amp; j &lt;= right)&#123; if(nums[i] &lt;= nums[j])&#123; result[k++] = nums[i++]; &#125;else result[k++] = nums[j++]; &#125; while(i &lt; mid)&#123; result[k++] = nums[i++]; &#125; while(j &lt;= right)&#123; result[k++] = nums[j++]; &#125; k = 0; for(i = left; i &lt;= right; i++)&#123; nums[i] = result[k++]; &#125;&#125; 快速排序Java基础类型数据排序使用双轴快排 1234567891011121314151617181920212223242526272829public static void sort(int[] nums, int leftBound, int rightBound)&#123; if(leftBound &gt;= rightBound) return; int pivotIndex = partition(nums, leftBound, rightBound);//得到每一次划分后轴的位置 sort(nums, leftBound, pivotIndex-1);//对轴左边的部分继续进行划分 sort(nums, pivotIndex+1, rightBound);//对轴右边的部分进行划分 &#125; /** * 一次划分将小于轴的数放在其左边，大于轴的数放在其右边 * @param nums * @param leftBound * @param rightBound * @return pivotIndex(轴的位置) */ private static int partition(int[] nums, int leftBound, int rightBound)&#123; int pivot = nums[rightBound];//将右边界的数定义为轴 int left = leftBound, right = rightBound - 1; while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &lt;= pivot) left++;//从左往右找到第一个比轴大的数 while(left &lt;= right &amp;&amp; nums[right] &gt; pivot) right--;//从右往左找到第一个比轴小的数 if(left &lt; right) swap(nums, left, right);//交换 &#125; swap(nums, left, rightBound);//交换nums[left]与轴则完成一次划分 return left; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"双指针","slug":"双指针","date":"2020-02-09T11:05:21.000Z","updated":"2020-09-07T11:35:01.457Z","comments":true,"path":"面试刷题/双指针/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"升序数组的TwoSum:167 1234567891011121314class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers == null) return null; int start = 0, end = numbers.length - 1; while(start &lt; end)&#123; if(numbers[start] + numbers[end] == target)&#123; return new int[]&#123;start+1, end+1&#125;; &#125; else if(numbers[start] + numbers[end] &lt; target)&#123; start++; &#125; else end--; &#125; return null; &#125;&#125; 判断某个数是否为平方数之和：633 12345678910111213class Solution &#123; public boolean judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int start = 0, end = (int)Math.sqrt(c); while(start &lt;= end)&#123; int squareSum = start*start + end*end; if(squareSum == c) return true; else if(squareSum &lt; c) start++; else end--; &#125; return false; &#125;&#125; 反转字符串中的元音字母：345 123456789101112131415161718192021222324class Solution &#123; public String reverseVowels(String s) &#123; HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); int start = 0, end = s.length() - 1; char[] result = new char[s.length()]; while(start &lt;= end)&#123; char startC = s.charAt(start); char endC = s.charAt(end); if(!vowels.contains(startC))&#123; result[start++] = startC; &#125; else if(!vowels.contains(endC))&#123; result[end--] = endC; &#125; else &#123; result[start++] = endC; result[end--] = startC; &#125; &#125; return new String(result); &#125;&#125; 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串:680 1234567891011121314151617181920212223class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0, right = s.length() - 1; while(left &lt;= right)&#123; if(s.charAt(left) == s.charAt(right))&#123; left++; right--; &#125;else return isPalindrome(s, left+1, right) || isPalindrome(s, left, right-1);//如果左右不对称，则判断删除s.charAt(left)或者s.charAt(right)后的子字符串是否为回文串 &#125; return true; &#125; private boolean isPalindrome(String s, int left, int right)&#123; while(left &lt;= right)&#123; if(s.charAt(left) != s.charAt(right)) return false; else &#123; left++; right--; &#125; &#125; return true; &#125;&#125; 合并两个有序数组：88 12345678910111213141516class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1, j = n - 1; int k = m+n-1; while(i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(nums2[j] &gt; nums1[i]) nums1[k--] = nums2[j--]; else nums1[k--] = nums1[i--]; &#125;//从两个数组尾部开始比较大小 //将剩余的某个数组中未比较的元素写入nums1 while(i &gt;= 0) nums1[k--] = nums1[i--]; while(j &gt;= 0) nums1[k--] = nums2[j--]; &#125;&#125; 判断链表中是否有环：141（快慢指针） 12345678910111213public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(slow != null &amp;&amp; fast!= null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(fast == slow) return true; &#125; return false; &#125;&#125; 通过删除字母匹配到字典里最长单词：524 1234567891011121314151617181920212223242526272829class Solution &#123; public String findLongestWord(String s, List&lt;String&gt; d) &#123; String result = \"\"; int maxLength = 0; for(String target : d)&#123; int targetLen = target.length(); if(isSubStr(s, target))&#123; if(maxLength &lt; targetLen)&#123; maxLength = targetLen; result = target; &#125;else if(maxLength == targetLen)&#123; if(result.compareTo(target) &lt; 0) continue;//比较字符串之间的字典顺序使用compareTo方法 else result = target; &#125; &#125; &#125; return result; &#125; private boolean isSubStr(String s, String target)&#123; int i = 0, j = 0; //遍历字符串s,每匹配一个target的字符j加1 while(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123; if(s.charAt(i) == target.charAt(j)) j++; i++; &#125; return j == target.length();//若j等于target.length(),说明target是s的一部分 &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"进程管理","slug":"进程管理","date":"2019-12-09T05:54:57.000Z","updated":"2020-09-07T11:35:29.949Z","comments":true,"path":"Linux/进程管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"进程管理工具 lscpu：显示cpu信息 pstree -p：打印进程树 ps：(process state)，Linux系统各进程的相关信息均保存在/proc/PID下 BSD选项，选项前没有-： a：打印所有终端中的进程 STAT： x：与终端无关的进程，例如守护进程 u：额外显示进程的USER，CPU/MEM占比，RSS（常驻内存集，不包括交换分区）与VSZ（分配给进程的虚拟内存，包括交换分区），START（开始运行的时间）。 f：显示进程父子关系 k -%cpu：倒序排序显示cpu占比，-表示倒序 o：只显示某些选项，后面跟要显示的选项；例如ps axo psr：显示命令使用哪个CPU核 Linux优先级：o ni,pri,rtprio 搜索进程 按预定义的模式：pgrep [options] pattern： -u uid：有效用户 -U uid：运行命令者 -t terminal：与指定终端相关的进程 -l：显示进程名，例如pgrep -l &#39;^ba.*&#39; -a：显示完整格式的进程名 -P pid：显示指定进程的子进程 按程序名称: pidof 程序名 进程管理工具：top，内置命令： 排序：P：按%CPU；M：按%MEM；T：按累积占据CPU时长(TIME+) 首部信息显示： uptime信息：l tasks及cpu信息：t cpu内核分别显示：1 内存信息：m 退出：q 修改刷新时间间隔：s 终止进程：k 保存当前进程信息：W 栏位信息： us：用户空间 sy：内核空间 ni：调整nice时间 id：空闲 wa：等待IO时间 hi：硬中断 si：软中断 st：虚拟机偷走的时间 选项： -b：显示所有进程（默认只显示前一部分） -p：指定显示某些进程 -H：线程模式；示例：top -H -p PID，指定显示某个进程的所有线程 EPEL源的htop，功能更丰富的进程管理工具 内存空间使用状态：free -h：易读格式 -s n：指定刷新间隔为n秒 查看虚拟内存使用状态：vmstat 系统监控工具： iostat：统计CPU和设备IO信息 iftop：显示带宽使用情况，EPEL源 dstat：替代iostat,vmstat,ifstat iotop：I/O监视器 nload：查看网络实时吞吐量 lsof：list open files；恢复文件： 进程信号与计划任务实现","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"磁盘管理","slug":"磁盘管理","date":"2019-11-29T07:26:51.000Z","updated":"2020-09-07T11:36:26.810Z","comments":true,"path":"Linux/磁盘管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"磁盘工作原理 不同硬盘标识：a-z，aa，ab… ​ /dev/sda，/dev/sdb 同一磁盘的不同分区：1，2，… ​ /dev/sda1，/dev/sda2，… 磁盘存储术语：head(磁头)，track(磁道)，cylinder(柱面)，sector(扇区) 磁盘使用步骤：磁盘分区 -&gt; 分区上创建文件系统 -&gt; 将分区挂载到目录 分区管理 分区原因 隔离系统和程序，可安装多个OS 采用不同文件系统 优化I/O性能 实现磁盘空间配额限制 提高修复速度 MBR分区管理 分区不超过2T 一块硬盘最多有4个主分区，也可以3主分区+1扩展分区（扩展分区包含N给逻辑分区） MBR分区结构： GPT分区管理 支持128个分区，分区可达ZB级别 GPT分区结构 分区管理命令 列出块设备：lsblk 查看块设备的UUID（通用唯一识别码）：blkid 创建分区： 创建MBR分区：fdisk fdisk -l查看当前分区情况 fdisk [device]，管理分区，常用子命令： p：分区列表 t：更改分区ID（输入L查询，不同的ID标识分区的类型） n：创建新分区 d：删除分区 v：校验分区 u：转换单位 w：保存退出 q：不保存退出 fdisk实时更改硬盘的分区，分区完成后注意与内存分区表同步（partprobe），查看内核是否已经识别新的分区cat /proc/partitions。 创建GPT分区：gdisk，用法与fdisk相似 高级分区操作：parted parted命令操作都是实时生效，需谨慎操作 parted /dev/sdb mklabel gpt：设置/dev/sdb这块磁盘为gpt类型 parted /dev/sdb print：打印/dev/sdb的分区信息 parted /dev/sdb mkpart primary 1 200：设置一个分区，从1MB到200MB，大小为199MB（注意分区需是连续空间） parted /dev/sdb rm 1：删除第一个分区 parted -l：列出所有硬盘的分区信息 重新设置内存中的内核分区表版本：partprobe 文件系统管理 查看当前OS支持的文件系统：cat /proc/filesystems 创建文件系统：mkfs -t [type] [device]：例如mkfs -t xfs /dev/sdb2，若要创建swap类型，使用mkswap /dev/xxx命令 管理文件系统： tune2fs：重新设定ext系列文件系统参数的值 -l：查看指定文件系统superblock信息 -L &#39;LABEL&#39;：修改卷标 -O：文件系统属性的启用或禁用 dumpe2fs：显示ext文件系统信息，将磁盘块分组管理 xfs_info 挂载点：显示已挂载的xfs文件系统信息 文件系统检测和修复： 文件系统故障常发生于死机或非正常关机后，注意一定要取消挂载后执行修复命令 fsck 、e2fsck、xfs_repair 常用工具： df：查看文件系统和磁盘空间使用情况，常用选项-T,-h du -h /xxx/yyy：查看某目录总体空间占用状态，--max-depth=3指定最大目录层级为3 dd：convert and copy a file 用法：dd if=/x/y of=/a/b bs=# count=# if=/x/y：从指定文件读取 of=/a/b：写入到指定文件 ibs=size：一次读size个字节 obs=size：一次写size个字节 bs=size：block size，指定块大小(既是ibs也是obs) cbs=size：一次转换size个字节 skip=blocks：从开头忽略blocks个ibs大小的块，只复制之后的内容 seek=blocks：从开头忽略blocks个obs大小的块，用if中复制的内容替换blocks个obs大小的块之后的内容。 count=n：复制n个bs 备份： dd if=/dev/sdx of=/dev/sdy：整盘备份到另一磁盘 dd if=/dev/sdx of=/xxx/image：整盘备份到文件 dd if=/dev/sdx | gzip &gt; /xxx/image.gz：整盘备份并压缩 恢复： dd if=/xxx/image of=/dev/sdx gzip -dc /xxx/image.gz | dd of=/dev/sdx 挂载设备 将分区挂载到目录，则该目录下的文件都存储于该分区中；若有其他分区挂载在该目录的子目录下，则子目录下的文件存储与另一分区中。 挂载点下原有文件在挂载完成后会被临时隐藏，因此挂载点目录一般为空。 一个分区可以同时挂载在多个目录下，一个目录只能与一个分区关联 实现永久挂载需要写入配置文件/etc/fstab，使用blkid查看UUID（也可使用设备分区名例如/dev/sda2）并按格式写入配置文件；若需要更改挂载点所属文件系统属性（是否启用acl，suid，exec等），亦可在该配置文件中更改，默认为defaults，然后mount -o remount /dev/xxx重新挂载使更改生效 swap的挂载：写入/etc/fstab，挂载点和文件系统均为swap，保存退出后键入swapon -a;swapoff命令取消交换分区。 mount /dev/sda2 /mnt：将分区sda2挂载在/mnt目录下 -r：只读挂载 -w：读写挂载，默认 mount -B 目录1 目录2：类似与软连接的效果，两个目录的文件共享。 -o options：挂载文件系统的选项 umount /mnt：取消挂载 cat /etc/mtab：查看目前的挂载情况 查看挂载情况：findmnt 挂载点/设备分区 查看正在访问指定挂载点的进程：lsof 挂载点、fuser -v 挂载点 终止所有正在访问指定挂载点的进程：fuser -km 挂载点 外围设备使用 使用光盘： 手动挂载：mount /dev/cdrom /mnt 操作光盘：eject弹出光盘；eject -t弹入光盘 创建ISO文件：cp /dev/cdrom /root/xxx.iso；mkisofs -r -o ./xxx.iso /etc… 挂载USB介质： 查看USB设备是否识别：lsusb 被内核探测为SCSI设备：/dev/sdaX、/dev/sdbX或类似的设备文件 手动挂载：mount /dev/sdbX /mnt 管理虚拟内存 swap交换分区是系统内存的补充，支持虚拟内存，当没有足够的内存保存系统处理的数据时会将数据写入swap分区 推荐系统swap空间 | 系统RAM | 推荐的swap空间 | 允许机器休眠的swap建议 || :————: | :——————: | :——————————: || 低于2GB | RAM的倍数 | RAM的三倍 || 2GB - 8GB | 等于RAM | RAM的倍数 || 8GB - 64GB | 8GB | RAM的1.5倍 || &gt; 64GB | 16GB | 不建议使用休眠功能 | free：查看内存使用情况 RAID管理 RAID：Redundant Arrays of Independent Disks（独立冗余磁盘阵列） 提高IO能力：磁盘并行读写 提高容错性 多块磁盘组织在一起工作 实现方式： 外接式：通过扩展卡提供适配能力 内接式：主板集成RAID控制器，安装OS前在BIOS里配置 软件RAID：软件实现 RAID级别： RAID-0：同一文件分块存储在多块硬盘上，读写性能提升，无容错能力 RAID-1：同一文件完全一样地存储于两块磁盘（镜像），读性能提升，写性能略有下降，有容错能力，磁盘利用率只有一半 RAID-5：读写性能提升，至少3块磁盘，有容错能力（允许最多1块磁盘损坏），每一块磁盘都划分一部分空间充当校验位 RAID-6：读写性能提升，至少4块磁盘，两个校验位，允许最多2块磁盘损坏，容错性较RAID-5高 RAID-10与RAID-01（实际使用RAID-10，RAID-10容错性较RAID-01好） RAID-50 RAID-7：自身带操作系统和管理工具，理论上性能最高的RAID模式 LVM（逻辑卷管理器） LVM：允许对卷进行方便操作的抽象层 将物理块设备指定为物理卷 用多个物理卷来创建一个卷组（物理卷是用固定大小的物理区域[PE,physical extent]来定义的） 从卷组中划分逻辑卷，可在逻辑卷上创建文件系统，逻辑卷大小可扩展。 示意图： 使用逻辑卷步骤： 将设备指定为物理卷，例如pvcreate /dev/sdb1 /dev/sdd或pvcreate /dev/sd{b1,d}，同时将分区和磁盘指定为物理卷。（如果是分区，需要将分区ID改为8e，表示Linux LVM类型） 用多个物理卷创建卷组，vgcreate [选项] vgName pv1 pv2 ...，例如vgcreate -s 16M vg0 /dev/sdb1 /dev/sdd，选项-s指定PE大小。 从卷组中划分逻辑卷，lvcreate -n mysql -L 8G vg0，-n指定逻辑卷名，-L指定大小，-l也是指定大小但是单位是PE个数。 ll /dev/vg0/mysql发现/dev/vg0/mysql为软链接，指向/dev/dm-0，其另一软链接为/dev/mapper/vg0-mysql，若继续创建逻辑卷，其真实设备名依次为/dev/dm-1、/dev/dm-2… 在逻辑卷上创建文件系统，mkfs.xfs /dev/vg0/mysql 挂载，mount /dev/vg0/mysql /mnt/mysql；将挂载写入配置文件/etc/fstab，在vim扩展命令模式下键入r!blkid /dev/vg0/mysql进行修改 列出现有的物理卷：pvs、pvdisplay 列出现有卷组：vgs、vgdisplay 列出现有逻辑卷：lvs、lvdisplay 扩展现有逻辑卷：lvextend -l +48%free /dev/vg0/mysql：剩余卷组的48%分配给逻辑卷，亦可使用PE数进行分配lvextend -l +200 /dev/vg0/mysql；此时使用lsblk或者fdisk -l查看已分配成功，但是df查看并未改变，还需要为新扩展的逻辑卷创建相同的文件系统 xfs：xfs_growfs 挂载点 ext：resize2fs 逻辑卷名（注意xfs与ext的区别） 亦可一次搞定（加上-r选项）：lvextend -r -l +xxx /dev/vg0/mysql 扩展现有的卷组：vgextend vg0 PV名 删除逻辑卷、卷组、物理卷：迁移数据 -&gt; umount /mnt/mysql -&gt; lvremove /dev/vg0/mysql -&gt; vgremove vg0 -&gt; pvremove /dev/sdb1 /dev/sdd LVM快照管理： 逻辑卷的快照需要与该逻辑卷在同一个卷组，且快照的容量小于等于逻辑卷 逻辑卷中每一个发生修改的文件都会备份到快照中 使用快照： lvcreate -n mysql_snapshot -s -L 1G /dev/vg0/mysql：创建逻辑卷mysql的快照，选项-s用于创建快照，快照上的文件系统与原逻辑卷相同 挂载快照到目录：mount -o nouuid /dev/vg0/mysql_snapshot /mnt/snap，由于快照的UUID与原逻辑卷一样，所以挂载时需要指定nouuid选项，不然挂载不上（xfs是这样，ext4不用） 还原快照到逻辑卷（逻辑卷恢复为快照）： umount /mnt/snap,umount /mnt/mysql：卸载快照和逻辑卷 lvconvert --merge /dev/vg0/mysql_snapshot：还原，此时快照已经删除 mount /dev/vg0/mysql /mnt/mysql：重新挂载","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Linux软件安装和包管理","slug":"Linux软件安装和包管理","date":"2019-11-25T04:47:01.000Z","updated":"2019-11-29T07:25:41.582Z","comments":true,"path":"Linux/Linux软件安装和包管理/","link":"","permalink":"http://thmasterplan.cn/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"","text":"软件运行环境 静态链接：libxxx.a，程序对应的依赖库复制到程序包，占用空间多,迁移容易，升级难，需重新编译。 动态链接：libxxx.so，只把依赖做一个动态链接，占用空间少。 ldd 命令：查看二进制程序所依赖的共享库文件。 ldconfig -p：查看本机已经缓存的所有可用库文件名及文件路径映射关系。 程序包的来源 管理程序包： 使用包管理器：rpm 使用前端工具：yum,dnf 获取程序包的途径：官方服务器，镜像站点，epel源（Extra Packages for Enterprise Linux） rpm包管理 rpm: redhat package manager，rpm包中是已经编译好的程序文件。 /var/lib/rpm/：数据库，其中包含了所有rpm包的名称及版本，依赖关系，功能说明，包安装后生成的各文件路径及校验码信息。 rpm -ivh [install-options] PACKAGE_FILES： -i：安装 -v：显示安装过程 -h：显示程序包管理执行进度 -q：查询包是否安装，与-l一起使用，列出包中的文件；与-f使用，查询文件的所属包；-a，查询所有安装的包 -e：卸载 -U：升级 -V：包校验 …其余查询man帮助 yum管理 YUM：Yellowdog Update Modifier，rpm的前端程序，基于C/S架构，可解决软件包相关依赖性，可在多个库之间定位软件包 配置yum源：/etc/yum.repos.d/路径下xxx.repo中配置源服务器路径，yum命令安装时，查询本地repo源 -&gt; 查询服务器端元数据 -&gt; 下载元数据到缓冲区 -&gt; 下载rpm包到缓冲区 -&gt; 按依赖顺序安装包。 使用本地光盘配置yum源 检查是否安装autofs(自动挂载服务) systemctl start autofs：启动 systemctl enable autofs：设置开机自启动 systemctl status autofs：查看服务状态 ls /misc/cd -&gt; df：光盘/dev/sr0已自动挂载到/misc/cd目录下 cd /etc/yum.repos.d/，将原有的国外源删除（备份），创建一个新的以.repo结尾的配置文件，例如创建base.repo,配置如下 1234[base]name&#x3D;cdrom basebaseurl&#x3D;file:&#x2F;&#x2F;&#x2F;misc&#x2F;cdgpgcheck&#x3D;0 yum repolist：查看可用的repo列表 网络源配置 可单独创建一个xxx.repo，也可在现有的repo中追加，例如在base.repo中追加 1234[epel]name&#x3D;aliyun epelbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;0 其中releasever变量代表当前OS发行版本，basearch代表cpu架构 yum clean all：清空yum源缓存 yum list：列出repo源所有包 yum install xxx：安装 yum remove xxx：删除 yum update pkgxxx yum info xxx：查看详细信息 定制yum仓库 使用httpd定制本地yum源 dnf管理 centos8之后默认安装 源码编译安装 首先使用wget URL下载好源码包 C/C++：make项目管理器 安装gcc 解压，进入到源码包目录中，运行./configure，通过选项传递参数指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile（安装前查看源码包中的说明帮助文档README、INSTALL等，亦可通过./configure --help查看可选项） make -j n根据Makefile文件，构建应用程序，j选项表示多线程并行编译。 make install 更改PATH Java：maven","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"压缩与解压缩","slug":"压缩与打包","date":"2019-11-23T00:43:05.000Z","updated":"2020-09-07T11:33:58.030Z","comments":true,"path":"Linux/压缩与打包/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/","excerpt":"","text":"一、压缩、解压缩工具 .Z后缀 compress：压缩后会删除原文件，可读取STDOUT内容进行压缩，支持管道 -c：结果输出至标准输出，不删除原文件。常见用法：compress -c file &gt; file.Z -v：显示详情 uncompress file.Z zcat file.Z：不显示解压缩的前提下查看文本文件内容 .gz后缀 gzip： -c：同compress -c -#：#取1-9，指定压缩比，值越大压缩比越大 gunzip file.gz zcat file.Z .bz2后缀 bzip2： -k： -#：默认为9 bunzip2 file.bz2 bzcat file.bz2 .xz xz： -k： -#：默认为6 unxz xzcat 一般来说压缩比：xz &gt; bzip2 &gt; gz &gt; compress，均不能压缩目录 .zip zip：支持压缩目录 unzip 二、打包(存档)和解包工具 tar常见用法：具体选项见man帮助 打包，保留权限：tar -cpvf xxx.tar file1 file2 file3... 追加文件至xxx.tar：tar -rf xxx.tar file1 file2..注：不支持对压缩文件追加 查看包中的文件列表：tar -tf xxx.tar 解包tar -xf xxx.tar [可选：-C /PATH] 结合压缩工具，打包并压缩： tar zcvf xxx.tar.gz [可选：/PATH]；.tar.gz也可写成.tgz tar jcvf xxx.tar.bz2 [可选：/PATH] tar Jcvf xxx.tar.xz [可选：/PATH] --eclude=/PATH/文件名：打包时排除某文件：tar -zcvf xxx.tgz --exclude=/a/b/abc.txt -T：指定打包列表；-X：指定排除列表 tar -zcvf xxx.tgz -T /a/list -X /a/excludeList split：分割一个文件为多份小文件 split -b SIZE xxx.tgz yyy：yyy为切割后的文件前缀，SIZE为每份大小 合并：cat yyy* &gt; xxx.tgz cpio：一种老的存档格式。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"文件查找工具","slug":"文件查找工具","date":"2019-11-22T07:44:54.000Z","updated":"2020-09-07T11:34:39.616Z","comments":true,"path":"Linux/文件查找工具/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"","text":"文件查找 在文件系统上查找符合条件的文件 非实时查找（数据库查找）：locate 查询系统上预建的文件索引数据库/var/lib/mlocate/mlocate.db 索引构建过程需要遍历整个根文件系统，极消耗资源 查找速度快，模糊查找，非实时，搜索的是文件的全路径，可手动更新updatedb 选项： -i：不区分大小写 -n N：只列举前N个匹配项目 -r：使用基本正则表达式 实时查找：find 通过遍历指定路径完成文件查找 查找速度略慢，精确，实时 语法：find [选项] [查找路径] [查找条件] [处理动作] 选项： -maxdepth level：最大搜索目录深度，指定目录下的文件为第1级 -mindepth level：最小搜索目录深度 -depth：先搜索文件，再搜索目录；不加该选项时默认为先搜目录再搜文件 查找路径：默认为当前目录 查找条件：可以查找文件名，大小，类型，权限等，默认为找出指定路径的所有文件 根据文件名和inode -name 文件名：支持文件通配符 -iname 文件名：不区分字母大小写 -inum n：按inode号查找 -samefile 文件名：相同inode号的文件 -links n：链接数为n的文件 -regex &#39;PATTERN&#39;：匹配整个文件路径而非文件名 根据owner,group -user 用户名 -group 组名 -uid UID -gid GID -nouser：比如某个用户被删除，但其文件还存在 -nogroup 根据文件类型 -type TYPE：TYPE包括f,d,l,s,b,c,p 空文件或目录：-empty，例如find /usr -type d -empty 根据文件大小 -size SIZE，常用单位k,M,G 对于SIZE的写法，-6k代表[0,5k]，6k代表(5k,6k]，+6k代表(6k,+∞) 根据时间 -atime/-mtime/-ctime -amin/-mmin/-cmin find ./ -mtime -3，代表[0,3）天内被修改，find ./ -mtime 3代表第3天被修改，find ./ -mtime +3代表被修改3天以上。 根据权限 -perm (/|-) MODE0配 MODE：精确权限匹配 /MODE：u,g,o中只要匹配到一个即可 -MODE：u,g,o必须同时满足指定权限 例如find ./ -perm -222指u,g,o均要有写权限才满足条件 不想搜索某目录时：使用-path &#39;目录&#39; -a -prune，例如find / -path &#39;/etc&#39; -a -prune -o -name passwd在根目录下除/etc外搜索文件名为passwd的文件。 组合条件：与：-a；或：-o；非：-not/!。即将以上各种条件组合使用查找。当需要使用括号时要转义。例如find /usr \\(-name &quot;f*&quot; -o -type f\\) -ls。 处理动作：对符合条件的文件做操作，默认输出至屏幕 -print：默认的处理动作，显示至屏幕 -ls：类似于对查找到的文件执行ls -l命令 -delete：删除查找到的文件 -fls file：查找到的所有文件的长格式信息保存至指定文件中。等价于-ls &gt; file -ok cmd {} \\;：对查找到的每个文件执行由cmd指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认 -exec cmd {} \\;：对查找到的每个文件执行由cmd指定的命令 {}用于引用查找到的文件名称自身，包含路径名。 xargs：cmd1 | xargs [选项] cmd2 xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。 xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。 xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。 之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令 具体选项见man帮助 举例：find linux-5.1.4/ -name &quot;*.c&quot; | xargs -n1 cat | wc -l统计出linux内核一共有多少行c代码；cat `find linux-5.1.4/ -name &quot;*.c&quot;`|wc -l实际运行更快。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-11-20T07:16:10.000Z","updated":"2020-09-07T11:33:43.881Z","comments":true,"path":"Linux/正则表达式/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"元字符分类：字符匹配、匹配次数、位置锚定、分组字符匹配 .：匹配任意单个字符 \\：转义字符，例如\\.表示匹配.本身而非任意单个字符。 []：匹配指定范围内任意单个字符 [^]：匹配指定范围外的任意单个字符 [:alnum:]：字母和数字 [:alpha:]：任何英文大小写字符 [:lower:]：小写字母 [:upper:]：大写字母 [:digit:]：十进制数字 [:xdigit:]：十六进制数字 [:blank:]：空白字符（空格和制表符） [:space:]：水平和垂直的空白字符 [:cntrl:]：不可打印的控制字符（退格、删除等） [:graph:]：可打印的非空白字符 [:print:]：可打印字符 [:punct:]：标点符号 匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数 *：匹配前面的字符0或多次。注意与文件名通配符里*的区别。 .*：任意长度的任意字符。 \\?：匹配前面的字符0或1次。 \\+：匹配前面的字符至少1次。 \\{n\\}：匹配前面的字符n次。 \\{m,n\\}：匹配前面的字符至少m次，至多n次。 \\{,n\\}：匹配前面的字符至多n次。 \\{n,\\}：匹配前面的字符至少n次。 位置锚定：定位出现的位置 ^：行首锚定，用于模式的最左侧。例如grep ^[^#] xxx表示显示xxx中所有非#开头的行，即显示非注释行。 $：行尾锚定，用于模式的最右侧。 ^PATTERN$：用于模式匹配整行。^$可表示空行。 \\b：词首或词尾锚定，用于单词模式的左/右侧。 分组：\\(\\) \\(string\\)：其中string会被正则表达式引擎记录与内部的变量中，这些变量的命名方式为：\\1,\\2,\\3,...。 示例：\\(string1\\(string2\\)\\)：\\1：string1\\(string2\\)；\\2：string2。 例如：\\(root\\)\\{1,3\\}：可匹配1-3个root字符串。 扩展的正则表达式： 去掉\\","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"常见文本处理命令","slug":"常见文本处理命令","date":"2019-11-19T11:49:20.000Z","updated":"2020-09-07T11:36:40.053Z","comments":true,"path":"Linux/常见文本处理命令/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%B8%B8%E8%A7%81%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看文本内容： cat：适合查看小文本 -E：显示行结束符$ -n：对显示的每一行编号 -A：显示所有控制符 tac：从最后一行向前反向显示 rev：每一行都是反向显示 more、less：分页查看 文本截取： head -c#：获取前#字节 -#：获取前#行 tail -c#：获取后#字节 -#：获取后#行 -f：可用于日志监控，例如tail -f /var/log/messages，即时显示日志追加文本的变化。 按列抽取： cut：cut -d# -f1,3：以#作为分隔符，截取第1列和第3列 -d：指明分隔符 -f：指明字段 练习：获取网卡ip地址：ifconfig ens33 | head -2 | tail -1 | tr -s &quot; &quot; | cut -d&quot; &quot; -f3 排序和统计： 文本排序sort：把排序后的文本显示在STDOUT，不改变原始文件 -n：按照数字大小排序 -r：反向排序 -u：删除重复行 -t#：#作为字段界定符 -kX：选项按照使用#分隔的第X列来排序 uniq：删除连续重复的行 -c：显示重复出现的行的次数，常与sort命令一起使用；sort a.txt| uniq -c。 文本数据统计wc： wc test.txt：依次输出行数，单词数，字节数 -l：只计数行数 -w：只计数单词数 -c：只计数字节数 -m：只计数字符总数 -L：显示文件中最长行的长度 比较文件：diff和patch 按关键字抽取： grep：grep [选项] 模式 file文本搜索工具，根据指定模式[由正则表达式字符及文本字符所编写的过滤条件]对目标文本逐行进行匹配检查，打印匹配到的行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Java位运算","slug":"Java位运算","date":"2019-11-19T10:25:55.000Z","updated":"2020-09-07T11:38:44.833Z","comments":true,"path":"Java基础/Java位运算/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"Java位运算符 &amp; ：按位与。同时为1才为1，否则为0。 | ：按位或。有一个为1则为1。 ~ ：按位取反。例如3：补码：0b00000000000000000000000000000011。~3—&gt;得:0b11111111111111111111111111111100。(依旧为补码)。减一后取反得原码(原码-&gt;补码的逆运算)：0b1000000000000000000000000000100。故3取反后为-4。 ^ ：按位异或。不同为1，相同为0。 0与任何数字异或都等于它本身 一个数据对相同的数据异或两次，值不变,常应用于加密。即a^b^b == a。 使用异或实现两个变量值交换。a = a^b; b = a^b; a = a^b。 &lt;&lt; ：左移。左操作数乘以2的n次幂。n是右操作数，即左移的位数。右边空出两位补0，左边两位被挤掉。 &gt;&gt; ：右移。左操作数除以2的n次幂。n是右操作数，即右移的位数。左边空出两位用符号位填充，右边两位被挤掉。 例如：-32 &gt;&gt; 2 ：原码：10000000000000000000000000100000，反码：11111111111111111111111111011111，补码：11111111111111111111111111100000。右移后为：11111111111111111111111111111000。求得原码为：10000000000000000000000000001000。得-8。 &gt;&gt;&gt; ：无符号右移。左边空出的位置用0补全。例如-32 &gt;&gt;&gt; 2变成一个很大的正数。 位运算均针对补码进行。正数的符号位为0，原、反、补码均为其本身；负数的符号位为1，其反码为对原码除符号位其余所有位求反，补码为对反码+1。 对于有符号数，计算机中存储的是补码。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"网络安全总结","slug":"网络安全总结","date":"2019-11-19T10:21:36.000Z","updated":"2020-09-07T11:34:47.674Z","comments":true,"path":"Others/网络安全总结/","link":"","permalink":"http://thmasterplan.cn/Others/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"Security一、 介绍 网络安全五个特征： 保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。 完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。 可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需网络安全解决措施的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击； 可控性：对信息的传播及内容具有控制能力。 不可否认性：出现的安全问题时提供依据与手段。 安全机制: 加密机制 数字签名机制 访问控制机制 数据完整性机制 认证交换机制 通信业务流填充 路由控制 公证机制 普遍性安全机制 网络攻击方法: 被动攻击 主动攻击 物理临近攻击 内部人员攻击 软硬件装配攻击 二、 古典加密技术 代替密码：明文中的每个字符被替换成密文中的另一个字符 凯撒码 将明文转换为数字，使用加密函数E（m）=m+k(mod 26)得密文。解密函数D（c）=c-k(mod 26)。（只是字母简单的偏移） 维吉尼亚密码 密钥：一个字符串，对应一个数表 暴力破解需要26的k次方 代替密码特点： 单字母代换密码 ：明文中字母的出现频度、重复字母的模式和字母相互之间的结合模式等统计特性不变，安全性差。 多字母代替密码 ：字符块被成组加密 ，有利于抗击统计分析。 置换密码：又称换位密码（transposition cipher） ，并没有改变明文字母，只改变了这些字母的出现顺序。在对密文进行统计之后，易于判断该密文是否使用了置换密码加密方案。 Kerckhoffs假设：假定密码分析者知道对方所使用的密码系统，包括明文的统计特性，加密体制（操作方式、处理方法和加/解密算法）、密钥空间及其统计特性。但是，不知道密钥。在设计一个密码系统时，目标是在Kerckhoffs假设的前提下实现安全。 密码分析方法：尝试发现明文或密钥的过程 唯密文攻击：知道部分密文试图恢复明文，并试图推算密钥 已知明文攻击：知道部分消息密文及对应明文，试图推导密钥或算法 选择明文攻击：事先选择部分明文让被攻击者加密，并得到相应密文，试图推导出密钥或算法。 选择密文攻击：密码分析者需要掌握的内容包括：加密算法、截获的部分密文、自己选择的密文消息以及相应的被解密的明文。密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。由此能够计算出加密者的私钥或者分解模数，运用这些信息，攻击者可以恢复所有的明文。 维吉尼亚密码的密码分析 字母频率统计用于猜测 Kasiski测试法确定密钥长度 重合指数法破译密文 三、 对称加密 分组密码的设计原则 混乱原则：密码设计应保证明文与密文之间的依赖关系足够复杂。 扩散原则：密码设计应保证密钥的每位数字能够影响密文中的多位数字（避免对密钥逐段破译），同时应保证明文的每位数字能够影响密文中的多位数字（隐藏明文的统计特性）。 分组密码特点 优点：易于标准化，易于实现同步 缺点：不善于隐藏明文的数据模式，对于重放、插入、删除等攻击方式的抵御能力不强。 对称加密算法：DES/AES 分组密码工作模式 ECB（Electronic Codebook）: 电码本 用相同的密钥分别对明文分组独立加密 对长明文不安全，因为重复的明文块在密文中也是重复的 CBC（Cipher Block Chaining）：密文分组链接 加密算法的输入是上一个密文组和下一个明文组的异或 优点：能够隐蔽明文的数据模式；能够一定程度上防止分组的重放、插入和删除攻击。 缺点：易导致错误传播。任意一个明文或密文组出错会导致其后的密文分组出错。 CFB（Cipher Feedback）:密文反馈 一次处理s位（明文和密文均是），加密算法的输入是上一块密文，加密后产生的伪随机数输出与明文异或作为下一单元的密文。 实质是一种自同步流密码 适用于必须按比特或字符对明文进行加密的情况 OFB（Output Feedback）：输出反馈 与CFB类似，只是加密算法的输入是上一次加密算法的输出，且使用整个分组 优点：能够克服错误传播 缺点：很难发现密文被篡改；不具备自同步能力 CTR计数器 每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增 并行加密效率高 分组密码典型攻击方法 依据攻击者所掌握的信息：唯密文攻击、已知明文攻击、选择明文攻击 根据采用的技术方法 强力攻击（适用于任何分组密码算法）：穷尽密钥搜索、字典、查表、时间-存储权衡 差分密码分析 线性密码分析 差分-线性密码分析 攻击复杂度：数据复杂度（实施攻击所需输入的数据量）和处理复杂度（处理数据所需的计算量）。 对称密钥编码问题：通信密钥太多，管理与分发困难 四、 公钥加密 RSA原理 计算：(a x b) mod n = [(a mod n) x (b mod n)] mod n. RSA实现上的问题在构造n时应选择p和q的长度相差不大 RSA适合低频少量数据交换，如密钥分发；不适合数据量大，实时性强的场合（因为运算量大，慢） 五、 消息鉴别 概念：消息接收者对消息进行验证（真实性：确认并非假冒）（完整性：内容未被篡改）。 网络通信安全威胁：泄露、伪造、篡改、行为抵赖 鉴别与保密：鉴别不能自动提供保密性，保密性不能自动提供鉴别功能。 报文鉴别系统功能：鉴别算法（鉴别函数f产生鉴别码），鉴别协议，鉴别函数f是决定鉴别系统特性的主要因素。 鉴别函数分类： 以整个报文的密文作为鉴别符； 对称密钥加密：加密的同时提供保密和鉴别（强制明文具有某种结构） 附加报文鉴别结构：发送端：校验码C = f（M），密文X = Ek[M || C]; 接收端：Y = Dk(X) = [M’ || C’], 若f(M’) = C’,则报文可信。 公钥加密：提供报文鉴别和签名，不提供加密功能。 报文鉴别码(MAC)：核心是一个类似于加密的算法Ck()（k为密钥）, Ck(M)输出一个较短的定长数据分组也即MAC。发送[MAC || M]。接收端同样计算MAC，比较两个MAC是否相同。PS：MAC与加密函数比较：MAC可以是单向的，而加密函数必须可逆；MAC算法不能提供保密性。 散列函数方式（采用一个公共散列函数，将任意长度的报文映射为一个定长的散列值，并以散列值作为鉴别符）。（常用SHA-3，MD5）散列函数特性： 输入任意大小数据块，输出定长 容易计算 单向性：对任意散列值h要找到一个M使得H(M) = h不可行。 弱抗冲突性：对任意给定M，要找到M’ != M,使得H(M)=H(M’)计算上不可行。该性质可防止伪造。 强抗冲突性：要找到两报文M和N使他们散列值相同不可行。该性质指出散列函数对“生日攻击”的抵抗能力。 生日悖论攻击：伪造消息报文使hash值不变 中间符合攻击概念 六、 密钥建立和管理 密钥建立的模式：点到点（通信双方直接通信，分布式）；密钥分配中心KDC（用户与KDC有共享主密钥，KDC生成并分配会话密钥，集中式）；密钥转换中心KTC（只负责转发，集中式） Diff-Hellman密钥交换 如图，双方都计算出密钥为2 公钥加密体制的密钥分配：公钥的分配；使用公钥体制来分配对称密钥密码体制的密钥。 伪随机数生成器:线性同余算法；基于密码算法的随机数生成器（循环加密方式，DES的OFB模式）；BBS生成器； 密钥控制技术：密钥标签（DES的64位密钥中的8个校验位作为控制使用这一密钥的标签）；控制矢量 七、 用户认证 身份认证：密码，令牌（磁条卡，存储卡，智能卡），生物识别（虹膜，视网膜，指纹，签名，声音，脸） 口令破解：字典攻击，密码猜测，彩虹表攻击（可见密码不能明文存储，要求哈希后加salt，盐：随机字符） 口令的脆弱性：离线字典攻击；特定账户攻击；流行密码的攻击；单个用户的密码猜测；工作站劫持；电子监控；利用用户失误 Bad Passwords:过短的密码；易猜测的密码 Countermeasures：阻止未经授权访问密码文件；入侵检测措施；帐户锁定机制；自动工作站注销；加密的网络链接 八、 身份认证协议 Kerberos身份认证协议：集中式的认证服务器结构，认证服务器的功能是实现用户与其访问的服务器间的相互鉴别；采用对称加密技术 数字签名：直接数字签名仅涉及通信双方 使用公钥算法进行数字签名 假定接收方知道发送方的公钥 发送方用私钥加密整个消息或者消息的散列码 接收方用公钥解密即可确认发送方的身份 公钥基础设施(PKI) 提供三种安全服务： 认证：身份认证，采用数字签名实现 完整性：数据完整性，采用数字签名或消息认证码 机密性：采用对称加密 包括：认证机构CA，证书库，证书撤销，密钥备份和恢复，自动密钥更新，密钥历史档案，交叉认证，时间戳… X.509认证服务： X.509协议实现基于公钥加密算法和数字签名技术 证书由CA创建，CA用其私钥对证书签名，用户可用CA的公钥验证证书有效性并提取被认证的用户的公钥 九、 互联网安全协议和标准 IPSec:提供认证、保密性、密钥管理。优点：在传输层下，因而对应用程序、用户透明；抵抗旁路攻击；保护路由架构… IPSec架构： IPv6强制，IPv4可选 安全关联SA： 发送方和接收方之间的单向的关系，为数据流提供安全保障 由三个参数定义：Security Parameters Index (SPI)；IP Destination Address；Security Protocol Identifier 有一个安全关联数据库（） SA管理： 创建：先协商SA参数，再更新SAD；可人工创建，也可动态创建 删除：有效期过期；密钥遭破坏；另一端要求删除该SA 认证头(AH)： 提供数据整合和IP包认证 有限地抗重播攻击 基于消息认证码（MAC） 重放攻击：攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。 抗重播服务： 序列号字段：创建一个新的SA时，发送者会将序列号计数器初始化为0； 每当在这一SA上发送一个数据包，序列号计数器的值就加1并将序列号字段设置成计数器的值； 当达到其最大值2³²-1时，就应建立一个新的SA。 一种滑动窗口机制：IP是无连接的、不可靠的 ，需设立窗口；窗口的最左端对应于窗口起始位置的数据包序列号N，则最右端对应于可以接收的合法分组的最高序号N+WindowSize-1 ESP:提供保密性和抗重播服务 密钥管理:密钥生成和分发；AH和ESP各一对密钥； 安全套接层SSL： SSL的两个重要概念： SSL连接： 一个连接是一个提供一种合适类型服务的传输 SSL连接是端对端的 连接是暂时的 SSL会话： 一个SSL会话是在客户端和服务器之间的一个关联 会话由Handshake Protocal创建。会话定义了一组可供多个连接共享的加密安全参数 会话用以：避免为每一个连接提供新的安全参数所需的昂贵的谈判代价 十、 Hacking 攻击思路：信息收集，获取权限，安装后门（木马），扩大影响（攻击该网络其他主机），清除痕迹 安全评估 TCSEC，CC 十一、 信息收集（选择题） Web与搜索引擎服务 目标：获取目标网络或公司的URL，获取目标网络的拓扑结构 扫描目的：查看目标网络中哪些主机是存活的，查看存活的主机运行了哪些服务，查看主机提供的服务有无漏洞 IP扫描：判断目标网络有多少台主机存活（ping）（ping使用ICMP协议） 端口扫描：判断目标主机有哪些端口是打开的(TCP端口和UDP端口)（端口是入侵的通道） TCP扫描：TCP Connect，SYN，FIN UDP扫描 漏洞扫描 操作系统类型探测 十二、 缓冲区溢出 缓冲区：应用程序保存用户输入数据，程序临时数据的内存空间。缓冲区本质：数组。位置：堆、栈、数据段 溢出：用户输入数据长度超出了程序为其分配的内存空间，这些数据会覆盖其他程序数据的内存空间。 危害：程序异常，系统崩溃，程序跳到恶意代码，控制权被窃 溢出种类：堆溢出、栈溢出、整型溢出、格式化字符串溢出、其他溢出 溢出的共性：大对象向小对象复制数据，容纳不下造成溢出 避免缓冲区溢出漏洞： 人编写正确的代码 编译器进行数组边界检查 使用类型安全语言 RunTime保护 操作系统 硬件 十三、 Web脚本攻击 SQL注入攻击 ：把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令。步骤 绕过认证：conditions：账号密码的查询是同一条查询语句；密码没有加密保护 判断能否进行SQL注入 判断数据库类型及注入方法 猜测表名和字段名 猜测用户名和密码 预防 过滤关键字 限制输入长度 秘密字段使用散列函数保护 XSS跨站脚本攻击：通过在链接中插入恶意代码就能盗取用户信息。 预防 对动态生成页面的字符进行编码 对输入进行过滤限制 对动态内容使用HTML和URL编码 设置浏览器不执行任何脚本下载 十四、 DOS攻击 概念：利用网络协议漏洞或其他系统以及应用软件的漏洞耗尽被攻击目标资源，使得被攻击目标无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式。 原理：攻击者向服务器发送众多的带有虚假地址的请求，服务器发送回复信息后无限等待进而无法释放资源，连接超时后攻击者再度发送虚假请求。 DOS分类：SYN Flood（请求方不发送ACK），ping of death（ping请求数据包声称超过64K，接收方TCP/IP堆栈崩溃），teardrop… 发现僵尸网络：IDS（提取僵尸程序指纹信息），行为监测（僵尸程序行为模式），蜜獾捕获（捕获僵尸程序样本） 十五、 恶意代码、病毒、蠕虫 计算机病毒：是一个指令序列，能够把自身拷贝插入到其他主程序中 病毒模块：引导、传染、表现 病毒按链接方式分类： 操作系统病毒：用自己的运行逻辑取代系统的正常逻辑模块 外壳型：将病毒本身包围在宿主程序周围，对原来程序不作修改 入侵型：将病毒插入攻击目标之中，一旦感染难以发现清除 源码病毒：利用java, VBS等网络语言编写放在e-mail附件或HTML主页中。 按传染对象分类：磁盘引导型（磁盘引导区），文件型（可执行文件），宏病毒（office系列） 检测病毒方法： 特征代码法：采样，提取特征代码，特征代码纳入病毒特征数据库，打开被检测文件检索，若出现新病毒重复1-3步 校验和法：在文件被感染前根据文件内容计算校验和保存在其他文件中。优点：既可发现已知病毒又可发现未知病毒；缺点：只能判断文件是否被修改，而不能识别病毒种类和名称，且对隐蔽性病毒无效。 行为监测法：利用病毒的特有行为来监测病毒的方法。 蠕虫：一种可以通过网络连接进行自身复制的程序，与以往病毒方式不同，文件型病毒、宏病毒需要在计算机的硬盘、软盘或文件系统中繁殖，而典型的蠕虫只会在内存中维持一个活动副本，甚至根本不向硬盘写入任何信息。 十六、 防火墙 概念：防火墙指应用于内部网络和外部网络之间的，用来保护内部网络免受非法访问和破坏的网络安全系统。 主要功能： 过滤进出网络的数据 防止不安全的协议和服务 管理进出网络的访问行为 记录通过防火墙的信息内容与活动 对网络攻击进行检测与告警 防止外部对内部网络信息的获取 提供与外部连接的集中管理 不能防范的攻击：内部威胁、病毒、应用程序漏洞、木马、社会工程、不当配置 防火墙分类：按实现技术（包过滤型（静态，动态），代理型（应用代理，电路代理，NAT））；按体系结构（双宿/多宿主机，屏蔽主机（双重保护安全性更高），屏蔽子网，混合结构）。 静态包过滤（传输层和网络层）：对包头内容进行简单过滤（源和目的IP，IP选项，IP上层协议，TCP和UDP源及目的端口，ICMP报文类型和代码）。 防火墙规则制定策略：a.拒绝任何访问，除非被规则特别允许。b.允许任何访问，除非规则特别禁止 过滤的两种基本方式：按服务过滤（如Telnet，SMTP，FTP等等）；按规则过滤。 静态包过滤的优缺点：速度快，价格低，对用户透明；配置难把握，防范能力低，没有用户身份验证机制。 动态包过滤（网络层）（状态检测防火墙）：不仅以一个数据包的内容作为过滤依据，还根据这个数据包在信息流位置加以判断 动态包过滤优缺点：基于应用程序信息验证一个包状态的能力，记录通过的每个包的详细信息；造成网络连接的迟滞，系统资源要求较高。 应用代理防火墙（应用层）：对所有规则内允许的应用程序作中转转发；牺牲了对应用程序的透明性。 应用代理优缺点：可以隐藏内部网络信息，具有强大的日志审核，实现内容过滤；价格高，速度慢，失效时造成网络瘫痪。 电路级代理（传输层）优缺点：隐藏内部网络信息，配置简单（无需为每个应用程序配置一个代理）；多数电路级网关都是基于TCP端口配置，不对数据包检测可能会有漏洞。 NAT优缺点：管理方便并且节约IP地址资源，隐藏内部IP地址信息；外部应用程序不能方便地与NAT网关后的应用程序联系。- 理解防火墙的四种体系结构 十七、 入侵检测IDS 由于防火墙无法发现和阻止:a.对合法服务的攻击。b.源自其他入口的攻击。c.来自内部网络的攻击。d.来自木马的威胁。入侵检测技术通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现网络或系统中是否有违反安全策略行为和被攻击迹象的一种安全技术。 IDS任务：从系统正常运行产生的和攻击者进行攻击时产生的混合数据中找出入侵痕迹。 通用入侵检测框架CIDF：体系结构；组件通信（事件产生器（数据获取）；事件分析器（数据分析）；事件数据库（数据管理）；响应单元（行为响应））；语言规范；编程接口。 小结：入侵检测技术收集主机日志及网络流量等信息，通过模式匹配、统计分析或完整性分析，能够有效发现入侵行为。入侵检测形成了网络的纵深防御，成为防火墙技术的有益补充。网络技术的发展给入侵检测带来各种新的困难，同时也带来机遇。","categories":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/tags/Others/"}]},{"title":"文件权限与用户组管理","slug":"文件权限与用户组管理","date":"2019-11-17T16:16:20.000Z","updated":"2020-09-07T11:34:14.104Z","comments":true,"path":"Linux/文件权限与用户组管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux的文件权限与用户组管理 文件权限：-rw-r--r-- 1 root root 4.0K 07-19 01:02 abc.log: 第1位： -：表示普通文件； d：目录 b：设备文件（块文件，即可以用来存储的设备文件） c：设备文件（字符文件，不能用来存储的设备文件） l：软链接（快捷方式） p：管道文件pipe s：套接字文件socket 后9位：r可读，w可写，x可执行。 2-4位：用户的权限范围 5-7位：组的权限范围 8-10位：其余人的权限范围 1表示该文件的硬链接数 第一个root表示该文件的所有者 第二个root表示该文件所属的组 4.0K表示该文件的大小 后面为最后一次修改的时间戳和文件名 r/w/x权限对于目录的意义： r权限：可读取目录结构列表，即可查看目录下的文件名和子目录名。[注：不能查看文件内容] w权限：可创建文件和目录，可删除，可重命名，可转移 x权限：可进入该目录。 更改权限：chmod chmod u+x,g+w,o-r abc.log：abc.log权限由-rw-r--r--变为：-rwxrw---- chmod a=r file或者chmod +r file:表示对file的u,g,o同时都赋予可读权限 另一种更简单的权限赋予方式，令r = 4, w = 2, x = 1,则u,g,o的权限分别可用一个整数表示，例如chmod 741 file表示file的u,g,o权限为-rwxr----x 参数-R：R及recursive（递归）；chmod -R 741 directory，表示改变目录及目录下所有文件的权限为741。 更改文件的所有者：chown chown user file:将file的所有者改为user chown user.group file:将file的所有者改为user,同时更改其组为group chown -R user directory：若要更改目录的权限，则需要加-R才能将其里面所有内容的权限更改 更改文件的所有组：chgrp chgrp root file: 将file的所有组改为root Linux组的类别： 用户的主要组：用户必须属于一个且只有一个主组，组名同用户名，且仅包含用户自己。 用户的附加组：一个用户可属于0或多个附加组。 id 用户名：查看用户的uid、gid（主组）、groups的id。管理员root的uid和gid为0。 用户和组的配置文件： /etc/passwd：用户及其属性信息(名称、UID、主组ID)。 /etc/group：组及其属性信息。 /etc/shadow：用户密码及其相关属性。 /etc/gshadow：组密码及其相关信息。 用户、组的增删改： useradd，userdel，usermod groupadd，groupdel，groupmod /etc/default/useradd：创建用户时的默认设置 文件与目录的默认权限与隐藏权限 文件预设权限:在没有umask的情况下，目录默认权限为777，文件默认权限为666；umask 022，表示创建文件和目录，g和o都过滤掉写(2)权限。 lsattr -a:显示所有隐藏属性 chattr [-RV][-v][+/-/=&lt;属性&gt;] [文件或目录]: -R：递归处理，将指定目录下的所有文件及子目录一并处理 -v：&lt;版本编号&gt; 设置文件或目录版本 -V： 显示指令执行过程 +&lt;属性&gt;： 开启文件或目录的该项属性 -&lt;属性&gt; ：关闭文件或目录的该项属 =&lt;属性&gt;： 指定文件或目录的该项属性 属性： a：让文件或目录只能加数据。 i：不得任意更动文件或目录。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 例如chattr +a /var/log/messages:让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件 文件特殊权限 SUID（最常用）：chmod u+s file：使file文件x权限上显示为s，非用户(u)执行者可以获得u的所有权限 SUID权限仅对二进制程序有效，不能用在脚本和目录上 执行者对于该程序有x的可执行权限 SUID权限仅在执行程序的过程中有效 让本没有相应权限的用户运行该程序时，可以获得其原本没有权限访问的资源 SGID：非组(g)成员获得该组的权限 非组成员对于该程序需要具备x的权限 SGID主要用于目录, 在该目录下创建的任何文件及子目录属于该目录所拥有的组 。 SBIT: 目前只针对目录有效，切只能分配给其他人（o）;对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除，例如/tmp。 SUID/SGID/SBIT权限设置 ： 文字法 ：SUID: u+s ，SGID: g+s，SBIT: o+t 数字法：将原来的三位数扩展为四位数即可，SUID为4，SGID为2，SBIT为1，把它们放在权限数字的最开头。例如设置SUID，可以写成4777，设置SGID可以写成，2777* 。 ACL(Access Control List)实现灵活权限控制： setfacl -m u/g:用户名/组名:权限 file。例如setfacl -m u:Tom:rw abc.txt，即Tom对abc.txt具有r和w权限，若不给权限则权限写0。 setfacl -x u/g:用户名/组名 file：删除权限。 setfacl -R -b dir/：删除dir下所有的ACL权限。 getfacl file：显示file的ACL权限。 权限优先级：所有者&gt;ACL权限(用户&gt;组&gt;other) 权限与指令间的关系(在用户模式下) 用户能进入某目录：需要权限x 进入目录后能利用ls查阅:需要权限r 进入目录后能够创建文件和目录:需要权限w 用户在目录内打开读取文件： 目录需要权限x 文件需要权限r","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"文件链接","slug":"文件链接","date":"2019-11-17T16:15:31.000Z","updated":"2020-09-07T11:34:21.902Z","comments":true,"path":"Linux/文件链接/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/","excerpt":"","text":"文件链接 硬链接：一个inode号对应多个文件名，硬链接也即同一个文件使用了多个别名，由命令ln oldfile newfile创建。 文件有相同的inode和data block 只能对已存在的文件进行创建，链接计数加1 不能交叉文件系统进行硬链接的创建 不能对目录进行创建，只可对文件创建 删除一个硬链接文件并不影响其他有相同inode号的文件 软链接（符号链接）：软链接的data block中存放的内容是另一文件的路径名的指向。软链接有自己的inode号和data block。由命令ln -s oldfile newfile创建，其中oldfile的相对路径为相对于newfile的，而newfile的相对路径是相对于当前工作目录的。rm -rf a.link/删除的是链接指向的文件，而rm -rf a.link删除的才是链接。 软链接有自己的文件属性及权限 可对不存在的文件或目录创建软链接 软链接可交叉文件系统 软链接可对文件或目录创建 创建软链接时，链接计数不会增加 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"目录配置与文件目录管理","slug":"目录配置与文件目录管理","date":"2019-11-17T16:14:20.000Z","updated":"2020-09-07T11:35:16.850Z","comments":true,"path":"Linux/目录配置与文件目录管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录配置与文件目录管理 目录配置：可参考FHS标准 /bin:存放二进制文件，常用命令 /boot：系统启动项文件,内核 /dev:设备文件，硬盘等 /etc：配置文件 /home:用户家目录，每一个用户在/home下都有一个文件夹 /lib：链接库文件 /media：媒体自动挂载点，比如U盘，光盘等 /mnt：媒体挂载点，手动挂载 /opt：自定义软件安装处，默认安装处为/usr/local /root：超级用户目录 /sbin：存放系统管理员所能执行的命令 /tmp：临时文件 /usr：类似于二层根目录 /var:存放缓存，日志，数据库文件；该文件夹需要分配的空间较大，因此在磁盘分区时挂载在/var的分区要大一些。 /proc：内存中的进程信息 /sys：硬件相关信息 文件与目录管理 常用命令： cd ~:切换到home;cd -:切换到上一次所在目录 pwd：打印当前目录 basename 和 dirname：分别获取当前路径的文件名和目录名 touch xx:若xx不存在，则创建一个新文件xx。若xx存在，把xx的修改时间改为当前。 &gt; xx：若文件不存在，则创建一个空文件xx；若文件存在，则清空现有文件xx(可用于清空大文件)。 mkdir 目录名 目录名 目录名 ... mkdir -p test/{a,b,c}/{d,e}:递归创建目录，分别在a,b,c三个目录下创建d,e两个目录。 rmdir 目录名:只能删除空目录 rm -rf目录:删除目录下所有东西（慎用rm） cp [选项] /PATH1/xx /PATH2/yy:若yy是一个目录，则把文件xx拷贝到yy下；若yy不是一个目录，则把文件xx拷贝到PATH2目录下并重命名为yy。cp不能直接拷贝目录，需要加选项参数，cp -rfp /目录1 /目录2 == cp -a /目录1 /目录2：将目录1及其所有子目录及文件拷贝到目录2。参数：-r即递归，-f即强制,-p同时复制属性信息。 mv [选项] /PATH1/xx /PATH2/yy：若yy是一个目录，则把文件xx剪切到yy下；若yy不是一个目录，则把文件xx剪切到PATH2目录下并重命名为yy。例如mv xx yy:就是把xx重命名为yy。 rename .log .logabc *：重命名，把所有文件名中的.log改为.logabc 关于执行文件路径的变量：执行程序必须在其所在目录下才能执行，亦可使用绝对路径调用，若要直接敲命令就可以执行，则需要设置PATH，把命令所在目录添加在PATH后面。 文件的三个时间属性: atime:access time mtime:modify time ctime:change time 文件名规则： 文件名最长255字节 蓝色—&gt;目录；绿色—&gt;可执行文件；红色—&gt;压缩文件；浅蓝色—&gt;链接文件；黄色—&gt;设备文件；粉色—&gt;套接字文件；棕色—&gt;管道文件；灰色—&gt;其他文件 文件通配符： *：匹配0个或多个字符 ?：匹配任意一个字符 [1-5]：匹配字符1,2,3,4,5 [a-c]：匹配字符a、A、b、B、c(没有C)。 [A-C]：匹配A，b，B，c，C [^abcd]：匹配除abcd外的所有单个字母 文件内容查阅 cat 文件名:显示所有文件内容，适合查看小文件，参数-n显示行数。cat -n 文件名== nl 文件名。 tac：从最后一行显示，倒数显示。 more/less 文件名:按空格一屏一屏地显示，按回车一行一行地显示。同时在文档下方输入/字符串即可查找文档中的字符串。 head -n 21 文件名:查看文件的前21行 tail -n 21 文件名:查看文件的尾21行；参数-f,监测日志，实时监测日志的变化。 od:查看非文本文档，比如二进制文件。 命令与文件的查询： which -a 命令:在PATH路径中搜寻命令位置 whereis 命令:返回命令路径及其帮助文档的路径；参数-b只返回命令路径。 locate 字符串:在/var/lib/mlocate/mlocate.db中查询所有文件名中包含该字符串的文件并返回，该数据库每天定时更新，亦可通过updatedb更新。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"磁盘与文件系统简介","slug":"磁盘与文件系统简介","date":"2019-11-17T16:12:54.000Z","updated":"2020-09-07T11:36:19.405Z","comments":true,"path":"Linux/磁盘与文件系统简介/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux磁盘与文件系统简介(centOS7之后使用xfs，centOS6使用ext4) 文件系统特性 索引式文件系统：对于linux，文件的权限和属性放置到inode中，文件的实际数据放在data block中。 superblock:记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量,以及文件系统的格式与相关信息等。 inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。 block:实际记录文件的内容，若文件过大一般会占用多个block。 linux的EXT2 ext2文件系统示意图 data clock：ext2文件系统所支持的block大小有1K,2K和4K三种 | Block大小 | 1KB | 2KB | 4KB || :————————: | —— | ——- | —— || 最大单一文件限制 | 16GB | 256GB | 2TB || 最大文件系统总容量 | 2TB | 8TB | 16TB | 除非重新格式化，block的大小与数量在格式化完就不能再改变 每个blcok内最多只能放置一个文件的数据 若文件大于block,则一个文件占用多个block；若文件小于block，则该blcok的剩余容量就不能再被使用。 inode table:记录文件的权限，拥有者与群组，容量，建立、最近一次读取、更改的时间。。。 每个inode大小均为固定128字节（ext4和xfs可设定到256字节） 每个文件仅占用一个inode 系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合。 superblock：一般为1024字节 dumpe2fs：查询EXT系列superblock信息的指令 文件系统与目录树的关系 目录：当在linux下的文件系统建立一个目录时，文件系统会分配一个inode与至少一块block给该目录，其中inode记录该目录的相关权限和属性，并记录分配的那块block号码，而block则记录在这个目录下的文件名与该文件名占用的inode号；ls -i查询当前目录下文件的inode号码。 文件:在ext2建立一个文件时，ext2会分配一个inode和相对于该文件大小的block数量。 目录树:例如读取/etc/passwd过程:/的inode -&gt; /的block -&gt; etc/的inode -&gt; etc/的block -&gt; passwd的inode -&gt; passwd的block。 日志式文件系统 挂载点的意义：挂载点一定是目录，该目录为进入该文件系统的入口。 Linux VFS用于管理所有类型的filesystem","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"常用命令入门","slug":"常用命令入门","date":"2019-11-17T16:11:48.000Z","updated":"2020-09-07T11:36:33.317Z","comments":true,"path":"Linux/常用命令入门/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/","excerpt":"","text":"常用命令入门 Xwindow与命令行界面的切换：ctrl + alt + f1...f7，其中只有f7为图形化界面，启动图形化界面也可以用startx命令。 命令帮助： whatis 命令：列出命令的作用以及man帮助的章节。 命令 --help：命令用法 man 章节号 命令：命令更详细的用法 info 命令 man -k 字符串:查找所有包含该字符串的命令 help：列出所有的内部命令 常见命令与快捷键： ls -a/-l:列出当前目录所有文件；ls -l == ll;ls -d .*/：列出所有目录 date:获取当前日期 cal:获取日历 bc:进入计算器,scale = n,n表示计算的精度 [Tab]:命令、文件名、选项、参数补全，连续两次Tab键可列出所有选项 ctrl c:终止目前程序 ctrl d :等同于输入exit shift pageup/pagedown:翻页 nano:一个简单的文本编辑器 reboot/shutdown -r:重启；shutdown/poweroff:关机；shutdown -h 1:定时1分钟关机；shutdown -h 8:20:8:20关机 su -/su root：获取root权限 sync：将内存中的数据写入磁盘，防止丢失 clear:清屏 file 文件名:查看文件类型 tree:查询当前目录的树形结构,需要安装；选项-d只显示目录；选项-L显示指定层级；例如tree -d /boot -L 1。 passwd：更改密码 hostname：查看主机名；hostnamectl set-hostname 名字：更改主机名。 ls -l $(which passwd)：命令的嵌套执行，用$()表示。 修改提示符颜色:修改PS1变量的值，并保存在配置文件/etc/profile.d/env.sh中。 type 命令：查看命令类型，内部命令集成在shell中。 enable：查看所有内部命令；enable -n 命令:禁用内部命令 Hash缓存表:系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将该命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先查看hash表，存在则执行命令，不存在则去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率。 hash：显示hash缓存 将外部命令路径添加到/etc/profile文件的PATH=$PATH:/xxx/yy中，再用source /etc/profile即可在任意路径下使用该外部命令。 alias 别名 = &#39;常用命令&#39;：设立别名；在centos7中，需在/root/.bashrc中保存。 alias可列出所有别名。 命令执行优先级:别名&gt;内部命令&gt;外部命令hash表&gt;$PATH。 若别名与原命令同名，可通过\\命令名执行原命令。 编辑配置文件不会立即生效，可通过. 配置文件名使bash进程重新读取配置文件使编辑生效。 多个命令可以用;分开一起执行，一个长命令可以用\\分成多行。 echo：回显字符串；显示变量 单引号：单引号中的内容就是字符串 反向单引号：其中的内容命令和变量均能识别。例如：touch `date +%F`.log：创建以当前时间命名的文件。反向单引号等价于$()。 双引号：能识别变量不能识别命令 {}：打印重复字符串；例如touch file{1..10}：创建了10个文件分别为file1,file2,,,file10。 Alt 数字n:重复显示字符n次","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"标准IO和重定向","slug":"标准IO和重定向","date":"2019-11-17T16:09:31.000Z","updated":"2020-09-07T11:36:46.764Z","comments":true,"path":"Linux/标准IO和重定向/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%A0%87%E5%87%86IO%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"标准IO和重定向 三种I/O设备 标准输入(STDIN)：（文件描述符0） 默认接收来自键盘的输入 标准输出（STDOUT）：（文件描述符1） 默认输出到终端窗口 标准错误（STDERR）：（文件描述符2） 默认输出到终端窗口 I/O重定向至文件 标准输出重定向：&gt;；例如hostname &gt; /dev/pts/2将输出重定向至另一设备；若为文件，则清空文件再写入。&gt;&gt;则是追加，而不清空原文件；例如hostname &gt;&gt; /data/abc.log。 标准错误重定向：2&gt;；&gt;&gt;则是追加。 &amp;&gt;：标准输出和标准错误一起重定向。 标准输入重定向：&lt;；例如bc &lt; bc.txt，将bc.txt文件作为输入用bc计算。 tr [选项] set1 set2 ：将输入的文本中所有的s1替换为s2。· -d：删除所有属于set1的字符。 -s：把连续重复的字符以单独一个字符表示。 -t：把set1对应字符转换为set2对应字符。 cat &gt; abc.log：标准输入单行重定向到文件；cat &lt;&lt;EOF &gt;abc.log标准输入多行重定向至文件，输入EOF才写入文件。 使用管道 管道命令1 | 命令2 | 命令3 | ...：将命令1的STDOUT发送给命令2的STDIN，再将命令2的STDOUT发送给命令3的STDIN。。。 STDERR默认不能通过管道转发，可利用|&amp;实现。 管道线后面的命令在一个subbash中执行，执行完就退出该subbash。 例子：echo {1..100} | tr &#39; &#39; + | bc：计算1到100的和。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"VIM的简单使用","slug":"VIM的简单使用","date":"2019-11-17T16:08:02.000Z","updated":"2020-09-07T11:37:08.150Z","comments":true,"path":"Linux/VIM的简单使用/","link":"","permalink":"http://thmasterplan.cn/Linux/VIM%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"VIM：一个模式编辑器 三种主要模式： Normal（命令）模式：默认模式，可移动光标，剪切/粘贴文本。 -&gt; Insert模式：输入i,a,o,I,A,O任意一个； -&gt; extended command模式:输入:； h:左; l:右; j:下; k:上； )：下一句；(：上一句 }：下一段；{：上一段 ctrl d：向下翻半屏 ctrl u：向上翻半屏 /字符串：全文查找字符串 Insert(编辑)模式：可修改文本。 -&gt; Normal模式:ESC键； 扩展命令(extended command)模式：保存，退出等。 -&gt; Normal模式：ESC键； wq：存盘退出； q!：不存盘退出； w：临时保存，类似于win下的ctrl+s； r filename：将filename的文件内容读到当前文件中； w filename：将当前文件内容写入filename文件中； !命令：在不退出vim的情况下执行命令； r!命令：在不退出vim的情况下，将执行命令的结果写入当前文件。 set number：显示行号；输入数字再输入+或-则向下或向上跳相应行数。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]}]}