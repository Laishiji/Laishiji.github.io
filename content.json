{"meta":{"title":"TheMasterplan","subtitle":"TheMasterplan","description":"","author":"LSJ","url":"http://thmasterplan.cn","root":"/"},"pages":[{"title":"关于","date":"2019-12-17T13:22:12.529Z","updated":"2019-12-17T13:22:12.525Z","comments":false,"path":"about/index.html","permalink":"http://thmasterplan.cn/about/index.html","excerpt":"","text":"邮箱laishiji86@gmail.com githubhttps://github.com/Laishiji 联系方式QQ：991327409"},{"title":"分类","date":"2019-11-18T06:42:54.196Z","updated":"2019-11-18T06:42:54.196Z","comments":false,"path":"categories/index.html","permalink":"http://thmasterplan.cn/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2019-11-18T05:58:22.890Z","updated":"2019-11-18T05:58:22.890Z","comments":false,"path":"repository/index.html","permalink":"http://thmasterplan.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2019-11-19T10:40:54.593Z","updated":"2019-11-18T06:43:04.379Z","comments":false,"path":"tags/index.html","permalink":"http://thmasterplan.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"JDK动态代理","slug":"JDK动态代理","date":"2020-04-05T08:53:39.000Z","updated":"2020-04-05T17:38:15.118Z","comments":true,"path":"JavaWeb/JDK动态代理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"一个小需求引入静态代理 假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？ 12345678910public class Calculator&#123; public int add(int a, int b)&#123; return a+b; &#125; public int subtract(int a, int b)&#123; return a-b; &#125; //其余算数运算方法。。。&#125; 方案：直接在Calculator类每个方法前后插入日志代码。缺点： 直接修改源码，不符合开闭原则。应该对扩展开放，对修改关闭。 如果Calculator类有许多方法，修改量太大。 重复代码太多。 日志代码硬编码在代理类中，不利于后期维护。 静态代理实现日志打印 代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于在目标实现的基础上增加额外的功能操作，以满足自身的业务需求。 静态代理的实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。 静态代理实现日志打印： 将Calculator抽取为接口 1234public interface Calculator &#123; int add(int a, int b); int subtract(int a, int b);&#125; 目标对象实现类 1234567891011public class CalculatorImpl implements Calculator &#123; public int add(int a, int b) &#123; return a + b; &#125; public int subtract(int a, int b) &#123; return a - b; &#125; //其余算数运算方法。。。&#125; 代理对象实现类 1234567891011121314151617181920212223242526272829public class CalculatorProxy implements Calculator &#123; //代理对象内部维护一个目标对象引用 private Calculator target; //构造方法，传入目标对象 public CalculatorProxy(Calculator target) &#123; this.target = target; &#125; //调用目标对象的add，并在前后打印日志 @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法开始...&quot;); int result = target.add(a, b); System.out.println(&quot;add方法结束...&quot;); return result; &#125; //调用目标对象的subtract，并在前后打印日志 @Override public int subtract(int a, int b) &#123; System.out.println(&quot;subtract方法开始...&quot;); int result = target.subtract(a, b); System.out.println(&quot;subtract方法结束...&quot;); return result; &#125; //其余算数运算方法。。。&#125; 使用代理对象实现计算器并打印日志 1234567public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorProxy(new CalculatorImpl()); calculator.add(1, 2); calculator.subtract(2, 1); &#125;&#125; 静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。 静态代理的缺点： 代理者与委托者一一对应，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。 如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。 动态代理 我们的目标只是为了实现增强功能，如何才能不编写代理类，只提供接口和目标对象就直接得到代理对象呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。 Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了JVM动态生成的代理类的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。实际开发中采用newProxyInstance方法，直接返回代理对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; /** * 测试 * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Calculator calculatorProxy =(Calculator) getProxy(new CalculatorImpl()); calculatorProxy.add(1, 2); calculatorProxy.subtract(3, 2); &#125; /** * 传入目标对象，得到代理对象 * @param targetObj * @throws Exception */ private static Object getProxy(final Object targetObj) throws Exception &#123; //传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口 //proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象 Class&lt;?&gt; proxyClass = Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces()); //得到代理类（com.sun.proxy.$Proxy0）的构造器 Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class); //通过构造器创建代理对象 Object proxyObj = constructor.newInstance(new InvocationHandler()&#123; //在重写invoke方法中编写增强功能代码 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);//增强功能代码 Object result = method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);//增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; private static Object getProxy1(final Object targetObj) throws Exception &#123; Object proxyObj = Proxy.getProxyClass( targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces() ) .getConstructor(InvocationHandler.class) .newInstance(new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);//增强功能代码 Object result = method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);//增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; /** * 实际使用的方法newProxyInstance * @param target * @return * @throws Exception */ public static Object getProxy2(final Object target) throws Exception &#123; Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);//增强功能代码 Object result = method.invoke(target,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);//增强功能代码 return result; &#125; &#125;); return proxy; &#125;&#125; 使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。 mybatis Mapper以及springAOP都是通过动态代理实现。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"mybatisHelloWorld","slug":"mybatisHelloWorld","date":"2020-04-05T08:39:41.000Z","updated":"2020-04-05T08:40:46.856Z","comments":true,"path":"Java框架/mybatisHelloWorld/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/","excerpt":"","text":"概述 mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务），而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 MybatisHelloWorld 工程文件结构如图 创建Maven工程，配置pom.xml，插入： 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建实体类和DAO接口 实体类 1234567public class User &#123; private Integer id;//包装类默认为null private String lastName; private String email; private String gender; //getters and setters, toString...&#125; DAO接口 123public interface UserMapper &#123; public User getUserById(Integer id);&#125; 创建sql映射文件：UserMapper.xml 12345678910111213&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;&lt;mapper namespace=&quot;com.laishiji.mybatis.dao.UserMapper&quot;&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt; &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt; &lt;select id=&quot;getUserById&quot; resultType=&quot;com.laishiji.mybatis.bean.User&quot;&gt; select id, last_name lastName, gender,email from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：mybatisConfig.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;&lt;configuration&gt; &lt;environments default=&quot;development&quot;&gt; &lt;environment id=&quot;development&quot;&gt; &lt;transactionManager type=&quot;JDBC&quot;/&gt; &lt;dataSource type=&quot;POOLED&quot;&gt; &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt; &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt; &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt; &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mysql中建表 12345678910111213drop database if exists mybatis;create database mybatis default character set utf8;create table user( id int(11) primary key auto_increment, last_name varchar(255), gender char(1), email varchar(255))engine=innodb default charset=utf8;insert into user(id,last_name,gender,email) values (1,&apos;Tom&apos;,&apos;男&apos;,&apos;123@qq.com&apos;), (2,&apos;Jim&apos;,&apos;男&apos;,&apos;234@qq.com&apos;), (3,&apos;Lisa&apos;,&apos;女&apos;,&apos;324@qq.com&apos;); 创建测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.laishiji.mybatis;import com.laishiji.mybatis.bean.User;import com.laishiji.mybatis.dao.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;/** * SqlSession代表和数据库的一次会话，用完必须关闭； * SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量； * mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。 */public class MybatisTest &#123; @Test public void test() throws IOException &#123; String resource = &quot;mybatisConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); User user = session.selectOne(&quot;com.laishiji.mybatis.dao.UserMapper.getUserById&quot;,1); System.out.println(user); session.close(); &#125; /** * 接口式编程： * 原生：DAO类 ---&gt; DAOImpl实现类 * mybatis：xxxMapper接口 ---&gt; xxxMapper.xml * @throws IOException */ @Test public void test2() throws IOException &#123; String resource = &quot;mybatisConfig.xml&quot;; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession openSession = sqlSessionFactory.openSession(); //通过反射+动态代理获取接口的实现类对象 UserMapper mapper = openSession.getMapper(UserMapper.class); User user = mapper.getUserById(1); System.out.println(user); openSession.close(); &#125;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://thmasterplan.cn/tags/Mybatis/"}]},{"title":"Maven入门","slug":"Maven入门","date":"2020-04-05T03:18:27.000Z","updated":"2020-04-05T03:20:55.615Z","comments":true,"path":"Java框架/Maven入门/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/","excerpt":"","text":"Maven配置踩坑 修改本地仓库路径：找到conf目录下的settings.xml，添加&lt;localRepository&gt;PATH&lt;/localRepository&gt;，PATH即为仓库路径。 修改Maven云仓库为国内镜像站：同样在conf目录下的settings.xml下，找到&lt;mirrors&gt;标签，添加 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;!-- 改为阿里云镜像 --&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; Maven项目目录结构 项目对象模型（POM） POM详解：https://www.runoob.com/maven/maven-pom.html。 POM是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。 groupId：公司或者组织的唯一标志。 artifactId：项目的唯一ID。 Maven构建生命周期 clean -&gt; default(build) {validate -&gt; compile -&gt; test -&gt; package -&gt; verify -&gt; install -&gt; deploy } -&gt; site 依赖管理模型 Maven 通过读取项目文件（pom.xml），找出库文件之间的依赖关系并从仓库自动下载。 引入外部依赖：先在 src 文件夹下添加 lib 文件夹，然后将工程需要的 jar 文件复制到 lib 文件夹下。然后添加以下依赖到pom.xml： 1234567&lt;dependency&gt; &lt;groupId&gt;xxx&lt;/groupId&gt; &lt;artifactId&gt;xxx&lt;/artifactId&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;scope&gt;system&lt;/scope&gt; &lt;!--作用域--&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\yyy.jar&lt;/systemPath&gt; &lt;/dependency&gt;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://thmasterplan.cn/tags/Maven/"}]},{"title":"Filter_Listener","slug":"Filter-Listener","date":"2020-04-03T07:52:10.000Z","updated":"2020-04-03T14:29:23.154Z","comments":true,"path":"JavaWeb/Filter-Listener/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Filter-Listener/","excerpt":"","text":"Filter（过滤器） 概念：客户端访问服务器资源时，filter拦截请求，作特殊处理：登录验证、统一编码处理、敏感字符过滤等。 使用 实现javax.servlet.Filter接口 覆写init()/doFilter()/destroy()方法 doFilter()放行代码：filterChain.doFilter(servletRequest, servletResponse); 配置拦截路径 注解配置：@WebFilter(&quot;/path&quot;) web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;name&lt;/filter-name&gt; &lt;filter-class&gt;filterClassName&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;name&lt;/filter-name&gt; &lt;url-pattern&gt;/path&lt;/url-pattern&gt; &lt;!-- 拦截路径 --&gt;&lt;/filter-mapping&gt; filter的执行流程 客户端请求 -&gt; 经过filter -&gt; 执行doFilter()： 对request对象请求消息处理 -&gt; 放行 -&gt; (服务器servlet执行后响应) 对response对象的响应消息处理 filter的生命周期 init()：服务器启动后，创建filter对象，调用init()方法，只执行一次。用于加载资源。 doFilter()：每一次请求被拦截资源时，都会执行。 destroy()：服务器关闭，filter对象被销毁。正常关闭情况下，会执行destroy()方法。用于释放资源。 拦截方式配置，设置dispatcherTypes属性 注解方式 DispatcherType.REQUEST：默认值。浏览器直接请求资源时，才会执行filter。 DispatcherType.FORWARD：转发访问资源。 DispatcherType.INCLUDE：包含访问资源。 DispatcherType.ERROR：错误跳转资源。 DispatcherType.ASYNC：异步访问资源。 web.xml方式 添加&lt;dispatcher&gt; &lt;/dispatcher&gt;标签，标签中文本取上述取值即可。 过滤器链的执行顺序：filter1 -&gt; filter2… -&gt; 资源执行 -&gt;…filter2 -&gt; filter1。 注解配置：按照类名的字符串比较规则比较，值小的先执行。例如filterA与filterB，则filterA先执行。 web.xml配置：按照&lt;filter-mapping&gt;的定义顺序执行。 Listener(监听器) 概念：监听器就是一个实现了特定接口的普通Java程序，这个程序专门用于监听另一个Java对象的方法调用或者属性改变（事件）。当被监听对象发生上述事件后，监听器某个方法将立即被执行。 常用的监听器”6 + 2”： 6个常规监听器，对应JavaWeb三大域对象 ServletContext ServletContextListener(生命周期监听)，项目启动时，ServletContext创建后创建该接口的实现类对象。注：Spring框架的ContextLoaderListener类实现了该接口。 ServletContextAttributeListener(属性监听) HttpSession HttpSessionListener(生命周期监听)，只有在servlet中调用了request.getSession()方法且根据JSESSIONID找不到对应的session时才会创建新的session对象，触发监听。 HttpSessionAttributeListener(属性监听) ServletRequest ServletRequestListener(生命周期监听)，每一次请求都会创建request对象并触发监听，每一次请求结束都会销毁request对象并触发监听。 ServletRequestAttributeListener(属性监听) 生命周期监听：每当tomcat创建或销毁三大域对象时，都会被其对应的Listener察觉并调用其特定的方法。 属性监听：每当调用域对象的setAttribute()或getAttribute()，都会被对应的属性监听器察觉并调用其特定的方法。 2个感知监听 HttpSessionBindingListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口，其有两个方法valueBound()/valueUnbound，当该对象被绑定(存储)时，触发该对象的valueBound()方法；当该对象被session解绑时session.removeAttribute(&quot;key&quot;);时触发该对象的valueUnbound()方法。 HttpSessionActivationListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口。当该session即将被钝化(序列化)时，触发该监听器的sessionWillPassivate()方法；当该session活化时，触发该监听器的sessionDidActivate方法。 设计模式：观察者模式（待补充） javax.servlet.ServletContextListener接口：用于监听ServletContext对象的销毁与创建 void contextDestroyed(ServletContextEvent sce)：ServletContext对象被销毁之前会调用该方法。 void contextInitialized(ServletContextEvent sce)：ServletContext对象创建后会调用该方法，服务器启动后自动调用。 使用：实现接口 -&gt; 覆写方法 -&gt; 配置 web.xml配置 123&lt;listener&gt; &lt;listener-class&gt;监听器类名&lt;/listener-class&gt;&lt;/listener&gt; 注解配置：@WebListener","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Cookie_Session","slug":"Cookie-Session","date":"2020-04-01T12:55:36.000Z","updated":"2020-04-03T07:49:07.529Z","comments":true,"path":"JavaWeb/Cookie-Session/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Cookie-Session/","excerpt":"","text":"会话 会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一标识一个用户并记录其状态。由于HTTP协议是无状态的，也就是说浏览器的每一次请求都是独立的，服务器并不知道这个浏览器之前是否请求过，这才有了会话机制。 Cookie 概念：客户端会话技术，将数据保存到客户端。javax.servlet.http.Cookie(类)。 主要作用：避免多次登录验证，一次登录后服务器便使用cookie验证身份。cookie的作用就像是身份凭证。 使用 创建Cookie对象，绑定数据：new Cookie(String name, String value) 发送Cookie对象到客户端：response.addCookie(Cookie cookie) 获取Cookie，拿到数据： 12345678Cookie[] cookies = request.getCookies();if(cookies != null)&#123; for(Cookie c : cookies)&#123; String name = c.getName(); String val = c.getValue(); //.......... &#125;&#125; 原理 客户端发送请求-&gt; 服务器创建Cookie并发送到客户端 -&gt; http响应头增加Set-Cookie：name=value字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证 Tips 一次可以创建多个Cookie并发送 Cookie在浏览器中存活时间 默认情况下，浏览器关闭后Cookie数据销毁 持久化存储：cookie.setMaxAge(int seconds) 正数：将cookie数据写到硬盘的文件中，seconds时间之后文件被删除。 负数：默认值 0：删除已经存在于客户端的cookie数据 Tomcat8之后Cookie支持中文 Cookie共享问题 假设在一个Tomcat服务器中部署了多个web项目： 默认情况下不同web项目的cookie不能共享 cookie.setPath(String path)：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，可将path设置为”/“。 服务器集群共享Cookie： setDomain(String path)：设置一级域名 例如setDomain(&quot;.baidu.com&quot;)，则tieba.baidu.com和news.baidu.com中cookie可以共享 Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。javax.servlet.http.HttpSession（接口）。 主要作用 用于存储一次会话的多次请求的数据 可以存储任意类型、任意大小的数据 使用 获取session对象：HttpSession session = request.getSession(); 存储数据：session.setAttribute(&quot;name&quot;, Object); 获取数据：session.getAttribute(&quot;name&quot;); 原理：Session的实现依赖于Cookie，服务器通过Cookie确保多次请求获取的Session对象为同一个。 客户端发送请求-&gt; 创建Session对象，若没有Cookie，则http响应头增加Set-Cookie：JSESSIONID=sessionID字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证sessionID Tips 浏览器关闭，服务器不关闭，浏览器重启，两次获取的session对象是否相同？ 默认情况下不是。 为避免这种情况，可手动设置持久化存储JSESSIONID 123Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());cookie.setMaxAge(60*60);//持久化存储cookieresponse.addCookie(cookie); 浏览器不关闭，服务器关闭，服务器开启，两次获取的session对象是否相同？ 新对象地址与原对象不同 为避免服务器重启数据丢失，采用session的钝化和活化技术。 session钝化：在服务器正常关闭前，将session对象序列化到硬盘上 session活化：服务器启动后，将session文件转化为内存中的session对象，删除文件 Tomcat已经集成了钝化与活化技术，正常关闭tomcat后，会在work工作目录的项目文件夹下生成一个SESSIONS.ser文件 session钝化与活化不仅仅是服务器关闭时发生，当在线用户过多时，大量session对象存在于服务器内存中。为减轻服务器内存负担，当一个session长时间没有被访问，也会被序列号到磁盘上（注意session中存储的对象所在的类必须要实现序列化接口）。可在tomcat的conf/context.xml中配置。 session何时被销毁？ 服务器关闭 session对象调用invalidate()方法 session默认失效时间为30分钟(可在tomcat的conf/web.xml中配置) 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;/session-timeout&gt; &lt;/session-config&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Servlet","slug":"Servlet","date":"2020-04-01T08:10:10.000Z","updated":"2020-04-03T15:17:16.496Z","comments":true,"path":"JavaWeb/Servlet/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Servlet/","excerpt":"","text":"Servlet(Server applet) 用于处理请求与业务逻辑。 调用流程： 用户访问html页面，表单提交 xml文件url-pattern与url匹配，若符合Tomcat则加载servlet-class对应的class文件进内存（反射） 实例化Servlet（class.newInstance()）得到一个Servlet对象 调用service()方法，根据表单的method，在该方法中调用doGet或doPost方法 request对象获取参数，response对象返回数据 服务器通过http协议返回数据 Servlet生命周期： 实例化：无论访问多少次该Servlet，构造方法只执行一次，只存在一个对象（单实例） 注：多个用户同时访问时，可能存在线程安全问题。因此尽量不要在Servlet中定义成员变量。 初始化：在构造方法执行后，执行init()方法，无论访问多少次该Servlet，init()方法只执行一次。init()方法的参数ServletConfig对象实例，通过解析web.xml文件创建。 提供服务：tomcat创建req和resp对象，将这两个对象作为参数传递给service()，执行service()方法，在该方法中判断执行doGet()还是doPost() 销毁：当在server.xml的Context字段中配置了reloadable=”true”时，表示web应用有任何类型的更新都会自动重启，重启就会调用destroy()方法；tomcat服务器关闭时destroy()方法会被调用。 被回收：等待下一次GC回收 自启动：假如需要在tomacat一启动就执行一些初始化的代码，比如校验数据库的完整性。但是Servlet的生命周期是在用户访问对应路径开始的，这就需要Servlet自启动，执行init()方法中的业务代码：在web.xml中增加&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;，取值范围是1-99，数字表示启动顺序，数字越小启动的优先级越高。 注解配置（Servlet3.0后支持，不再需要web.xml配置文件） Servlet类上使用@WebServlet(&quot;/URI&quot;)配置 页面跳转： 服务端跳转forward(转发)：request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);,服务器内部访问success.html，并将其发送给浏览器。客户端只请求一次，服务器内部跳转。 客户端跳转redirect(重定向)：response.sendRedirect(&quot;fail.html&quot;);，发送一条消息给浏览器让其访问fail.html，浏览器访问，服务器获取fail.html发送给浏览器。客户端一共请求了两次。 Servlet映射器(Mapper)：每一个请求，对应的URL要交给哪一个Servlet处理，由Tomcat中的映射器Mapper类处理。 request对象：封装请求消息数据 获取参数： request.getParameter()：用于获取单值的参数request.getParameterValues()：用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap()：用于遍历所有的参数，并返回Map类型。 获取头信息： request.getHeader()：获取浏览器传递过来的头信息。request.getHeaderNames()：获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 服务端传参：request.setAttribute()与request.getAttribute() 设置编码：request.setCharacterEncoding(&quot;UTF-8&quot;); 常见方法： request.getRequestURL()：浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI()：浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString()：请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr()：浏览器所处于的客户机的IP地址request.getRemoteHost()：浏览器所处于的客户机的主机名request.getRemotePort()：浏览器所处于的客户机使用的网络端口request.getLocalAddr()：服务器的IP地址request.getLocalName()：服务器的主机名request.getMethod()：得到客户机请求方式，一般是GET或者POST response对象：通过response对象设置响应消息数据 设置响应内容：response.getWriter()获取PrintWriter对象，使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。 设置响应格式与编码：response.setContentType(&quot;text/html;charset=utf-8&quot;)或response.setCharacterEncoding(&quot;UTF-8&quot;) ServletContext对象：服务器启动后自动创建，在整个Web应用的动态资源（Servlet/JSP…）之间共享数据，与servlet容器通信，服务器关闭时销毁。 通过request.getServletContext()或this.getServletContext()获取 获取MIME(text/html, image/jpeg…)类型数据：getMimeType(String file) 作为域对象共享数据：setAttribute() getAttribute() removeAttribute()，共享所有用户请求的数据 获取文件的真实路径：getRealPath(String file) ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序（对称） ServletContext -&gt; ServletContextListener -&gt; Filter -&gt; 自启动Servlet -&gt; 浏览器请求访问普通Servlet -&gt; 销毁自启动Servlet -&gt; 销毁Filter-&gt; 销毁ServletContextListener -&gt; 销毁ServletContext Listener, Filter, Servlet的实现类对象均是服务器通过反射创建。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"JSON","slug":"JSON","date":"2020-04-01T08:09:57.000Z","updated":"2020-04-01T08:11:33.597Z","comments":true,"path":"JavaWeb/JSON/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JSON/","excerpt":"","text":"JSON简介 概念：JavaScript对象表示法(JavaScript Object Notation)。 作用：JSON是存储和交换文本信息的语法，常用于信息传输，比XML更小、更快、更易解析。 语法 基本语法： 数据由键值对构成，值的取值类型有： 整数或浮点数 字符串：&quot;string&quot; 布尔值：true/false 数组：[] 对象：{name:&quot;Tom&quot;,age:23,gender:&quot;male&quot;} null 数据由,分隔 {}保存对象，同时也定义了JSON格式 []保存数组 获取数据方式：JSON对象.键名；JSON对象[“键名”]；数组对象[索引]。 JSON在Java中的解析 Java常用的JSON解析类库：GSON, FastJson, Jackson；以Jackson为例。 Java对象转JSON 123456789101112131415161718192021222324252627public class Person&#123; private String name; private int age; private String gender; //getter and setter&#125;public class JacksonTest&#123; //创建Java对象 Person p = new Person(); p.setName(&quot;Tom&quot;); p.setAge(23); p.setGender(&quot;男&quot;); //创建Jackson对象 ObjectMapper mapper = new ObjectMapper(); //转换方法： /* writeValue(args, obj): args: File:将obj对象转换为JSON字符串，并保存到指定文件； Writer:转换，并将json数据填充到字符输出流 OutputStream:转换，并将json数据填充到字节输出流 writeValueAsString(obj):将对象转换为json字符串 */ String json = mapper.writeValueAsString(p); &#125; 注解： @JsonIgnore：排除属性（该注解置于要忽略的属性上），指定属性不会被转换 @JsonFormat：属性值格式化（该注解置于要格式化的属性上），例@JsonFormat(pattern=&quot;yyyy-MM-dd&quot;) JSON转Java对象 123String json = &quot;&#123;name:\\&quot;Tom\\&quot;,age:23&#125;&quot;;ObjectMapper mapper = new ObjectMapper();Person p = mapper.readValue(json, Person.class);","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"XML","slug":"XML","date":"2020-03-30T14:00:41.000Z","updated":"2020-03-30T14:15:08.072Z","comments":true,"path":"JavaWeb/XML/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/XML/","excerpt":"","text":"概念扩展标记语言（Extensible Markup Language），标签可自定义。 功能 用于存储与传输数据 配置文件 在网络中传输 语法 基本语法： 第一行必须定义为文档声明，例如&lt;? xml version=&#39;1.0&#39; ?&gt;。 xml文档中有且仅有一个根标签 属性值必须用使用引号 标签必须正确关闭 标签名称严格区分大小写 例： 12345678910111213 &lt;?xml version=&apos;1.0&apos; ?&gt; &lt;users&gt; &lt;user id=&apos;1&apos;&gt; &lt;name&gt;Tom&lt;/name&gt; &lt;age&gt;23&lt;/age&gt; &lt;br/&gt; &lt;/user&gt; &lt;user id=&apos;2&apos;&gt; &lt;name&gt;Lisa&lt;/name&gt; &lt;age&gt;20&lt;/age&gt; &lt;/user&gt;&lt;/users&gt; 组成部分： 文档声明：&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt; 标签：自定义标签 属性：id属性值唯一 文本 XML命名空间（XML Namespaces）：提供避免元素命名冲突的方法，比如不同的两个XML被同时使用，且他们有一个相同的标签时，可通过命名空间避免冲突。 XML命名空间属性被放置于元素的开始标签中，语法为xmlns:namespace-prefix=&#39;namespaceURI&#39; 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联 约束 约束：规定xml文档的书写规则。一般来说，框架提供约束，框架使用者按照约束来编写xml。 DTD：简单的约束技术，文件后缀为.dtd &lt;!ELEMENT &gt;定义标签，&lt;!ATTLIST &gt;定义属性，()定义子标签 约束内容例： 123456&lt;!ELEMENT students (student*)&gt;&lt;!ELEMENT student (name,age,sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 引入dtd文档到xml中 内部dtd：将约束规则定义在xml文档中 &lt;!DOCTYPE 根标签名 [约束内容] &gt; 外部dtd：将约束规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的绝对路径&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;URL路径&quot;&gt; Schema：复杂的约束技术，本质上就是xml，文件后缀为.xsd 可定义xml中文本的类型，文本取值的范围，标签出现的顺序等 引入.xsd约束文件到xml 引入无命名空间的.xsd 1234567&lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation=&quot;无命名空间XSD文件的URI&quot;&gt;&lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，通过xsi命名空间下的属性noNamespaceSchemaLocation指定XSD文件的URI--&gt;&lt;/root&gt; 引入有命名空间的.xsd 1234567891011&lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:ns1=&quot;前缀ns1对应命名空间&quot; xmlns:ns2=&quot;前缀ns2对应命名空间&quot; xsi:schemaLocation=&quot;ns1前缀对应命名空间 前缀ns1对应命名空间XSD文件的URI ns2前缀对应命名空间 前缀ns2对应命名空间XSD文件的URI&quot;&gt; &lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，添加命名空间，可添加多个，但没有前缀的命名空间最多只能有1个 3.第三步，通过xsi命名空间下的属性schemaLocation指定每个命名空间XSD文件的URI，命名空间和相应URI一一对应，多个命名空间用空格分隔 --&gt; &lt;/root&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"动态规划入门","slug":"动态规划入门","date":"2020-03-28T13:38:15.000Z","updated":"2020-03-29T02:30:37.680Z","comments":true,"path":"面试刷题/动态规划入门/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和为Sum 例：lintcode114 123456789101112131415161718192021public class Solution &#123; /** * @param m: positive integer (1 &lt;= m &lt;= 100) * @param n: positive integer (1 &lt;= n &lt;= 100) * @return: An integer */ public int uniquePaths(int m, int n) &#123; // write your code here int[][] dp = new int[m][n];//dp[i][j]表示机器人有多少种方式从左上角走到(i,j) //dp[i][j] = dp[i-1][j]+dp[i][j-1] for(int i = 0; i &lt; m; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == 0 || j == 0) dp[i][j] = 1;//第0行(列)的所有格子都只有一种方式到达 else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 求最值 从左上角走到右下角路径的最大数字和 最长上升序列长度 例：lintcode669 1234567891011121314151617181920212223242526public class Solution &#123; /** * @param coins: a list of integer * @param amount: a total amount of money amount * @return: the fewest number of coins that you need to make up */ public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount+1];//记录组成从0-amount分别需要的最少的硬币数 dp[0] = 0; for(int i = 1; i &lt;= amount; ++i)&#123; dp[i] = Integer.MAX_VALUE;//表示不存在组成i所需要的最少硬币数,同时看作min变量，储存dp[i-coins[j]]+1,j=1,2...中的最小值 for(int j = 0; j &lt; coins.length; ++j)&#123; if(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != Integer.MAX_VALUE &amp;&amp; dp[i-coins[j]]+1 &lt; dp[i])&#123; dp[i] = dp[i-coins[j]] + 1;//组成总数为i需要的最少的硬币数为：组成总数为i-coins[j],j=1,2...coins.length需要的最少硬币数中最小的一个,再加1 &#125; &#125; &#125; if(dp[amount] == Integer.MAX_VALUE) return -1; else return dp[amount]; &#125; &#125; 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和为Sum 例：lintcode116 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; /** * @param A: A list of integers * @return: A boolean */ //动态规划 public boolean canJump(int[] A)&#123; if(A == null || A.length == 0) return false; int len = A.length; boolean[] dp = new boolean[len]; dp[0] = true; //思路:最后一步A[len-1]可达，当且仅当前面某个下标i可达且i+A[i]&gt;=A[len-1]；推广到对任意j = 1,2,...len-1，i &lt; j都必须满足dp[i] &amp;&amp; i + A[i] &gt;= j for(int j = 1; j &lt; len; ++j)&#123; dp[j] = false; for(int i = 0; i &lt; j; ++i)&#123; if(dp[i] &amp;&amp; i + A[i] &gt;= j)&#123;//状态方程：能够到达i，并且i+A[i]&gt;=j即表示从i能到达j dp[j] = true; break; &#125; &#125; &#125; return dp[len-1]; &#125; //贪心算法 public boolean canJumpGreedy(int[] A) &#123; //[3,2,1,0,4] if(A == null || A.length == 0) return false; int farthest = A[0];//farthest变量记录当前能够到达的最远距离 for(int i = 1; i &lt; A.length; ++i)&#123; if(farthest &lt; i) return false;//farthest比i小，表示不能到达i，return false else farthest = i + A[i] &gt; farthest ? i + A[i] : farthest;//更新farthest &#125; return true; &#125;&#125; 动态规划组成部分 确定状态：创建数组，数组的每个元素代表什么？ 两个要点 最后一步 子问题 递归算法的问题：重复计算，效率低下 转移方程：根据子问题定义得到。将计算结果保存下来，并改变计算顺序，空间换时间 初始条件和边界情况 计算顺序：利用之前的计算结果 常见动态规划类型 坐标型 序列型 划分型 区间型 背包型 最长序列型 博弈型","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"lintcode","slug":"lintcode","permalink":"http://thmasterplan.cn/tags/lintcode/"}]},{"title":"常量与反编译及助记符","slug":"常量与反编译及助记符","date":"2020-03-26T06:11:57.000Z","updated":"2020-03-26T06:13:58.910Z","comments":true,"path":"JVM/常量与反编译及助记符/","link":"","permalink":"http://thmasterplan.cn/JVM/%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6/","excerpt":"","text":"JVM参数，均以-XX:开始，其中-XX:+&lt;option&gt;，表示开启option选项；-XX:-&lt;option&gt;，表示关闭option选项；-XX:&lt;option&gt;=&lt;value&gt;，表示将option选项的值设置为value。 -XX:+TraceClassLoading，用于追踪类的加载信息并打印。 常量的本质： 12345678910111213public class MyTest2 &#123; public static void main(String[] args) &#123; System.out.println(MyParent2.string); &#125;&#125;class MyParent2&#123; public static final String string = \"hello world\"; static&#123; System.out.println(\"MyParent2 static block\"); &#125;&#125; 输出为：hello world 原理：常量在编译阶段会存入调用该常量所在类的常量池中，本质上调用类并没有直接引用常量所在的类，因此不会触发常量所在类的初始化。 123456789101112131415import java.util.UUID;public class MyTest3 &#123; public static void main(String[] args) &#123; System.out.println(MyParent3.string); &#125;&#125;class MyParent3&#123; public static final String string = UUID.randomUUID().toString(); static&#123; System.out.println(\"MyParent3 static block\"); &#125;&#125; 输出为：MyParent3 static block 016933b5-7da0-46b5-88fa-b662d6f01494 原理：常量string在编译期未知，在运行期间才赋值，故而静态代码块会初始化。 反编译.class文件：javap -c 全类名 反编译代码助记符： getstatic：获取类的静态字段 ldc：表示将int, float或是String类型的常量值从常量池推送至栈顶 bipush：表示将单字节（-128-127）的常量值从常量池推送至栈顶 sipush：表示将一个短整型（-32768—32767）常量值推送至栈顶 iconst_1：表示将int类型的1推送至栈顶（iconst_0 - iconst_5） anewarray：创建一个引用类型数组，并将其引用值压入栈顶 newarray：创建一个基本类型的数组，并将其引用值压入栈顶 数组创建本质：new一个数组，对于数组实例来说，其类型是由JVM在运行期间动态生成的，动态生成的类型其父类为Object。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"贪心","slug":"贪心","date":"2020-03-26T06:11:35.000Z","updated":"2020-03-26T06:13:26.316Z","comments":true,"path":"面试刷题/贪心/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心算法 解决贪心问题的步骤： 将原问题分解为子问题 找出贪心策略（寻找局部最优解） 得到每一个子问题的最优解 将所有局部最优解的集合构成称为原问题的一个解 leetcode455：分发饼干 123456789101112131415class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; int child = 0; int cookie = 0; Arrays.sort(g); //先将饼干 和 孩子所需大小都进行排序 Arrays.sort(s); while (child &lt; g.length &amp;&amp; cookie &lt; s.length )&#123; //当其中一个遍历就结束 if (g[child] &lt;= s[cookie])&#123; //当用当前饼干可以满足当前孩子的需求，可以满足的孩子数量+1 child++; &#125; cookie++; // 饼干只可以用一次，因为饼干如果小的话，就是无法满足被抛弃，满足的话就是被用了 &#125; return child; &#125;&#125; leetcode435：无重叠区间 123456789101112131415161718192021222324class Solution &#123; //思路：按区间开始处升序排序后，尽量保留结尾小的 public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) return 0; Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] - o2[0]; &#125; &#125;);//按照区间开始升序排序 int prev = 0, count = 0;//变量prev保存遍历时的前一个区间 for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[prev][1] &gt; intervals[i][0]) &#123;//前一个区间的结尾&gt;后一个区间的开始，表明有重叠 if (intervals[prev][1] &gt; intervals[i][1]) prev = i;//前一个区间的结尾&gt;后一个区间的结尾，表明前一个区间覆盖后一个区间，删除结尾大的区间 count++; &#125; else prev = i;//无重叠 &#125; return count; &#125;&#125; leetcode452：用最少数量的箭引爆气球 1234567891011121314151617181920212223class Solution &#123; //类似于435，删除k个区间后便无重叠区间，则该题答案为n-k，n为总区间个数 public int findMinArrowShots(int[][] points) &#123; if(points.length == 0) return 0; Arrays.sort(points, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] point1, int[] point2)&#123; return point1[0] - point2[0]; &#125; &#125;);//升序排序 int prev = 0, count = 0; for(int i = 1; i &lt; points.length; i++)&#123; if(points[prev][1] &gt;= points[i][0] )&#123; if(points[prev][1] &gt; points[i][1]) prev = i; count++; &#125;else prev = i; &#125; return points.length - count; &#125;&#125; leetcode406：根据身高重建队列 123456789101112131415161718192021222324//将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。//按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。//直到完成为止。class Solution &#123; //1.排序：按高度降序排列；在同一高度的人中，按 k 值的升序排列。 //2.逐个地把它们放在输出队列中，索引等于它们的 k 值。 //3.返回输出队列 public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] == o2[0] ? o1[1] - o2[1]: o2[0] - o1[0]; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for(int[] p : people)&#123; list.add(p[1],p); &#125; return list.toArray(new int[people.length][2]); &#125;&#125; leetcode121：买卖股票的最佳时机 12345678910111213class Solution &#123; public int maxProfit(int prices[]) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, min = prices[0];//min记录前面的最小价格 for(int i = 1; i &lt; prices.length; i++)&#123; int profit = prices[i] - min;//利润等于当前价格减去最小价格 result = result &gt; profit ? result : profit;//更新最大利润 min = prices[i] &gt; min ? min : prices[i];//每一天更新最小价格 &#125; return result; &#125;&#125; leetcode122：买卖股票的最佳时机2 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, buy = prices[0]; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &lt; prices[i-1]) buy = prices[i];//股票降了，抄底买入 else&#123; result += prices[i] - buy;//股票涨的阶段，卖掉前一天的股票 buy = prices[i];//买入当天的股票，利润最大化 &#125; &#125; return result; &#125;&#125; leetcode605：种花问题 1234567891011121314public class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int i = 0; while (i &lt; flowerbed.length) &#123; if (flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) &#123;//数组元素为0，并且其左右两边均为0，或者该数组下标位于首（尾） flowerbed[i++] = 1; n--; &#125; if(n &lt;= 0) return true; i++; &#125; return false; &#125;&#125; leetcode392：判断子序列 1234567891011121314class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int sLen = s.length(); if(sLen == 0) return true; int j = 0; for(int i = 0; i &lt; t.length(); i++)&#123; if(j &lt; sLen &amp;&amp; t.charAt(i) == s.charAt(j)) j++; if(j == sLen) return true; &#125; return false; &#125;&#125; leetcode53：最大子数组和 1234567891011class Solution &#123; public int maxSubArray(int[] nums) &#123; int currMaxSum = nums[0], maxSum = nums[0]; for(int i = 1; i &lt; nums.length; ++i) &#123; currMaxSum = Math.max(nums[i], currMaxSum + nums[i]);//计算以当前元素nums[i]为终点的所有的子数组的最大和 maxSum = Math.max(maxSum, currMaxSum);//maxSum是所有currMaxSum中的最大值 &#125; return maxSum; &#125;&#125; leetcode763：划分字母区间 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; partitionLabels(String S) &#123; int[] last = new int[26];//定义一个大小为26的数组，用于存储每个字母最后一次出现的下标 for(int i = 0; i &lt; S.length(); ++i)&#123; last[S.charAt(i) - 'a'] = i;//遍历字符串，更新每个字符的下标 &#125; int start = 0, end = 0; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; S.length(); ++i)&#123; end = Math.max(end, last[S.charAt(i) - 'a']);//遍历字符串时扩展区间末端end if(i == end)&#123;//当前下标等于区间末端end时，为一次划分，更新start=end+1 res.add(end-start+1); start = end+1; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"注解","slug":"注解","date":"2020-03-25T09:58:33.000Z","updated":"2020-04-05T14:37:47.629Z","comments":true,"path":"Java基础/注解/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解 注解（Annotation），也叫元数据，JDK1.5后引入的特性，与类、接口、枚举在同一层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用于对这些元素进行说明。 定义注解 -&gt; 使用注解 -&gt;读取注解 作用分类 编写文档 ：命令行输入javadoc xxx.java，通过代码里标识的注解自动生成doc文档 代码分析：通过代码里标识的注解对代码进行分析（使用反射机制） 编译检查 ：编译器对代码进行编译检查 JDK预定义的注解 @Override：检测被注解的方法是否继承自父类（接口） @Deprecated：被注解的内容已过时，不建议使用 @SuppressWarnings：压制警告，一般传递参数all 自定义注解 注解通过@interface定义，例如public @interface MyAnnotation{} 本质是接口：public interface MyAnnotation extends java.lang.annotation.Annotation{} 注解的属性：接口中的抽象方法 属性的返回值类型 基本数据类型 String 枚举 注解 以上类型的数组 使用注解时，需要对属性赋值，例@SuppressWarning(&quot;all&quot;)；亦可以在定义注解时使用default设置默认值，使用时就不用赋值；如果只有一个属性需要赋值，且属性名为value，则value可以省略可直接赋值，上述压制警告就是这种情形。 123public @interface MyAnno&#123; int a() default 5; &#125; 元注解：可以注释到注解上的注解，一共有五种。 @Retention：描述注解被保留的阶段 12345public enum RetentionPolicy&#123; SOURCE,//注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视 CLASS,//注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 RUNTIME//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时才能获取到它们（常用）&#125; 使用示例： 123@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno&#123;&#125; @Documented：描述注解是否被抽取到doc文档中 @Target：当一个注解被 @Target 注解时，这个注解就被限定了运用的场景 ElementType.ANNOTATION_TYPE：可以给一个注解进行注解 ElementType.CONSTRUCTOR：可以给构造方法进行注解 ElementType.FIELD：可以给成员变量进行注解 ElementType.LOCAL_VARIABLE：可以给局部变量进行注解 ElementType.METHOD：可以给方法进行注解 ElementType.PACKAGE：可以给一个包进行注解 ElementType.PARAMETER：可以给一个方法内的参数进行注解 ElementType.TYPE：可以给一个类型进行注解，比如类、接口、枚举 @Inherited：描述注解是否被子类继承 @Repeatable 在程序中使用（解析）注解：获取注解中定义的属性值 例如在反射中的自定义框架，使用注解后便不需要使用配置文件传参数，通过更改注解的属性值即可实现创建不同的对象、使用对象的方法。 1234567891011121314151617package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 描述需要执行的类名和方法名 * */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String methodName();&#125; 12345678910111213141516171819202122232425262728293031package annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Method;@Pro(className = \"model.Person\",methodName=\"eat\")public class MyFrame2 &#123; public static void main(String[] args) throws Exception &#123; //1.获取注解对象 Class&lt;MyFrame2&gt; myFrame2Class = MyFrame2.class; Pro anno = myFrame2Class.getAnnotation(Pro.class);//在内存中生成了一个该注解接口的子类的实现对象 //2.调用注解对象中定义的抽象方法，获取返回值 String className = anno.className(); String methodName = anno.methodName(); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance(); Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125; 使用注解方式创建DBUtil工具类（降低耦合度） 1234567891011121314151617181920212223package anno;import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.ElementType.TYPE;import java.lang.annotation.Documented;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;METHOD,TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface JDBCConfig &#123; String ip(); int port() default 3306; String database(); String encoding(); String loginName(); String password(); &#125; 12345678910111213141516171819202122232425262728293031323334353637package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import anno.JDBCConfig;@JDBCConfig(ip = \"127.0.0.1\", database = \"test\", encoding = \"UTF-8\", loginName = \"root\", password = \"admin\")public class DBUtil &#123; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException &#123; JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);//通过反射获取DBUtil类上的注解对象 String ip = config.ip(); int port = config.port(); String database = config.database(); String encoding = config.encoding(); String loginName = config.loginName(); String password = config.password(); String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException &#123; Connection c = getConnection(); System.out.println(c); &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"类加载过程","slug":"类加载过程","date":"2020-03-24T09:08:23.000Z","updated":"2020-03-24T11:55:23.653Z","comments":true,"path":"JVM/类加载过程/","link":"","permalink":"http://thmasterplan.cn/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/","excerpt":"","text":"类加载的阶段分解 Java代码中，class的加载、连接与初始化都是在程序运行期间完成。.java -&gt; 编译为.class(磁盘) -&gt;ClassLoader将类加载到内存中 -&gt;连接（确定类与类之间的关系）-&gt;初始化。 如下几种情况，JVM将结束自身进程： 执行了System.exit()方法 正常执行结束 异常或错误（常见） 操作系统错误导致JVM进程终止 类的加载、连接与初始化过程 ClassLoader将类从磁盘加载到内存中的三个阶段： 加载：查找并加载类的二进制数据。 连接： 验证：确保被加载类的正确性。 准备：为类的静态变量分配内存，并将其初始化为默认值（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型默认为null）。 解析：把类中的符号引用（涉及字符串，用文本形式表示引用关系，JVM间接使用）转换为直接引用（JVM能直接找到对象的内存位置）。(https://www.zhihu.com/question/30300585) 初始化：为类的静态变量赋予正确的初始值（此时才赋予程序员设定的值），执行静态代码块。 类的加载： 概念：将类的.class文件中的二进制数据读入内存，将其放在运行时数据区的方法区中，然后在内存中创建一个java.lang.Class对象用于封装类在方法区内的数据结构。 加载方式： 本地加载 网络下载.class文件 从zip, jar等归档文件中加载 从专有数据库中提取.class文件 将.java动态编译为.class文件（动态代理；JSP-&gt;Servlet类） Java程序对类的使用方式可分为两种：主动使用与被动使用，每个类或接口只有被Java程序“首次主动使用”时才初始化。 主动使用： new一个对象 访问某个类或接口的静态变量，或对其赋值，或调用类的静态方法 反射，获取类的Class对象 初始化某类的子类（对父类的主动使用） 启动类（带main方法的类） JDK1.7开始提供的动态语言支持 * 被动使用：除上述情况以外，其他使用Java类的方式都不会导致类的初始化。 测试 12345678910111213141516171819202122package classloader;public class MyTest1 &#123; public static void main(String[] args) &#123; System.out.println(MyChild1.string); &#125;&#125;class MyParent1&#123; public static String string = \"hello world\"; static&#123; System.out.println(\"MyParent1 static block\"); &#125;&#125;class MyChild1 extends MyParent1&#123; static&#123; System.out.println(\"MyChild1 static block\"); &#125;&#125; ​ 控制台输出为：​ MyParent1 static block​ hello world ​ 原因：并没有主动使用Mychild1类，也就没有初始化Mychild1类 package classloader; public class MyTest1 { public static void main(String[] args) { System.out.println(MyChild1.string2); } } class MyParent1{ public static String string = &quot;hello world&quot;; static{ System.out.println(&quot;MyParent1 static block&quot;); } } class MyChild1 extends MyParent1{ public static String string2 = &quot;welcome&quot;; static{ System.out.println(&quot;MyChild1 static block&quot;); } } 控制台输出为： MyParent1 static blockMyChild1 static blockwelcome 原因：因为使用了子类的变量，子类被初始化的前提是其所有的父类已被初始化。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"反射","slug":"反射","date":"2020-03-24T09:08:10.000Z","updated":"2020-04-05T14:37:30.392Z","comments":true,"path":"Java基础/反射/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"反射：将类的各个组成部分封装为其他对象。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 反射的好处 可以在程序运行期间操作封装好的对象（Field,Constructor,Method） 解耦，提高程序的可扩展性 获取Class对象 Class对象中将类的成员变量封装到Field[]中，将类的构造方法封装到Constructor[]中，将类的方法封装到Method[]中。 三种方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。此种方式多用于配置文件，将类名定义在配置文件中，通过读取文件加载类。 类名.class：通过类名的class属性获取。多用于参数的传递。 new 类名().getClass() ：getClass()方法在Object类中定义。通过对象获取类的字节码。 注：不论使用哪种方式，同一个.class文件在一次程序运行中只会被加载一次，因此在一次运行中即使使用三种方式各获取一次，获取的都是同一个对象。 获取类的Class对象是Java程序对类的主动使用，会初始化该类（静态代码块，静态变量）。 静态synchronized方法的同步对象是：静态同步方法所在类的Class对象。 Class对象功能 获取所有成员变量 Field[] getFields() 获取public修饰的,包括所有父类的 Field getField(String name) Field[] getDeclaredFields() 不考虑修饰符，但是不能获取父类的 Field getDeclaredFields(String name) 获取所有构造方法 getConstructors() getDeclaredConstructors() 获取所有成员方法 getMethods() getDeclaredMethods() 获取全类名（包括包名在内）: getName() Field对象常用方法: set(),get(),setAccessible(true)【暴力反射】 Constructor对象常用方法:newInstance(Object… initargs) Method对象常用方法：invoke(Object obj, Object… args), getName() 测试 12345678910111213141516171819202122232425262728293031323334import java.lang.reflect.Field;public class ReflectTest &#123; public static void main(String[] args) throws Exception &#123; Class&lt;Test&gt; testClass = Test.class;//获取Class对象 Test test = new Test(); Field a = testClass.getDeclaredField(\"a\");//获取指定变量 a.set(test, 100);//给指定变量设置值 Field[] fields = testClass.getDeclaredFields();//获取所有变量 for (Field field : fields) &#123; field.setAccessible(true);//暴力反射，使得可以访问private修饰的成员变量 System.out.print(\" \"+field.get(test)); &#125; &#125;&#125;class Test&#123; public int a = 5; protected int b = 6; int c = 7; private int d = 8; public int getD() &#123; return d; &#125; public void setD(int d) &#123; this.d = d; &#125;&#125; 控制台输出：100 6 7 8 练习：写一个“框架”，可以创建任意类的对象，并能够执行其中任意方法 思路：使用反射，不需要更改框架的代码，只需更改配置文件的参数，就可以体现泛用性。（平时创建不同的对象是需要不同的代码的，比如 new Person(), new Student()） 步骤：1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中 ​ 2.在框架程序中读取配置文件 ​ 3.使用反射技术来加载要创建的对象的类文件进内存 ​ 4.创建对象（使用newInstance()方法） ​ 5.执行方法（使用invoke()方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package reflect;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;public class MyFrame &#123; public static void main(String[] args) throws Exception &#123; //1.加载配置文件 Properties properties = new Properties(); ClassLoader classLoader = MyFrame.class.getClassLoader(); InputStream iStream = classLoader.getResourceAsStream(\"pro.properties\"); properties.load(iStream); //2.获取配置文件中定义的数据 String className = properties.getProperty(\"className\"); String methodName = properties.getProperty(\"methodName\"); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance();本质仍然是调用Constructor对象的newInstance()方法 Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125;//Person类package model;public class Person &#123; public void eat() &#123; System.out.println(\"eating...\"); &#125;&#125;//pro.properties配置文件内容className=model.PersonmethodName=eat https://zhuanlan.zhihu.com/p/66853751","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"String StringBuffer StringBuilder","slug":"String-StringBuffer-StringBuilder","date":"2020-03-15T03:51:39.000Z","updated":"2020-04-05T14:37:14.572Z","comments":true,"path":"Java基础/String-StringBuffer-StringBuilder/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/String-StringBuffer-StringBuilder/","excerpt":"","text":"String String是不可变的字符串，底层是一个用final修饰的字符数组。 String对象直接赋值之后会在字符串常量池（堆内存中）缓存，下次创建相同字符串对象时判断常量池中是否有，如果有则返回其地址。 使用new String(“str”)方法创建字符串对象时，首先判断字符串常量池中是否存在，若没有则在常量池创建字符串，然后在堆内存创建，将堆内存中的地址返回。 字符串的拼接：由于常量池中字符串不可变，一个字符串和另一个字符串拼接需要开辟三块内存空间，效率低下。 StringBuffer与StringBuilder 都继承于AbstractStringBuilder，底层使用的字符数组没有final修饰，因此在做字符串拼接就在原来的内存上拼接，不会浪费内存空间。 StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是 synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。 StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-03-07T08:01:05.000Z","updated":"2020-04-05T14:36:58.806Z","comments":true,"path":"Java基础/JDBC/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JDBC/","excerpt":"","text":"JDBC概念：官方定义的一套操作所有关系型数据库的接口，各个数据库厂商实现这套接口，提供数据库驱动jar包。 基础 初始化驱动类：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 建立与数据库的连接： 123456789static String ip = \"127.0.0.1\";static int port = 3306;static String database = \"tmall\";static String encoding = \"UTF-8\";static String loginName = \"root\";static String password = \"admin\";//mysql数据库url写法：jdbc:mysql://ip:端口号/数据库名称String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding);Connection connection = DriverManager.getConnection(url, loginName, password); 创建Statement并执行sql语句： 123Statement statement = connection.createStatement();String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\";statement.execute(sql); 使用try-with-resource自动关闭连接： 123456try (Connection connection = DriverManager.getConnection(url, loginName, password);Statement statement = c.createStatement();)&#123; String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\"; statement.execute(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; PreparedStatement 12345678910111213String sql = \"insert into hero values(null,?,?,?)\";try (Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\",\"root\", \"admin\"); // 根据sql语句创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql);) &#123; // 设置参数 ps.setString(1, \"提莫\"); ps.setFloat(2, 313.0f); ps.setInt(3, 50); // 执行 ps.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 使用预编译statement优点： 参数设置，可读性好，不需要进行字符串拼接 预编译机制性能比Statement好 可防止SQL注入攻击 execute/executeQuery/executeUpdate executeQuery: 返回一个结果集，这个方法用来执行select语句. 12345678ResultSet rs = statement.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt(\"id\");// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat(\"hp\"); int damage = rs.getInt(4); System.out.printf(\"%d\\t%s\\t%f\\t%d%n\", id, name, hp, damage); &#125; executeUpdate:用于执行insert，delete，update等SQL语句，executeupdate返回的值是一个整数，表示受影响的行数，对于create table等不操作行的语句，executeupdate的返回值为0。 execute: 可执行任何sql语句，其返回值为布尔类型，是true时，表示执行的是查询语句，可以通过getResultSet方法获取结果；返回值为false时，执行的是更新语句或DDL语句，getUpdateCount方法获取更新的记录数量 获取自增长ID：在执行完插入语句后，为获取新增记录的id 1234567// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id// JDBC通过getGeneratedKeys获取该idResultSet rs = prepareStatement.getGeneratedKeys();if (rs.next()) &#123; int id = rs.getInt(1); System.out.println(id);&#125; 使用事务：在mysql中，只有当表的类型是innodb时才支持事务 12345connection.setAutoCommit(false);//事务代码块connection.commit();//回滚事务:connection.rollback() ORM：Object Relationship Database Mapping，即对象与关系数据库的映射，对象中的各成员变量值与关系数据库里一条记录相对应。 DAO：Database Access Object，数据库访问对象，把对数据库某张表相关的操作都封装在这个类里面 数据库连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package jdbc; import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.ArrayList;import java.util.List; public class ConnectionPool &#123; List&lt;Connection&gt; cs = new ArrayList&lt;Connection&gt;(); int size; public ConnectionPool(int size) &#123; this.size = size; init(); &#125; public void init() &#123; //这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是\"活\"的，不要被自动关闭了 try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); for (int i = 0; i &lt; size; i++) &#123; Connection c = DriverManager .getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\", \"root\", \"admin\"); cs.add(c); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public synchronized Connection getConnection() &#123; while (cs.isEmpty()) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Connection c = cs.remove(0); return c; &#125; public synchronized void returnConnection(Connection c) &#123; cs.add(c); this.notifyAll(); &#125; &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"字符串","slug":"字符串","date":"2020-02-15T11:33:53.000Z","updated":"2020-02-15T11:34:55.098Z","comments":true,"path":"面试刷题/字符串/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"leetcode面试题01.09.字符串轮转： 给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。（同leetcode：796） 12345678910111213141516171819202122232425262728class Solution &#123; //只需要判断s2是否是s1s1的子串，并且s2.length == s1.length两个条件即可。 public boolean isFlipedString(String s1, String s2) &#123; if(s1.length() != s2.length()) return false;//长度不相等直接返回false else if(s1.length() == 0) return true;//长度相等但是都为空，返回true String s1s1 = s1+s1; if(isSubString(s1s1, s2)) return true;//判断s2是否为s1+s1的子串，是则为true return false; &#125; private boolean isSubString(String s1, String s2)&#123; int i = 0, j = 0; while(i &lt; s1.length())&#123; int k = i; while(k &lt; s1.length() &amp;&amp; j &lt; s2.length() &amp;&amp; s1.charAt(k) == s2.charAt(j) )&#123; k++; j++; &#125; if(j == s2.length()) return true; else j = 0; i++; &#125; return false; &#125;&#125;//一行代码版：//return s1.length() == s2.length &amp;&amp; (s1+s1).indexOf(s2) != -1; 面试题58 - ll左旋转字符串（类似于189.旋转数组）： 12输入: s = &quot;abcdefg&quot;, k = 2输出: &quot;cdefgab&quot; 1234567891011121314151617class Solution &#123; public String reverseLeftWords(String s, int n) &#123; char[] chars = s.toCharArray(); reverseString(chars, 0, n-1); reverseString(chars, n, chars.length-1); reverseString(chars, 0, chars.length-1); return new String(chars); &#125; private void reverseString(char[] s, int start, int end)&#123; while(start &lt; end)&#123; char temp = s[start]; s[start++] = s[end]; s[end--] = temp; &#125; &#125;&#125; 翻转字符串里的单词：151 12输入: &quot; a good example &quot;输出: &quot;example good a&quot; 123456789101112131415161718192021222324252627282930//翻转每个单词后再翻转整个字符串class Solution &#123; public String reverseWords(String s) &#123; s = s.trim();//去除首尾空格 s = s.replaceAll(\"\\\\s+\", \" \");//去除多余空格 char[] chars = s.toCharArray(); int i = 0, start = 0; while(i &lt; chars.length)&#123;//遇到空格即翻转每个单词 if(chars[i] == ' ')&#123; reverse(chars, start, i-1); start = i+1; &#125; i++; &#125; reverse(chars, start, --i);//翻转最后一个单词 reverse(chars, 0, i);//翻转整个字符串 return new String(chars); &#125; private void reverse(char[] c, int start, int end)&#123; while(start &lt; end)&#123; char temp = c[start]; c[start++] = c[end]; c[end--] = temp; &#125; &#125;&#125; 有效的字母异位词：242 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125; for(char c : t.toCharArray())&#123; if(!charFrequency.containsKey(c)) return false; else charFrequency.put(c, charFrequency.get(c)-1); &#125; for( char c : charFrequency.keySet())&#123; if(charFrequency.get(c) != 0) return false; &#125; return true; &#125; /* 用数组实现更快 public boolean isAnagram(String s, String t) &#123; int[] cnts = new int[26]; for (char c : s.toCharArray()) cnts[c - 'a']++; for (char c : t.toCharArray()) cnts[c - 'a']--; for (int cnt : cnts) if (cnt != 0) return false; return true; &#125; */&#125; 最长回文串：409 1234567891011121314151617181920212223242526272829303132class Solution &#123; //使用数组 public int longestPalindrome(String s) &#123; int[] charFrequency = new int[256]; for (char c : s.toCharArray()) charFrequency[c]++; int result = 0; for (int freq : charFrequency) result += (freq / 2) * 2; return result == s.length() ? result : result+1; &#125; &#125;/* 使用哈希表 public int longestPalindrome(String s) &#123; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125;//HashMap记录所有字母的频率 int result = 0; for(char c : charFrequency.keySet())&#123; int freq = charFrequency.get(c); result += (freq/2)*2;//为偶数则直接加，为奇数则-1 &#125; return result == s.length() ? result : result+1; &#125;*/ 同构字符串：205 123456789101112131415161718class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; return isIsomorphicSinglePass(s, t) &amp;&amp; isIsomorphicSinglePass(t, s); //必须双向验证 //例如\"bar\" -&gt; \" foo\"满足唯一映射，但是反之则不满足 &#125; //单方向判断s -&gt; t, s中的每个字母是否唯一映射t中的每个字母 private boolean isIsomorphicSinglePass(String s, String t)&#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; char charS = s.charAt(i); char charT = t.charAt(i); if(!map.containsKey(charS)) map.put(charS, charT); else if(map.get(charS) != charT) return false; &#125; return true; &#125;&#125; 回文数：9 1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x == 0) return true; if(x &lt; 0 || x % 10 == 0) return false; return x == reverse(x); &#125; //反转整数 private int reverse(int x)&#123; int result = 0; while(x &gt; 0)&#123; result = result*10; result += x%10; x = x/10; &#125; return result; &#125;&#125; 计数二进制子串：696 123输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 123456789101112131415161718class Solution &#123; //先统计连续的0和1分别有多少个，如：111100011000，得到4、3、2、3；在4323中的任意相邻两个数字，取小的一个加起来，就是3+2+2 = 7. public int countBinarySubstrings(String s) &#123; int res = 0; int i = 0, count = 1, precount = 0;//count记录相同数字连续子串的长度，precount记录前一个连续子串的长度 while(i &lt; s.length()-1)&#123; if(s.charAt(i) == s.charAt(i+1)) count++; else &#123; res += precount &gt; count ? count : precount;//取小的一个 precount = count; count = 1; &#125; i++; &#125; res += precount &gt; count ? count : precount; return res; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2020-02-14T14:43:29.000Z","updated":"2020-02-14T14:44:19.265Z","comments":true,"path":"面试刷题/栈与队列/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"用栈实现队列：232 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; stack; /** Initialize your data structure here. */ public MyQueue() &#123; stack = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; stack.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.pop(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Get the front element. */ public int peek() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.peek(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack.empty(); &#125;&#125; 用队列实现栈：225 1234567891011121314151617181920212223242526272829303132class MyStack &#123; private Queue&lt;Integer&gt; queue; /** Initialize your data structure here. */ public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; /** Push element x onto stack. */ public void push(int x) &#123; queue.offer(x); int size = queue.size(); while(size-- &gt; 1)&#123; queue.offer(queue.poll()); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; return queue.poll(); &#125; /** Get the top element. */ public int top() &#123; return queue.peek(); &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 最小栈：155 12345678910111213141516171819202122232425262728293031323334class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack;//minStack的栈顶元素即是当前stack的最小值 /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.empty())&#123; minStack.push(x); &#125;else&#123; if(x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; &#125; public void pop() &#123; int pop = stack.pop(); if(pop == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; 有效的括号：20 12345678910111213class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //遍历字符串，每遇到一种类型的左括号，则将其对应的右括号入栈；若不是左括号，且栈不为空，则出栈，出栈的有括号应与遍历到的右括号一致。 for(char c: s.toCharArray())&#123; if(c == '(') stack.push(')'); else if(c == '[') stack.push(']'); else if((c== '&#123;')) stack.push('&#125;'); else if(stack.empty() || c != stack.pop()) return false; &#125; return stack.empty(); &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"链表","slug":"链表","date":"2020-02-13T12:45:27.000Z","updated":"2020-02-13T12:46:24.855Z","comments":true,"path":"面试刷题/链表/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"找出两个链表的交点：160 1234567891011121314151617181920public class Solution &#123; /*设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。*/ public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while(pA != pB)&#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 反转链表：206 123456789101112131415//原地翻转三个主要变量，当前节点cur，前一个节点pre,后一个节点nextTempclass Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125;&#125; 合并两个有序链表：21 1234567891011121314151617181920212223class Solution &#123; //类似于归并排序中的merge过程 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode newList = new ListNode(0); ListNode cur = newList; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; cur.next = l1; cur = cur.next; l1 = l1.next; &#125;else&#123; cur.next = l2; cur = cur.next; l2 = l2.next; &#125; &#125; if(l1 == null) cur.next = l2;//任一链表为空，直接连接另一条链表 else cur.next = l1; return newList.next; &#125;&#125; 删除排序链表中的重复元素：83 123456789101112class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null &amp;&amp; cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125;else cur = cur.next; &#125; return head; &#125;&#125; 删除链表的倒数第N个节点：19 1234567891011121314151617class Solution &#123; //先使快指针移动n个节点，然后快慢指针同时移动直到快指针达到链表尾部，此时慢指针即指向要删除的节点的前一个节点 public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode first = head, second = head; for(int i = 0; i &lt; n; i++) second = second.next; if(second == null) return head.next;//若n等于链表节点数，直接返回head.next while(second.next != null)&#123; first = first.next; second = second.next; &#125; first.next = first.next.next; return head; &#125;&#125; 两两交换链表中的节点：24 123456789101112class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode firstNode = head, secondNode = head.next; firstNode.next = swapPairs(secondNode.next);//swapParis交换一对节点，并返回第二个节点 secondNode.next = firstNode; return secondNode; &#125;&#125; 两数相加：445 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; //两栈用于存储两个数，另一个栈存储和 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; first = new Stack&lt;&gt;(); Stack&lt;Integer&gt; second = new Stack&lt;&gt;(); while(l1 != null)&#123; first.push(l1.val); l1 = l1.next; &#125; while(l2 != null)&#123; second.push(l2.val); l2 = l2.next; &#125; Stack&lt;Integer&gt; sumStack = new Stack&lt;&gt;(); int carry = 0;//进位 while(!first.empty() &amp;&amp; !second.empty())&#123; int sum = first.pop() + second.pop() + carry; carry = 0;//进位用完归0 if(sum &gt;= 10)&#123; carry = 1; sum = sum % 10; &#125; sumStack.push(sum); &#125; while(!first.empty())&#123; if(carry == 1)&#123; int sum = first.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(first.pop()); &#125; while(!second.empty())&#123; if(carry == 1)&#123; int sum = second.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(second.pop()); &#125; if(carry == 1) sumStack.push(1);//和的第二位有进位的情况 ListNode sumList = new ListNode(sumStack.pop()); ListNode cur = sumList; while(!sumStack.empty())&#123; cur.next = new ListNode(sumStack.pop()); cur = cur.next; &#125; return sumList; &#125;&#125; 判断一个链表是否为回文链表：234（要求O（n）和O（1）） 1234567891011121314151617181920212223242526272829303132333435363738394041424344sclass Solution &#123; //该算法使用快慢指针找到链表中间节点，然后将链表切分，将后半部分翻转，再进行比较 public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) return true; ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125;//使用快慢指针使slow指针到达链表中间 if(fast != null) slow = slow.next;//链表节点个数为奇数，slow指针右移离开中间节点 ListNode cur = head; while(cur.next != slow)&#123; cur = cur.next; &#125; cur.next = null;//切分链表为两部分，后半部分第一个节点为slow return isEqual(head, reverseList(slow)); &#125; private ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125; private boolean isEqual(ListNode l1, ListNode l2) &#123; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; &#125; return true; &#125;&#125; 将链表奇数节点和偶数节点分别放在一起：328 （O（n）和O（1）） 1234567891011121314151617class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null) return head; ListNode odd = head, even = head.next; ListNode evenHead = even; while(even != null &amp;&amp; even.next != null)&#123; odd.next = even.next; odd = odd.next; even.next = odd.next; even = even.next; &#125; odd.next = evenHead; return head; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-02-12T07:23:45.000Z","updated":"2020-02-12T07:24:36.505Z","comments":true,"path":"面试刷题/二分查找/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"求开方：69 1234567891011121314151617class Solution &#123; public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int start = 1, end = x; while(start &lt;= end)&#123; int mid = start + (end - start)/2; int sqrt = x/mid;//不使用square与mid*mid判断是因为可能整型溢出 if(sqrt == mid) return mid; else if(sqrt &lt; mid) end = mid - 1; else start = mid + 1; &#125; return end; &#125;&#125; 寻找比目标字母大的最小字母：744 123456789101112131415161718class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; if(target &lt; letters[0] || target &gt;= letters[letters.length-1]) return letters[0]; int start = 0, end = letters.length - 2; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(letters[mid] == target)&#123; int i = mid+1; while(letters[i] == target) i++; return letters[i]; &#125; else if(letters[mid] &lt; target) start = mid + 1; else end = mid - 1; &#125; return letters[end+1]; &#125;&#125; 有序数组中的单一元素：540（时空复杂度要求为O（logn）和O(1)） 12345678910111213class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int start = 0, end = nums.length - 1; while(start &lt; end)&#123; int mid = start + (end - start)/2; if(mid%2 == 1) mid--;//只对偶数索引进行二分查找 //以[3,3,7,7,10,11,11]为例，只有当单一元素出现后，其后的数组部分，偶数索引mid处才不满足nums[mid] == nums[mid+1] if(nums[mid] == nums[mid+1]) start = mid + 2;//单一元素一定在mid后 else end = mid;//单一元素为mid或者在mid之前 &#125; return nums[start]; &#125;&#125; 寻找第一个错误的版本：278 1234567891011public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int low = 1, high = n; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(isBadVersion(mid)) high = mid;//第mid个版本错误，之后全是错的，向前继续找第一个错误的版本 else low = mid + 1;//第mid个版本正确，向后找 &#125; return low; &#125;&#125; 寻找旋转排序数组中的最小值：153 12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= nums[high]) high = mid; else low = mid+1; &#125; return nums[low]; &#125; /*时间复杂度O(n) public int findMin(int[] nums) &#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i+1]) return nums[i+1]; &#125; return nums[0]; &#125; */&#125; 在排序数组中查找元素的第一个和最后一个位置：34 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length == 0) return new int[]&#123;-1,-1&#125;; int firstIndex = findFirst(nums, target); if(nums[firstIndex] != target) return new int[]&#123;-1,-1&#125;; int lastIndex = findLast(nums,target); if(nums[nums.length-1] == target) return new int[]&#123;firstIndex,nums.length-1&#125;; return new int[]&#123;firstIndex, firstIndex &lt; lastIndex ? lastIndex : firstIndex&#125;; &#125; private static int findFirst(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &gt;= target) high = mid;//向左逼近，找左边界 else low = mid + 1; &#125; return low; &#125; private static int findLast(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= target) low = mid + 1;//向右逼近，找右边界，注意若最后一个数为target，则low不用-1 else high = mid; &#125; return low-1; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"排序","slug":"排序","date":"2020-02-11T08:07:19.000Z","updated":"2020-03-22T14:03:56.283Z","comments":true,"path":"面试刷题/排序/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"常见排序算法 排序的稳定性：排序过程中，具有相同关键字经过排序后，相对的顺序保持不变，则是稳定的；意义：在对象排序中，对其某个属性进行排序后，希望保持其他属性的顺序不发生改变，则需要稳定的排序算法。 选择排序：从数组开始处遍历，找到剩余未遍历数组中的最小值，与本次遍历第一个数交换，重复此过程，每一次内层循环找到未遍历数组的最小值，外层循环中将一个最小值排好序。 1234567891011public static void sort(int[] nums)&#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; int minPostion = i; for(int j = i+1; j &lt; nums.length; j++)&#123; minPostion = nums[minPostion] &gt; nums[j] ? j :minPostion; &#125; swap(nums, minPostion, i); &#125; &#125; 冒泡排序：内层循环两两比较，将大的数放在后面，最终结果是一次内层循环将一个最大的数排好顺序，与选择排序恰好相反。 1234567public static void sort(int[] nums)&#123; for(int i = nums.length-1; i &gt; 0; i--)&#123;//外层循环决定最大的数的位置 for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &gt; nums[j+1]) swap(nums, j, j+1); &#125; &#125; &#125; 插入排序：外层循环遍历数组（选择某张牌），内层循环将外层循环选择的牌插入到前面已经排好序的牌中。 1234567public static void sort(int[] nums)&#123; for(int i = 1; i &lt; nums.length; i++)&#123; for(int j = i; j &gt; 0; j--)&#123; if(nums[j] &lt; nums[j-1]) swap(nums, j, j-1); &#125; &#125; &#125; 插入排序在样本较小且基本有序时效率较高。 堆排序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HeapSort &#123; //堆：满足“任一非叶子节点均大于（小于）等于其孩子节点”条件的完全二叉树，分为大根堆和小根堆 public static void main(String[] args) &#123; int[] test = &#123;3,2,5,6,4,7,0,1,10,9,8&#125;; sort(test); for(int num:test)&#123; System.out.print(\" \"+num); &#125; &#125; public static void sort(int[] tree)&#123; buildHeap(tree); for(int j = tree.length - 1; j &gt; 0; j--)&#123; swap(tree,0,j);//将堆顶元素与末尾元素进行交换 adjustHeap(tree,0,j);//重新对堆进行调整 &#125; &#125; /** * 创建大根堆 * @param tree */ public static void buildHeap(int[] tree) &#123; for(int i = tree.length/2 - 1; i &gt;= 0; i--)//从第一个非叶子结点（完全二叉树中必为n/2-1）从下至上，从右至左调整结构 adjustHeap(tree, i, tree.length); &#125; /** * 堆化操作，将第i个节点与其孩子节点进行比较，将最大值放在位置i上； * 递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 * @param tree * @param i * @param length */ public static void adjustHeap(int[] tree,int i,int length)&#123; if(i &gt;= length) return;//递归出口，孩子的下标大于等于数组长度返回 int leftChildIndex = 2*i + 1;//左孩子下标 int rightChildIndex = 2*i + 2;//右孩子下标 int maxIndex = i;//用一个变量来记录i, 2*i+1, 2*i+2三者中的最大值的下标 if(leftChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[leftChildIndex]) maxIndex = leftChildIndex; if(rightChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[rightChildIndex]) maxIndex = rightChildIndex; if(maxIndex != i)&#123; swap(tree, i, maxIndex); adjustHeap(tree, maxIndex, length);//递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 &#125; &#125; private static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 归并排序（Java对象排序使用，对象排序要求稳定性） 12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 对数组的left至right这部分进行排序 * @param nums * @param left * @param right */public static void sort(int[] nums, int left, int right)&#123; if(left == right) return; int mid = left + (right - left)/2;//防止整型溢出 sort(nums, left, mid);//对数组的左半部分排序 sort(nums, mid+1, right);//对数组的右半部分排序 merge(nums, left, mid+1, right);//合并数组的两半部分&#125; /** * 合并数组的任意两半部分（均有序的情况下） * @param nums */private static void merge(int[] nums, int left, int mid, int right)&#123; int[] result = new int[right - left + 1]; int i = left, j = mid; int k = 0; while(i &lt; mid &amp;&amp; j &lt;= right)&#123; if(nums[i] &lt;= nums[j])&#123; result[k++] = nums[i++]; &#125;else result[k++] = nums[j++]; &#125; while(i &lt; mid)&#123; result[k++] = nums[i++]; &#125; while(j &lt;= right)&#123; result[k++] = nums[j++]; &#125; k = 0; for(i = left; i &lt;= right; i++)&#123; nums[i] = result[k++]; &#125;&#125; 快速排序（Java基础类型数据排序使用双轴快排） 1234567891011121314151617181920212223242526272829public static void sort(int[] nums, int leftBound, int rightBound)&#123; if(leftBound &gt;= rightBound) return; int pivotIndex = partition(nums, leftBound, rightBound);//得到每一次划分后轴的位置 sort(nums, leftBound, pivotIndex-1);//对轴左边的部分继续进行划分 sort(nums, pivotIndex+1, rightBound);//对轴右边的部分进行划分 &#125; /** * 一次划分将小于轴的数放在其左边，大于轴的数放在其右边 * @param nums * @param leftBound * @param rightBound * @return pivotIndex(轴的位置) */ private static int partition(int[] nums, int leftBound, int rightBound)&#123; int pivot = nums[rightBound];//将右边界的数定义为轴 int left = leftBound, right = rightBound - 1; while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &lt;= pivot) left++;//从左往右找到第一个比轴大的数 while(left &lt;= right &amp;&amp; nums[right] &gt; pivot) right--;//从右往左找到第一个比轴小的数 if(left &lt; right) swap(nums, left, right);//交换 &#125; swap(nums, left, rightBound);//交换nums[left]与轴则完成一次划分 return left; &#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"双指针","slug":"双指针","date":"2020-02-09T11:05:21.000Z","updated":"2020-02-09T11:06:47.339Z","comments":true,"path":"面试刷题/双指针/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"升序数组的TwoSum:167 1234567891011121314class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers == null) return null; int start = 0, end = numbers.length - 1; while(start &lt; end)&#123; if(numbers[start] + numbers[end] == target)&#123; return new int[]&#123;start+1, end+1&#125;; &#125; else if(numbers[start] + numbers[end] &lt; target)&#123; start++; &#125; else end--; &#125; return null; &#125;&#125; 判断某个数是否为平方数之和：633 12345678910111213class Solution &#123; public boolean judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int start = 0, end = (int)Math.sqrt(c); while(start &lt;= end)&#123; int squareSum = start*start + end*end; if(squareSum == c) return true; else if(squareSum &lt; c) start++; else end--; &#125; return false; &#125;&#125; 反转字符串中的元音字母：345 123456789101112131415161718192021222324class Solution &#123; public String reverseVowels(String s) &#123; HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); int start = 0, end = s.length() - 1; char[] result = new char[s.length()]; while(start &lt;= end)&#123; char startC = s.charAt(start); char endC = s.charAt(end); if(!vowels.contains(startC))&#123; result[start++] = startC; &#125; else if(!vowels.contains(endC))&#123; result[end--] = endC; &#125; else &#123; result[start++] = endC; result[end--] = startC; &#125; &#125; return new String(result); &#125;&#125; 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串:680 1234567891011121314151617181920212223class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0, right = s.length() - 1; while(left &lt;= right)&#123; if(s.charAt(left) == s.charAt(right))&#123; left++; right--; &#125;else return isPalindrome(s, left+1, right) || isPalindrome(s, left, right-1);//如果左右不对称，则判断删除s.charAt(left)或者s.charAt(right)后的子字符串是否为回文串 &#125; return true; &#125; private boolean isPalindrome(String s, int left, int right)&#123; while(left &lt;= right)&#123; if(s.charAt(left) != s.charAt(right)) return false; else &#123; left++; right--; &#125; &#125; return true; &#125;&#125; 合并两个有序数组：88 12345678910111213141516class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1, j = n - 1; int k = m+n-1; while(i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(nums2[j] &gt; nums1[i]) nums1[k--] = nums2[j--]; else nums1[k--] = nums1[i--]; &#125;//从两个数组尾部开始比较大小 //将剩余的某个数组中未比较的元素写入nums1 while(i &gt;= 0) nums1[k--] = nums1[i--]; while(j &gt;= 0) nums1[k--] = nums2[j--]; &#125;&#125; 判断链表中是否有环：141（快慢指针） 12345678910111213public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(slow != null &amp;&amp; fast!= null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(fast == slow) return true; &#125; return false; &#125;&#125; 通过删除字母匹配到字典里最长单词：524 1234567891011121314151617181920212223242526272829class Solution &#123; public String findLongestWord(String s, List&lt;String&gt; d) &#123; String result = \"\"; int maxLength = 0; for(String target : d)&#123; int targetLen = target.length(); if(isSubStr(s, target))&#123; if(maxLength &lt; targetLen)&#123; maxLength = targetLen; result = target; &#125;else if(maxLength == targetLen)&#123; if(result.compareTo(target) &lt; 0) continue;//比较字符串之间的字典顺序使用compareTo方法 else result = target; &#125; &#125; &#125; return result; &#125; private boolean isSubStr(String s, String target)&#123; int i = 0, j = 0; //遍历字符串s,每匹配一个target的字符j加1 while(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123; if(s.charAt(i) == target.charAt(j)) j++; i++; &#125; return j == target.length();//若j等于target.length(),说明target是s的一部分 &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"for foreach iterator","slug":"for-foreach-iterator","date":"2020-01-31T08:23:18.000Z","updated":"2020-04-05T14:36:45.023Z","comments":true,"path":"Java基础/for-foreach-iterator/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/for-foreach-iterator/","excerpt":"","text":"一、形式 for: for（int i=0;i&lt;arr.size();i++）{...} foreach:for（int i：arr）{...} iterator:Iterator it = arr.iterator();while(it.hasNext()){ object o =it.next(); ...} 二、差别 for需要指定集合的大小和集合元素的类型。 foreach需要知道集合元素的类型。 iterator既不需要指定集合元素的类型也不需要指定集合的大小。 foreach是iterator的语法糖，其底层使用iterator实现。 不能使用foreach语句进行add/remove操作。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"Java容器","slug":"Java容器","date":"2020-01-18T07:35:59.000Z","updated":"2020-04-05T14:36:26.373Z","comments":true,"path":"Java基础/Java容器/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%AE%B9%E5%99%A8/","excerpt":"","text":"Java容器关系图 图片来源：https://zhuanlan.zhihu.com/p/29421226","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"接口与抽象类","slug":"接口与抽象类","date":"2020-01-14T03:50:19.000Z","updated":"2020-04-05T14:36:04.823Z","comments":true,"path":"Java基础/接口与抽象类/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/","excerpt":"","text":"接口与抽象类的异同","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"进程管理","slug":"进程管理","date":"2019-12-09T05:54:57.000Z","updated":"2019-12-11T07:28:24.900Z","comments":true,"path":"Linux/进程管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"进程管理工具 lscpu：显示cpu信息 pstree -p：打印进程树 ps：(process state)，Linux系统各进程的相关信息均保存在/proc/PID下 BSD选项，选项前没有-： a：打印所有终端中的进程 STAT： x：与终端无关的进程，例如守护进程 u：额外显示进程的USER，CPU/MEM占比，RSS（常驻内存集，不包括交换分区）与VSZ（分配给进程的虚拟内存，包括交换分区），START（开始运行的时间）。 f：显示进程父子关系 k -%cpu：倒序排序显示cpu占比，-表示倒序 o：只显示某些选项，后面跟要显示的选项；例如ps axo psr：显示命令使用哪个CPU核 Linux优先级：o ni,pri,rtprio 搜索进程 按预定义的模式：pgrep [options] pattern： -u uid：有效用户 -U uid：运行命令者 -t terminal：与指定终端相关的进程 -l：显示进程名，例如pgrep -l &#39;^ba.*&#39; -a：显示完整格式的进程名 -P pid：显示指定进程的子进程 按程序名称: pidof 程序名 进程管理工具：top，内置命令： 排序：P：按%CPU；M：按%MEM；T：按累积占据CPU时长(TIME+) 首部信息显示： uptime信息：l tasks及cpu信息：t cpu内核分别显示：1 内存信息：m 退出：q 修改刷新时间间隔：s 终止进程：k 保存当前进程信息：W 栏位信息： us：用户空间 sy：内核空间 ni：调整nice时间 id：空闲 wa：等待IO时间 hi：硬中断 si：软中断 st：虚拟机偷走的时间 选项： -b：显示所有进程（默认只显示前一部分） -p：指定显示某些进程 -H：线程模式；示例：top -H -p PID，指定显示某个进程的所有线程 EPEL源的htop，功能更丰富的进程管理工具 内存空间使用状态：free -h：易读格式 -s n：指定刷新间隔为n秒 查看虚拟内存使用状态：vmstat 系统监控工具： iostat：统计CPU和设备IO信息 iftop：显示带宽使用情况，EPEL源 dstat：替代iostat,vmstat,ifstat iotop：I/O监视器 nload：查看网络实时吞吐量 lsof：list open files；恢复文件： 进程信号与计划任务实现","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"matplotlib","slug":"matplotlib","date":"2019-12-05T04:50:04.000Z","updated":"2019-12-06T06:38:21.568Z","comments":true,"path":"Python/matplotlib/","link":"","permalink":"http://thmasterplan.cn/Python/matplotlib/","excerpt":"","text":"基本用法 1234567import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1,1,50)y = x**3+1plt.plot(x,y)plt.show figure 123456789101112131415161718192021222324import matplotlib.pyplot as pltimport numpy as npx = np.linspace(-1,1,50)y = x**3+1y2 = x**2-2plt.figure() #创建一张图plt.plot(x,y,label='up')plt.plot(x,y2,color='red',linewidth=1.5,linestyle='--',label='down')plt.legend()#设置图例，需在调用plot()方法时指定label#plt.annotate()该方法对图中数据作详细注释#plt.text()该方法在作简单的文本注释plt.xlim((-1,2)) #设置x轴范围plt.ylim((-2,3)) #设置y轴范围#plt.xticks(np.linspace(-1,2,5)) #设置x轴范围并均匀划分为5段#plt.yticks([-2,0,3],['bad','normal','good']) #以文字代替数字表示y轴范围plt.xlabel('This is x') #设置x轴的标签plt.ylabel('This is y')plt.show() 散点图 123456789plt.figure()X = np.random.normal(0,1,1024)Y = np.random.normal(0,1,1024)T = np.arctan2(Y,X)plt.scatter(X,Y,s=75,c=T,alpha=0.5)#plt.bar()柱状图plt.xlim((-1.5,1.5))plt.ylim((-1.5,1.5))plt.show() subplot 1234567891011121314plt.figure()plt.subplot(2,2,1)plt.plot([0,1],[0,1])plt.subplot(2,2,2)plt.plot([0,1],[0,2])plt.subplot(2,2,3)plt.plot([0,1],[0,3])plt.subplot(2,2,4)plt.plot([0,1],[0,4])plt.show()","categories":[{"name":"Python","slug":"Python","permalink":"http://thmasterplan.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://thmasterplan.cn/tags/Python/"}]},{"title":"Numpy_Pandas","slug":"Numpy-Pandas","date":"2019-12-05T04:49:23.000Z","updated":"2019-12-05T13:27:39.968Z","comments":true,"path":"Python/Numpy-Pandas/","link":"","permalink":"http://thmasterplan.cn/Python/Numpy-Pandas/","excerpt":"","text":"Numpy 创建数组： 1234567891011121314151617import numpy as nparr = np.array([[1,2,3],[4,5,6]])print(arr)print('元素类型：',arr.dtype) #默认为int32，也可在np.array()中指定参数dtype=np.float/np.float32/...print('维度:',arr.ndim) #2print('形状:',arr.shape) #（2，3）print('大小：',arr.size) #6arr = np.zeros((3,4)) #返回3行4列全为0的二维数组arr = np.ones((2,2)) #返回2行2列全为1的二维数组arr = np.arange(12,20, 2).reshape((2,2)) #arange返回一个一维数组，取值区间为[12,20)步长为2，数组的reshape方法将其变为2行2列的二维数组并返回arr = np.linspace(1,10,10) #生成等差数列 基础运算 1234567891011121314151617181920212223242526272829a = np.array([2,4,6,8])b = np.arange(4)print(a-b) #[2 3 4 5]print(b**2) #[0 1 4 9]print(np.sin(a)) #[ 0.90929743 -0.7568025 -0.2794155 0.98935825]print(10*np.cos(b)) #[10. 5.40302306 -4.16146837 -9.89992497]print(b==2) #[False False True False]a = np.array([[1,2], [0,1]])b = np.arange(4).reshape(2,2)print(a*b) #对应位置做乘法：[[0 2] [0 3]]print(a.dot(b)) #矩阵乘法：[[4 7] [2 3]]a = np.random.random((2,2)) #随机生成两行两列的二维数组print(a)print(np.sum(a)) #求数组a中所有元素之和print(np.min(a,axis=1)[1]) #axis=1表示取每一行的最小值，axis=0表示取每一列的最小值print(np.max(a)) #求最大值print(np.argmin(a)) #最小值的索引print(np.argmax(a)) #最大值的索引print(np.mean(a)) #求平均值print(np.median(a)) #求中位数print(np.cumsum(a)) #求累加和，返回一个数组print(np,sort(a)) #返回每一行的排序结果（二维数组）print(a.T) #转置二维数组 访问数组： 12345678910A = np.arange(1,12).reshape(3,4)print(A[1,1:2]) #5；格式：A[行，列]，同时可分别对行、列做切片操作for row in A: print(row) #迭代打印每一行for col in A.T: print(col) #迭代打印A每的一列for item in A.flat: print(item) #迭代访问二维数组的每一个元素 数组的合并和分割： 1234567891011121314A = np.array([1,2,3])B = np.array([4,5,6])print(np.vstack((A,B))) #垂直合并#[[1 2 3]# [4 5 6]] print(np.hstack((A,b))) #水平合并#[1 2 3 4 5 6]A = np.arange(12).reshape(3,4)# 等量分割：np.split(A,3,axis=0) &lt;==&gt; np.vsplit(A,3) # np.split(A,2,axis=1) &lt;==&gt; np.hsplit(A,2)#不等量分割：np.array_split(A,3,axis=1) copy与deepcopy 12345a = np.arange(4) # a=[0,1,2,3]b = a # b=[0,1,2,3] 浅拷贝a[0] = 10 # b=[10,1,2,3],也即b是a的引用,a改变b也会改变b = a.copy() #deep copy：b是一个新的对象 NumPy 中包含了一个矩阵库numpy.matlib，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象 Pandas Pandas处理三类数据结构：Series、DataFrame、Panel，它们均构建在Numpy数组之上；DataFrame是Series的容器，Panel是DataFrame的容器。 Series是具有均匀数据的一维数组结构，其尺寸大小不可变 12345678s = pd.Series([1,2,3,np.nan,5])print(s)# 0 1.0# 1 2.0# 2 3.0# 3 NaN# 4 5.0# dtype: float64 DataFrame是一个具有异构数据的二维数组，一个表格其每一列的数据类型可以不同 12345678910dates = pd.date_range('20190101',periods=6)df = pd.DataFrame(np.random.randn(6,4),index=dates,columns=['a','b','c','d'])#可以传入字典print(df)# a b c d#2019-01-01 -0.151005 0.193516 -2.719792 -0.889789#2019-01-02 1.454217 -0.251116 0.115353 1.467178#2019-01-03 2.329084 -1.141316 -0.566037 -0.012965#2019-01-04 0.230406 0.466682 0.156473 1.464802#2019-01-05 0.628908 0.093684 -0.342491 -0.215695#2019-01-06 -1.175620 1.210320 0.352923 -0.112040 Panel是具有异构数据的三维数据结构 数据选取 12345678910111213141516171819202122232425262728df = pd.DataFrame(np.arange(12).reshape(3,4),index=['A','B','C'],columns=['a','b','c','d'])print(df)# a b c d# A 0 1 2 3# B 4 5 6 7# C 8 9 10 11print(df['a']) #或者print(df.a),打印选取的某列，不能选行，数组类型# A 0# B 4# C 8# Name: a, dtype: int32print(df.loc['A']) #打印行，数组类型 &lt;==&gt;df.iloc[0]# a 0# b 1# c 2# d 3# Name: A, dtype: int32print(df[1:2]) #打印行，DataFrame类型# a b c d# B 4 5 6 7print(df['A':'B']) #打印行，DataFrame类型# a b c d# A 0 1 2 3# B 4 5 6 7 导入导出数据 12data = pd.read_xxx('fileName.xxx') #读取哪种格式的文件就用对应的方法data.to_yyy('newFileName.yyy') #保存为哪种格式的文件就用对应的方法 合并 12345678910111213141516171819202122232425262728df1 = pd.DataFrame(np.ones((2,2))*0,columns=['a','b'])df2 = pd.DataFrame(np.ones((2,2))*1,columns=['a','b'])df3 = pd.DataFrame(np.ones((2,2))*2,columns=['a','b'])print(pd.concat([df1,df2,df3],axis=0,ignore_index=True))# a b# 0 0.0 0.0# 1 0.0 0.0# 2 1.0 1.0# 3 1.0 1.0# 4 2.0 2.0# 5 2.0 2.0df1 = pd.DataFrame(np.ones((2,2))*0,columns=['a','b'])df2 = pd.DataFrame(np.ones((2,2))*1,columns=['b','c'])print(pd.concat([df1,df2],ignore_index=True))#默认为外连接# a b c# 0 0.0 0.0 NaN# 1 0.0 0.0 NaN# 2 NaN 1.0 1.0# 3 NaN 1.0 1.0print(pd.concat([df1,df2],join='inner',ignore_index=True))# b# 0 0.0# 1 0.0# 2 1.0# 3 1.0#pd.merge()也可用于合并","categories":[{"name":"Python","slug":"Python","permalink":"http://thmasterplan.cn/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"http://thmasterplan.cn/tags/Python/"}]},{"title":"磁盘管理","slug":"磁盘管理","date":"2019-11-29T07:26:51.000Z","updated":"2019-12-02T06:47:09.737Z","comments":true,"path":"Linux/磁盘管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"磁盘工作原理 不同硬盘标识：a-z，aa，ab… ​ /dev/sda，/dev/sdb 同一磁盘的不同分区：1，2，… ​ /dev/sda1，/dev/sda2，… 磁盘存储术语：head(磁头)，track(磁道)，cylinder(柱面)，sector(扇区) 磁盘使用步骤：磁盘分区 -&gt; 分区上创建文件系统 -&gt; 将分区挂载到目录 分区管理 分区原因 隔离系统和程序，可安装多个OS 采用不同文件系统 优化I/O性能 实现磁盘空间配额限制 提高修复速度 MBR分区管理 分区不超过2T 一块硬盘最多有4个主分区，也可以3主分区+1扩展分区（扩展分区包含N给逻辑分区） MBR分区结构： GPT分区管理 支持128个分区，分区可达ZB级别 GPT分区结构 分区管理命令 列出块设备：lsblk 查看块设备的UUID（通用唯一识别码）：blkid 创建分区： 创建MBR分区：fdisk fdisk -l查看当前分区情况 fdisk [device]，管理分区，常用子命令： p：分区列表 t：更改分区ID（输入L查询，不同的ID标识分区的类型） n：创建新分区 d：删除分区 v：校验分区 u：转换单位 w：保存退出 q：不保存退出 fdisk实时更改硬盘的分区，分区完成后注意与内存分区表同步（partprobe），查看内核是否已经识别新的分区cat /proc/partitions。 创建GPT分区：gdisk，用法与fdisk相似 高级分区操作：parted parted命令操作都是实时生效，需谨慎操作 parted /dev/sdb mklabel gpt：设置/dev/sdb这块磁盘为gpt类型 parted /dev/sdb print：打印/dev/sdb的分区信息 parted /dev/sdb mkpart primary 1 200：设置一个分区，从1MB到200MB，大小为199MB（注意分区需是连续空间） parted /dev/sdb rm 1：删除第一个分区 parted -l：列出所有硬盘的分区信息 重新设置内存中的内核分区表版本：partprobe 文件系统管理 查看当前OS支持的文件系统：cat /proc/filesystems 创建文件系统：mkfs -t [type] [device]：例如mkfs -t xfs /dev/sdb2，若要创建swap类型，使用mkswap /dev/xxx命令 管理文件系统： tune2fs：重新设定ext系列文件系统参数的值 -l：查看指定文件系统superblock信息 -L &#39;LABEL&#39;：修改卷标 -O：文件系统属性的启用或禁用 dumpe2fs：显示ext文件系统信息，将磁盘块分组管理 xfs_info 挂载点：显示已挂载的xfs文件系统信息 文件系统检测和修复： 文件系统故障常发生于死机或非正常关机后，注意一定要取消挂载后执行修复命令 fsck 、e2fsck、xfs_repair 常用工具： df：查看文件系统和磁盘空间使用情况，常用选项-T,-h du -h /xxx/yyy：查看某目录总体空间占用状态，--max-depth=3指定最大目录层级为3 dd：convert and copy a file 用法：dd if=/x/y of=/a/b bs=# count=# if=/x/y：从指定文件读取 of=/a/b：写入到指定文件 ibs=size：一次读size个字节 obs=size：一次写size个字节 bs=size：block size，指定块大小(既是ibs也是obs) cbs=size：一次转换size个字节 skip=blocks：从开头忽略blocks个ibs大小的块，只复制之后的内容 seek=blocks：从开头忽略blocks个obs大小的块，用if中复制的内容替换blocks个obs大小的块之后的内容。 count=n：复制n个bs 备份： dd if=/dev/sdx of=/dev/sdy：整盘备份到另一磁盘 dd if=/dev/sdx of=/xxx/image：整盘备份到文件 dd if=/dev/sdx | gzip &gt; /xxx/image.gz：整盘备份并压缩 恢复： dd if=/xxx/image of=/dev/sdx gzip -dc /xxx/image.gz | dd of=/dev/sdx 挂载设备 将分区挂载到目录，则该目录下的文件都存储于该分区中；若有其他分区挂载在该目录的子目录下，则子目录下的文件存储与另一分区中。 挂载点下原有文件在挂载完成后会被临时隐藏，因此挂载点目录一般为空。 一个分区可以同时挂载在多个目录下，一个目录只能与一个分区关联 实现永久挂载需要写入配置文件/etc/fstab，使用blkid查看UUID（也可使用设备分区名例如/dev/sda2）并按格式写入配置文件；若需要更改挂载点所属文件系统属性（是否启用acl，suid，exec等），亦可在该配置文件中更改，默认为defaults，然后mount -o remount /dev/xxx重新挂载使更改生效 swap的挂载：写入/etc/fstab，挂载点和文件系统均为swap，保存退出后键入swapon -a;swapoff命令取消交换分区。 mount /dev/sda2 /mnt：将分区sda2挂载在/mnt目录下 -r：只读挂载 -w：读写挂载，默认 mount -B 目录1 目录2：类似与软连接的效果，两个目录的文件共享。 -o options：挂载文件系统的选项 umount /mnt：取消挂载 cat /etc/mtab：查看目前的挂载情况 查看挂载情况：findmnt 挂载点/设备分区 查看正在访问指定挂载点的进程：lsof 挂载点、fuser -v 挂载点 终止所有正在访问指定挂载点的进程：fuser -km 挂载点 外围设备使用 使用光盘： 手动挂载：mount /dev/cdrom /mnt 操作光盘：eject弹出光盘；eject -t弹入光盘 创建ISO文件：cp /dev/cdrom /root/xxx.iso；mkisofs -r -o ./xxx.iso /etc… 挂载USB介质： 查看USB设备是否识别：lsusb 被内核探测为SCSI设备：/dev/sdaX、/dev/sdbX或类似的设备文件 手动挂载：mount /dev/sdbX /mnt 管理虚拟内存 swap交换分区是系统内存的补充，支持虚拟内存，当没有足够的内存保存系统处理的数据时会将数据写入swap分区 推荐系统swap空间 | 系统RAM | 推荐的swap空间 | 允许机器休眠的swap建议 || :————: | :——————: | :——————————: || 低于2GB | RAM的倍数 | RAM的三倍 || 2GB - 8GB | 等于RAM | RAM的倍数 || 8GB - 64GB | 8GB | RAM的1.5倍 || &gt; 64GB | 16GB | 不建议使用休眠功能 | free：查看内存使用情况 RAID管理 RAID：Redundant Arrays of Independent Disks（独立冗余磁盘阵列） 提高IO能力：磁盘并行读写 提高容错性 多块磁盘组织在一起工作 实现方式： 外接式：通过扩展卡提供适配能力 内接式：主板集成RAID控制器，安装OS前在BIOS里配置 软件RAID：软件实现 RAID级别： RAID-0：同一文件分块存储在多块硬盘上，读写性能提升，无容错能力 RAID-1：同一文件完全一样地存储于两块磁盘（镜像），读性能提升，写性能略有下降，有容错能力，磁盘利用率只有一半 RAID-5：读写性能提升，至少3块磁盘，有容错能力（允许最多1块磁盘损坏），每一块磁盘都划分一部分空间充当校验位 RAID-6：读写性能提升，至少4块磁盘，两个校验位，允许最多2块磁盘损坏，容错性较RAID-5高 RAID-10与RAID-01（实际使用RAID-10，RAID-10容错性较RAID-01好） RAID-50 RAID-7：自身带操作系统和管理工具，理论上性能最高的RAID模式 LVM（逻辑卷管理器） LVM：允许对卷进行方便操作的抽象层 将物理块设备指定为物理卷 用多个物理卷来创建一个卷组（物理卷是用固定大小的物理区域[PE,physical extent]来定义的） 从卷组中划分逻辑卷，可在逻辑卷上创建文件系统，逻辑卷大小可扩展。 示意图： 使用逻辑卷步骤： 将设备指定为物理卷，例如pvcreate /dev/sdb1 /dev/sdd或pvcreate /dev/sd{b1,d}，同时将分区和磁盘指定为物理卷。（如果是分区，需要将分区ID改为8e，表示Linux LVM类型） 用多个物理卷创建卷组，vgcreate [选项] vgName pv1 pv2 ...，例如vgcreate -s 16M vg0 /dev/sdb1 /dev/sdd，选项-s指定PE大小。 从卷组中划分逻辑卷，lvcreate -n mysql -L 8G vg0，-n指定逻辑卷名，-L指定大小，-l也是指定大小但是单位是PE个数。 ll /dev/vg0/mysql发现/dev/vg0/mysql为软链接，指向/dev/dm-0，其另一软链接为/dev/mapper/vg0-mysql，若继续创建逻辑卷，其真实设备名依次为/dev/dm-1、/dev/dm-2… 在逻辑卷上创建文件系统，mkfs.xfs /dev/vg0/mysql 挂载，mount /dev/vg0/mysql /mnt/mysql；将挂载写入配置文件/etc/fstab，在vim扩展命令模式下键入r!blkid /dev/vg0/mysql进行修改 列出现有的物理卷：pvs、pvdisplay 列出现有卷组：vgs、vgdisplay 列出现有逻辑卷：lvs、lvdisplay 扩展现有逻辑卷：lvextend -l +48%free /dev/vg0/mysql：剩余卷组的48%分配给逻辑卷，亦可使用PE数进行分配lvextend -l +200 /dev/vg0/mysql；此时使用lsblk或者fdisk -l查看已分配成功，但是df查看并未改变，还需要为新扩展的逻辑卷创建相同的文件系统 xfs：xfs_growfs 挂载点 ext：resize2fs 逻辑卷名（注意xfs与ext的区别） 亦可一次搞定（加上-r选项）：lvextend -r -l +xxx /dev/vg0/mysql 扩展现有的卷组：vgextend vg0 PV名 删除逻辑卷、卷组、物理卷：迁移数据 -&gt; umount /mnt/mysql -&gt; lvremove /dev/vg0/mysql -&gt; vgremove vg0 -&gt; pvremove /dev/sdb1 /dev/sdd LVM快照管理： 逻辑卷的快照需要与该逻辑卷在同一个卷组，且快照的容量小于等于逻辑卷 逻辑卷中每一个发生修改的文件都会备份到快照中 使用快照： lvcreate -n mysql_snapshot -s -L 1G /dev/vg0/mysql：创建逻辑卷mysql的快照，选项-s用于创建快照，快照上的文件系统与原逻辑卷相同 挂载快照到目录：mount -o nouuid /dev/vg0/mysql_snapshot /mnt/snap，由于快照的UUID与原逻辑卷一样，所以挂载时需要指定nouuid选项，不然挂载不上（xfs是这样，ext4不用） 还原快照到逻辑卷（逻辑卷恢复为快照）： umount /mnt/snap,umount /mnt/mysql：卸载快照和逻辑卷 lvconvert --merge /dev/vg0/mysql_snapshot：还原，此时快照已经删除 mount /dev/vg0/mysql /mnt/mysql：重新挂载","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Linux软件安装和包管理","slug":"Linux软件安装和包管理","date":"2019-11-25T04:47:01.000Z","updated":"2019-11-29T07:25:41.582Z","comments":true,"path":"Linux/Linux软件安装和包管理/","link":"","permalink":"http://thmasterplan.cn/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"","text":"软件运行环境 静态链接：libxxx.a，程序对应的依赖库复制到程序包，占用空间多,迁移容易，升级难，需重新编译。 动态链接：libxxx.so，只把依赖做一个动态链接，占用空间少。 ldd 命令：查看二进制程序所依赖的共享库文件。 ldconfig -p：查看本机已经缓存的所有可用库文件名及文件路径映射关系。 程序包的来源 管理程序包： 使用包管理器：rpm 使用前端工具：yum,dnf 获取程序包的途径：官方服务器，镜像站点，epel源（Extra Packages for Enterprise Linux） rpm包管理 rpm: redhat package manager，rpm包中是已经编译好的程序文件。 /var/lib/rpm/：数据库，其中包含了所有rpm包的名称及版本，依赖关系，功能说明，包安装后生成的各文件路径及校验码信息。 rpm -ivh [install-options] PACKAGE_FILES： -i：安装 -v：显示安装过程 -h：显示程序包管理执行进度 -q：查询包是否安装，与-l一起使用，列出包中的文件；与-f使用，查询文件的所属包；-a，查询所有安装的包 -e：卸载 -U：升级 -V：包校验 …其余查询man帮助 yum管理 YUM：Yellowdog Update Modifier，rpm的前端程序，基于C/S架构，可解决软件包相关依赖性，可在多个库之间定位软件包 配置yum源：/etc/yum.repos.d/路径下xxx.repo中配置源服务器路径，yum命令安装时，查询本地repo源 -&gt; 查询服务器端元数据 -&gt; 下载元数据到缓冲区 -&gt; 下载rpm包到缓冲区 -&gt; 按依赖顺序安装包。 使用本地光盘配置yum源 检查是否安装autofs(自动挂载服务) systemctl start autofs：启动 systemctl enable autofs：设置开机自启动 systemctl status autofs：查看服务状态 ls /misc/cd -&gt; df：光盘/dev/sr0已自动挂载到/misc/cd目录下 cd /etc/yum.repos.d/，将原有的国外源删除（备份），创建一个新的以.repo结尾的配置文件，例如创建base.repo,配置如下 1234[base]name=cdrom basebaseurl=file:///misc/cdgpgcheck=0 yum repolist：查看可用的repo列表 网络源配置 可单独创建一个xxx.repo，也可在现有的repo中追加，例如在base.repo中追加 1234[epel]name=aliyun epelbaseurl=https://mirrors.aliyun.com/epel/$releasever/$basearch/gpgcheck=0 其中releasever变量代表当前OS发行版本，basearch代表cpu架构 yum clean all：清空yum源缓存 yum list：列出repo源所有包 yum install xxx：安装 yum remove xxx：删除 yum update pkgxxx yum info xxx：查看详细信息 定制yum仓库 使用httpd定制本地yum源 dnf管理 centos8之后默认安装 源码编译安装 首先使用wget URL下载好源码包 C/C++：make项目管理器 安装gcc 解压，进入到源码包目录中，运行./configure，通过选项传递参数指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile（安装前查看源码包中的说明帮助文档README、INSTALL等，亦可通过./configure --help查看可选项） make -j n根据Makefile文件，构建应用程序，j选项表示多线程并行编译。 make install 更改PATH Java：maven","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"压缩与解压缩","slug":"压缩与打包","date":"2019-11-23T00:43:05.000Z","updated":"2019-11-23T13:25:30.409Z","comments":true,"path":"Linux/压缩与打包/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/","excerpt":"","text":"一、压缩、解压缩工具 .Z后缀 compress：压缩后会删除原文件，可读取STDOUT内容进行压缩，支持管道 -c：结果输出至标准输出，不删除原文件。常见用法：compress -c file &gt; file.Z -v：显示详情 uncompress file.Z zcat file.Z：不显示解压缩的前提下查看文本文件内容 .gz后缀 gzip： -c：同compress -c -#：#取1-9，指定压缩比，值越大压缩比越大 gunzip file.gz zcat file.Z .bz2后缀 bzip2： -k： -#：默认为9 bunzip2 file.bz2 bzcat file.bz2 .xz xz： -k： -#：默认为6 unxz xzcat 一般来说压缩比：xz &gt; bzip2 &gt; gz &gt; compress，均不能压缩目录 .zip zip：支持压缩目录 unzip 二、打包(存档)和解包工具 tar常见用法：具体选项见man帮助 打包，保留权限：tar -cpvf xxx.tar file1 file2 file3... 追加文件至xxx.tar：tar -rf xxx.tar file1 file2..注：不支持对压缩文件追加 查看包中的文件列表：tar -tf xxx.tar 解包tar -xf xxx.tar [可选：-C /PATH] 结合压缩工具，打包并压缩： tar zcvf xxx.tar.gz [可选：/PATH]；.tar.gz也可写成.tgz tar jcvf xxx.tar.bz2 [可选：/PATH] tar Jcvf xxx.tar.xz [可选：/PATH] --eclude=/PATH/文件名：打包时排除某文件：tar -zcvf xxx.tgz --exclude=/a/b/abc.txt -T：指定打包列表；-X：指定排除列表 tar -zcvf xxx.tgz -T /a/list -X /a/excludeList split：分割一个文件为多份小文件 split -b SIZE xxx.tgz yyy：yyy为切割后的文件前缀，SIZE为每份大小 合并：cat yyy* &gt; xxx.tgz cpio：一种老的存档格式。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"文件查找工具","slug":"文件查找工具","date":"2019-11-22T07:44:54.000Z","updated":"2019-11-23T13:25:06.354Z","comments":true,"path":"Linux/文件查找工具/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"","text":"文件查找 在文件系统上查找符合条件的文件 非实时查找（数据库查找）：locate 查询系统上预建的文件索引数据库/var/lib/mlocate/mlocate.db 索引构建过程需要遍历整个根文件系统，极消耗资源 查找速度快，模糊查找，非实时，搜索的是文件的全路径，可手动更新updatedb 选项： -i：不区分大小写 -n N：只列举前N个匹配项目 -r：使用基本正则表达式 实时查找：find 通过遍历指定路径完成文件查找 查找速度略慢，精确，实时 语法：find [选项] [查找路径] [查找条件] [处理动作] 选项： -maxdepth level：最大搜索目录深度，指定目录下的文件为第1级 -mindepth level：最小搜索目录深度 -depth：先搜索文件，再搜索目录；不加该选项时默认为先搜目录再搜文件 查找路径：默认为当前目录 查找条件：可以查找文件名，大小，类型，权限等，默认为找出指定路径的所有文件 根据文件名和inode -name 文件名：支持文件通配符 -iname 文件名：不区分字母大小写 -inum n：按inode号查找 -samefile 文件名：相同inode号的文件 -links n：链接数为n的文件 -regex &#39;PATTERN&#39;：匹配整个文件路径而非文件名 根据owner,group -user 用户名 -group 组名 -uid UID -gid GID -nouser：比如某个用户被删除，但其文件还存在 -nogroup 根据文件类型 -type TYPE：TYPE包括f,d,l,s,b,c,p 空文件或目录：-empty，例如find /usr -type d -empty 根据文件大小 -size SIZE，常用单位k,M,G 对于SIZE的写法，-6k代表[0,5k]，6k代表(5k,6k]，+6k代表(6k,+∞) 根据时间 -atime/-mtime/-ctime -amin/-mmin/-cmin find ./ -mtime -3，代表[0,3）天内被修改，find ./ -mtime 3代表第3天被修改，find ./ -mtime +3代表被修改3天以上。 根据权限 -perm (/|-) MODE0配 MODE：精确权限匹配 /MODE：u,g,o中只要匹配到一个即可 -MODE：u,g,o必须同时满足指定权限 例如find ./ -perm -222指u,g,o均要有写权限才满足条件 不想搜索某目录时：使用-path &#39;目录&#39; -a -prune，例如find / -path &#39;/etc&#39; -a -prune -o -name passwd在根目录下除/etc外搜索文件名为passwd的文件。 组合条件：与：-a；或：-o；非：-not/!。即将以上各种条件组合使用查找。当需要使用括号时要转义。例如find /usr \\(-name &quot;f*&quot; -o -type f\\) -ls。 处理动作：对符合条件的文件做操作，默认输出至屏幕 -print：默认的处理动作，显示至屏幕 -ls：类似于对查找到的文件执行ls -l命令 -delete：删除查找到的文件 -fls file：查找到的所有文件的长格式信息保存至指定文件中。等价于-ls &gt; file -ok cmd {} \\;：对查找到的每个文件执行由cmd指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认 -exec cmd {} \\;：对查找到的每个文件执行由cmd指定的命令 {}用于引用查找到的文件名称自身，包含路径名。 xargs：cmd1 | xargs [选项] cmd2 xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。 xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。 xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。 之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令 具体选项见man帮助 举例：find linux-5.1.4/ -name &quot;*.c&quot; | xargs -n1 cat | wc -l统计出linux内核一共有多少行c代码；cat `find linux-5.1.4/ -name &quot;*.c&quot;`|wc -l实际运行更快。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Shell编程","slug":"Shell编程","date":"2019-11-20T09:05:48.000Z","updated":"2019-11-23T13:23:43.860Z","comments":true,"path":"shell编程/Shell编程/","link":"","permalink":"http://thmasterplan.cn/shell%E7%BC%96%E7%A8%8B/Shell%E7%BC%96%E7%A8%8B/","excerpt":"","text":"一、shell脚本基础 shell：解释型语言 在脚本首行需注释使用的解释器类型，比如#!/bin/bash，#!/usr/bin/python等。 bash -n xxx.sh：执行语法检查 bash -x xxx.sh：解释执行的同时一边执行一边打印执行结果。 变量不用事先声明，可随时改变类型；不同数据类型之间可直接运算而不用做类型转换；常用类型为字符，整型，浮点型。 变量命名规则： 只能使用数字、字母及下划线，且不能以数字开头。 shell中命名建议： 变量名大写 局部变量小写 函数名小写 显示已定义的所有变量：set 注意脚本中定义别名不生效。 二、特殊位置变量 pstree -p：查看进程树 getent：查看系统数据库的相关记录，例如getent passwd root，查看passwd库中root的信息。 变量BASHPID：当前bash进程的pid (命令列表)：该语法的作用，小括号会开启一个subbash，其中的命令和变量只是临时生效，当命令列表执行完毕，将会退出subbash。要想退出当前进程，则需使用{命令列表}。 环境变量：子进程，父进程均可访问 定义方式：export NAME=abc、declare -x NAME=abc 变量引用：$NAME、${NAME} 显示所有环境变量：env、export、declare -x、printenv 删除变量：unset 子进程更改环境变量，父进程访问相同环境变量不变。 只读和位置变量： 只读变量（常量）：只能声明，但不能修改和删除 声明：readonly NAME、declare -r NAME 查看：readonly -p 退出当前bash自动删除 位置变量： $1代表脚本的第一个参数，$2代表脚本的第二个参数。。。 $*或者$@：脚本的所有参数；前者全部参数合为一个字符串，后者每个参数为独立字符串。 $#：脚本的参数个数 $0：脚本的路径及脚本名 set --：清空所有位置变量 例如rm a b c：则$1在脚本中代表a；$*为a，b，c；$#为3。 退出状态：进程使用退出状态来报告成功或失败，0代表成功，1-255代表失败。$?变量保存最近的命令退出状态。 三、算术逻辑运算和条件测试 算术运算：+,-,*,/,%,**（乘方），乘法符号有些场景需要转义。 let var=算术表达式 var=$[算术表达式] var=$((算术表达式)) var=$(expr arg1 arg2 arg3...) declare -i var = xxx echo &#39;算术表达式&#39;|bc RANDOM：系统随机数变量，随机生成0-32767之间的数。 逻辑运算： 短路与：cmd1 &amp;&amp; cmd2：如果cmd1结果失败，不执行cmd2；如果cmd1成功，执行cmd2。 短路或：cmd1 || cmd 2：如果cmd1成功，不执行cmd2；如果cmd1失败，执行cmd2。 cmd1 &amp;&amp; cmd2 || cmd3，cmd1失败，则执行cmd3；cmd1成功，则执行cmd2，根据cmd2的结果进一步判断是否执行cmd3，一般来说cmd2是执行成功的所有不会再进一步执行cmd3，因而该写法类似于其他语言中的x ? y : z。 条件测试： test EXPRESSION或者[ EXPRESSION ]或者[[ EXPRESSION ]]，EXPRESSION前后必须要有空格，其中[[]]语法支持正则表达式。 help test：查看相关选项 脚本练习：查看磁盘最大使用率 123#!/bin/bashvar=`df | grep '/dev/sda' | sort -rn | head -1 | tr -s ' ' % | cut -d% -f5`test $var -gt 80 &amp;&amp; echo \"disk is almost full\" || echo \"the use rate of the disk is $var\" bash的数值测试： -v VAR：变量VAR是否设置 -gt：是否&gt; -ge：是否&gt;= -eq：是否= -ne：是否!= -lt：是否&lt; -le：是否&lt;= bash的字符串测试： =：是否等于 &gt;：ASCII码值是否大于 &lt; != =~：左侧字符串是否能够被右侧的PATTERN所匹配，例如[[ &#39;abcde&#39; =~ [[:digit:]] ]]，返回false，因为左侧字符串不包含数字。 bash的组合测试条件 判断某文件是否是.sh结尾并且可执行，file=./test.sh; [[ $file =~ \\.sh$ ]] &amp;&amp; [ -x $file ] ，也可以这样写[ &quot;$file =~ \\.sh$&quot; -a &quot;-x $file&quot; ]即使用-a选项。 [ EXPRESSION1 -a EXPRESSION2 ]表示与，[ EXPRESSION1 -o EXPRESSION2 ]表示或。 read：从标准输入读一行，例如read -p &quot; Please input your name&quot; NAME，则用户输入的值赋给NAME变量。 -p：指定要显示的提示 -s：静默输入，一般用于密码 -n N：指定输入的字符长度N -d &#39;字符&#39;：输入中出现该字符即结束输入。 -t N：超时时长N秒 四、条件分支 ```if [ EXPRESSION ];then 条件为真的分支代码 else 条件为假的分支代码 fi 或者if [ ];then xxxxxelif [ ];then xxxxxelif [ ];then xxxxx…….else yyyyyfi 1234567891011121314- ```shell case $NUM in 1|3|5) cmd1 ;; 2|4|6) cmd2 ;; ... *) cmdN ;; esac 五、脚本安全 set -u：在脚本前加上该语句，在引用一个未设置的变量时，显示错误信息，并且不执行含有未设置变量的语句。 set -e：如果一个命令执行失败就退出脚本。","categories":[{"name":"shell编程","slug":"shell编程","permalink":"http://thmasterplan.cn/categories/shell%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"},{"name":"shell编程","slug":"shell编程","permalink":"http://thmasterplan.cn/tags/shell%E7%BC%96%E7%A8%8B/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-11-20T07:16:10.000Z","updated":"2020-04-01T08:20:12.602Z","comments":true,"path":"Linux/正则表达式/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"元字符分类：字符匹配、匹配次数、位置锚定、分组字符匹配 .：匹配任意单个字符 \\：转义字符，例如\\.表示匹配.本身而非任意单个字符。 []：匹配指定范围内任意单个字符 [^]：匹配指定范围外的任意单个字符 [:alnum:]：字母和数字 [:alpha:]：任何英文大小写字符 [:lower:]：小写字母 [:upper:]：大写字母 [:digit:]：十进制数字 [:xdigit:]：十六进制数字 [:blank:]：空白字符（空格和制表符） [:space:]：水平和垂直的空白字符 [:cntrl:]：不可打印的控制字符（退格、删除等） [:graph:]：可打印的非空白字符 [:print:]：可打印字符 [:punct:]：标点符号 匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数 *：匹配前面的字符0或多次。注意与文件名通配符里*的区别。 .*：任意长度的任意字符。 \\?：匹配前面的字符0或1次。 \\+：匹配前面的字符至少1次。 \\{n\\}：匹配前面的字符n次。 \\{m,n\\}：匹配前面的字符至少m次，至多n次。 \\{,n\\}：匹配前面的字符至多n次。 \\{n,\\}：匹配前面的字符至少n次。 位置锚定：定位出现的位置 ^：行首锚定，用于模式的最左侧。例如grep ^[^#] xxx表示显示xxx中所有非#开头的行，即显示非注释行。 $：行尾锚定，用于模式的最右侧。 ^PATTERN$：用于模式匹配整行。^$可表示空行。 \\b：词首或词尾锚定，用于单词模式的左/右侧。 分组：\\(\\) \\(string\\)：其中string会被正则表达式引擎记录与内部的变量中，这些变量的命名方式为：\\1,\\2,\\3,...。 示例：\\(string1\\(string2\\)\\)：\\1：string1\\(string2\\)；\\2：string2。 例如：\\(root\\)\\{1,3\\}：可匹配1-3个root字符串。 扩展的正则表达式： 去掉\\","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"常见文本处理命令","slug":"常见文本处理命令","date":"2019-11-19T11:49:20.000Z","updated":"2019-11-26T14:20:37.984Z","comments":true,"path":"Linux/常见文本处理命令/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%B8%B8%E8%A7%81%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看文本内容： cat：适合查看小文本 -E：显示行结束符$ -n：对显示的每一行编号 -A：显示所有控制符 tac：从最后一行向前反向显示 rev：每一行都是反向显示 more、less：分页查看 文本截取： head -c#：获取前#字节 -#：获取前#行 tail -c#：获取后#字节 -#：获取后#行 -f：可用于日志监控，例如tail -f /var/log/messages，即时显示日志追加文本的变化。 按列抽取： cut：cut -d# -f1,3：以#作为分隔符，截取第1列和第3列 -d：指明分隔符 -f：指明字段 练习：获取网卡ip地址：ifconfig ens33 | head -2 | tail -1 | tr -s &quot; &quot; | cut -d&quot; &quot; -f3 排序和统计： 文本排序sort：把排序后的文本显示在STDOUT，不改变原始文件 -n：按照数字大小排序 -r：反向排序 -u：删除重复行 -t#：#作为字段界定符 -kX：选项按照使用#分隔的第X列来排序 uniq：删除连续重复的行 -c：显示重复出现的行的次数，常与sort命令一起使用；sort a.txt| uniq -c。 文本数据统计wc： wc test.txt：依次输出行数，单词数，字节数 -l：只计数行数 -w：只计数单词数 -c：只计数字节数 -m：只计数字符总数 -L：显示文件中最长行的长度 比较文件：diff和patch 按关键字抽取： grep：grep [选项] 模式 file文本搜索工具，根据指定模式[由正则表达式字符及文本字符所编写的过滤条件]对目标文本逐行进行匹配检查，打印匹配到的行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Java位运算","slug":"Java位运算","date":"2019-11-19T10:25:55.000Z","updated":"2020-04-05T14:35:37.605Z","comments":true,"path":"Java基础/Java位运算/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"Java位运算符 &amp; ：按位与。同时为1才为1，否则为0。 | ：按位或。有一个为1则为1。 ~ ：按位取反。例如3：补码：0b00000000000000000000000000000011。~3—&gt;得:0b11111111111111111111111111111100。(依旧为补码)。减一后取反得原码(原码-&gt;补码的逆运算)：0b1000000000000000000000000000100。故3取反后为-4。 ^ ：按位异或。不同为1，相同为0。 0与任何数字异或都等于它本身 一个数据对相同的数据异或两次，值不变,常应用于加密。即a^b^b == a。 使用异或实现两个变量值交换。a = a^b; b = a^b; a = a^b。 &lt;&lt; ：左移。左操作数乘以2的n次幂。n是右操作数，即左移的位数。右边空出两位补0，左边两位被挤掉。 &gt;&gt; ：右移。左操作数除以2的n次幂。n是右操作数，即右移的位数。左边空出两位用符号位填充，右边两位被挤掉。 例如：-32 &gt;&gt; 2 ：原码：10000000000000000000000000100000，反码：11111111111111111111111111011111，补码：11111111111111111111111111100000。右移后为：11111111111111111111111111111000。求得原码为：10000000000000000000000000001000。得-8。 &gt;&gt;&gt; ：无符号右移。左边空出的位置用0补全。例如-32 &gt;&gt;&gt; 2变成一个很大的正数。 位运算均针对补码进行。正数的符号位为0，原、反、补码均为其本身；负数的符号位为1，其反码为对原码除符号位其余所有位求反，补码为对反码+1。 对于有符号数，计算机中存储的是补码。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"网络安全总结","slug":"网络安全总结","date":"2019-11-19T10:21:36.000Z","updated":"2019-11-23T13:24:48.513Z","comments":true,"path":"安全/网络安全总结/","link":"","permalink":"http://thmasterplan.cn/%E5%AE%89%E5%85%A8/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"Security一、 介绍 网络安全五个特征： 保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。 完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。 可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需网络安全解决措施的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击； 可控性：对信息的传播及内容具有控制能力。 不可否认性：出现的安全问题时提供依据与手段。 安全机制: 加密机制 数字签名机制 访问控制机制 数据完整性机制 认证交换机制 通信业务流填充 路由控制 公证机制 普遍性安全机制 网络攻击方法: 被动攻击 主动攻击 物理临近攻击 内部人员攻击 软硬件装配攻击 二、 古典加密技术 代替密码：明文中的每个字符被替换成密文中的另一个字符 凯撒码 将明文转换为数字，使用加密函数E（m）=m+k(mod 26)得密文。解密函数D（c）=c-k(mod 26)。（只是字母简单的偏移） 维吉尼亚密码 密钥：一个字符串，对应一个数表 暴力破解需要26的k次方 代替密码特点： 单字母代换密码 ：明文中字母的出现频度、重复字母的模式和字母相互之间的结合模式等统计特性不变，安全性差。 多字母代替密码 ：字符块被成组加密 ，有利于抗击统计分析。 置换密码：又称换位密码（transposition cipher） ，并没有改变明文字母，只改变了这些字母的出现顺序。在对密文进行统计之后，易于判断该密文是否使用了置换密码加密方案。 Kerckhoffs假设：假定密码分析者知道对方所使用的密码系统，包括明文的统计特性，加密体制（操作方式、处理方法和加/解密算法）、密钥空间及其统计特性。但是，不知道密钥。在设计一个密码系统时，目标是在Kerckhoffs假设的前提下实现安全。 密码分析方法：尝试发现明文或密钥的过程 唯密文攻击：知道部分密文试图恢复明文，并试图推算密钥 已知明文攻击：知道部分消息密文及对应明文，试图推导密钥或算法 选择明文攻击：事先选择部分明文让被攻击者加密，并得到相应密文，试图推导出密钥或算法。 选择密文攻击：密码分析者需要掌握的内容包括：加密算法、截获的部分密文、自己选择的密文消息以及相应的被解密的明文。密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。由此能够计算出加密者的私钥或者分解模数，运用这些信息，攻击者可以恢复所有的明文。 维吉尼亚密码的密码分析 字母频率统计用于猜测 Kasiski测试法确定密钥长度 重合指数法破译密文 三、 对称加密 分组密码的设计原则 混乱原则：密码设计应保证明文与密文之间的依赖关系足够复杂。 扩散原则：密码设计应保证密钥的每位数字能够影响密文中的多位数字（避免对密钥逐段破译），同时应保证明文的每位数字能够影响密文中的多位数字（隐藏明文的统计特性）。 分组密码特点 优点：易于标准化，易于实现同步 缺点：不善于隐藏明文的数据模式，对于重放、插入、删除等攻击方式的抵御能力不强。 对称加密算法：DES/AES 分组密码工作模式 ECB（Electronic Codebook）: 电码本 用相同的密钥分别对明文分组独立加密 对长明文不安全，因为重复的明文块在密文中也是重复的 CBC（Cipher Block Chaining）：密文分组链接 加密算法的输入是上一个密文组和下一个明文组的异或 优点：能够隐蔽明文的数据模式；能够一定程度上防止分组的重放、插入和删除攻击。 缺点：易导致错误传播。任意一个明文或密文组出错会导致其后的密文分组出错。 CFB（Cipher Feedback）:密文反馈 一次处理s位（明文和密文均是），加密算法的输入是上一块密文，加密后产生的伪随机数输出与明文异或作为下一单元的密文。 实质是一种自同步流密码 适用于必须按比特或字符对明文进行加密的情况 OFB（Output Feedback）：输出反馈 与CFB类似，只是加密算法的输入是上一次加密算法的输出，且使用整个分组 优点：能够克服错误传播 缺点：很难发现密文被篡改；不具备自同步能力 CTR计数器 每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增 并行加密效率高 分组密码典型攻击方法 依据攻击者所掌握的信息：唯密文攻击、已知明文攻击、选择明文攻击 根据采用的技术方法 强力攻击（适用于任何分组密码算法）：穷尽密钥搜索、字典、查表、时间-存储权衡 差分密码分析 线性密码分析 差分-线性密码分析 攻击复杂度：数据复杂度（实施攻击所需输入的数据量）和处理复杂度（处理数据所需的计算量）。 对称密钥编码问题：通信密钥太多，管理与分发困难 四、 公钥加密 RSA原理 计算：(a x b) mod n = [(a mod n) x (b mod n)] mod n. RSA实现上的问题在构造n时应选择p和q的长度相差不大 RSA适合低频少量数据交换，如密钥分发；不适合数据量大，实时性强的场合（因为运算量大，慢） 五、 消息鉴别 概念：消息接收者对消息进行验证（真实性：确认并非假冒）（完整性：内容未被篡改）。 网络通信安全威胁：泄露、伪造、篡改、行为抵赖 鉴别与保密：鉴别不能自动提供保密性，保密性不能自动提供鉴别功能。 报文鉴别系统功能：鉴别算法（鉴别函数f产生鉴别码），鉴别协议，鉴别函数f是决定鉴别系统特性的主要因素。 鉴别函数分类： 以整个报文的密文作为鉴别符； 对称密钥加密：加密的同时提供保密和鉴别（强制明文具有某种结构） 附加报文鉴别结构：发送端：校验码C = f（M），密文X = Ek[M || C]; 接收端：Y = Dk(X) = [M’ || C’], 若f(M’) = C’,则报文可信。 公钥加密：提供报文鉴别和签名，不提供加密功能。 报文鉴别码(MAC)：核心是一个类似于加密的算法Ck()（k为密钥）, Ck(M)输出一个较短的定长数据分组也即MAC。发送[MAC || M]。接收端同样计算MAC，比较两个MAC是否相同。PS：MAC与加密函数比较：MAC可以是单向的，而加密函数必须可逆；MAC算法不能提供保密性。 散列函数方式（采用一个公共散列函数，将任意长度的报文映射为一个定长的散列值，并以散列值作为鉴别符）。（常用SHA-3，MD5）散列函数特性： 输入任意大小数据块，输出定长 容易计算 单向性：对任意散列值h要找到一个M使得H(M) = h不可行。 弱抗冲突性：对任意给定M，要找到M’ != M,使得H(M)=H(M’)计算上不可行。该性质可防止伪造。 强抗冲突性：要找到两报文M和N使他们散列值相同不可行。该性质指出散列函数对“生日攻击”的抵抗能力。 生日悖论攻击：伪造消息报文使hash值不变 中间符合攻击概念 六、 密钥建立和管理 密钥建立的模式：点到点（通信双方直接通信，分布式）；密钥分配中心KDC（用户与KDC有共享主密钥，KDC生成并分配会话密钥，集中式）；密钥转换中心KTC（只负责转发，集中式） Diff-Hellman密钥交换 如图，双方都计算出密钥为2 公钥加密体制的密钥分配：公钥的分配；使用公钥体制来分配对称密钥密码体制的密钥。 伪随机数生成器:线性同余算法；基于密码算法的随机数生成器（循环加密方式，DES的OFB模式）；BBS生成器； 密钥控制技术：密钥标签（DES的64位密钥中的8个校验位作为控制使用这一密钥的标签）；控制矢量 七、 用户认证 身份认证：密码，令牌（磁条卡，存储卡，智能卡），生物识别（虹膜，视网膜，指纹，签名，声音，脸） 口令破解：字典攻击，密码猜测，彩虹表攻击（可见密码不能明文存储，要求哈希后加salt，盐：随机字符） 口令的脆弱性：离线字典攻击；特定账户攻击；流行密码的攻击；单个用户的密码猜测；工作站劫持；电子监控；利用用户失误 Bad Passwords:过短的密码；易猜测的密码 Countermeasures：阻止未经授权访问密码文件；入侵检测措施；帐户锁定机制；自动工作站注销；加密的网络链接 八、 身份认证协议 Kerberos身份认证协议：集中式的认证服务器结构，认证服务器的功能是实现用户与其访问的服务器间的相互鉴别；采用对称加密技术 数字签名：直接数字签名仅涉及通信双方 使用公钥算法进行数字签名 假定接收方知道发送方的公钥 发送方用私钥加密整个消息或者消息的散列码 接收方用公钥解密即可确认发送方的身份 公钥基础设施(PKI) 提供三种安全服务： 认证：身份认证，采用数字签名实现 完整性：数据完整性，采用数字签名或消息认证码 机密性：采用对称加密 包括：认证机构CA，证书库，证书撤销，密钥备份和恢复，自动密钥更新，密钥历史档案，交叉认证，时间戳… X.509认证服务： X.509协议实现基于公钥加密算法和数字签名技术 证书由CA创建，CA用其私钥对证书签名，用户可用CA的公钥验证证书有效性并提取被认证的用户的公钥 九、 互联网安全协议和标准 IPSec:提供认证、保密性、密钥管理。优点：在传输层下，因而对应用程序、用户透明；抵抗旁路攻击；保护路由架构… IPSec架构： IPv6强制，IPv4可选 安全关联SA： 发送方和接收方之间的单向的关系，为数据流提供安全保障 由三个参数定义：Security Parameters Index (SPI)；IP Destination Address；Security Protocol Identifier 有一个安全关联数据库（） SA管理： 创建：先协商SA参数，再更新SAD；可人工创建，也可动态创建 删除：有效期过期；密钥遭破坏；另一端要求删除该SA 认证头(AH)： 提供数据整合和IP包认证 有限地抗重播攻击 基于消息认证码（MAC） 重放攻击：攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。 抗重播服务： 序列号字段：创建一个新的SA时，发送者会将序列号计数器初始化为0； 每当在这一SA上发送一个数据包，序列号计数器的值就加1并将序列号字段设置成计数器的值； 当达到其最大值2³²-1时，就应建立一个新的SA。 一种滑动窗口机制：IP是无连接的、不可靠的 ，需设立窗口；窗口的最左端对应于窗口起始位置的数据包序列号N，则最右端对应于可以接收的合法分组的最高序号N+WindowSize-1 ESP:提供保密性和抗重播服务 密钥管理:密钥生成和分发；AH和ESP各一对密钥； 安全套接层SSL： SSL的两个重要概念： SSL连接： 一个连接是一个提供一种合适类型服务的传输 SSL连接是端对端的 连接是暂时的 SSL会话： 一个SSL会话是在客户端和服务器之间的一个关联 会话由Handshake Protocal创建。会话定义了一组可供多个连接共享的加密安全参数 会话用以：避免为每一个连接提供新的安全参数所需的昂贵的谈判代价 十、 Hacking 攻击思路：信息收集，获取权限，安装后门（木马），扩大影响（攻击该网络其他主机），清除痕迹 安全评估 TCSEC，CC 十一、 信息收集（选择题） Web与搜索引擎服务 目标：获取目标网络或公司的URL，获取目标网络的拓扑结构 扫描目的：查看目标网络中哪些主机是存活的，查看存活的主机运行了哪些服务，查看主机提供的服务有无漏洞 IP扫描：判断目标网络有多少台主机存活（ping）（ping使用ICMP协议） 端口扫描：判断目标主机有哪些端口是打开的(TCP端口和UDP端口)（端口是入侵的通道） TCP扫描：TCP Connect，SYN，FIN UDP扫描 漏洞扫描 操作系统类型探测 十二、 缓冲区溢出 缓冲区：应用程序保存用户输入数据，程序临时数据的内存空间。缓冲区本质：数组。位置：堆、栈、数据段 溢出：用户输入数据长度超出了程序为其分配的内存空间，这些数据会覆盖其他程序数据的内存空间。 危害：程序异常，系统崩溃，程序跳到恶意代码，控制权被窃 溢出种类：堆溢出、栈溢出、整型溢出、格式化字符串溢出、其他溢出 溢出的共性：大对象向小对象复制数据，容纳不下造成溢出 避免缓冲区溢出漏洞： 人编写正确的代码 编译器进行数组边界检查 使用类型安全语言 RunTime保护 操作系统 硬件 十三、 Web脚本攻击 SQL注入攻击 ：把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令。步骤 绕过认证：conditions：账号密码的查询是同一条查询语句；密码没有加密保护 判断能否进行SQL注入 判断数据库类型及注入方法 猜测表名和字段名 猜测用户名和密码 预防 过滤关键字 限制输入长度 秘密字段使用散列函数保护 XSS跨站脚本攻击：通过在链接中插入恶意代码就能盗取用户信息。 预防 对动态生成页面的字符进行编码 对输入进行过滤限制 对动态内容使用HTML和URL编码 设置浏览器不执行任何脚本下载 十四、 DOS攻击 概念：利用网络协议漏洞或其他系统以及应用软件的漏洞耗尽被攻击目标资源，使得被攻击目标无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式。 原理：攻击者向服务器发送众多的带有虚假地址的请求，服务器发送回复信息后无限等待进而无法释放资源，连接超时后攻击者再度发送虚假请求。 DOS分类：SYN Flood（请求方不发送ACK），ping of death（ping请求数据包声称超过64K，接收方TCP/IP堆栈崩溃），teardrop… 发现僵尸网络：IDS（提取僵尸程序指纹信息），行为监测（僵尸程序行为模式），蜜獾捕获（捕获僵尸程序样本） 十五、 恶意代码、病毒、蠕虫 计算机病毒：是一个指令序列，能够把自身拷贝插入到其他主程序中 病毒模块：引导、传染、表现 病毒按链接方式分类： 操作系统病毒：用自己的运行逻辑取代系统的正常逻辑模块 外壳型：将病毒本身包围在宿主程序周围，对原来程序不作修改 入侵型：将病毒插入攻击目标之中，一旦感染难以发现清除 源码病毒：利用java, VBS等网络语言编写放在e-mail附件或HTML主页中。 按传染对象分类：磁盘引导型（磁盘引导区），文件型（可执行文件），宏病毒（office系列） 检测病毒方法： 特征代码法：采样，提取特征代码，特征代码纳入病毒特征数据库，打开被检测文件检索，若出现新病毒重复1-3步 校验和法：在文件被感染前根据文件内容计算校验和保存在其他文件中。优点：既可发现已知病毒又可发现未知病毒；缺点：只能判断文件是否被修改，而不能识别病毒种类和名称，且对隐蔽性病毒无效。 行为监测法：利用病毒的特有行为来监测病毒的方法。 蠕虫：一种可以通过网络连接进行自身复制的程序，与以往病毒方式不同，文件型病毒、宏病毒需要在计算机的硬盘、软盘或文件系统中繁殖，而典型的蠕虫只会在内存中维持一个活动副本，甚至根本不向硬盘写入任何信息。 十六、 防火墙 概念：防火墙指应用于内部网络和外部网络之间的，用来保护内部网络免受非法访问和破坏的网络安全系统。 主要功能： 过滤进出网络的数据 防止不安全的协议和服务 管理进出网络的访问行为 记录通过防火墙的信息内容与活动 对网络攻击进行检测与告警 防止外部对内部网络信息的获取 提供与外部连接的集中管理 不能防范的攻击：内部威胁、病毒、应用程序漏洞、木马、社会工程、不当配置 防火墙分类：按实现技术（包过滤型（静态，动态），代理型（应用代理，电路代理，NAT））；按体系结构（双宿/多宿主机，屏蔽主机（双重保护安全性更高），屏蔽子网，混合结构）。 静态包过滤（传输层和网络层）：对包头内容进行简单过滤（源和目的IP，IP选项，IP上层协议，TCP和UDP源及目的端口，ICMP报文类型和代码）。 防火墙规则制定策略：a.拒绝任何访问，除非被规则特别允许。b.允许任何访问，除非规则特别禁止 过滤的两种基本方式：按服务过滤（如Telnet，SMTP，FTP等等）；按规则过滤。 静态包过滤的优缺点：速度快，价格低，对用户透明；配置难把握，防范能力低，没有用户身份验证机制。 动态包过滤（网络层）（状态检测防火墙）：不仅以一个数据包的内容作为过滤依据，还根据这个数据包在信息流位置加以判断 动态包过滤优缺点：基于应用程序信息验证一个包状态的能力，记录通过的每个包的详细信息；造成网络连接的迟滞，系统资源要求较高。 应用代理防火墙（应用层）：对所有规则内允许的应用程序作中转转发；牺牲了对应用程序的透明性。 应用代理优缺点：可以隐藏内部网络信息，具有强大的日志审核，实现内容过滤；价格高，速度慢，失效时造成网络瘫痪。 电路级代理（传输层）优缺点：隐藏内部网络信息，配置简单（无需为每个应用程序配置一个代理）；多数电路级网关都是基于TCP端口配置，不对数据包检测可能会有漏洞。 NAT优缺点：管理方便并且节约IP地址资源，隐藏内部IP地址信息；外部应用程序不能方便地与NAT网关后的应用程序联系。- 理解防火墙的四种体系结构 十七、 入侵检测IDS 由于防火墙无法发现和阻止:a.对合法服务的攻击。b.源自其他入口的攻击。c.来自内部网络的攻击。d.来自木马的威胁。入侵检测技术通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现网络或系统中是否有违反安全策略行为和被攻击迹象的一种安全技术。 IDS任务：从系统正常运行产生的和攻击者进行攻击时产生的混合数据中找出入侵痕迹。 通用入侵检测框架CIDF：体系结构；组件通信（事件产生器（数据获取）；事件分析器（数据分析）；事件数据库（数据管理）；响应单元（行为响应））；语言规范；编程接口。 小结：入侵检测技术收集主机日志及网络流量等信息，通过模式匹配、统计分析或完整性分析，能够有效发现入侵行为。入侵检测形成了网络的纵深防御，成为防火墙技术的有益补充。网络技术的发展给入侵检测带来各种新的困难，同时也带来机遇。","categories":[{"name":"安全","slug":"安全","permalink":"http://thmasterplan.cn/categories/%E5%AE%89%E5%85%A8/"}],"tags":[{"name":"安全","slug":"安全","permalink":"http://thmasterplan.cn/tags/%E5%AE%89%E5%85%A8/"}]},{"title":"Git笔记","slug":"Git笔记","date":"2019-11-19T10:18:31.000Z","updated":"2019-11-23T13:23:14.088Z","comments":true,"path":"git/Git笔记/","link":"","permalink":"http://thmasterplan.cn/git/Git%E7%AC%94%E8%AE%B0/","excerpt":"","text":"一.设置12git config --global user.name &quot;Your Name&quot;git config --global user.email &quot;email@example.com&quot; 二.创建版本库 创建空目录 隐藏目录.git为版本库git init 添加 123git add xxx.txtgit add xxxx.txtgit add xxxxx.txt 提交git commit -m &quot;说明文字&quot; 三.版本回退 查看版本日志git log 回退 12git reset --hard [HEAD^,HEAD^^，HEAD~100]回退到以前某个版本git reset --hard [回退之前的版本号] 撤销回退 查看命令历史，以便确定回到未来哪个版本git reflog 四.版本库的工作区与暂存区、分支git add命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行git commit就可以一次性把暂存区的所有修改提交到分支。 五.每次修改，如果不用git add到暂存区，那就不会commit。六.撤销修改 直接丢弃工作区的修改，用命令git checkout -- file。[误删也是一种修改] 当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令git reset HEAD &lt;file&gt;，就回到了场景1，第二步按场景1操作。 已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。 七.删除文件 12git rm filegit commit 八.推送到github git push origin master 九.克隆远程库到本地git clone git@github.com:Laishiji/directoryName.git 十.分支 查看分支：git branch 创建分支：git branch name 切换分支：git checkout name 创建+切换分支：git checkout -b name 合并某分支到当前分支：git merge name 删除分支：git branch -d name 十一.分支合并失败当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。用git log --graph命令可以看到分支合并图。","categories":[{"name":"git","slug":"git","permalink":"http://thmasterplan.cn/categories/git/"}],"tags":[{"name":"git","slug":"git","permalink":"http://thmasterplan.cn/tags/git/"}]},{"title":"Java基础","slug":"Java基础","date":"2019-11-19T09:33:47.000Z","updated":"2020-04-05T14:35:10.745Z","comments":true,"path":"Java基础/Java基础/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"字符串 String常用方法： 1) 比较 2) 获取 3) 截取子串 4) 转换 5) 分割 补充：boolean endsWith)(String suffix);判断字符串是否是以suffix为后缀。 Static关键字 1) 内存图： 2) 静态代码块： Arrays常用方法 继承 抽象类与接口 多态 向上转型，即父类引用指向子类对象，则引用无法调用原本子类特有的方法，例如Animal a = new Cat(); 向下转型，也即还原a的类型为cat，使其可以访问cat特有的方法，例如Cat cat = (Cat) a;[类似于强制类型转换]。 final关键字1) 修饰类：当前类不能有任何子类。 2) 修饰方法：该方法不能被子类覆盖重写。（显然对于类、方法来说，abstract和final无法同时使用） 3) 修饰局部变量：该变量（引用类型不能再指向其他变量）不能再改变。 4) 修饰成员变量：该变量必须直接赋值或者在构造方法中赋值。 内部类1) 成员内部类 在内部类中访问重名的外部类成员变量： 2) 局部内部类 3) 局部内部类中的匿名内部类： 包装类 自动装箱与自动拆箱。 基本类型与字符串的转换： 集合框架+ 1) Collection 2) Iterator接口 3) 泛型 4) List List的子类： A. ArrayList:此实现不是同步的，底层是一个数组，增删慢，查询快。 B. LinkedList:此实现不是同步的，底层是双向链表，增删快，查询慢。 C. Vector:底层是数组，同步，了解即可 5) Set:set在调用add方法时，会调用元素的hashCode方法和equals方法判断元素是否重复，在存储自定义类型元素时，前提是需要重写对象中的hashCode和equals方法。 A. HashSet:不同步，底层是哈希表（查询速度快），无序。 哈希值：十进制整数，逻辑地址值，由哈希函数计算而得。 哈希表：jdk1.8之后，哈希表由数组+链表/红黑树构成。 B. LinkedHashSet:相较于HashSet多了一条链表记录元素的存储顺序，保证元素有序。 6) 可变参数： 7) Collections集合工具类： Comparator: Comparable: 要比较的类需要实现Comparable接口，同时覆盖compareTo方法： 8) Map A. 概述 B. Map接口常用方法： C. Map遍历方法： a) 键找值： b) Entry键值对对象：Map.Entry，在Map接口中有一个内部接口Entry,Map集合一创建就会创建一个Entry对象，记录键值对对象。 D. HashMap存储自定义类型键值为防止键重复，必须重写自定义类型的hashCode和equals方法。 9) HashTable: 异常 自定义异常： 并发1. 线程状态图： ​ ​ 等待-唤醒案例： notifyAll唤醒所有waiting状态的线程，唤醒之后的线程要与其他线程竞争锁，获取锁之后才能继续执行wait()方法之后的代码。 2. 创建线程第一种方法： 每个线程都有自己的栈空间。 3. Thread**类构造方法和常用方法：** 4. 创建线程第二种方法：实现Runnable接口 5. 两种创建方式的区别 6. 匿名内部类两种方式创建线程： 7. 线程安全与线程同步： 1) 同步代码块 （可以直接用synchronized(this){ ​ ///////////**代码块** }**）this代表Runnable的实现类对象，唯一。** 同步中的线程，没有执行完代码块中的内容不会释放锁，其余线程没有锁就算获取cpu执行权也会阻塞；同步保证了只能有一个线程在同步中执行共享数据，保证了安全；但是程序频繁地判断锁，获取锁，释放锁，程序效率会降低。 2) 同步方法 静态同步方法： 3) 加lock锁 8. 线程池：一个容纳多个线程的容器（例如LinkedList），其中的线程可以反复使用，无需反复创建线程而消耗过多资源。 9. Lambda**表达式：省略了实现接口，重写方法等。** 例： File1. File类的静态成员变量： 2. File类构造方法 1) File（String pathname){}； 2) File(String Parent, String child){}：这个构造意思是根据一个目录和子目录得到File对象。如果我们想对某一个文件路径下的多个文件进行操作，这个时候采用这个构造函数就显示优势。 3) File(File parent, String child){}：这个函数的好处就是可以对parent进行File相关的操作，例如打印父路径下有多少个文件等。 3. 获取类方法： 4. 判断类方法： 5. 创建删除类方法： 6. 目录遍历 7. 文件过滤器：FileFilter接口 listFiles(传递过滤器实现类对象，可直接用lambda表达式简化)。例如： IO 1. OutputStream: 1) FileOutputStream 2) 一次写一个字节 3) 一次写多个字节 4) 续写与换行 2. InputStream&amp;FileInputStream 1) 一次读一个字节，read()方法返回一个ASCII码值。 2) 一次读多个字节： 若未读取到字节，则同样返回-1. 3. 练习：文件复制操作： 4. 使用字节流读取中文时，会出现乱码的问题；一个中文字符：GBK占2个字节，UTF-8占3个字节。因此需要使用字符流。 5. Reader&amp;FileReader 6. writer&amp;FileWriter 7. IO中的异常处理 1) 常规 2) JDK7新特性 8. 属性集 1) setProperty/getProperty/stringPropertyNames 2) store 3) load 9. 缓冲流 1) BufferedOutputStream 2) BufferedInputStream 3) BufferedWriter 4) BufferedReader 10. 转换流 1) 字符编码和字符集： A. 字符编码：一套自然语言的字符与二进制数之间的对应规则。 B. 字符集：即编码表，生活中文字与二进制对应规则 C. 常用字符集： a) ASCII：美国 b) ISO：欧洲 c) GBxxx:GB2312,GBK,GB18030国标。GBK两个字节表示一个汉字。 d) Unicode：万国码。UTF-8/UTF-16/UTF-32。UTF-8三个字节表示一个汉字。 2) 编码引出的问题： FileReader可以读取IDE默认编码格式UTF-8的文件，但是读取系统默认编码为GBK时会产生乱码。 FileReader底层调用的是FileInputStream方法读取字节流，再通过字符集转换为字符，其父类为InputStreamReader. FileWriter同理。 3) OutputStreamWriter 4) InputStreamReader 11. 序列化流 1) ObjectOutputStream 只需要序列化的类implements Serializable接口即可，并不需要实现任何方法。 2) ObjectInputStream 与序列化相似。 3) 静态变量不能被序列化或反序列化。 4) 使用transient关键字修饰变量避免序列化。 A. 一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。 B. transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。 C. 被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。 5) InvalidClassException: 序列化一个类后，又修改类的内容后，序列号会改变，反序列化时会出现InvalidClassException。 12. PrintStream打印流 网络编程1. 客户端： 注意：在客户端发送完毕之后，要调用socket的shutdownOutput()方法，以免服务端的inputStream.read()方法阻塞。 2. 服务器端","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"文件权限与用户组管理","slug":"文件权限与用户组管理","date":"2019-11-17T16:16:20.000Z","updated":"2019-11-23T13:25:22.564Z","comments":true,"path":"Linux/文件权限与用户组管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux的文件权限与用户组管理 文件权限：-rw-r--r-- 1 root root 4.0K 07-19 01:02 abc.log: 第1位： -：表示普通文件； d：目录 b：设备文件（块文件，即可以用来存储的设备文件） c：设备文件（字符文件，不能用来存储的设备文件） l：软链接（快捷方式） p：管道文件pipe s：套接字文件socket 后9位：r可读，w可写，x可执行。 2-4位：用户的权限范围 5-7位：组的权限范围 8-10位：其余人的权限范围 1表示该文件的硬链接数 第一个root表示该文件的所有者 第二个root表示该文件所属的组 4.0K表示该文件的大小 后面为最后一次修改的时间戳和文件名 r/w/x权限对于目录的意义： r权限：可读取目录结构列表，即可查看目录下的文件名和子目录名。[注：不能查看文件内容] w权限：可创建文件和目录，可删除，可重命名，可转移 x权限：可进入该目录。 更改权限：chmod chmod u+x,g+w,o-r abc.log：abc.log权限由-rw-r--r--变为：-rwxrw---- chmod a=r file或者chmod +r file:表示对file的u,g,o同时都赋予可读权限 另一种更简单的权限赋予方式，令r = 4, w = 2, x = 1,则u,g,o的权限分别可用一个整数表示，例如chmod 741 file表示file的u,g,o权限为-rwxr----x 参数-R：R及recursive（递归）；chmod -R 741 directory，表示改变目录及目录下所有文件的权限为741。 更改文件的所有者：chown chown user file:将file的所有者改为user chown user.group file:将file的所有者改为user,同时更改其组为group chown -R user directory：若要更改目录的权限，则需要加-R才能将其里面所有内容的权限更改 更改文件的所有组：chgrp chgrp root file: 将file的所有组改为root Linux组的类别： 用户的主要组：用户必须属于一个且只有一个主组，组名同用户名，且仅包含用户自己。 用户的附加组：一个用户可属于0或多个附加组。 id 用户名：查看用户的uid、gid（主组）、groups的id。管理员root的uid和gid为0。 用户和组的配置文件： /etc/passwd：用户及其属性信息(名称、UID、主组ID)。 /etc/group：组及其属性信息。 /etc/shadow：用户密码及其相关属性。 /etc/gshadow：组密码及其相关信息。 用户、组的增删改： useradd，userdel，usermod groupadd，groupdel，groupmod /etc/default/useradd：创建用户时的默认设置 文件与目录的默认权限与隐藏权限 文件预设权限:在没有umask的情况下，目录默认权限为777，文件默认权限为666；umask 022，表示创建文件和目录，g和o都过滤掉写(2)权限。 lsattr -a:显示所有隐藏属性 chattr [-RV][-v][+/-/=&lt;属性&gt;] [文件或目录]: -R：递归处理，将指定目录下的所有文件及子目录一并处理 -v：&lt;版本编号&gt; 设置文件或目录版本 -V： 显示指令执行过程 +&lt;属性&gt;： 开启文件或目录的该项属性 -&lt;属性&gt; ：关闭文件或目录的该项属 =&lt;属性&gt;： 指定文件或目录的该项属性 属性： a：让文件或目录只能加数据。 i：不得任意更动文件或目录。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 例如chattr +a /var/log/messages:让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件 文件特殊权限 SUID（最常用）：chmod u+s file：使file文件x权限上显示为s，非用户(u)执行者可以获得u的所有权限 SUID权限仅对二进制程序有效，不能用在脚本和目录上 执行者对于该程序有x的可执行权限 SUID权限仅在执行程序的过程中有效 让本没有相应权限的用户运行该程序时，可以获得其原本没有权限访问的资源 SGID：非组(g)成员获得该组的权限 非组成员对于该程序需要具备x的权限 SGID主要用于目录, 在该目录下创建的任何文件及子目录属于该目录所拥有的组 。 SBIT: 目前只针对目录有效，切只能分配给其他人（o）;对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除，例如/tmp。 SUID/SGID/SBIT权限设置 ： 文字法 ：SUID: u+s ，SGID: g+s，SBIT: o+t 数字法：将原来的三位数扩展为四位数即可，SUID为4，SGID为2，SBIT为1，把它们放在权限数字的最开头。例如设置SUID，可以写成4777，设置SGID可以写成，2777* 。 ACL(Access Control List)实现灵活权限控制： setfacl -m u/g:用户名/组名:权限 file。例如setfacl -m u:Tom:rw abc.txt，即Tom对abc.txt具有r和w权限，若不给权限则权限写0。 setfacl -x u/g:用户名/组名 file：删除权限。 setfacl -R -b dir/：删除dir下所有的ACL权限。 getfacl file：显示file的ACL权限。 权限优先级：所有者&gt;ACL权限(用户&gt;组&gt;other) 权限与指令间的关系(在用户模式下) 用户能进入某目录：需要权限x 进入目录后能利用ls查阅:需要权限r 进入目录后能够创建文件和目录:需要权限w 用户在目录内打开读取文件： 目录需要权限x 文件需要权限r","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"文件链接","slug":"文件链接","date":"2019-11-17T16:15:31.000Z","updated":"2019-11-23T13:25:14.526Z","comments":true,"path":"Linux/文件链接/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/","excerpt":"","text":"文件链接 硬链接：一个inode号对应多个文件名，硬链接也即同一个文件使用了多个别名，由命令ln oldfile newfile创建。 文件有相同的inode和data block 只能对已存在的文件进行创建，链接计数加1 不能交叉文件系统进行硬链接的创建 不能对目录进行创建，只可对文件创建 删除一个硬链接文件并不影响其他有相同inode号的文件 软链接（符号链接）：软链接的data block中存放的内容是另一文件的路径名的指向。软链接有自己的inode号和data block。由命令ln -s oldfile newfile创建，其中oldfile的相对路径为相对于newfile的，而newfile的相对路径是相对于当前工作目录的。rm -rf a.link/删除的是链接指向的文件，而rm -rf a.link删除的才是链接。 软链接有自己的文件属性及权限 可对不存在的文件或目录创建软链接 软链接可交叉文件系统 软链接可对文件或目录创建 创建软链接时，链接计数不会增加 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"目录配置与文件目录管理","slug":"目录配置与文件目录管理","date":"2019-11-17T16:14:20.000Z","updated":"2019-11-23T13:24:39.525Z","comments":true,"path":"Linux/目录配置与文件目录管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录配置与文件目录管理 目录配置：可参考FHS标准 /bin:存放二进制文件，常用命令 /boot：系统启动项文件,内核 /dev:设备文件，硬盘等 /etc：配置文件 /home:用户家目录，每一个用户在/home下都有一个文件夹 /lib：链接库文件 /media：媒体自动挂载点，比如U盘，光盘等 /mnt：媒体挂载点，手动挂载 /opt：自定义软件安装处，默认安装处为/usr/local /root：超级用户目录 /sbin：存放系统管理员所能执行的命令 /tmp：临时文件 /usr：类似于二层根目录 /var:存放缓存，日志，数据库文件；该文件夹需要分配的空间较大，因此在磁盘分区时挂载在/var的分区要大一些。 /proc：内存中的进程信息 /sys：硬件相关信息 文件与目录管理 常用命令： cd ~:切换到home;cd -:切换到上一次所在目录 pwd：打印当前目录 basename 和 dirname：分别获取当前路径的文件名和目录名 touch xx:若xx不存在，则创建一个新文件xx。若xx存在，把xx的修改时间改为当前。 &gt; xx：若文件不存在，则创建一个空文件xx；若文件存在，则清空现有文件xx(可用于清空大文件)。 mkdir 目录名 目录名 目录名 ... mkdir -p test/{a,b,c}/{d,e}:递归创建目录，分别在a,b,c三个目录下创建d,e两个目录。 rmdir 目录名:只能删除空目录 rm -rf目录:删除目录下所有东西（慎用rm） cp [选项] /PATH1/xx /PATH2/yy:若yy是一个目录，则把文件xx拷贝到yy下；若yy不是一个目录，则把文件xx拷贝到PATH2目录下并重命名为yy。cp不能直接拷贝目录，需要加选项参数，cp -rfp /目录1 /目录2 == cp -a /目录1 /目录2：将目录1及其所有子目录及文件拷贝到目录2。参数：-r即递归，-f即强制,-p同时复制属性信息。 mv [选项] /PATH1/xx /PATH2/yy：若yy是一个目录，则把文件xx剪切到yy下；若yy不是一个目录，则把文件xx剪切到PATH2目录下并重命名为yy。例如mv xx yy:就是把xx重命名为yy。 rename .log .logabc *：重命名，把所有文件名中的.log改为.logabc 关于执行文件路径的变量：执行程序必须在其所在目录下才能执行，亦可使用绝对路径调用，若要直接敲命令就可以执行，则需要设置PATH，把命令所在目录添加在PATH后面。 文件的三个时间属性: atime:access time mtime:modify time ctime:change time 文件名规则： 文件名最长255字节 蓝色—&gt;目录；绿色—&gt;可执行文件；红色—&gt;压缩文件；浅蓝色—&gt;链接文件；黄色—&gt;设备文件；粉色—&gt;套接字文件；棕色—&gt;管道文件；灰色—&gt;其他文件 文件通配符： *：匹配0个或多个字符 ?：匹配任意一个字符 [1-5]：匹配字符1,2,3,4,5 [a-c]：匹配字符a、A、b、B、c(没有C)。 [A-C]：匹配A，b，B，c，C [^abcd]：匹配除abcd外的所有单个字母 文件内容查阅 cat 文件名:显示所有文件内容，适合查看小文件，参数-n显示行数。cat -n 文件名== nl 文件名。 tac：从最后一行显示，倒数显示。 more/less 文件名:按空格一屏一屏地显示，按回车一行一行地显示。同时在文档下方输入/字符串即可查找文档中的字符串。 head -n 21 文件名:查看文件的前21行 tail -n 21 文件名:查看文件的尾21行；参数-f,监测日志，实时监测日志的变化。 od:查看非文本文档，比如二进制文件。 命令与文件的查询： which -a 命令:在PATH路径中搜寻命令位置 whereis 命令:返回命令路径及其帮助文档的路径；参数-b只返回命令路径。 locate 字符串:在/var/lib/mlocate/mlocate.db中查询所有文件名中包含该字符串的文件并返回，该数据库每天定时更新，亦可通过updatedb更新。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"磁盘与文件系统简介","slug":"磁盘与文件系统简介","date":"2019-11-17T16:12:54.000Z","updated":"2019-11-23T13:24:31.256Z","comments":true,"path":"Linux/磁盘与文件系统简介/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux磁盘与文件系统简介(centOS7之后使用xfs，centOS6使用ext4) 文件系统特性 索引式文件系统：对于linux，文件的权限和属性放置到inode中，文件的实际数据放在data block中。 superblock:记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量,以及文件系统的格式与相关信息等。 inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。 block:实际记录文件的内容，若文件过大一般会占用多个block。 linux的EXT2 ext2文件系统示意图 data clock：ext2文件系统所支持的block大小有1K,2K和4K三种 | Block大小 | 1KB | 2KB | 4KB || :————————: | —— | ——- | —— || 最大单一文件限制 | 16GB | 256GB | 2TB || 最大文件系统总容量 | 2TB | 8TB | 16TB | 除非重新格式化，block的大小与数量在格式化完就不能再改变 每个blcok内最多只能放置一个文件的数据 若文件大于block,则一个文件占用多个block；若文件小于block，则该blcok的剩余容量就不能再被使用。 inode table:记录文件的权限，拥有者与群组，容量，建立、最近一次读取、更改的时间。。。 每个inode大小均为固定128字节（ext4和xfs可设定到256字节） 每个文件仅占用一个inode 系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合。 superblock：一般为1024字节 dumpe2fs：查询EXT系列superblock信息的指令 文件系统与目录树的关系 目录：当在linux下的文件系统建立一个目录时，文件系统会分配一个inode与至少一块block给该目录，其中inode记录该目录的相关权限和属性，并记录分配的那块block号码，而block则记录在这个目录下的文件名与该文件名占用的inode号；ls -i查询当前目录下文件的inode号码。 文件:在ext2建立一个文件时，ext2会分配一个inode和相对于该文件大小的block数量。 目录树:例如读取/etc/passwd过程:/的inode -&gt; /的block -&gt; etc/的inode -&gt; etc/的block -&gt; passwd的inode -&gt; passwd的block。 日志式文件系统 挂载点的意义：挂载点一定是目录，该目录为进入该文件系统的入口。 Linux VFS用于管理所有类型的filesystem","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"常用命令入门","slug":"常用命令入门","date":"2019-11-17T16:11:48.000Z","updated":"2019-11-23T13:24:22.325Z","comments":true,"path":"Linux/常用命令入门/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/","excerpt":"","text":"常用命令入门 Xwindow与命令行界面的切换：ctrl + alt + f1...f7，其中只有f7为图形化界面，启动图形化界面也可以用startx命令。 命令帮助： whatis 命令：列出命令的作用以及man帮助的章节。 命令 --help：命令用法 man 章节号 命令：命令更详细的用法 info 命令 man -k 字符串:查找所有包含该字符串的命令 help：列出所有的内部命令 常见命令与快捷键： ls -a/-l:列出当前目录所有文件；ls -l == ll;ls -d .*/：列出所有目录 date:获取当前日期 cal:获取日历 bc:进入计算器,scale = n,n表示计算的精度 [Tab]:命令、文件名、选项、参数补全，连续两次Tab键可列出所有选项 ctrl c:终止目前程序 ctrl d :等同于输入exit shift pageup/pagedown:翻页 nano:一个简单的文本编辑器 reboot/shutdown -r:重启；shutdown/poweroff:关机；shutdown -h 1:定时1分钟关机；shutdown -h 8:20:8:20关机 su -/su root：获取root权限 sync：将内存中的数据写入磁盘，防止丢失 clear:清屏 file 文件名:查看文件类型 tree:查询当前目录的树形结构,需要安装；选项-d只显示目录；选项-L显示指定层级；例如tree -d /boot -L 1。 passwd：更改密码 hostname：查看主机名；hostnamectl set-hostname 名字：更改主机名。 ls -l $(which passwd)：命令的嵌套执行，用$()表示。 修改提示符颜色:修改PS1变量的值，并保存在配置文件/etc/profile.d/env.sh中。 type 命令：查看命令类型，内部命令集成在shell中。 enable：查看所有内部命令；enable -n 命令:禁用内部命令 Hash缓存表:系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将该命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先查看hash表，存在则执行命令，不存在则去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率。 hash：显示hash缓存 将外部命令路径添加到/etc/profile文件的PATH=$PATH:/xxx/yy中，再用source /etc/profile即可在任意路径下使用该外部命令。 alias 别名 = &#39;常用命令&#39;：设立别名；在centos7中，需在/root/.bashrc中保存。 alias可列出所有别名。 命令执行优先级:别名&gt;内部命令&gt;外部命令hash表&gt;$PATH。 若别名与原命令同名，可通过\\命令名执行原命令。 编辑配置文件不会立即生效，可通过. 配置文件名使bash进程重新读取配置文件使编辑生效。 多个命令可以用;分开一起执行，一个长命令可以用\\分成多行。 echo：回显字符串；显示变量 单引号：单引号中的内容就是字符串 反向单引号：其中的内容命令和变量均能识别。例如：touch `date +%F`.log：创建以当前时间命名的文件。反向单引号等价于$()。 双引号：能识别变量不能识别命令 {}：打印重复字符串；例如touch file{1..10}：创建了10个文件分别为file1,file2,,,file10。 Alt 数字n:重复显示字符n次","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"标准IO和重定向","slug":"标准IO和重定向","date":"2019-11-17T16:09:31.000Z","updated":"2019-11-23T13:24:02.434Z","comments":true,"path":"Linux/标准IO和重定向/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%A0%87%E5%87%86IO%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"标准IO和重定向 三种I/O设备 标准输入(STDIN)：（文件描述符0） 默认接收来自键盘的输入 标准输出（STDOUT）：（文件描述符1） 默认输出到终端窗口 标准错误（STDERR）：（文件描述符2） 默认输出到终端窗口 I/O重定向至文件 标准输出重定向：&gt;；例如hostname &gt; /dev/pts/2将输出重定向至另一设备；若为文件，则清空文件再写入。&gt;&gt;则是追加，而不清空原文件；例如hostname &gt;&gt; /data/abc.log。 标准错误重定向：2&gt;；&gt;&gt;则是追加。 &amp;&gt;：标准输出和标准错误一起重定向。 标准输入重定向：&lt;；例如bc &lt; bc.txt，将bc.txt文件作为输入用bc计算。 tr [选项] set1 set2 ：将输入的文本中所有的s1替换为s2。· -d：删除所有属于set1的字符。 -s：把连续重复的字符以单独一个字符表示。 -t：把set1对应字符转换为set2对应字符。 cat &gt; abc.log：标准输入单行重定向到文件；cat &lt;&lt;EOF &gt;abc.log标准输入多行重定向至文件，输入EOF才写入文件。 使用管道 管道命令1 | 命令2 | 命令3 | ...：将命令1的STDOUT发送给命令2的STDIN，再将命令2的STDOUT发送给命令3的STDIN。。。 STDERR默认不能通过管道转发，可利用|&amp;实现。 管道线后面的命令在一个subbash中执行，执行完就退出该subbash。 例子：echo {1..100} | tr &#39; &#39; + | bc：计算1到100的和。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"VIM的简单使用","slug":"VIM的简单使用","date":"2019-11-17T16:08:02.000Z","updated":"2019-11-23T13:23:52.646Z","comments":true,"path":"Linux/VIM的简单使用/","link":"","permalink":"http://thmasterplan.cn/Linux/VIM%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"VIM：一个模式编辑器 三种主要模式： Normal（命令）模式：默认模式，可移动光标，剪切/粘贴文本。 -&gt; Insert模式：输入i,a,o,I,A,O任意一个； -&gt; extended command模式:输入:； h:左; l:右; j:下; k:上； )：下一句；(：上一句 }：下一段；{：上一段 ctrl d：向下翻半屏 ctrl u：向上翻半屏 /字符串：全文查找字符串 Insert(编辑)模式：可修改文本。 -&gt; Normal模式:ESC键； 扩展命令(extended command)模式：保存，退出等。 -&gt; Normal模式：ESC键； wq：存盘退出； q!：不存盘退出； w：临时保存，类似于win下的ctrl+s； r filename：将filename的文件内容读到当前文件中； w filename：将当前文件内容写入filename文件中； !命令：在不退出vim的情况下执行命令； r!命令：在不退出vim的情况下，将执行命令的结果写入当前文件。 set number：显示行号；输入数字再输入+或-则向下或向上跳相应行数。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]}]}