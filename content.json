{"meta":{"title":"TheMasterplan","subtitle":"TheMasterplan","description":"","author":"LSJ","url":"http://thmasterplan.cn","root":"/"},"pages":[{"title":"关于","date":"2020-09-09T05:18:01.539Z","updated":"2020-09-09T05:18:01.539Z","comments":false,"path":"about/index.html","permalink":"http://thmasterplan.cn/about/index.html","excerpt":"","text":"常用站点DocJavaEE7 Doc：https://docs.oracle.com/javaee/7/api/toc.htm JavaSE8 Doc：https://docs.oracle.com/javase/8/docs/api/index.html Spring Doc：https://docs.spring.io/spring/docs/5.2.5.RELEASE/spring-framework-reference/ BlogJava全栈：https://www.pdai.tech/md/java/basic/java-basic-oop.html JavaGuide：https://snailclimb.gitee.io/javaguide/#/ CS-Notes: https://cyc2018.github.io/CS-Notes/#/ JULY（算法）： https://blog.csdn.net/v_JULY_v/article/list/3 xieyuooo：https://blog.csdn.net/xieyuooo 兰亭风雨：https://blog.csdn.net/ns_code?viewmode=list 赵伊凡: http://irfen.me/ SiteStack Overflow：https://stackoverflow.com/ 联系方式Mail：laishiji86@gmail.com QQ：991327409"},{"title":"分类","date":"2019-11-18T06:42:54.196Z","updated":"2019-11-18T06:42:54.196Z","comments":false,"path":"categories/index.html","permalink":"http://thmasterplan.cn/categories/index.html","excerpt":"","text":""},{"title":"友情链接","date":"2020-09-03T15:20:27.746Z","updated":"2020-04-08T10:56:53.574Z","comments":true,"path":"links/index.html","permalink":"http://thmasterplan.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-05T13:38:03.477Z","updated":"2019-11-18T05:58:22.890Z","comments":false,"path":"repository/index.html","permalink":"http://thmasterplan.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-05T13:38:09.506Z","updated":"2019-11-18T06:43:04.379Z","comments":false,"path":"tags/index.html","permalink":"http://thmasterplan.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"线程安全与锁优化","slug":"线程安全与锁优化","date":"2020-09-12T12:39:28.000Z","updated":"2020-09-12T12:39:28.427Z","comments":true,"path":"uncategorized/线程安全与锁优化/","link":"","permalink":"http://thmasterplan.cn/uncategorized/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java内存模型与线程","slug":"Java内存模型与线程","date":"2020-09-12T12:39:07.000Z","updated":"2020-09-13T04:35:16.496Z","comments":true,"path":"Java并发/Java内存模型与线程/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"Java内存模型主内存与工作内存Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。（C/C++直接使用物理硬件和操作系统的内存模型，因此可能会由于平台差异导致同一份代码无法正常运行。） JMM规定了所有的变量都存储在主内存中。注意： 此处的变量不包括局部变量与方法参数，因为它们是线程私有的。 此处的主内存与硬件的主内存不同，此处仅是JVM内存的一部分。 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存拷贝副本（如果是对象，不会拷贝整个对象，只会拷贝某些字段值）。 线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也无法访问对方的工作内存。JMM示意图如下： 这与硬件的缓存访问操作很相似： 内存间交互操作JMM定义了8种操作来完成主内存和工作内存之间的交互，这些操作是原子的、不可再分的。 lock: 作用于主内存，把一个变量标识为一条线程独占。 unlock: 作用于主内存，把一个锁定状态的变量释放。 read: 把一个变量的值从主内存传输到工作内存。 load: 把read操作得到的值放入工作内存的变量副本中。 use: 把工作内存变量的值传递给执行引擎。每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行此操作。 assign: 把执行引擎接收到的值赋给工作内存的变量。 store: 把工作内存的一个变量值传输到主内存。 write: 把store传的值放入主内存的变量中。 内存模型三大特征Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 原子性原子性的含义理解：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 由JMM直接保证的原子性变量操作包括read/load/use/assign/store/write。 如果应用场景需要一个更大范围的原子性保证，JMM还提供了lock和unlock来满足这种需求，对应的更高层次的字节码指令为monitorenter和monitorexit隐式使用这两个操作，反应到代码中就是synchronized关键字的使用，也即synchronized块的操作也具有原子性。 synchronized关键字经过编译后，会在同步块前后分别形成monitorenter和moniterexit两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明锁对象（monitorenter含义：获得对象的锁；monitorexit含义：释放对象的锁），比如同步块的this/某个对象，或者synchronized方法对应的实例对象，以及静态synchronized方法对应的类Class对象。 可见性可见性是指：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 JMM如何实现可见性？ 答：在变量修改后将新值同步回主内存，变量读取前从主内存刷新变量值。 Java哪些关键字可以保证可见性？ volatile synchronized: 对一个变量执行unlock操作之前，必须先把变量值同步回主内存。 final: 被 final 修饰的字段在构造器中一旦初始化完成，那么其它线程就能看见 final 字段的值。 有序性有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序以及工作内存与主内存同步有延迟。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码，相当于是让线程顺序执行同步代码。 先行发生原则（Happens-Before规则）先行发生是JMM中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其含义是：B发生之前，A产生的影响能被B观察到。“影响”包括修改了内存中共享变量的、发送了消息、调用了方法等。 JMM中一些天然的先行发生关系如下： 程序次序规则（Program Order Rule）在一个线程内，在程序前面的操作先行发生于后面的操作。 管程锁定规则（Monitor Lock Rule）一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile变量规则（Volatile Variable Rule）对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则（Thread Start Rule）Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则（Thread Join Rule）Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则（Thread Interruption Rule）对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性（Transitivity）如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 线程线程的实现Thread类的所有关键方法都是声明为native的，也即Java线程的实现本质是使用平台的实现手段。 JDK1.2后，线程模型替换为基于操作系统原生线程模型来实现。 Java线程优先级Java一共设置了10个级别的线程优先级，在两个线程同时处于Ready状态时，优先级高的线程更容易被系统选择执行。 Java的线程优先级是通过映射到系统的原生线程上实现的，因此线程调度最终取决于操作系统，并且操作系统的优先级并不能与Java的优先级一一对应。例如Solaris中有2^32种优先级，Windows只有7种。Windows平台的JDK中使用了除THREAD_PRIORITY_IDLE之外的其余6种线程优先级，对应关系如下表： Java线程优先级 Window线程优先级 1（Thread.MIN_PRIORITY） THREAD_PRIORITY_LOWEST 2 THREAD_PRIORITY_LOWEST 3 THREAD_PRIORITY_BELOW_NORMAL 4 THREAD_PRIORITY_BELOW_NORMAL 5（Thread.NORM_PRIORITY） THREAD_PRIORITY_NORMAL 6 THREAD_PRIORITY_ABOVE_NORMAL 7 THREAD_PRIORITY_ABOVE_NORMAL 8 THREAD_PRIORITY_HIGHEST 9 THREAD_PRIORITY_HIGHEST 10（Thread.MAX_PRIORITY） THREAD_PRIORITY_CRITICAL 状态转换Java线程状态转换图如下： New：创建后尚未启动。 Runnable：包括了操作系统线程状态中的Ready和Runnning。 Waiting（无限期等待）：处于该状态的线程要等待被其他线程显式地唤醒。 Timed Waiting（限期等待）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 Blocked：等待获取一个排它锁。阻塞和等待的区别在于，阻塞是被动的，而等待线程是主动进入的。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"数据结构复习","slug":"数据结构复习","date":"2020-09-10T03:05:44.000Z","updated":"2020-09-10T06:50:15.337Z","comments":true,"path":"数据结构与算法/数据结构复习/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/","excerpt":"","text":"OverView 数据结构数组 优点：存取速度快。 缺点：a.事先必须知道数组的长度。b.需要大块连续的内存块。c.插入删除元素的效率低 Java中主要类似的实现为ArrayList，其他一些容器底层也几乎都会用数组存储数据。 链表 优点：插入删除元素快；无空间限制。 缺点：查找存取慢。 分类：单向链表；双向链表；循环链表 Java中主要类似的实现为LinkedList，其他一些容器底层也会用到链表。 哈希表 详情见HashMap源码剖析。 栈和队列 栈：LIFO 队列：FIFO Java中推荐使用ArrayDeque。 树基础二叉树最多有两棵子树的树。 满二叉树二叉树中所有非叶子节点的度都是2，且叶子节点都在同一层次上。 完全二叉树如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。 二叉搜索树（BST）二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树: 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 平衡二叉树（AVL）平衡二叉树是指一棵空树或者它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。并且它满足二叉查找树的性质。 红黑树（R-B Tree）B树B树是一种平衡多路查找树。 B+树B*树R树哈夫曼树图基础 定义 相关概念 类型 无向图 有向图 完全图 存储结构 邻接矩阵表示法 邻接表表示法 BFS和DFS最小生成树 相关概念 Kruskal算法 Prim算法 最短路径算法 Dijkstra算法 Floyd算法 拓扑排序AOE网与关键路径Blog推荐 基础：https://www.cnblogs.com/skywang12345/p/3603935.html 进阶：https://blog.csdn.net/v_JULY_v/article/list/3 参考：https://www.pdai.tech/md/algorithm/alg-basic-overview.html","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"LinkedHashMap源码剖析","slug":"LinkedHashMap源码剖析","date":"2020-09-09T07:13:05.000Z","updated":"2020-09-11T05:11:08.849Z","comments":true,"path":"Java集合框架/LinkedHashMap源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述LinkedHashMap是HashMap的一个子类，保存了键值对的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的键值对肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 LinkedHashMap的实现底层数据结构 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; 节点Entry继承自HashMap.Node，包含前置指针和后置指针。 123456//双向链表的头指针transient LinkedHashMap.Entry&lt;K,V&gt; head;//双向链表的尾指针transient LinkedHashMap.Entry&lt;K,V&gt; tail;//为false维护的是插入顺序；为true则是维护访问顺序。final boolean accessOrder; 由此可见LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了一个变量用于维护插入顺序或者访问顺序。 构造方法12345678910111213141516171819public LinkedHashMap(int initialCapacity, float loadFactor)&#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 由构造方法知LinkedHashMap默认维护的是插入顺序。 常用方法分析get()12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount;//get也会导致结构性更改 &#125; &#125; 由get方法可知，accessOrder为true，也即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get方法都会将当前节点移动至链表尾部。保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 put()查看源码发现LinkedHashMap并没有重写put方法，但是重写了newNode方法，因此put会调用重写的newNode方法。并且发现put方法最后调用了afterNodeAccess方法。 123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p);//新建节点连接于链表尾部 return p;&#125;// link at the end of listprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; removeEldestEntry()重写该方法可以删除最久未被使用的元素。 afterNodeInsertion()新增时判断是否需要删除最久未被使用的元素。 开启accessOrder的情况和最后这两个方法主要用于实现LRU缓存。 小结 LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了变量accessOrder用于维护插入顺序或者访问顺序。 accessOrder为true，即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get/put都会将当前节点移动至链表尾部。注意这意味着get也会导致modCount变化，迭代器会快速失败。","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"HashMap源码剖析","slug":"HashMap源码剖析","date":"2020-09-09T05:10:49.000Z","updated":"2020-09-12T02:07:43.589Z","comments":true,"path":"Java集合框架/HashMap源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述Map接口主要实现类有四个：HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图： 其中HashMap根据key的hashCode计算得到的哈希值存储数据，因此在访问数据时直接根据hash函数计算就可以得到数据在数组中的位置，访问速度很快，但是遍历顺序却是不确定的。 HashMap最多只允许一个节点的key为null，允许多个节点的value为null。 HashMap非线程安全。若要满足线程安全，可以使用Collections.synchronizedMap方法使HashMap具有线程安全的能力，或者直接使用ConcurrentHashMap。 HashMap的实现底层数据结构 如上图所示，HashMap使用链地址法来解决冲突问题。jdk8后HashMap使用数组+链表/红黑树实现。 1234567891011121314151617181920212223242526272829303132333435363738394041transient Node&lt;K,V&gt;[] table;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//用来定位数组索引位置 final K key;//final修饰，key不可变，否则根据hash函数计算所得的索引位置就变了 V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; HashMap成员变量的含义12345678910111213141516171819202122232425262728293031323334353637383940//数组默认初始容量16.数组容量必须是2的幂，定位索引时采用&amp;运算效率高。static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//数组最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;//当链表节点个数 &gt;= 8时，转换为红黑树，访问的时间复杂度由O(N)降为O(logN)static final int TREEIFY_THRESHOLD = 8;//当红黑树节点个数 &lt; 6时，退化为链表static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 只有当数组容量&gt;=64时，bin中的链表才会转换为红黑树； * 否则就算链表节点个数&gt;=8，也不会树化，而是对数组进行扩容。 */static final int MIN_TREEIFY_CAPACITY = 64;//等于capacity * load factor, 当哈希表中有threshold个bin有节点时，进行扩容int threshold; //记录HashMap发生结构性更改的次数，用于实现迭代器fail-fast机制transient int modCount;//负载因子,如果内存空间充足，可以在构造HashMap时适当减小负载因子和增大初 始容量，以此来提高HashMap效率；//相反，如果内存空间紧张而对时间效率要求不高，则可以适当调大负载因子final float loadFactor;//总节点个数transient int size;//用于entrySet()方法返回所有键值对transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; 哈希方法哈希函数用于确定节点在数组中的索引位置，其数学形式为index = hash(key)。jdk1.8实现源码如下： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 由源码可知，hash函数的返回值并不是数组索引，因为数组长度并没有参与运算。实际上，获取索引的最后一步操作在获取节点的方法中实现，比如getNode()方法中的代码片段tab[(n - 1) &amp; hash]，tab就是哈希数组，n为数组长度。 以上代码可分为三步： h = key.hashCode() 取key的hashCode值。 hash = h ^ (h &gt;&gt;&gt; 16) 无符号右移16bit(左边补0), 高位运算。高16位异或运算结果为hashCode原来的值，低16位运算结果则是hashCode值的高16位和低16位异或所得。这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销，并且减小了冲突的可能。 index = (n - 1) &amp; hash 相当于求模运算，但是效率比%更高。因为数组的大小永远是2的幂，所以n - 1是011..11（32位）的形式，任何非负整数（且 &lt;= n-1）和它按位&amp;都会等于其本身。 举个例子： 构造方法123456789101112131415161718192021222324252627//创建指定初始容量和负载因子的HashMappublic HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125;//创建指定初始容量和默认负载因子的HashMap public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125;public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 注意，构造方法中并没有创建哈希数组，初始化数组操作是通过resize()方法完成，而resize()方法是在放入键值对的时候才进行调用（初始化或者扩容2倍），比如putVal()方法。 构造方法中调用了tableSizeFor()来获取大于指定容量的最小的2的幂（在ArrayDeque中已分析），其源代码如下： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;//从左往右依次运算 &#125; 扩容机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//旧数组容量 int oldThr = threshold;//旧扩容阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//扩容前数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return oldTab;//直接返回旧数组不再扩容 &#125;//扩容两倍并检验是否超过最大容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // 阈值同样翻倍 &#125; else if (oldThr &gt; 0) //oldCap为0但是oldThr&gt;0，这是因为构造方法中并没有创建哈希数组，但是却通过tableSizeFor()为threshold赋了值 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //对应上面代码的第二种情形，计算新的threshold if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab;//创建新hash数组并赋值 if (oldTab != null) &#123; //以下代码块将每个bin都复制到新的数组中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//释放引用，避免内存泄漏 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode)//转为红黑树操作 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; //将该链表的冲突节点重新计算索引分配‘原索引’和‘原索引+oldCap’处 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; //e.hash与oldCap按位与只有两种结果，要么为0，要么为oldCap，因为oldCap的二进制形式为0...01000..0 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123;//原索引+oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bin if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bin if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 由注释知，resize()方法用于初始化哈希数组或者扩容2倍。注意，扩容后元素的位置要么是在原位置，要么是在原位置再移动单倍容量位移的位置。 常用方法分析put()该方法的流程图如下： 判断table是否为空，空则调用resize()创建数组 计算index，并判断该处是否为null，为null则直接创建节点，并转向6。 不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value 不一致则判断该链为红黑树。 该链为链表则遍历，遍历过程判断链表长度&gt;=8转红黑树处理；不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value 添加节点后判断是否超过阈值threshold，是则扩容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //1.判断table是否为空，空则调用resize()创建数组 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2.计算index，并判断该处是否为null if ((p = tab[i = (n - 1) &amp; hash]) == null) //为null则直接创建节点，并转向6 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //3.不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //4.判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //5.该链为链表则遍历 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //5.1 判断，链表长度&gt;=8转红黑树处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //5.2 不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value;//覆盖value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //6.添加节点后判断是否超过阈值threshold，是则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 其他常用方法： size()：获取总节点个数 isEmpty()：判断是否为空 containsKey()：判断是否包含指定key get()：获取指定key节点的value remove()：移除指定key的节点 keySet()：获取包含所有key的Set entrySet()：获取包含所有节点的Set 小结 扩容特别耗性能，所以在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 负载因子可以修改，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 JDK1.8引入红黑树大程度优化了HashMap的性能。 参考：https://zhuanlan.zhihu.com/p/21673805 ​ http://irfen.me/java1-8-hashmap/","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"PriorityQueue源码剖析","slug":"PriorityQueue源码剖析","date":"2020-09-08T10:40:43.000Z","updated":"2020-09-08T12:36:44.247Z","comments":true,"path":"Java集合框架/PriorityQueue源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述Java中优先级队列通过二叉小根堆（任意一个非叶子节点的权值都不大于其孩子节点的权值）实现，可以用一棵完全二叉树表示，这意味着数组可以作为PriorityQueue的底层实现。优先队列的作用是能保证每次取出的元素都是队列中权值最小的，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器。注意，PriorityQueue不允许放入null元素。 在完全二叉树中，假设某个节点的下标为Node，其左孩子下标为LNode、右孩子下标为RNode，那么有如下关系： Node == (LNode - 1)/2 == (RNode - 1)/2 LNode == 2*Node + 1 RNode == 2*Node + 2 通过上述三个公式，可以很容易计算出某个节点的父节点和孩子节点的下标。 PriorityQueue的实现底层数据结构1234567891011121314/** * Priority queue represented as a balanced binary heap: the two * children of queue[n] are queue[2*n+1] and queue[2*(n+1)]. The * priority queue is ordered by comparator, or by the elements' * natural ordering, if comparator is null: For each node n in the * heap and each descendant d of n, n &lt;= d. The element with the * lowest value is in queue[0], assuming the queue is nonempty. */ transient Object[] queue; // non-private to simplify nested class access /** * The number of elements in the priority queue. */ private int size = 0; 构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102private static final int DEFAULT_INITIAL_CAPACITY = 11;/** * The comparator, or null if priority queue uses elements' * natural ordering. */private final Comparator&lt;? super E&gt; comparator;public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null); &#125;//默认构造，默认容量，不使用比较器public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125;//指定初始容量，不使用比较器public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator); &#125;//指定比较器，使用默认容量public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125;//以上构造都使用this()调用了本构造方法/** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified collection. If the specified collection is an instance of * a &#123;@link SortedSet&#125; or is another &#123;@code PriorityQueue&#125;, this * priority queue will be ordered according to the same ordering. * Otherwise, this priority queue will be ordered according to the * &#123;@linkplain Comparable natural ordering&#125; of its elements. * * @param c the collection whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of the specified collection * cannot be compared to one another according to the priority * queue's ordering * @throws NullPointerException if the specified collection or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(Collection&lt;? extends E&gt; c) &#123; if (c instanceof SortedSet&lt;?&gt;) &#123; SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) ss.comparator(); initElementsFromCollection(ss); &#125; else if (c instanceof PriorityQueue&lt;?&gt;) &#123; PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) pq.comparator(); initFromPriorityQueue(pq); &#125; else &#123; this.comparator = null; initFromCollection(c); &#125; &#125; /** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified priority queue. This priority queue will be * ordered according to the same ordering as the given priority * queue. * * @param c the priority queue whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of &#123;@code c&#125; cannot be * compared to one another according to &#123;@code c&#125;'s * ordering * @throws NullPointerException if the specified priority queue or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123; this.comparator = (Comparator&lt;? super E&gt;) c.comparator(); initFromPriorityQueue(c); &#125; /** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified sorted set. This priority queue will be ordered * according to the same ordering as the given sorted set. * * @param c the sorted set whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of the specified sorted * set cannot be compared to one another according to the * sorted set's ordering * @throws NullPointerException if the specified sorted set or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(SortedSet&lt;? extends E&gt; c) &#123; this.comparator = (Comparator&lt;? super E&gt;) c.comparator(); initElementsFromCollection(c); &#125;","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"ArrayDeque源码剖析","slug":"ArrayDeque源码剖析","date":"2020-09-08T07:05:08.000Z","updated":"2020-09-12T02:08:42.300Z","comments":true,"path":"Java集合框架/ArrayDeque源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayDeque%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述Deque, 即“double ended queue”，表示双向队列，它既可以当作队列使用，也可以当作栈使用。ArrayDeque和LinkedList是Deque的两个通用实现，但是官方更推荐使用AarryDeque用作栈和队列。 ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，需要设置head指针和tail指针，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。也就是说ArrayDeque底层实现是一个循环数组（circular array），并且数组的任何一点都可能被看作起点或终点。 ArrayDeque是非线程安全的，另外该容器不允许放入null元素。 ArrayDeque实现底层数据机构123456789101112131415161718192021222324252627282930/** * The array in which the elements of the deque are stored. * The capacity of the deque is the length of this array, which is * always a power of two. The array is never allowed to become * full, except transiently within an addX method where it is * resized (see doubleCapacity) immediately upon becoming full, * thus avoiding head and tail wrapping around to equal each * other. We also guarantee that all array cells not holding * deque elements are always null. */ transient Object[] elements; // non-private to simplify nested class access /** * The index of the element at the head of the deque (which is the * element that would be removed by remove() or pop()); or an * arbitrary number equal to tail if the deque is empty. */ transient int head; /** * The index at which the next element would be added to the tail * of the deque (via addLast(E), add(E), or push(E)). */ transient int tail; /** * The minimum capacity that we'll use for a newly created deque. * Must be a power of 2. */ private static final int MIN_INITIAL_CAPACITY = 8; 由注释总结得出以下几点重要信息： 最小初始容量为8，并且自动扩容后数组的大小永远是2的幂。 数组永远不能满，以避免head和tail指针相等。 数组元素不能为null。 构造函数1234567891011121314151617181920212223242526272829303132333435 public ArrayDeque() &#123; elements = new Object[16]; &#125; public ArrayDeque(int numElements) &#123; allocateElements(numElements); &#125; public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); addAll(c); &#125;private void allocateElements(int numElements) &#123; elements = new Object[calculateSize(numElements)]; &#125;private static int calculateSize(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests \"&lt;=\" because arrays aren't kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; return initialCapacity; &#125; 由源码可知： 如果不指定容量创建ArrayDeque，默认数组大小为16。 如果指定容量大小，构造方法会调用static int calculateSize(int numElements)计算最合适的2的幂来创建数组。若指定容量小于MIN_INITIAL_CAPACITY8，则直接创建大小为8的数组；若指定容量大于等于8，则会通过以下代码块来获得大于指定容量的最小2的次幂数。 1234567initialCapacity = numElements;initialCapacity |= (initialCapacity &gt;&gt;&gt; 1);initialCapacity |= (initialCapacity &gt;&gt;&gt; 2);initialCapacity |= (initialCapacity &gt;&gt;&gt; 4);initialCapacity |= (initialCapacity &gt;&gt;&gt; 8);initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);initialCapacity++; &gt;&gt;&gt;为无符号右移运算，以8为例，其二进制数为000…01000共32位，后面简写为1000。8 &gt;&gt;&gt; 1后则为0100，相当于除以2的1次幂；8 &gt;&gt;&gt; 2后则为0010，相当于除以2的2次幂… |为按位或，两数按位或，对应位只要有一个1该为结果即为1。 那么以initialCapacity等于8为例： 12345ini &gt;&gt;&gt; 1, 得0100；1000 | 0100 得 ini &#x3D;1100ini &gt;&gt;&gt; 2, 得0011；1100 | 0011 得 ini &#x3D;1111ini &gt;&gt;&gt; 4, 得0000；1111 | 0000 得 ini &#x3D;1111ini &gt;&gt;&gt; 8, 得0000；1111 | 0000 得 ini &#x3D;1111ini &gt;&gt;&gt; 16, 得0000；1111 | 0000 得 ini &#x3D;1111 最后结果为16。 12345initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 1);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 2);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 4);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 8);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 16); 实际上，以上代码块的作用是将initialCapacity 的最高位1的所有低位全部变为1，如下图所示： 5次操作后再进行自加，就会得到大于initialCapacity的最小2的次幂数。 有一个特殊情况需要处理，即initialCapacity的最高位1是在第31位上： 01XXXXXX XXXXXXXX XXXXXXXX XXXXXXXX 这样在进行所有操作后initialCapacity会变为： 10000000 00000000 00000000 00000000 最高位为1，实际上就上溢为一个负数(-2^31)(32位整型范围为-2^31 ~ 2^31 - 1)。为了处理这种情况，会将initialCapacity右移一位，这样它就变为了一个很大的整数（2的30次幂）。 参考：https://blog.csdn.net/liubin119712/article/details/51075861 使用集合元素创建ArrayDeque调用的addAll()方法实际上继承自父抽象类AbstractCollection的，因为ArrayDeque没有重写该方法。 1234567public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; 然后addAll中的add方法为ArrayDeque重写的add方法。 扩容：doubleCapacity方法ArrayDeque的自动扩容发生在head == tail的情况下，此时直接扩容为原来的两倍。int newCapacity = n &lt;&lt; 1;。 12345678910111213141516171819/** * Doubles the capacity of this deque. Call only when full, i.e., * when head and tail have wrapped around to become equal. */ private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素个数 int newCapacity = n &lt;&lt; 1;//扩容为原空间2倍 if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制head右半部分 System.arraycopy(elements, 0, a, r, p);//复制head左半部分 elements = a; head = 0; tail = n; &#125; addFirst() 1234567public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); &#125; 因为tail指针总是指向下一个可插入的空位，也即在进行任何添加元素的操作时，总会有空位，所以不需要考虑空间问题。 head = (head - 1) &amp; (elements.length - 1)：这段代码在head不为0时，相当于求模运算，但是效率比使用%高。因为数组的大小永远是2的幂，所以elements.length - 1是011..11（32位）的形式，任何非负整数（且 &lt;= len-1）和它按位与都会等于其本身；而在head为0时，head-1则为-1，其二进制源码为1000...01（32位），由于计算机运算使用补码，-1的补码则为除符号位外全部取反后+1，为1111...11（32位），那么它和elements.length - 1按位与的结果就是elements.length - 1本身，也就是在数组末尾插入。 addLast()1234567public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; (tail = (tail + 1) &amp; (elements.length - 1)相当于求模运算。 pollFirst()1234567891011public E pollFirst() &#123; int h = head; @SuppressWarnings(\"unchecked\") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // 让GC回收 head = (h + 1) &amp; (elements.length - 1);//求模 return result; &#125; pollLast()12345678910public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(\"unchecked\") E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result; &#125; peekFirst()1234public E peekFirst() &#123; // elements[head] is null if deque empty return (E) elements[head]; &#125; peekLast()123public E peekLast() &#123; return (E) elements[(tail - 1) &amp; (elements.length - 1)]; &#125; 参考：https://www.pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"LinkedList源码剖析","slug":"LinkedList源码剖析","date":"2020-09-07T12:11:21.000Z","updated":"2020-09-08T11:49:46.276Z","comments":true,"path":"Java集合框架/LinkedList源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述LinkedList同时实现了List, Queue和Deque三个接口，因此它既可以看作一个顺序容器，又可以看作一个队列，也可以看作一个栈。由于Java官方已经不建议使用Vector和Stack，因此LinkedList是一个选择。关于栈和队列，现在的首选是ArrayDeque，它 没有容量限制，可根据需求自动进行扩容。由于ArrayDeque的底层实现为数组，其作为队列或数组时效率相较于基于双向链表的 LinkedList也要更好一些。注意，ArrayDeque 不支持为 null 的元素，LinkedList支持null。 LinkedList实现底层数据结构LinkedList底层通过双向链表实现，这决定了它所有与下标有关的操作都是线性时间，而在首尾插入删除元素只需要常数时间。为了追求效率LinkedList没有实现同步，如果需要并发访问，可以采用Collections.synchronizedList()方法进行包装。 123456789101112131415161718transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;//节点内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 构造方法1234567891011121314public LinkedList() &#123;&#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; getFirst(), getLast()获取list的第一个元素和最后一个元素 12345678910111213public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; removeFirst(), removeLast(), remove(e), remove(index)删除第一个节点 123456789101112131415161718192021public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++;//fast-fail return element; &#125; 删除最后一个节点 12345678910111213141516171819202122public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; 删除第一次出现的指定元素，若没有则返回false。注意LinkedList允许null元素，因此分为两种情况遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 删除指定index的节点，使用index &lt; (size &gt;&gt; 1判断index在前半段还是后半段，以此来决定从头部还是尾部开始遍历，可以一定程度提高效率。 1234567891011121314151617181920public E remove(int index) &#123; checkElementIndex(index);//检查是否越界 return unlink(node(index)); &#125;//返回指定index的节点Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; add(), addAll()末尾添加节点 12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true; &#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; 指定index添加元素。通过node(index)找到index处的节点，将element插入到该节点之前。 123456789101112131415161718192021public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; 末尾添加集合里所有元素 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; 指定index添加集合元素。添加到指定元素之前。 1234567891011121314151617181920212223242526272829303132333435363738public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; clear()清空链表 12345678910111213141516public void clear() &#123; // Clearing all of the links between nodes is \"unnecessary\", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++; &#125; set(), get()123456789101112public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; indexOf(), lastIndexOf()查找第一次出现指定元素的下标和最后一次出现指定元素的下标，找不到则返回-1。 1234567891011121314151617181920212223242526272829303132333435public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; Queue接口的方法peek(): 获取第一个元素。null不会抛异常。 element(): 获取第一个元素，如果为null会抛异常。 poll(): 获取并删除第一个元素。 offer(): 末尾添加元素。 参考：https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"ArrayList源码剖析","slug":"ArrayList源码剖析","date":"2020-09-07T09:18:35.000Z","updated":"2020-09-10T07:19:39.773Z","comments":true,"path":"Java集合框架/ArrayList源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述​ ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。 ​ 每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。 ​ size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 ​ 为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，可使用Vector替代。ArrayList除未实现同步外，其余跟Vector大致相同。 ArrayList的实现ArrayList中的常量12345678910111213141516/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 底层数据结构1234567891011121314/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 三种构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 扩容机制​ 每当向数组中添加元素时，都要检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行自动扩容。 ​ 数组扩容通过公开方法ensureCapacity(int minCapacity)实现。当需要使用ArrayList存储较多数据时，我们最好手动使用该方法进行扩容，以减少每次1.5倍自动扩容产生的复制数组元素的开销。因为ArrayList的初始容量只有10。 ​ 注意以下源码中，grow()方法中的int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);，可见每次扩容是在现有容量的基础上增加0.5倍容量。由于每次扩容老数组的元素会复制到新数组中，可见自动扩容机制的开销非常大。我们在实际使用ArrayList的时候，在可预知要保存多少个元素的情况下，应该在new ArrayList时指定容量大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add(), addAll()​ 添加元素之前，调用ensureCapacityInternal(size + 1);检查当前数组元素个数是否已达容量上限，是则进行grow操作。 1234567891011121314151617181920212223242526272829303132333435/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; add(int index, E element)操作的时间复杂度与插入元素的位置相关。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 与add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 set(), get()12345678910111213141516171819202122public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index]; &#125;public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; remove()remove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。注意，根据可达性分析算法，必须将数组中最后一个位置的引用清除掉，堆中的对象才会被回收，也就是显式的为最后一个位置赋null值。 123456789101112131415161718192021222324252627282930313233343536373839public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125;public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; trimToSize()将底层数组的容量调整为当前列表保存的实际元素的大小。 12345678910111213/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; indexOf(), lastIndexOf()获取元素第一次出现的index: 12345678910111213141516171819/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 获取元素最后一次出现的index: （倒序遍历数组） 12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 快速失败机制ArrayList的Fail-Fast机制通过记录modCount的值来实现。该变量在ArrayList的父抽象类AbastractList定义，其含义是容器发生结构性修改的次数。详细介绍在迭代器篇。 Arrays.copyof()和System.arraycopy()Arrays的copyof()方法有很多重载方法，以下为ArrayList中使用的重载版本。 12345678910111213public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass()); &#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 第二个方法最后一个参数表示最后返回的数组元素数据类型，也就是新数组的数据元素类型。该方法在内部创建了了一个长度为newLength的新数组，又调用了System.arraycopy()方法将老数组的元素复制到新数组。 查看java.lang.System发现，System.arraycopy()为本地方法，最终调用了C语言的函数来实现复制。 1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 参考：https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html ​ https://blog.csdn.net/ns_code/article/details/35568011","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"集合知识体系结构","slug":"集合知识体系结构","date":"2020-09-07T09:17:52.000Z","updated":"2020-09-10T15:25:02.002Z","comments":true,"path":"Java集合框架/集合知识体系结构/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"集合知识体系结构 CollectionListArrayList 基于动态数组实现，支持随机访问。 Vector 和 ArrayList 类似，但它是线程安全的。 StackLinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 QueueLinkedList 同上 PriorityQueue 基于小根堆实现，可以用它来实现优先队列。 Deque&lt;&gt;ArrayDeque 基于循环数组实现的队列，比LinkedList性能更好。 SetHashSet 基于HashMap实现（适配器模式），支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 继承自HashSet，具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 MapHashMap 基于哈希表实现。 LinkedHashMap 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。 HashTable 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 TreeMap 基于红黑树实现。 Collections工具类","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"比较器与迭代器","slug":"比较器与迭代器","date":"2020-09-07T09:17:29.000Z","updated":"2020-09-07T11:36:53.302Z","comments":true,"path":"Java集合框架/比较器与迭代器/","link":"","permalink":"http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"比较器Comparable java.lang.Comparable源码： 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; Comparable的实现类，其实例化对象和同类型对象比较。 其compareTo方法只有一个参数，一个和自己比较的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。 对于容器来说，在容器内部实现compareTo方法。 Comparator java.util.Comparator源码主要部分： 1234public interface Comparator&lt;T&gt;&#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; Comparator的实现类，其实例化对象作为裁判。 其compare方法是两个参数，裁判来比较传入的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。 对于容器来说，在容器外部实现compare方法。 二者的选择 排序规则固定，Comparable接口。排序规则经常变化，Comparator接口。 迭代器概述​ 由于各种容器的底层实现结构（数组，链表，哈希表等）不同，把容器元素的访问逻辑从不同类型容器中抽取出来，从而避免暴露容器的内部结构，使用户对容器元素的操作更简单，即迭代器模式。 Iterable java.lang.Iteable源码： 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action)&#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; Collection接口继承自Iterable接口，Iterable的作用是： 使得其所有实现成为foreach语句的目标 其iterator()方法返回一个标准的Iterator实现 Iterator java.util.Iterator源码： 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext();&#x2F;&#x2F;判断是否存在下一个元素 E next();&#x2F;&#x2F;获取下一个元素 default void remove() &#123; throw new UnsupportedOperationException(&quot;remove&quot;); &#125;&#x2F;&#x2F;移除元素 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; Iterator遍历时禁止对容器进行增删的问题 ​ 使用Iterator或者foreach（foreach底层实现为Iterator）时，禁止对所遍历的容器进行改变其大小结构的操作，也即不能使用容器的add/remove方法，否则会报ConcurrentModificationException。 ​ ArrayList中Iterator实现源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&#x2F;&#x2F;ArrayList的内部类private class Itr implements Iterator&lt;E&gt; &#123; int cursor; &#x2F;&#x2F; index of next element to return int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such int expectedModCount &#x3D; modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor !&#x3D; size; &#125; @SuppressWarnings(&quot;unchecked&quot;) public E next() &#123; checkForComodification(); int i &#x3D; cursor; if (i &gt;&#x3D; size) throw new NoSuchElementException(); Object[] elementData &#x3D; ArrayList.this.elementData; if (i &gt;&#x3D; elementData.length) throw new ConcurrentModificationException(); cursor &#x3D; i + 1; return (E) elementData[lastRet &#x3D; i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor &#x3D; lastRet; lastRet &#x3D; -1; expectedModCount &#x3D; modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(&quot;unchecked&quot;) public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;&#x2F;&#x2F;省略 &#125; final void checkForComodification() &#123; if (modCount !&#x3D; expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; ​ 由源码可知，检查并抛出异常的是checkForComodification方法，其判断条件为modCount != expectedModCount。expectedModCount是迭代器类Itr的成员变量，在迭代器对象创建时赋初值为modCount。那么modCount是什么呢？ ​ 找遍ArrayList类也没有发现modCount，那么向上找，发现其是ArrayList的父抽象类AbstractList的成员变量，其注释如下图 ​ 由注释可知，modCount的含义是list被结构性修改的次数。 ​ 由此可知，当ArrayList调用其add/remove方法时，modCount会自加，而此时迭代器中的expectedModCount未同步，因此才会导致再次调用next方法时抛出异常。如若使用ArrayList迭代器自带的remove方法，迭代器会同步更新expectedModCount的值，因此再次调用next不会报异常。 ​ 使用该机制的主要目的是为了实现ArrayList中的快速失败机制（fail-fast），在Java集合中较大一部分集合是存在快速失败机制的。 ​ 快速失败机制产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。 所以要保证在使用Iterator遍历集合的时候不出错误，就应该保证在遍历集合的过程中不会对集合产生结构上的修改。 总结：在使用迭代器时，ArrayList不能调用自身的add/remove方法。 ​ 但可以使用ArrayList的迭代器的remove方法，该方法移除迭代器返回的最后一个元素，且每调用一次next方法才能调用一次该remove方法（一对一）。 ​ 还可以使用ListIterator，它是一个更加强大的Iterator的子类型，可以使用add/remove方法。 ​ 参考：https://www.cnblogs.com/zyuze/p/7726582.html","categories":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Java集合框架","slug":"Java集合框架","permalink":"http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"}]},{"title":"Java泛型","slug":"Java泛型","date":"2020-09-04T11:06:21.000Z","updated":"2020-09-07T11:39:01.507Z","comments":true,"path":"Java基础/Java泛型/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"概述 在创建接口、类、方法时，为了代码复用和类型安全，使用泛型来作为类型。泛型可以看作形式参数，用于接受数据类型，当创建对象、实现接口、调用方法时才指定具体的类型。例如 123class List&lt;T&gt;&#123; private T element; &#125; 12345678class TestList&#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new List&lt;&gt;(); List&lt;Integer&gt; list = new List&lt;&gt;(); List&lt;Double&gt; list = new List&lt;&gt;(); //使用类时才指定List中元素具体的类型 &#125;&#125; Java泛型从JDK1.5引入，为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但在编译阶段会进行“类型擦除（Type Erasure）”，将所有的泛型表示都替换为具体的类型。 为什么引入泛型 为了代码复用：适用于多种数据类型执行相同的代码，例如 123private static &lt;T extends Number&gt; double add(T a, T b) &#123; return a.doubleValue() + b.doubleValue();&#125; 如果没有泛型，则对于int、float、double等类型都需要重载一个add方法。 为了类型安全：泛型类型在使用时指定，同时也就限定了集合中只能存储某一种具体类型的数据。以ArrayList为例： 12345678910111213public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;transient Object[] elementData;//ArrayList源码中定义的元素类型为Objectpublic E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index];//强制类型转换，由Object向下转型 &#125;&#125; 由源码可知，当调用get方法获取ArrayList元素时，get方法调用elementData方法，其return时由ArrayList完成强制类型转换（向下转型）。 如若ArrayList没有泛型机制会怎么样呢？ 那么，get方法只能返回Object类型的数据，好处是程序员可以使用ArrayList存储多种类型的数据。但是坏处也显而易见，当程序员使用ArrayList存储”String”、”Integer”、”Double”等各种类型的数据时，调用get方法得到的是Object类型，此时若程序员对这些数据向下转型为某种类型（比如String，String s = (String) obj），编译期不会报错，运行期才会报ClassCastException（因为Integer、Double不能强制转换为String），也就是类型不安全。 泛型的基本使用泛型类 使用泛型类 1234567891011121314151617class A&lt;T&gt;&#123; private T element; public T getElement()&#123; retruen element; &#125; public void setElement(T elem)&#123; this.element = elem; &#125;&#125;public class TestA&#123; public static void main(String[] args)&#123; A&lt;String&gt; a = new A&lt;&gt;(); a.setElement(\"test string...\"); System.out.println(a.getElement().length()); &#125;&#125; 多元泛型 123456789101112131415class B&lt;K, V&gt;&#123; private K key; private V value; //set,get方法。。。&#125;public class TestB&#123; public static void main(String[] args)&#123; B&lt;String, Integer&gt; b = new B&lt;&gt;(); b.setKey(\"小明\"); b.setValue(\"18\"); System.out.println(\"姓名：\"+b.getKey()); System.out.println(\"年龄：\"+b.getValue()); &#125;&#125; 泛型接口1234567891011121314interface C&lt;T&gt;&#123; public T getElem();&#125;class CImpl&lt;T&gt; implements C&lt;T&gt;&#123; //....&#125;//也可在接口的实现类这一步指定具体的类型public class TestC&#123; public static void main(String[] args)&#123; C&lt;String&gt; c = new CImpl&lt;&gt;(); //... &#125;&#125; 泛型方法 格式：修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){ //方法体 }。泛型方法在调用方法时确定数据类型。 1234567891011121314class GenericMethod&#123; public &lt;T&gt; void method&lt;T t&gt;&#123; System.out.println(t); &#125;&#125;public class TestGenericMethod&#123; public static void main(String[] args)&#123; GenericMethod gm = new GenericMethod(); gm.method(\"123\"); gm.method(123); //传递什么类型的参数，泛型就是什么类型 &#125;&#125; 泛型的上下限 有时候我们希望泛型只接收某些类型，而不是所有类型，那么我们就需要限定泛型的接收范围。 &lt;?&gt;：无限制通配符，表示任意类型。 &lt;? extends E&gt;： 表示只接收E类型，或者E类型的子类。 &lt;? super E&gt;： 表示只接收E类型，或者E类型的父类。 例如：以下代码表示T类型只能是Number类或者其子类，在限定了接收类型的同时，还可以使用Number类的方法和成员变量。 123private static &lt;T extends Number&gt; double add(T a, T b) &#123; return a.doubleValue() + b.doubleValue();&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"虚拟机类加载机制","slug":"虚拟机类加载机制","date":"2020-09-03T09:22:40.000Z","updated":"2020-09-07T11:34:07.032Z","comments":true,"path":"JVM/虚拟机类加载机制/","link":"","permalink":"http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"类加载过程 一个Java类从编写完成到被卸载的过程：X.java -&gt; X.class（编译为磁盘中的二进制文件）-&gt; 加载（ClassLoader将X.class加载到虚拟机内存）-&gt; 连接 （确定类与类之间的关系，包含验证、准备、解析三步） -&gt; 初始化 -&gt; 使用 -&gt; 卸载。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。类加载过程如下图： 加载：加载是类加载的一个阶段，注意不要混淆。 加载阶段完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时数据结构。 在内存中生成一个代表该类的java.lang.Class对象，作为方法区该类的各种数据的访问入口。 二进制字节流的获取方式有： 从ZIP包读取，成为 JAR、EAR、WAR 格式的基础。 从网络获取，典型应用为Applet 运行时计算生成，比如动态代理技术，在java.lang.reflect.Proxy中使用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。 由其他文件生成，比如由JSP文件生成对应的Class类。 从数据库读取。 连接 验证：这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备：在方法区中，为类的静态变量分配内存，并将其初始化为默认值（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型为null…），但是对于final修饰的常量则直接赋指定值。注意：实例变量（即未被static修饰的变量）不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，也就是类加载完成之后了。 解析：将class文件常量池的符号引用替换为直接引用的过程。 符号引用：与虚拟机的内存布局无关。可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用：与虚拟机实现的内存布局相关。可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。 初始化：为类的静态变量赋予正确的初始值（此时才赋予程序员设定的值），并执行静态代码块。 Java程序对类的使用方式可分为两种：主动引用与被动引用。每个类（接口）只有被Java程序“首次主动引用”时才初始化。包括： 使用new实例化该类对象。 读取或设置一个类（接口）的静态字段，以及调用一个类（接口）的静态方法。注：被final修饰的静态字段除外。 使用java.lang.reflect包的方法对类进行反射调用。 初始化某类的子类（先初始化父类）。 带main方法的类。 JDK1.7开始提供的动态语言支持 *。 被动引用例子： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value);&#x2F;&#x2F;value字段在SuperClass中为静态字段 通过数组定义来引用类，不会触发被引用类的初始化。但是该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] array &#x3D; new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类加载器 类与类加载器：加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作在虚拟机外部实现，由类加载器实现。我们可以通过自定义类加载器去控制字节流的获取方式。注意：数组类不通过类加载器创建，它由JVM直接创建。 HotSpot VM内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :面向用户的加载器，负责加载当前应用classpath下的所有jar包和类。 双亲委派模型：每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候： 系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。 当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。 以上的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 双亲委派模型的好处：双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。 破坏双亲委派模型：自定义类加载器，需要继承ClassLoader。如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载；如果想打破双亲委派模型则需要重写 loadClass() 方法。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"GC与内存分配策略","slug":"GC与内存分配策略","date":"2020-09-02T07:17:43.000Z","updated":"2020-09-07T11:39:12.560Z","comments":true,"path":"JVM/GC与内存分配策略/","link":"","permalink":"http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"","text":"对象已死吗（GC回收的前提是判断对象已死） 概述：对于程序计数器、虚拟机栈、本地方法栈，其内存区域和回收都具备确定性，方法结束或线程结束时，其内存自然就回收了。GC主要关注堆和方法区的分配与回收。 引用计数算法（不常用）：给对象添加一个引用计数器，每当被引用时，计数器值+1；引用失效（引用不再指向该对象）时，计数器值-1。任何时刻计数器为0的对象就是不可能再被使用的。缺点：难以解决对象之间相互循环使用的问题。（比如对象A中的引用指向B，对象B中的引用指向A，对象A、B计数器永远为1） 可达性分析算法（主流实现）：通过一系列的称为“GC Roots”的对象作为起始点向下搜索，搜索走过的路径称为“引用链”，当一个对象到“GC Roots”没有任何引用链相连，即证明对象不可达。 可作为GC Roots的对象包括： 虚拟机栈：栈帧中局部变量表中引用的对象 方法区： 类静态变量引用的对象 常量引用的对象 本地方法栈：JNI引用的对象 再谈引用：JDK1.2之后，引用概念分为以下4种，强度依次减弱 强引用：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。 软引用：描述有用但非必须的对象，当系统将要发生OOM异常时，软引用指向的对象才被真正回收。通过SoftReference类实现。 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。 虚引用：为一个对象设置虚引用关联的唯一目的时能在对象被回收时收到一个系统通知。通过PhantomReference类实现。 生存还是死亡：即使在可达性分析算法中不可达的对象，在该对象的finalize()方法中也有一次自救的方法，即重新与引用链上的任何一个对象建立关联即可，譬如把this赋值给某个类变量或者对象的成员变量。但是，建议使用try-finally语法而尽量不使用finally()方法。 回收方法区：主要回收废弃常量和无用的类。废弃常量的回收与堆中的对象类似，而无用类的判定则要复杂的多，需要满足： 堆中不存在该类的实例 ClassLoader已被回收 Class对象没有被引用，且无法在任何地方通过反射访问该类的方法。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息。 注：对于大量使用反射、动态代理、CGLib等ByteCode框架的场景，要注意方法区的类卸载。 垃圾收集算法 标记-清除算法：标记回收对象，标记完成后统一回收。 缺点：标记和清除效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 标记-整理算法：标记回收对象，让所有存活的对象向一端移动，然后直接清理掉对象所在的连续内存后的所有内存。 特点：适用于老年代的算法，不会产生内存碎片。 复制算法：对于现在的商业虚拟机，堆内存被划分为三块，一块较大的Eden空间、两块较小的Survivor空间。 当Eden空间满时，第一次Minor-GC（针对新生代的GC）将Eden还存活的对象全部复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden； 当Eden满时，第二次Minor-GC将Eden和Survivor-0中还存活的对象复制到Survivor-1中，存活对象“寿命计数器”+1，清理Eden和Survivor-0； 当Eden满时，第三次Minor-GC将Eden和Survivor-1中还存活的对象复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden和Survivor-1； ……. 如此往复，当某个Survivor满或者对象“寿命计数器”值达到阈值，则将对象复制到老年代中。 当老年代和新生代都满时，会进行一次Full-GC。 HotSpot虚拟机的Eden和Survivor大小默认比例为8:1，保证了内存利用率达到90%。 分代收集算法：现在的商业虚拟机采用分代收集算法。 新生代：由于每次GC时都有绝大部分对象死去，只有少量对象存活，故采用复制算法，因为只需要付出少量存活对象的复制成本。 老年代：由于老年代对象存活率高且没有额外空间对它分配担保，故采用标记-整理算法或标记-清除算法。 垃圾收集器 以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器之间可以搭配使用。 Serial收集器：单线程；简单高效，拥有最高的单线程收集效率；Client场景下的默认新生代收集器。 ParNew收集器：Serial的多线程版本；Server场景下默认的新生代收集器；唯一能与CMS收集器配合使用的收集器。 Parallel Scavenge收集器：多线程，吞吐量（CPU运行用户代码的时间除以CPU总消耗时间）优先的收集器。 Serial Old收集器：Serial的老年代版本，Client场景使用。 Parallel Old收集器：Parallel Scavenge的老年代版本 CMS(Concurrent Mark Sweep)收集器：以获取最短回收停顿时间为目标，基于标记-清除算法。分为四个阶段： 初始标记：只标记与GC Roots直接关联的对象，需要Stop The World。 并发标记：进行 GC Roots Tracing，耗时最长，不需要停顿。 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要Stop The World。 并发清除：不需要停顿。 缺点明显： CPU资源敏感：CMS默认启动的回收线程数是（CPU数+3）/4，当CPU数较少时，吞吐量很低。 无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能下一次GC清除。 标记-清除算法会产生大量空间碎片。 总体上来说，CMS的垃圾回收过程是与用户线程一起并发执行的。 G1(Garbage First)收集器：面向服务端应用。 使用G1时，Java堆内存布局与以往不同，它将整个Java堆划分为多个大小相等的独立Region，新生代与老年代是一部分不连续Region的集合，如图： G1通过记录每个Region垃圾回收时间和回收所得空间（这两个值通过过去回收的经验计算），并维护一个优先列表，每次根据用户允许的收集时间，优先回收价值最大的Region。使用Region划分内存空间，有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的收集效率。 每个Region都维护一个Remembered Set，用于记录Region之间的对象引用，来避免GC时的全堆扫描。（其他收集器新生代与老年代之间的对象引用也是使用Remembered Set，避免Minor-GC时全堆扫描）。 如不计算维护Remembered Set的操作，G1的运作可划分如下： 初始标记：停顿。 并发标记 最终标记：停顿。为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。 筛选回收：根据用户允许的收集时间和优先列表来回收。 总结G1的特点如下： 并行与并发：G1在多CPU和大内存的硬件优势下能有效缩短Stop-The-World的时间。 分代收集：新生代和老年代可以一起回收。 空间整合：整体上看基于“标记-整理”算法，局部上看基于“复制”算法。不会产生内存碎片。 可预测的停顿：能让用户自定义在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。 垃圾收集器参数总结 内存分配与回收策略 对象优先在Eden分配 大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 通过参数-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 长期存活的对象将进入老年代：通过参数-XX:MaxTenuringThreshold用来定义年龄的阈值。 动态对象年龄判定：虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 GC的触发条件 对于Minor GC，其触发条件为Eden区满时。而对于Full GC: 调用System.gc()。 老年代空间不足。 空间分配担保失败。 Concurrent Mode Failure。 减少Full GC的方法： 尽量不要创建大对象和数组。 通过-Xmn调大新生代大小。 通过-XX:MaxTenuringThreshold调大进入老年代的阈值。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"Java内存区域与内存溢出异常","slug":"Java内存区域与内存溢出异常","date":"2020-08-23T03:24:45.000Z","updated":"2020-09-10T02:34:48.688Z","comments":true,"path":"JVM/Java内存区域与内存溢出异常/","link":"","permalink":"http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"","text":"运行时数据区域​ 线程私有：与线程生命周期相同 程序计数器（Program Counter Register）：记住下一条JVM字节码指令的地址。每条线程都有一个独立的PCR。此内存区域是唯一一个在JVM规范中没有任何OOM情况的区域。 Java虚拟机栈：描述Java方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈等。每个方法从调用到执行完毕，对应一个栈帧从入栈到出栈的过程。 局部变量表存放编译期可知的各种基本数据类型和引用。 JVM规范定义了该区域两种异常情况： 线程请求的栈深度大于VM允许的深度，将抛出StackOverflowError异常。 若虚拟机栈可动态扩展，且扩展时无法申请到足够的内存，将抛出OOM异常。 本地方法栈：与虚拟机栈的区别在于，虚拟机栈为VM执行Java方法服务，而本地方法栈为VM使用到的本地方法服务。 异常情况同虚拟机栈。 线程共享：VM启动时创建 堆：用于存放对象实例和数组。 Java堆是GC管理的主要区域。 扩：随着JIT（Just in Time）技术与逃逸分析技术逐渐成熟，所有对象都分配在堆上并不绝对了。 ​ 热代码：频繁调用的字节码。 ​ [https://developer.ibm.com/zh/articles/j-lo-just-in-time/#] 方法区：存储已被VM加载的类信息（变量和方法数据，方法和构造器的字节码等）、运行时常量池、JIT编译后的机器码等。 许多主流框架都会用到CGLib或者JDK动态代理，动态生成大量Class容易导致方法区OOM异常。 三种常量池区分 class文件常量池：编译阶段，存放编译期生成的字面量（常量值）和符号引用，其中符号引用包括类名、方法名、参数类型等信息。javap -v Main.class反编译如下代码： 12345678public class Main &#123; final String stest &#x3D; &quot;String Test ...&quot;; public static void main(String[] args) &#123; System.out.println(&quot;helloworld&quot;); &#125; &#125; 结果如下： 字符串常量池： 类加载完后在堆中生成字符串对象实例（JDK1.7及以后），然后将该字符串对象实例的引用存到字符串常量池中。 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。注意：对于new的String对象，若在类中new，则其引用变量存于方法区；若在方法中new，则其引用在虚拟机栈的栈帧的局部变量表中。 StringTable编译期优化： 运行时常量池：类加载完成之后，编译期生成的非字符串类型常量和符号引用进入运行时常量池，由符号引用翻译而来的直接引用也会存入运行时常量池。 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也会频繁使用，可能导致OOM异常。 JDK1.4中加入了NIO类（New Input/Output），引入了一种基于Channel与Buffer的I/O方式，它可以使用本地函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 常见的VM堆栈参数 -Xms: 设置堆的最小值，如-Xms20m -Xmx: 设置堆的最大值，如-Xmx20m -Xmn: 设置堆新生代值 -Xss: 设置虚拟机栈容量 -Xoss: 设置本地方法栈容量（HotSpot的虚拟机栈和本地方法栈仅由-Xss决定） -XX:Permsize=10M: 设置方法区大小为10M -XX:MaxDirectMemorySize=10M: 设置本机直接内存大小为10M 常见的OOM原因 堆堆内存没有足够空间存放新创建的对象。常见异常：java.lang.OutOfMemoryError:Javaheap space; java.lang.OutOfMemoryError:GC overhead limit exceeded 常见原因： 创建了一个超大对象，比如大数组 超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。 过度使用终结器（Finalizer），该对象没有立即被 GC。重写了finalize()方法的对象不会被立即GC。 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。 解决方案：针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理： 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。 如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。 方法区常见原因：对象数组和类型数组所关联的class太多。 解决方案： 修改 -XX:MaxPermSize 启动参数，调大永久代空间。 设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class。 JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），调整 Metaspace 空间大小的启动参数为 -XX:MaxMetaspaceSize。 其他OOM原因参考：https://zhuanlan.zhihu.com/p/79355050","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"SpringAOP","slug":"SpringAOP","date":"2020-04-23T08:36:02.000Z","updated":"2020-09-07T11:37:24.361Z","comments":true,"path":"uncategorized/SpringAOP/","link":"","permalink":"http://thmasterplan.cn/uncategorized/SpringAOP/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"SpringIOC","slug":"SpringIOC","date":"2020-04-14T13:36:18.000Z","updated":"2020-09-07T11:37:16.877Z","comments":true,"path":"Java框架/SpringIOC/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringIOC/","excerpt":"","text":"Spring概述 Spring以IOC(Inversion of Control)和AOP(Aspect Oriented Programming)为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。 控制反转Inversion of Control(IOC)耦合度 概念：模块（类）之间的关联、依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。耦合的程度依赖于以下几个因素： 模块间的调用 模块间传递的数据量 一个模块施加到另一个模块的控制的多少 模块间接口的复杂程度 耦合按从高到低的顺序可分为： 内容耦合：一个模块直接修改或操作另一个模块的数据，或者直接转入另一个模块时，就发生了内容耦合。例如，类与类之间直接调用或继承关系都属于这种耦合。 公共耦合：多个模块共同引用一个全局数据项。 控制耦合：一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。 标记耦合：模块间通过参数传递复杂的内部数据结构。 数据耦合：模块间通过参数传递基本类型的数据。 需要低耦合的原因：在耦合度很高的情况下，维护代码时修改一个地方会牵连到很多地方，难以厘清，可谓是牵一发而动全身。 降低耦合度的方法： 少用继承，多用接口。 模块的功能划分尽可能的单一（高内聚）。 遵循一个定义只在一个地方出现。 少使用全局变量。 类成员变量和方法少用public，多用private。 多使用设计模式，比如使用MVC设计模式就可以降低界面与业务逻辑的耦合度。 如果模块间必须存在耦合，尽量使用数据耦合。例如使用配置文件或注解传递参数，使用反射创建对象等都属于数据耦合。 工厂模式解耦例子 持久层 123456&#x2F;** * 账户的持久层接口 *&#x2F;public interface IAccountDao &#123; void saveAccount();&#125; 12345678&#x2F;** * 持久层实现类 *&#x2F;public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(&quot;账户已经保存！&quot;); &#125;&#125; 业务层 123456789&#x2F;** * 账户业务层的接口 *&#x2F;public interface IAccountService &#123; &#x2F;** * 模拟保存账户 *&#x2F; void saveAccount();&#125; 1234567891011&#x2F;** * 业务层实现类 *&#x2F;public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao &#x3D; (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;); public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 表现层 123456789&#x2F;** * 模拟表现层调用业务层，实际开发中类似Servlet *&#x2F;public class Client &#123; public static void main(String[] args) &#123; IAccountService as &#x3D; (IAccountService) BeanFactory.getBean(&quot;accountService&quot;); as.saveAccount(); &#125;&#125; bean.properties配置文件 12accountService&#x3D;com.itheima.service.impl.AccountServiceImplaccountDao&#x3D;com.itheima.dao.impl.AccountDaoImpl BeanFactory 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748&#x2F;** * 一个创建Bean对象的工厂 * Bean: 可重用组件，例如在Java中JavaBean有实体类、service和dao对象等 * * 工厂模式解耦：使用配置文件或注解传递参数，使用反射创建对象。 *&#x2F;public class BeanFactory &#123; &#x2F;&#x2F;定义一个Properties对象 private static Properties props; &#x2F;&#x2F;定义Map存储bean对象，避免多实例降低效率（即避免每次调用getBean方法都要重新创建对象） private static Map&lt;String, Object&gt; beansMap; &#x2F;&#x2F;初始化 static&#123; props &#x3D; new Properties(); try &#123; &#x2F;&#x2F;获取properties文件的流对象并加载 props.load(BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;)); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;); &#125; beansMap &#x3D; new HashMap&lt;&gt;(); Enumeration keys &#x3D; props.keys(); &#x2F;&#x2F;遍历properties中的每个key，创建对应的实例并存入beansMap中 while(keys.hasMoreElements())&#123; String beanName &#x3D; keys.nextElement().toString(); String beanPath &#x3D; props.getProperty(beanName); Object bean &#x3D; null; try &#123; bean &#x3D; Class.forName(beanPath).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; beansMap.put(beanName, bean); &#125; &#125; &#x2F;** * 根据bean的名称获取bean对象 * @param beanName * @return bean对象 *&#x2F; public static Object getBean(String beanName)&#123; return beansMap.get(beanName); &#125;&#125; IOC 概念与作用：控制反转把创建对象的权力交给框架，它包括Dependency Injection与Dependency Lookup两部分。其作用在于降低程序的耦合度。 基于XML的IoC配置 bean.xml示例 12345678&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt; &lt;!--将对象的创建交给spring管理--&gt; &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;&lt;&#x2F;beans&gt; ApplicationContext的三个常用实现类 ClassPathXmlApplicationContext：加载类路径下的配置文件 FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件 AnnotationConfigApplicationContext：读取注解 核心容器的两个接口引发的问题 ApplicationContext（常用）：单例对象适用。创建核心容器时，创建对象的策略为立即加载。只要一读取完配置文件就立马创建bean对象。 BeanFactory（ApplicationContext父接口的父接口）：多例对象适用。创建核心容器时，创建对象的策略为延迟加载。也即，何时调用获取bean对象的方法，那时才创建对象。 Spring对bean对象的管理细节 创建bean对象的三种方式 使用默认构造函数创建：在spring的xml配置文件中使用bean标签，配置id和class属性后，且没有其他属性和标签时，采用的是默认构造函数创建bean对象(反射中的newInstance方法使用默认构造创建对象)，如果类没有默认构造函数则无法创建对象。 使用普通类(工厂)中的方法创建对象并存入spring容器(比如jar包中的类)： 12345public class InstanceFactory&#123; public IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 1234&lt;!--创建实例工厂对象--&gt;&lt;bean id&#x3D;&quot;instanceFactory&quot; class&#x3D;&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;&#x2F;bean&gt; &lt;!--通过指定实例工厂对象的方法，创建指定对象--&gt;&lt;bean id&#x3D;&quot;accountService&quot; factory-bean&#x3D;&quot;instanceFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt; 使用工厂中的静态方法创建对象并存入容器(比如jar包中的类)： 12345public class StaticFactory&#123; public static IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 12&lt;!--通过指定工厂类的静态方法创建对象--&gt;&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.factory.StaticFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt; bean对象的作用范围调整：bean标签scope属性，取值为以下 singleton：单例（默认的，不管new多少次，内存中只有一个实例对象） prototype：多例 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），若不是集群环境，则效果与session相同 bean对象的生命周期 单例对象：单例对象的生命周期与容器相同，容器创建则对象创建，容器销毁时对象销毁，可在bean标签中指定init-method与destroy-method属性来执行bean对象中的init方法和destroy方法。 多例对象：使用对象时才创建对象，spring不能销毁，只能通过GC回收，因此无论如何都不会执行bean对象中的destroy方法。 依赖注入（Dependency Injection）：当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例，但在IoC中，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。要实现IoC，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过【构造器/方法/注解】注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。 注入的数据类型 基本数据类型和String bean 复杂类型/集合类型 注入的方式有 构造器：通过bean标签中的constructor-arg标签配置实现 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; &#x2F;&#x2F;读取xml，通过反射创建bean对象；依赖查找 ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); &#x2F;&#x2F; IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;); IAccountService as &#x3D; ac.getBean(&quot;accountService&quot;, IAccountService.class);&#x2F;&#x2F;两种方式获取bean对象 as.saveAccount(); &#x2F;** 使用BeanFactory * BeanFactory beanFactory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;bean.xml&quot;)); * IAccountService as &#x3D; (IAccountService) beanFactory.getBean(&quot;accountService&quot;); *&#x2F; &#125;&#125; 1234567891011public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public AccountServiceImpl(IAccountDao accountDao) &#123; this.accountDao &#x3D; accountDao; &#125; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 12345&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt; &lt;!--value属性用于注入基本类型和String类型，ref属性则为bean类型--&gt; &lt;constructor-arg name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDaoImpl&quot;&gt;&lt;&#x2F;constructor-arg&gt; &lt;&#x2F;bean&gt;&lt;bean id&#x3D;&quot;accountDaoImpl&quot; class&#x3D;&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;&#x2F;bean&gt; set方法：property标签，name属性指定方法名，value属性用于注入基本类型和String类型，ref属性则为bean类型。bean类需要设置set方法。 集合类型的注入：使用set,list,arroCay,map,props等子标签 注解：@Autowired 基于注解的IoC配置 首先配置context 12345678910&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot; xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot; xsi:schemaLocation&#x3D;&quot; http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; &lt;!--指定spring在创建容器时要扫描的包--&gt; &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;&lt;&#x2F;beans&gt; 创建bean对象的注解 @Component：被注解的类由spring创建并存入IoC容器 @Controller：用于表现层 @Service：用于业务层 @Repository：用于持久层 后三个注解的作用与属性都与@Component相同 依赖注入的注解 @Resource：在需要注入依赖的变量上标记，并在其实现类上标记@Component（或其余三种）注解。通过name属性匹配实现类。 123456789@Component(&quot;accountService&quot;)public class AccountServiceImpl implements IAccountService &#123; @Resource(name&#x3D;&quot;accountDao&quot;) private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 123456@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(&quot;Your Account has been saved!&quot;); &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;); IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;); as.saveAccount(); &#125;&#125; @Autowired：@Qualifier需要与@Autowired一起使用。 以上的注解只能用于bean类型的注入，集合类型的注入只能通过xml配置文件实现。 @Value：用于注入基本类型与String类型数据。 改变作用范围的注解：@Scope，value属性常用取值为singleton，prototype 与生命周期相关的注解 @PreDestroy：指定销毁方法 @PostConstruct：指定初始化方法 基于注解的IoC配置（不再需要xml文件） @Configuration：创建一个代替bean.xml的配置类SpringConfig后，使用该注解标记该类为配置类 @Import：标记主配置类，用于导入其他的从配置类。属性：Class&lt;?&gt;[] value;。使用该注解后可不再使用@Configuration注解。 @ComponentScan：指定spring在创建容器时需要扫描的包 @Bean：标记一个方法，将该方法的返回值作为bean对象存入IoC容器。其属性name用于指定bean对象的id，默认值为方法名。 @PropertySource：指定properties配置文件的位置。用于配置数据库等字符串信息。 使用new AnnotationConfigApplicationContext(SpringConfig.class);获取容器。 IoC案例 使用xml配置，注解结合xml配置，纯注解配置三种方式 Use “Sourcegraph” to view the code：https://github.com/Laishiji/SpringLearningDemo Spring整合Junit 导入依赖spring-test 使用Junit提供的@RunWith替换Runner(替换main方法) 使用@ContextConfiguration告知Spring的运行器，spring容器的创建是基于xml还是注解，并说明位置 123456789101112131415161718&#x2F;** * 单元测试,Spring整合Junit *&#x2F;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes &#x3D; SpringConfig.class)public class AccountServiceTest &#123; @Autowired IAccountService as; @Test public void testFindAll()&#123; List&lt;Account&gt; accounts &#x3D; as.findAllAccount(); for (Account a : accounts) &#123; System.out.println(a); &#125; &#125;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"检索技巧","slug":"检索技巧","date":"2020-04-09T09:00:06.000Z","updated":"2020-09-07T11:35:36.764Z","comments":true,"path":"Others/检索技巧/","link":"","permalink":"http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Github搜索 in:name example：项目名中包含”example“ in:readme example：readme.md中包含”example“ in:description example：描述中包含”example“ stars:&gt;1000：项目 star数大于1000 forks:&gt;1000：项目fork数大于1000 pushed:&gt;2020-03-05：项目在该日期后有更新 language:java：项目用Java编写 以上条件可组合使用 搜索引擎检索 &quot;example&quot;：完全匹配 example site:www.xxx.com：站点内搜索 example -csdn.net：排除关键字","categories":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/tags/Others/"}]},{"title":"Java基础","slug":"Java基础","date":"2020-04-08T14:47:15.000Z","updated":"2020-09-09T04:12:18.967Z","comments":true,"path":"Java基础/Java基础/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"面向对象三大特性继承 Java类是单继承的，不允许子类继承多个父类的原因在于，编译器无法确定使用哪个父类方法。 在父子类的继承关系中，创建父或子类对象，访问成员方法的规则：优先使用创建的对象的方法，没有则向上找。 继承关系中，父子构造方法访问的特点 子类构造方法有一个默认隐含的super()调用，因此一定是先调用的父类构造，后执行子类构造。 子类构造可以通过显示使用super()来调用父类重载构造，并且必须是子类构造的第一条语句。 重载与重写 重写：子类重写方法与父类方法名相同，参数列表相同。 重载：一个类中有多个相同的方法名，但参数列表不同。 多态 概念：父类（接口）引用指向子类对象。 多态代码中 成员重写方法的访问规则：先在子类对象中找，没有则向上找。 成员变量访问规则：直接使用父类成员变量。 向上转型即多态：父类引用指向子类对象；引用无法调用原本子类特有的方法。 向下转型，例如Anaimal a = new Cat();Cat cat = (Cat) a;，这个过程将父类变量还原为子类类型，使其又可以访问子类特有的方法。 多态的作用？ Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations. 封装 封装通过将类属性定义为私有，对外提供类属性的setters/getters方法来修改和获取属性值实现。 封装可以减少耦合，防止类数据被外部类定义的代码随机访问。 权限修饰符作用范围 外部类只有public和default两种权限。 private：只能修饰类方法和类变量，类内部才能访问。 default：无论对于类、类变量还是类方法，只能同一包内才能访问。 protected：修饰类变量和类方法，同一包内的类和该类的子类可访问。 关键字static 修饰成员变量或成员方法：不需要创建对象就可通过类名调用，它们均属于类，而非某个对象 修饰内部类（不允许修饰普通类） 12345678910111213141516171819public class StaticTest &#123; public static class Inner&#123; static&#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类静态代码块&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; Inner() &#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类构造方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; public void innerMethod()&#123; System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类普通方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;); &#125; &#125; public static void main(String[] args) &#123; Inner inner &#x3D; new Inner(); inner.innerMethod(); &#125;&#125; 输出：====静态内部类静态代码块==== ====静态内部类构造方法==== ====静态内部类普通方法==== 结论：想要在普通类中创建内部类实例，可以用static修饰内部类。 静态代码块 第一次使用类时，类的静态代码块执行唯一的一次。（类加载的初始化阶段执行静态代码块） 静态代码块先于构造方法执行。 Tips: 静态不能直接访问非静态 静态方法中不能用this, this代表当前对象。 final 修饰类：当前类不能有子类。 修饰方法：该方法不能被子类重写。（显然对于类、方法来说，abstract和final无法同时使用） 修饰数据：对于基本数据类型，其值不能再改变；对于引用数据类型，不能再改为存储其他对象的地址或引用（对象自身是可以改变的）。对于类变量，必须赋初始值或在构造方法中赋值。 修饰数组：数组的引用不能再指向其他数组，当数组内容可变。 instanceof instanceof 的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean类型。 native 使用native关键字修饰方法，说明这个方法是本地函数，也就是这个方法是用C/C++语言（或者其他语言）实现的，并且被编译成了DLL，由JVM调用。 native修饰的方法没有方法体。 transient 实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中，该属性的将只会存在于内存中。常见的应用有密码、银行卡号等敏感信息。 transient关键字只能修饰变量。 接口与抽象类抽象类 public abstract class Name{}；抽象类是描述一个对象是什么，它可以包含成员变量、成员方法、构造方法等，与普通类不同的点只在于：它可能包含抽象方法；它必须要被非抽象子类继承才能实例化，并且非抽象子类必须实现抽象方法（假如父类有抽象方法的话）。 单继承。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；抽象方法没有方法体。 抽象类使用： 创建子类继承抽象父类。 子类重写父类抽象方法，去掉abstract关键字，实现方法体。 接口 public interface IName{}；接口是多个类的公共规范。 接口可以继承多个接口，实现类可以实现多个接口。（多继承，多实现） 接口的成员变量默认都是public static final的：假如两个接口有相同的成员变量，一个类实现了这两个接口，那么实现类只能通过接口名.变量名来调用以避免歧义，因此必须为static。声明为final的原因是实现类不能够修改接口成员变量的值。 Java7：常量，抽象方法 Java8：新增了默认方法(default修饰)，静态方法。 增加默认方法的原因：Java升级后的兼容性问题。如果想在老版本接口中添加某个功能，在添加抽象方法的情况下，所有的老版本实现类都需要修改代码；而通过增加default方法来增加功能就不会有这种问题。 考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法。解决方案：重写方法，并使用接口名.super.方法名()调用指定接口的方法。 12345 public interface Vehicle &#123; default void print()&#123; System.out.println(&quot;vehicle...&quot;); &#125;&#125; 12345 public interface FourWheeler &#123; default void print()&#123; System.out.println(&quot;fourWheeler...&quot;); &#125;&#125; 12345678910111213public class Car implements Vehicle, FourWheeler &#123; @Override public void print() &#123; FourWheeler.super.print(); Vehicle.super.print(); &#125; public static void main(String[] args) &#123; Vehicle car &#x3D; new Car(); car.print(); &#125;&#125; ​ 输出：fourWheeler… ​ vehicle… Java9：新增了私有方法，私有静态方法 面向接口编程？ 内部类成员内部类 三种方法使用成员内部类 在外部类的方法中创建内部类实例 main方法中：Inner inner = new Outer.new Inner(); main方法中直接new，前提是静态内部类 在内部类中访问重名的外部类变量 1234567891011121314151617181920public class Outer &#123; private int num &#x3D; 10;&#x2F;&#x2F;外部类私有变量，内部类也可访问 class Inner&#123; private int num &#x3D; 20; public void innerMethod()&#123; int num &#x3D; 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125; public static void main(String[] args) &#123; Inner inner &#x3D; new Outer().new Inner(); inner.innerMethod(); &#125;&#125; 局部内部类 该类定义在方法内部，只有在该方法内部才能使用。 局部内部类中的匿名内部类 如果接口的实现类（或者父类的子类）只需要使用一次，那么这种情况下可以省略掉该类的定义，而使用匿名内部类。 最常见的使用：通过将Runnable接口的实现类的实例对象作为参数传给Thread，创建线程。不仅省略了类定义，同时完成了向上转型。 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(&quot;...&quot;); &#125; &#125;).start(); 包装类 包装类通过将基本数据类型封装起来，在类中提供一些方法，便于操作这些基本数据类型。 Java自jdk5后提供自动装箱与自动拆箱机制。 基本类型与字符串的转换 基本类型 -&gt; String：基本类型值+”” String -&gt; 基本类型：使用包装类的静态方法parseXXX(&quot;str&quot;) Integer：static int parseInt(String s) Double：static double parseDouble(String s) 值传递与引用传递 实参与形参： 形式参数：定义函数时使用的参数，用来接收实际参数。 实际参数：调用有参函数时，传入的内容。 值类型与引用类型 值类型（基本数据类型）：直接存储值。 引用类型：存储的是对象的地址。对象在堆中。 求值策略（Evaluation Strategy）：值传递与引用传递，属于函数调用时参数的求值策略，是对调用函数时求值和传值的方式的描述，而非传递的内容的类型。（内容的类型是指：值类型还是引用类型。）值类型与引用类型，用于区分两种内存分配方式，值类型在虚拟机栈上分配，引用类型在堆上分配。 值传递概念：调用函数时，将实际参数拷贝一份传递给函数。In call by value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (frequently by copying the value into a new memory region). Java uses call by value evaluate function arguments left-to-right 引用传递概念：调用函数时，将实际参数的地址传递给函数。Call by reference (or pass by reference) is an evaluation strategy where a function receives an implicit reference to a variable used as argument, rather than a copy of its value. 总结-“Java中只有值传递，值传递与引用传递的区别重点在于是否拷贝”：对于基本数据类型，传递的是基本数据类型的值的拷贝；对于引用类型，传递的是对象的地址值的拷贝，形参与实参都保存的是堆内存中同一个对象的地址。 参考：https://en.wikipedia.org/wiki/Evaluation_strategy Deep Copy, Shallow CopyShallow Copy B对A的浅拷贝：创建新对象B，将A的字段值复制到B。 如果该字段值是对对象（例如，存储器地址）的引用，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。 如果该字段值是基本数据类型，则复制值。 Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法，then B = (A) new A().clone(); Deep Copy B对A的深拷贝：创建新对象B，对于A的引用类型，在B中创建该引用对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。 参考：https://en.wikipedia.org/wiki/Object_copying#Methods_of_copying Java四种引用类型 JDK1.2之后，引用概念分为以下4种，强度依次减弱 强引用：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。 软引用：描述有用但非必须的对象，当系统将要发生OOM异常时，软引用指向的对象才被真正回收。通过SoftReference类实现。 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。 虚引用：为一个对象设置虚引用关联的唯一目的时能在对象被回收时收到一个系统通知。通过PhantomReference类实现。 集合的三种遍历方式 for 形式：for(初始化;结束条件;自增操作等) 需要知道集合的大小和元素类型，使用索引。 foreach 形式：for(T element : colletion) 需要知道集合元素的类型，不需要索引。 iterator 形式：Iterator it = collection.iterator();while(it.hasNext()){ object o =it.next(); ...} 集合的大小和类型都无需知道，也无需索引。 Tips: foreach是iterator的语法糖，底层使用iterator实现。 使用for循环进行remove操作时，每一次操作完成后索引需要自减。 iterator/foreach遍历集合时的add/remove操作见“Java集合框架”。 异常 Java异常图解 Throwable类中定义了一些查看异常的方法： public String getMessage()：获取异常的描述信息。 public String toString()：获取异常的类型和异常描述信息。 void printStackTrace()：打印异常的跟踪栈信息。最常用。 捕获异常 1234567891011121314try&#123; &#x2F;&#x2F;可能产生异常的代码&#125;catch(异常类型1 e)&#123; &#x2F;&#x2F;异常的处理逻辑；一般会记录到日志中&#125;... catch(异常类型n e)&#123; &#125;finally&#123; &#x2F;&#x2F;无论是否出现异常都会执行，常用于资源释放 &#125;&#x2F;&#x2F;jdk1.8之后支持try with resource写法try(需要释放资源的代码)&#123;&#125;catch(Exception e)&#123;&#125; 自定义异常类 1234567891011public class XXXException extends Exception&#123; &#x2F;&#x2F;添加一个空参构造 public XXXException()&#123; super(); &#125; &#x2F;&#x2F;添加一个带异常信息的构造 public XXXException(String message)&#123; super(message);&#x2F;&#x2F;所有的子类异常都交给父类处理 &#125;&#125; 自定义异常类一般以命名Exception结尾，必须继承Exception类或者RuntimeException类： 继承自Exception：自定义异常为编译期异常，必须处理。 继承自RuntimeException：运行期异常无需处理。 字符串String String类是final的，因此不能被继承。源码是一个final修饰的字符数组，因此一旦创建就是一个不可变的字符串。 1private final char value[]; StringTable编译期优化： 判断字符串是否相等？ 值在编译阶段确定（相等） 1234567public static void main(String[] args) &#123; String a &#x3D; &quot;helloWorld&quot;; String b &#x3D; &quot;helloWorld&quot;; String c &#x3D; &quot;hello&quot; + &quot;World&quot;; System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;true System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;true&#125; 分析：字符串常量在编译阶段会存入常量池中共享，编译阶段完成字符串的拼接（无引用的情况下），因此在运行期a,b,c均指向同一个地址。 值在编译器无法确定（不相等） 1234567public static void main(String[] args) &#123; String a &#x3D; &quot;helloWorld&quot;; String b &#x3D; new String(&quot;helloWorld&quot;); String c &#x3D; &quot;hello&quot; + new String(&quot;World&quot;); System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;false&#125; 分析：b,c均在运行期创建，存在于堆内存。 涉及引用操作，编译期值无法确定（不相等） 12345public static void main(String[] args) &#123; String a &#x3D; &quot;helloWorld2&quot;; String b &#x3D; a + 2; System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false&#125; 分析：引用a的值在编译阶段无法确定，在运行期才给其分配内存来指向常量池中的字符串，因此a+2是在运行期创建的，两个对象地址并不相同。 涉及引用操作，编译期值确定（相等） 123456public static void main(String[] args) &#123; String a &#x3D; &quot;helloWorld&quot;; final String b &#x3D; &quot;hello&quot;; String c &#x3D; b + &quot;World&quot;; System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;true&#125; 分析：变量b被final修饰，在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中，此时b已经确定指向”hello”,可以被引用。 字符串的拼接：由于常量池中字符串不可变，一个字符串和另一个字符串拼接需要开辟三块内存空间，效率低下。建议使用StringBuffer或StringBuilder，这两者的区别稍后讲解。 String常用方法 比较 equals(Object obj)：如果比较双方一个常量一个变量，应把常量写在前面，如&quot;abc&quot;.equals(str)。因为如使用str.equals(&quot;abc&quot;)，假如str为空会导致空指针异常。 equalsIgnoreCase(String str)：忽略大小写。 endsWith(String suffix)：比较suffix是否为串的后缀。 获取 length()：获取长度。 concat(String str)：获取拼接后的串。 charAt(int index)：获取指定索引字符。 public int indexOf(String str)：查找参数串在本串中首次出现的索引位置，如无匹配结果返回-1。可用于字符串匹配。 截取 subString(int index)：截取从参数位置开始后的子串。 subString(int begin, int end)：截取[begin, end)子串。 trim()：去除字符串的前后空格。 转换 toCharArray()：串转换为字符数组 getBytes()：串转换为底层的字节数组 toUpperCase()和toLowerCase()：大小写转换。 replaceAll(String regex, String replacement)：使用给定的replacement替换所有符合regex规则的子串。 分割：split(String regex)：按照参数规则分割字符串为若干子串。 StringBuffer与StringBuilder 都由final修饰，不能被继承。 都继承于AbstractStringBuilder，底层使用的字符数组没有final修饰，因此在做字符串拼接就在原来的内存上拼接（append()方法），不会浪费内存空间。 StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是 synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。 StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。 jdk1.9后String/StringBuffer/StringBuilder均不再使用字符数组，而是直接使用字节数组byte[] value。 Arrays常用方法 static List&lt;T&gt; asList&lt;T... a&gt;：返回参数列表的List，例List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;); binarySearch()：有多个重载的方法，二分查找 static String toString(数组)：将参数数组变成字符串，默认格式为[元素1, 元素2, 元素3….] sort(数组)：按照默认升序对数组元素排序；自定义类型需要实现Comparator接口。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JavaIO","slug":"JavaIO","date":"2020-04-08T14:23:56.000Z","updated":"2020-09-07T11:39:06.944Z","comments":true,"path":"Java基础/JavaIO/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/","excerpt":"","text":"Java IO/NIO/AIO - Overview","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JDK动态代理","slug":"JDK动态代理","date":"2020-04-05T08:53:39.000Z","updated":"2020-09-07T11:38:33.732Z","comments":true,"path":"JavaWeb/JDK动态代理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"一个小需求引入静态代理 假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？ 12345678910public class Calculator&#123; public int add(int a, int b)&#123; return a+b; &#125; public int subtract(int a, int b)&#123; return a-b; &#125; &#x2F;&#x2F;其余算数运算方法。。。&#125; 方案：直接在Calculator类每个方法前后插入日志代码。缺点： 直接修改源码，不符合开闭原则。应该对扩展开放，对修改关闭。 如果Calculator类有许多方法，修改量太大。 重复代码太多。 日志代码硬编码在代理类中，不利于后期维护。 静态代理实现日志打印 代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于在目标实现的基础上增加额外的功能操作，以满足自身的业务需求。 静态代理的实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。 静态代理实现日志打印： 将Calculator抽取为接口 1234public interface Calculator &#123; int add(int a, int b); int subtract(int a, int b);&#125; 目标对象实现类 1234567891011public class CalculatorImpl implements Calculator &#123; public int add(int a, int b) &#123; return a + b; &#125; public int subtract(int a, int b) &#123; return a - b; &#125; &#x2F;&#x2F;其余算数运算方法。。。&#125; 代理对象实现类 1234567891011121314151617181920212223242526272829public class CalculatorProxy implements Calculator &#123; &#x2F;&#x2F;代理对象内部维护一个目标对象引用 private Calculator target; &#x2F;&#x2F;构造方法，传入目标对象 public CalculatorProxy(Calculator target) &#123; this.target &#x3D; target; &#125; &#x2F;&#x2F;调用目标对象的add，并在前后打印日志 @Override public int add(int a, int b) &#123; System.out.println(&quot;add方法开始...&quot;); int result &#x3D; target.add(a, b); System.out.println(&quot;add方法结束...&quot;); return result; &#125; &#x2F;&#x2F;调用目标对象的subtract，并在前后打印日志 @Override public int subtract(int a, int b) &#123; System.out.println(&quot;subtract方法开始...&quot;); int result &#x3D; target.subtract(a, b); System.out.println(&quot;subtract方法结束...&quot;); return result; &#125; &#x2F;&#x2F;其余算数运算方法。。。&#125; 使用代理对象实现计算器并打印日志 1234567public class Test &#123; public static void main(String[] args) &#123; Calculator calculator &#x3D; new CalculatorProxy(new CalculatorImpl()); calculator.add(1, 2); calculator.subtract(2, 1); &#125;&#125; 静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。 静态代理的缺点： 代理者与委托者一一对应，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。 如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。 动态代理 我们的目标只是为了实现增强功能，如何才能不编写代理类，只提供接口和目标对象就直接得到代理对象呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。 Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了JVM动态生成的代理类的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。实际开发中采用newProxyInstance方法，直接返回代理对象。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; &#x2F;** * 测试 * @param args * @throws Exception *&#x2F; public static void main(String[] args) throws Exception &#123; Calculator calculatorProxy &#x3D;(Calculator) getProxy(new CalculatorImpl()); calculatorProxy.add(1, 2); calculatorProxy.subtract(3, 2); &#125; &#x2F;** * 传入目标对象，得到代理对象 * @param targetObj * @throws Exception *&#x2F; private static Object getProxy(final Object targetObj) throws Exception &#123; &#x2F;&#x2F;传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口 &#x2F;&#x2F;proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象 Class&lt;?&gt; proxyClass &#x3D; Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces()); &#x2F;&#x2F;得到代理类（com.sun.proxy.$Proxy0）的构造器 Constructor&lt;?&gt; constructor &#x3D; proxyClass.getConstructor(InvocationHandler.class); &#x2F;&#x2F;通过构造器创建代理对象 Object proxyObj &#x3D; constructor.newInstance(new InvocationHandler()&#123; &#x2F;&#x2F;在重写invoke方法中编写增强功能代码 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码 Object result &#x3D; method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; private static Object getProxy1(final Object targetObj) throws Exception &#123; Object proxyObj &#x3D; Proxy.getProxyClass( targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces() ) .getConstructor(InvocationHandler.class) .newInstance(new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码 Object result &#x3D; method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; &#x2F;** * 实际使用的方法newProxyInstance * @param target * @return * @throws Exception *&#x2F; public static Object getProxy2(final Object target) throws Exception &#123; Object proxy &#x3D; Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码 Object result &#x3D; method.invoke(target,args); System.out.println(result); System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码 return result; &#125; &#125;); return proxy; &#125;&#125; 使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。 mybatis Mapper以及springAOP都是通过动态代理实现。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"mybatisHelloWorld","slug":"mybatisHelloWorld","date":"2020-04-05T08:39:41.000Z","updated":"2020-09-07T11:37:45.843Z","comments":true,"path":"Java框架/mybatisHelloWorld/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/","excerpt":"","text":"概述 mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务），而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 MybatisHelloWorld 工程文件结构如图 创建Maven工程，配置pom.xml，插入： 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt; &lt;version&gt;5.1.48&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt; &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt; &lt;version&gt;3.5.4&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;&#x2F;groupId&gt; &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt; &lt;version&gt;4.12&lt;&#x2F;version&gt; &lt;&#x2F;dependency&gt; &lt;&#x2F;dependencies&gt; 创建实体类和DAO接口 实体类 1234567public class User &#123; private Integer id;&#x2F;&#x2F;包装类默认为null private String lastName; private String email; private String gender; &#x2F;&#x2F;getters and setters, toString...&#125; DAO接口 123public interface UserMapper &#123; public User getUserById(Integer id);&#125; 创建sql映射文件：UserMapper.xml 12345678910111213&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE mapper PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;&lt;mapper namespace&#x3D;&quot;com.laishiji.mybatis.dao.UserMapper&quot;&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt; &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt; &lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;com.laishiji.mybatis.bean.User&quot;&gt; select id, last_name lastName, gender,email from user where id &#x3D; #&#123;id&#125; &lt;&#x2F;select&gt;&lt;&#x2F;mapper&gt; 创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：mybatisConfig.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE configuration PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot; &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;&lt;configuration&gt; &lt;environments default&#x3D;&quot;development&quot;&gt; &lt;environment id&#x3D;&quot;development&quot;&gt; &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt; &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt; &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt; &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;admin&quot;&#x2F;&gt; &lt;&#x2F;dataSource&gt; &lt;&#x2F;environment&gt; &lt;&#x2F;environments&gt; &lt;mappers&gt; &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt; &lt;&#x2F;mappers&gt;&lt;&#x2F;configuration&gt; mysql中建表 12345678910111213drop database if exists mybatis;create database mybatis default character set utf8;create table user( id int(11) primary key auto_increment, last_name varchar(255), gender char(1), email varchar(255))engine&#x3D;innodb default charset&#x3D;utf8;insert into user(id,last_name,gender,email) values (1,&#39;Tom&#39;,&#39;男&#39;,&#39;123@qq.com&#39;), (2,&#39;Jim&#39;,&#39;男&#39;,&#39;234@qq.com&#39;), (3,&#39;Lisa&#39;,&#39;女&#39;,&#39;324@qq.com&#39;); 创建测试类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package com.laishiji.mybatis;import com.laishiji.mybatis.bean.User;import com.laishiji.mybatis.dao.UserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;&#x2F;** * SqlSession代表和数据库的一次会话，用完必须关闭； * SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量； * mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。 *&#x2F;public class MybatisTest &#123; @Test public void test() throws IOException &#123; String resource &#x3D; &quot;mybatisConfig.xml&quot;; InputStream inputStream &#x3D; Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); SqlSession session &#x3D; sqlSessionFactory.openSession(); User user &#x3D; session.selectOne(&quot;com.laishiji.mybatis.dao.UserMapper.getUserById&quot;,1); System.out.println(user); session.close(); &#125; &#x2F;** * 接口式编程： * 原生：DAO类 ---&gt; DAOImpl实现类 * mybatis：xxxMapper接口 ---&gt; xxxMapper.xml * @throws IOException *&#x2F; @Test public void test2() throws IOException &#123; String resource &#x3D; &quot;mybatisConfig.xml&quot;; InputStream inputStream &#x3D; Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory &#x3D; new SqlSessionFactoryBuilder().build(inputStream); SqlSession openSession &#x3D; sqlSessionFactory.openSession(); &#x2F;&#x2F;通过反射+动态代理获取接口的实现类对象 UserMapper mapper &#x3D; openSession.getMapper(UserMapper.class); User user &#x3D; mapper.getUserById(1); System.out.println(user); openSession.close(); &#125;&#125;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Mybatis","slug":"Mybatis","permalink":"http://thmasterplan.cn/tags/Mybatis/"}]},{"title":"Maven入门","slug":"Maven入门","date":"2020-04-05T03:18:27.000Z","updated":"2020-09-07T11:38:15.279Z","comments":true,"path":"Java框架/Maven入门/","link":"","permalink":"http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/","excerpt":"","text":"Maven配置踩坑 修改本地仓库路径：找到conf目录下的settings.xml，添加&lt;localRepository&gt;PATH&lt;/localRepository&gt;，PATH即为仓库路径。 修改Maven云仓库为国内镜像站：同样在conf目录下的settings.xml下，找到&lt;mirrors&gt;标签，添加 123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;&#x2F;id&gt; &lt;name&gt;aliyun maven&lt;&#x2F;name&gt; &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;!-- 改为阿里云镜像 --&gt; &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt; &lt;&#x2F;mirror&gt; 修改默认jdk版本1.5为期望的版本：同样在conf目录下的settings.xml下，找到&lt;profiles&gt;标签，添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;&#x2F;id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt; &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt; &lt;&#x2F;activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; &lt;&#x2F;properties&gt; &lt;&#x2F;profile&gt; idea中Maven项目执行两次的问题：找到maven设置项Runner，取消勾选Delegate IDE build/run actions to Maven。 Maven项目目录结构 项目对象模型（POM） POM详解：https://www.runoob.com/maven/maven-pom.html。 POM是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。 groupId：公司或者组织的唯一标志。 artifactId：项目的唯一ID。 Maven构建生命周期 clean -&gt; default(build) {validate -&gt; compile -&gt; test -&gt; package -&gt; verify -&gt; install -&gt; deploy } -&gt; site 依赖管理模型 Maven 通过读取项目文件（pom.xml），找出库文件之间的依赖关系并从仓库自动下载。 引入外部依赖：先在 src 文件夹下添加 lib 文件夹，然后将工程需要的 jar 文件复制到 lib 文件夹下。然后添加以下依赖到pom.xml： 1234567&lt;dependency&gt; &lt;groupId&gt;xxx&lt;&#x2F;groupId&gt; &lt;artifactId&gt;xxx&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;scope&gt;system&lt;&#x2F;scope&gt; &lt;!--作用域--&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\yyy.jar&lt;&#x2F;systemPath&gt; &lt;&#x2F;dependency&gt;","categories":[{"name":"Java框架","slug":"Java框架","permalink":"http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://thmasterplan.cn/tags/Maven/"}]},{"title":"Filter_Listener","slug":"Filter-Listener","date":"2020-04-03T07:52:10.000Z","updated":"2020-09-07T11:39:18.455Z","comments":true,"path":"JavaWeb/Filter-Listener/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Filter-Listener/","excerpt":"","text":"Filter（过滤器） 概念：客户端访问服务器资源时，filter拦截请求，作特殊处理：登录验证、统一编码处理、敏感字符过滤等。 使用 实现javax.servlet.Filter接口 覆写init()/doFilter()/destroy()方法 doFilter()放行代码：filterChain.doFilter(servletRequest, servletResponse); 配置拦截路径 注解配置：@WebFilter(&quot;/path&quot;) web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;filterClassName&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;path&lt;&#x2F;url-pattern&gt; &lt;!-- 拦截路径 --&gt;&lt;&#x2F;filter-mapping&gt; filter的执行流程 客户端请求 -&gt; 经过filter -&gt; 执行doFilter()： 对request对象请求消息处理 -&gt; 放行 -&gt; (服务器servlet执行后响应) 对response对象的响应消息处理 filter的生命周期 init()：服务器启动后，创建filter对象，调用init()方法，只执行一次。用于加载资源。 doFilter()：每一次请求被拦截资源时，都会执行。 destroy()：服务器关闭，filter对象被销毁。正常关闭情况下，会执行destroy()方法。用于释放资源。 拦截方式配置，设置dispatcherTypes属性 注解方式 DispatcherType.REQUEST：默认值。浏览器直接请求资源时，才会执行filter。 DispatcherType.FORWARD：转发访问资源。 DispatcherType.INCLUDE：包含访问资源。 DispatcherType.ERROR：错误跳转资源。 DispatcherType.ASYNC：异步访问资源。 web.xml方式 添加&lt;dispatcher&gt; &lt;/dispatcher&gt;标签，标签中文本取上述取值即可。 过滤器链的执行顺序：filter1 -&gt; filter2… -&gt; 资源执行 -&gt;…filter2 -&gt; filter1。 注解配置：按照类名的字符串比较规则比较，值小的先执行。例如filterA与filterB，则filterA先执行。 web.xml配置：按照&lt;filter-mapping&gt;的定义顺序执行。 Listener(监听器) 概念：监听器就是一个实现了特定接口的普通Java程序，这个程序专门用于监听另一个Java对象的方法调用或者属性改变（事件）。当被监听对象发生上述事件后，监听器某个方法将立即被执行。 常用的监听器”6 + 2”： 6个常规监听器，对应JavaWeb三大域对象 ServletContext ServletContextListener(生命周期监听)，项目启动时，ServletContext创建后创建该接口的实现类对象。注：Spring框架的ContextLoaderListener类实现了该接口。 ServletContextAttributeListener(属性监听) HttpSession HttpSessionListener(生命周期监听)，只有在servlet中调用了request.getSession()方法且根据JSESSIONID找不到对应的session时才会创建新的session对象，触发监听。 HttpSessionAttributeListener(属性监听) ServletRequest ServletRequestListener(生命周期监听)，每一次请求都会创建request对象并触发监听，每一次请求结束都会销毁request对象并触发监听。 ServletRequestAttributeListener(属性监听) 生命周期监听：每当tomcat创建或销毁三大域对象时，都会被其对应的Listener察觉并调用其特定的方法。 属性监听：每当调用域对象的setAttribute()或getAttribute()，都会被对应的属性监听器察觉并调用其特定的方法。 2个感知监听 HttpSessionBindingListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口，其有两个方法valueBound()/valueUnbound，当该对象被绑定(存储)时，触发该对象的valueBound()方法；当该对象被session解绑时session.removeAttribute(&quot;key&quot;);时触发该对象的valueUnbound()方法。 HttpSessionActivationListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口。当该session即将被钝化(序列化)时，触发该监听器的sessionWillPassivate()方法；当该session活化时，触发该监听器的sessionDidActivate方法。 设计模式：观察者模式（待补充） javax.servlet.ServletContextListener接口：用于监听ServletContext对象的销毁与创建 void contextDestroyed(ServletContextEvent sce)：ServletContext对象被销毁之前会调用该方法。 void contextInitialized(ServletContextEvent sce)：ServletContext对象创建后会调用该方法，服务器启动后自动调用。 使用：实现接口 -&gt; 覆写方法 -&gt; 配置 web.xml配置 123&lt;listener&gt; &lt;listener-class&gt;监听器类名&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt; 注解配置：@WebListener","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Cookie_Session","slug":"Cookie-Session","date":"2020-04-01T12:55:36.000Z","updated":"2020-09-07T11:39:26.811Z","comments":true,"path":"JavaWeb/Cookie-Session/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Cookie-Session/","excerpt":"","text":"会话 会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一标识一个用户并记录其状态。由于HTTP协议是无状态的，也就是说浏览器的每一次请求都是独立的，服务器并不知道这个浏览器之前是否请求过，这才有了会话机制。 Cookie 概念：客户端会话技术，将数据保存到客户端。javax.servlet.http.Cookie(类)。 主要作用：避免多次登录验证，一次登录后服务器便使用cookie验证身份。cookie的作用就像是身份凭证。 使用 创建Cookie对象，绑定数据：new Cookie(String name, String value) 发送Cookie对象到客户端：response.addCookie(Cookie cookie) 获取Cookie，拿到数据： 12345678Cookie[] cookies &#x3D; request.getCookies();if(cookies !&#x3D; null)&#123; for(Cookie c : cookies)&#123; String name &#x3D; c.getName(); String val &#x3D; c.getValue(); &#x2F;&#x2F;.......... &#125;&#125; 原理 客户端发送请求-&gt; 服务器创建Cookie并发送到客户端 -&gt; http响应头增加Set-Cookie：name=value字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证 Tips 一次可以创建多个Cookie并发送 Cookie在浏览器中存活时间 默认情况下，浏览器关闭后Cookie数据销毁 持久化存储：cookie.setMaxAge(int seconds) 正数：将cookie数据写到硬盘的文件中，seconds时间之后文件被删除。 负数：默认值 0：删除已经存在于客户端的cookie数据 Tomcat8之后Cookie支持中文 Cookie共享问题 假设在一个Tomcat服务器中部署了多个web项目： 默认情况下不同web项目的cookie不能共享 cookie.setPath(String path)：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，可将path设置为”/“。 服务器集群共享Cookie： setDomain(String path)：设置一级域名 例如setDomain(&quot;.baidu.com&quot;)，则tieba.baidu.com和news.baidu.com中cookie可以共享 Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。javax.servlet.http.HttpSession（接口）。 主要作用 用于存储一次会话的多次请求的数据 可以存储任意类型、任意大小的数据 使用 获取session对象：HttpSession session = request.getSession(); 存储数据：session.setAttribute(&quot;name&quot;, Object); 获取数据：session.getAttribute(&quot;name&quot;); 原理：Session的实现依赖于Cookie，服务器通过Cookie确保多次请求获取的Session对象为同一个。 客户端发送请求-&gt; 创建Session对象，若没有Cookie，则http响应头增加Set-Cookie：JSESSIONID=sessionID字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证sessionID Tips 浏览器关闭，服务器不关闭，浏览器重启，两次获取的session对象是否相同？ 默认情况下不是。 为避免这种情况，可手动设置持久化存储JSESSIONID 123Cookie cookie &#x3D; new Cookie(&quot;JSESSIONID&quot;, session.getId());cookie.setMaxAge(60*60);&#x2F;&#x2F;持久化存储cookieresponse.addCookie(cookie); 浏览器不关闭，服务器关闭，服务器开启，两次获取的session对象是否相同？ 新对象地址与原对象不同 为避免服务器重启数据丢失，采用session的钝化和活化技术。 session钝化：在服务器正常关闭前，将session对象序列化到硬盘上 session活化：服务器启动后，将session文件转化为内存中的session对象，删除文件 Tomcat已经集成了钝化与活化技术，正常关闭tomcat后，会在work工作目录的项目文件夹下生成一个SESSIONS.ser文件 session钝化与活化不仅仅是服务器关闭时发生，当在线用户过多时，大量session对象存在于服务器内存中。为减轻服务器内存负担，当一个session长时间没有被访问，也会被序列号到磁盘上（注意session中存储的对象所在的类必须要实现序列化接口）。可在tomcat的conf/context.xml中配置。 session何时被销毁？ 服务器关闭 session对象调用invalidate()方法 session默认失效时间为30分钟(可在tomcat的conf/web.xml中配置) 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Servlet","slug":"Servlet","date":"2020-04-01T08:10:10.000Z","updated":"2020-09-07T11:37:38.668Z","comments":true,"path":"JavaWeb/Servlet/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Servlet/","excerpt":"","text":"Servlet(Server applet) 用于处理请求与业务逻辑。 调用流程： 用户访问html页面，表单提交 xml文件url-pattern与url匹配，若符合Tomcat则加载servlet-class对应的class文件进内存（反射） 实例化Servlet（class.newInstance()）得到一个Servlet对象 调用service()方法，根据表单的method，在该方法中调用doGet或doPost方法 request对象获取参数，response对象返回数据 服务器通过http协议返回数据 Servlet生命周期： 实例化：无论访问多少次该Servlet，构造方法只执行一次，只存在一个对象（单实例） 注：多个用户同时访问时，可能存在线程安全问题。因此尽量不要在Servlet中定义成员变量。 初始化：在构造方法执行后，执行init()方法，无论访问多少次该Servlet，init()方法只执行一次。init()方法的参数ServletConfig对象实例，通过解析web.xml文件创建。 提供服务：tomcat创建req和resp对象，将这两个对象作为参数传递给service()，执行service()方法，在该方法中判断执行doGet()还是doPost() 销毁：当在server.xml的Context字段中配置了reloadable=”true”时，表示web应用有任何类型的更新都会自动重启，重启就会调用destroy()方法；tomcat服务器关闭时destroy()方法会被调用。 被回收：等待下一次GC回收 自启动：假如需要在tomacat一启动就执行一些初始化的代码，比如校验数据库的完整性。但是Servlet的生命周期是在用户访问对应路径开始的，这就需要Servlet自启动，执行init()方法中的业务代码：在web.xml中增加&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;，取值范围是1-99，数字表示启动顺序，数字越小启动的优先级越高。 注解配置（Servlet3.0后支持，不再需要web.xml配置文件） Servlet类上使用@WebServlet(&quot;/URI&quot;)配置 页面跳转： 服务端跳转forward(转发)：request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);,服务器内部访问success.html，并将其发送给浏览器。客户端只请求一次，服务器内部跳转。 客户端跳转redirect(重定向)：response.sendRedirect(&quot;fail.html&quot;);，发送一条消息给浏览器让其访问fail.html，浏览器访问，服务器获取fail.html发送给浏览器。客户端一共请求了两次。 Servlet映射器(Mapper)：每一个请求，对应的URL要交给哪一个Servlet处理，由Tomcat中的映射器Mapper类处理。 request对象：封装请求消息数据 获取参数： request.getParameter()：用于获取单值的参数request.getParameterValues()：用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap()：用于遍历所有的参数，并返回Map类型。 获取头信息： request.getHeader()：获取浏览器传递过来的头信息。request.getHeaderNames()：获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 服务端传参：request.setAttribute()与request.getAttribute() 设置编码：request.setCharacterEncoding(&quot;UTF-8&quot;); 常见方法： request.getRequestURL()：浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI()：浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString()：请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr()：浏览器所处于的客户机的IP地址request.getRemoteHost()：浏览器所处于的客户机的主机名request.getRemotePort()：浏览器所处于的客户机使用的网络端口request.getLocalAddr()：服务器的IP地址request.getLocalName()：服务器的主机名request.getMethod()：得到客户机请求方式，一般是GET或者POST response对象：通过response对象设置响应消息数据 设置响应内容：response.getWriter()获取PrintWriter对象，使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。 设置响应格式与编码：response.setContentType(&quot;text/html;charset=utf-8&quot;)或response.setCharacterEncoding(&quot;UTF-8&quot;) ServletContext对象：服务器启动后自动创建，在整个Web应用的动态资源（Servlet/JSP…）之间共享数据，与servlet容器通信，服务器关闭时销毁。 通过request.getServletContext()或this.getServletContext()获取 获取MIME(text/html, image/jpeg…)类型数据：getMimeType(String file) 作为域对象共享数据：setAttribute() getAttribute() removeAttribute()，共享所有用户请求的数据 获取文件的真实路径：getRealPath(String file) ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序（对称） ServletContext -&gt; ServletContextListener -&gt; Filter -&gt; 自启动Servlet -&gt; 浏览器请求访问普通Servlet -&gt; 销毁自启动Servlet -&gt; 销毁Filter-&gt; 销毁ServletContextListener -&gt; 销毁ServletContext Listener, Filter, Servlet的实现类对象均是服务器通过反射创建。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"JSON","slug":"JSON","date":"2020-04-01T08:09:57.000Z","updated":"2020-09-07T11:38:27.081Z","comments":true,"path":"JavaWeb/JSON/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JSON/","excerpt":"","text":"JSON简介 概念：JavaScript对象表示法(JavaScript Object Notation)。 作用：JSON是存储和交换文本信息的语法，常用于信息传输，比XML更小、更快、更易解析。 语法 基本语法： 数据由键值对构成，值的取值类型有： 整数或浮点数 字符串：&quot;string&quot; 布尔值：true/false 数组：[] 对象：{name:&quot;Tom&quot;,age:23,gender:&quot;male&quot;} null 数据由,分隔 {}保存对象，同时也定义了JSON格式 []保存数组 获取数据方式：JSON对象.键名；JSON对象[“键名”]；数组对象[索引]。 JSON在Java中的解析 Java常用的JSON解析类库：GSON, FastJson, Jackson；以Jackson为例。 Java对象转JSON 123456789101112131415161718192021222324252627public class Person&#123; private String name; private int age; private String gender; &#x2F;&#x2F;getter and setter&#125;public class JacksonTest&#123; &#x2F;&#x2F;创建Java对象 Person p &#x3D; new Person(); p.setName(&quot;Tom&quot;); p.setAge(23); p.setGender(&quot;男&quot;); &#x2F;&#x2F;创建Jackson对象 ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;转换方法： &#x2F;* writeValue(args, obj): args: File:将obj对象转换为JSON字符串，并保存到指定文件； Writer:转换，并将json数据填充到字符输出流 OutputStream:转换，并将json数据填充到字节输出流 writeValueAsString(obj):将对象转换为json字符串 *&#x2F; String json &#x3D; mapper.writeValueAsString(p); &#125; 注解： @JsonIgnore：排除属性（该注解置于要忽略的属性上），指定属性不会被转换 @JsonFormat：属性值格式化（该注解置于要格式化的属性上），例@JsonFormat(pattern=&quot;yyyy-MM-dd&quot;) JSON转Java对象 123String json &#x3D; &quot;&#123;name:\\&quot;Tom\\&quot;,age:23&#125;&quot;;ObjectMapper mapper &#x3D; new ObjectMapper();Person p &#x3D; mapper.readValue(json, Person.class);","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"XML","slug":"XML","date":"2020-03-30T14:00:41.000Z","updated":"2020-09-07T11:37:01.887Z","comments":true,"path":"JavaWeb/XML/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/XML/","excerpt":"","text":"概念扩展标记语言（Extensible Markup Language），标签可自定义。 功能 用于存储与传输数据 配置文件 在网络中传输 语法 基本语法： 第一行必须定义为文档声明，例如&lt;? xml version=&#39;1.0&#39; ?&gt;。 xml文档中有且仅有一个根标签 属性值必须用使用引号 标签必须正确关闭 标签名称严格区分大小写 例： 12345678910111213 &lt;?xml version&#x3D;&#39;1.0&#39; ?&gt; &lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name&gt;Tom&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;br&#x2F;&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;Lisa&lt;&#x2F;name&gt; &lt;age&gt;20&lt;&#x2F;age&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 组成部分： 文档声明：&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt; 标签：自定义标签 属性：id属性值唯一 文本 XML命名空间（XML Namespaces）：提供避免元素命名冲突的方法，比如不同的两个XML被同时使用，且他们有一个相同的标签时，可通过命名空间避免冲突。 XML命名空间属性被放置于元素的开始标签中，语法为xmlns:namespace-prefix=&#39;namespaceURI&#39; 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联 约束 约束：规定xml文档的书写规则。一般来说，框架提供约束，框架使用者按照约束来编写xml。 DTD：简单的约束技术，文件后缀为.dtd &lt;!ELEMENT &gt;定义标签，&lt;!ATTLIST &gt;定义属性，()定义子标签 约束内容例： 123456&lt;!ELEMENT students (student*)&gt;&lt;!ELEMENT student (name,age,sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 引入dtd文档到xml中 内部dtd：将约束规则定义在xml文档中 &lt;!DOCTYPE 根标签名 [约束内容] &gt; 外部dtd：将约束规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的绝对路径&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;URL路径&quot;&gt; Schema：复杂的约束技术，本质上就是xml，文件后缀为.xsd 可定义xml中文本的类型，文本取值的范围，标签出现的顺序等 引入.xsd约束文件到xml 引入无命名空间的.xsd 1234567&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation&#x3D;&quot;无命名空间XSD文件的URI&quot;&gt;&lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，通过xsi命名空间下的属性noNamespaceSchemaLocation指定XSD文件的URI--&gt;&lt;&#x2F;root&gt; 引入有命名空间的.xsd 1234567891011&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:ns1&#x3D;&quot;前缀ns1对应命名空间&quot; xmlns:ns2&#x3D;&quot;前缀ns2对应命名空间&quot; xsi:schemaLocation&#x3D;&quot;ns1前缀对应命名空间 前缀ns1对应命名空间XSD文件的URI ns2前缀对应命名空间 前缀ns2对应命名空间XSD文件的URI&quot;&gt; &lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，添加命名空间，可添加多个，但没有前缀的命名空间最多只能有1个 3.第三步，通过xsi命名空间下的属性schemaLocation指定每个命名空间XSD文件的URI，命名空间和相应URI一一对应，多个命名空间用空格分隔 --&gt; &lt;&#x2F;root&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"动态规划入门","slug":"动态规划入门","date":"2020-03-28T13:38:15.000Z","updated":"2020-09-07T11:36:11.707Z","comments":true,"path":"面试刷题/动态规划入门/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划题目特点 计数 有多少种方式走到右下角 有多少种方法选出k个数使得和为Sum 例：lintcode114 123456789101112131415161718192021public class Solution &#123; /** * @param m: positive integer (1 &lt;= m &lt;= 100) * @param n: positive integer (1 &lt;= n &lt;= 100) * @return: An integer */ public int uniquePaths(int m, int n) &#123; // write your code here int[][] dp = new int[m][n];//dp[i][j]表示机器人有多少种方式从左上角走到(i,j) //dp[i][j] = dp[i-1][j]+dp[i][j-1] for(int i = 0; i &lt; m; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == 0 || j == 0) dp[i][j] = 1;//第0行(列)的所有格子都只有一种方式到达 else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 求最值 从左上角走到右下角路径的最大数字和 最长上升序列长度 例：lintcode669 1234567891011121314151617181920212223242526public class Solution &#123; /** * @param coins: a list of integer * @param amount: a total amount of money amount * @return: the fewest number of coins that you need to make up */ public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount+1];//记录组成从0-amount分别需要的最少的硬币数 dp[0] = 0; for(int i = 1; i &lt;= amount; ++i)&#123; dp[i] = Integer.MAX_VALUE;//表示不存在组成i所需要的最少硬币数,同时看作min变量，储存dp[i-coins[j]]+1,j=1,2...中的最小值 for(int j = 0; j &lt; coins.length; ++j)&#123; if(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != Integer.MAX_VALUE &amp;&amp; dp[i-coins[j]]+1 &lt; dp[i])&#123; dp[i] = dp[i-coins[j]] + 1;//组成总数为i需要的最少的硬币数为：组成总数为i-coins[j],j=1,2...coins.length需要的最少硬币数中最小的一个,再加1 &#125; &#125; &#125; if(dp[amount] == Integer.MAX_VALUE) return -1; else return dp[amount]; &#125; &#125; 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和为Sum 例：lintcode116 1234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; /** * @param A: A list of integers * @return: A boolean */ //动态规划 public boolean canJump(int[] A)&#123; if(A == null || A.length == 0) return false; int len = A.length; boolean[] dp = new boolean[len]; dp[0] = true; //思路:最后一步A[len-1]可达，当且仅当前面某个下标i可达且i+A[i]&gt;=A[len-1]；推广到对任意j = 1,2,...len-1，i &lt; j都必须满足dp[i] &amp;&amp; i + A[i] &gt;= j for(int j = 1; j &lt; len; ++j)&#123; dp[j] = false; for(int i = 0; i &lt; j; ++i)&#123; if(dp[i] &amp;&amp; i + A[i] &gt;= j)&#123;//状态方程：能够到达i，并且i+A[i]&gt;=j即表示从i能到达j dp[j] = true; break; &#125; &#125; &#125; return dp[len-1]; &#125; //贪心算法 public boolean canJumpGreedy(int[] A) &#123; //[3,2,1,0,4] if(A == null || A.length == 0) return false; int farthest = A[0];//farthest变量记录当前能够到达的最远距离 for(int i = 1; i &lt; A.length; ++i)&#123; if(farthest &lt; i) return false;//farthest比i小，表示不能到达i，return false else farthest = i + A[i] &gt; farthest ? i + A[i] : farthest;//更新farthest &#125; return true; &#125;&#125; 动态规划组成部分 确定状态：创建数组，数组的每个元素代表什么？ 两个要点 最后一步 子问题 递归算法的问题：重复计算，效率低下 转移方程：根据子问题定义得到。将计算结果保存下来，并改变计算顺序，空间换时间 初始条件和边界情况 计算顺序：利用之前的计算结果 常见动态规划类型 坐标型 序列型 划分型 区间型 背包型 最长序列型 博弈型","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"lintcode","slug":"lintcode","permalink":"http://thmasterplan.cn/tags/lintcode/"}]},{"title":"反编译及助记符","slug":"反编译及助记符","date":"2020-03-26T06:11:57.000Z","updated":"2020-09-07T11:35:57.552Z","comments":true,"path":"JVM/反编译及助记符/","link":"","permalink":"http://thmasterplan.cn/JVM/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6/","excerpt":"","text":"JVM参数，均以-XX:开始，其中-XX:+&lt;option&gt;，表示开启option选项；-XX:-&lt;option&gt;，表示关闭option选项；-XX:&lt;option&gt;=&lt;value&gt;，表示将option选项的值设置为value。 -XX:+TraceClassLoading，用于追踪类的加载信息并打印。 反编译.class文件：javap -c 全类名 反编译代码助记符： getstatic：获取类的静态字段 ldc：表示将int, float或是String类型的常量值从常量池推送至栈顶 bipush：表示将单字节（-128-127）的常量值从常量池推送至栈顶 sipush：表示将一个短整型（-32768—32767）常量值推送至栈顶 iconst_1：表示将int类型的1推送至栈顶（iconst_0 - iconst_5） anewarray：创建一个引用类型数组，并将其引用值压入栈顶 newarray：创建一个基本类型的数组，并将其引用值压入栈顶 数组创建本质：new一个数组，对于数组实例来说，其类型是由JVM在运行期间动态生成的，动态生成的类型其父类为Object。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"贪心","slug":"贪心","date":"2020-03-26T06:11:35.000Z","updated":"2020-09-07T11:34:54.269Z","comments":true,"path":"面试刷题/贪心/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"贪心算法 解决贪心问题的步骤： 将原问题分解为子问题 找出贪心策略（寻找局部最优解） 得到每一个子问题的最优解 将所有局部最优解的集合构成称为原问题的一个解 leetcode455：分发饼干 123456789101112131415class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; int child = 0; int cookie = 0; Arrays.sort(g); //先将饼干 和 孩子所需大小都进行排序 Arrays.sort(s); while (child &lt; g.length &amp;&amp; cookie &lt; s.length )&#123; //当其中一个遍历就结束 if (g[child] &lt;= s[cookie])&#123; //当用当前饼干可以满足当前孩子的需求，可以满足的孩子数量+1 child++; &#125; cookie++; // 饼干只可以用一次，因为饼干如果小的话，就是无法满足被抛弃，满足的话就是被用了 &#125; return child; &#125;&#125; leetcode435：无重叠区间 123456789101112131415161718192021222324class Solution &#123; //思路：按区间开始处升序排序后，尽量保留结尾小的 public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) return 0; Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] - o2[0]; &#125; &#125;);//按照区间开始升序排序 int prev = 0, count = 0;//变量prev保存遍历时的前一个区间 for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[prev][1] &gt; intervals[i][0]) &#123;//前一个区间的结尾&gt;后一个区间的开始，表明有重叠 if (intervals[prev][1] &gt; intervals[i][1]) prev = i;//前一个区间的结尾&gt;后一个区间的结尾，表明前一个区间覆盖后一个区间，删除结尾大的区间 count++; &#125; else prev = i;//无重叠 &#125; return count; &#125;&#125; leetcode452：用最少数量的箭引爆气球 1234567891011121314151617181920212223class Solution &#123; //类似于435，删除k个区间后便无重叠区间，则该题答案为n-k，n为总区间个数 public int findMinArrowShots(int[][] points) &#123; if(points.length == 0) return 0; Arrays.sort(points, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] point1, int[] point2)&#123; return point1[0] - point2[0]; &#125; &#125;);//升序排序 int prev = 0, count = 0; for(int i = 1; i &lt; points.length; i++)&#123; if(points[prev][1] &gt;= points[i][0] )&#123; if(points[prev][1] &gt; points[i][1]) prev = i; count++; &#125;else prev = i; &#125; return points.length - count; &#125;&#125; leetcode406：根据身高重建队列 123456789101112131415161718192021222324//将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。//按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。//直到完成为止。class Solution &#123; //1.排序：按高度降序排列；在同一高度的人中，按 k 值的升序排列。 //2.逐个地把它们放在输出队列中，索引等于它们的 k 值。 //3.返回输出队列 public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] == o2[0] ? o1[1] - o2[1]: o2[0] - o1[0]; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for(int[] p : people)&#123; list.add(p[1],p); &#125; return list.toArray(new int[people.length][2]); &#125;&#125; leetcode121：买卖股票的最佳时机 12345678910111213class Solution &#123; public int maxProfit(int prices[]) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, min = prices[0];//min记录前面的最小价格 for(int i = 1; i &lt; prices.length; i++)&#123; int profit = prices[i] - min;//利润等于当前价格减去最小价格 result = result &gt; profit ? result : profit;//更新最大利润 min = prices[i] &gt; min ? min : prices[i];//每一天更新最小价格 &#125; return result; &#125;&#125; leetcode122：买卖股票的最佳时机2 123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, buy = prices[0]; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &lt; prices[i-1]) buy = prices[i];//股票降了，抄底买入 else&#123; result += prices[i] - buy;//股票涨的阶段，卖掉前一天的股票 buy = prices[i];//买入当天的股票，利润最大化 &#125; &#125; return result; &#125;&#125; leetcode605：种花问题 1234567891011121314public class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int i = 0; while (i &lt; flowerbed.length) &#123; if (flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) &#123;//数组元素为0，并且其左右两边均为0，或者该数组下标位于首（尾） flowerbed[i++] = 1; n--; &#125; if(n &lt;= 0) return true; i++; &#125; return false; &#125;&#125; leetcode392：判断子序列 1234567891011121314class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int sLen = s.length(); if(sLen == 0) return true; int j = 0; for(int i = 0; i &lt; t.length(); i++)&#123; if(j &lt; sLen &amp;&amp; t.charAt(i) == s.charAt(j)) j++; if(j == sLen) return true; &#125; return false; &#125;&#125; leetcode53：最大子数组和 1234567891011class Solution &#123; public int maxSubArray(int[] nums) &#123; int currMaxSum = nums[0], maxSum = nums[0]; for(int i = 1; i &lt; nums.length; ++i) &#123; currMaxSum = Math.max(nums[i], currMaxSum + nums[i]);//计算以当前元素nums[i]为终点的所有的子数组的最大和 maxSum = Math.max(maxSum, currMaxSum);//maxSum是所有currMaxSum中的最大值 &#125; return maxSum; &#125;&#125; leetcode763：划分字母区间 123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; partitionLabels(String S) &#123; int[] last = new int[26];//定义一个大小为26的数组，用于存储每个字母最后一次出现的下标 for(int i = 0; i &lt; S.length(); ++i)&#123; last[S.charAt(i) - 'a'] = i;//遍历字符串，更新每个字符的下标 &#125; int start = 0, end = 0; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; S.length(); ++i)&#123; end = Math.max(end, last[S.charAt(i) - 'a']);//遍历字符串时扩展区间末端end if(i == end)&#123;//当前下标等于区间末端end时，为一次划分，更新start=end+1 res.add(end-start+1); start = end+1; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"注解","slug":"注解","date":"2020-03-25T09:58:33.000Z","updated":"2020-09-07T11:33:34.575Z","comments":true,"path":"Java基础/注解/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解 注解（Annotation），也叫元数据，JDK1.5后引入的特性，与类、接口、枚举在同一层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用于对这些元素进行说明。 定义注解 -&gt; 使用注解 -&gt;读取注解 作用分类 编写文档 ：命令行输入javadoc xxx.java，通过代码里标识的注解自动生成doc文档 代码分析：通过代码里标识的注解对代码进行分析（使用反射机制） 编译检查 ：编译器对代码进行编译检查 JDK预定义的注解 @Override：检测被注解的方法是否继承自父类（接口） @Deprecated：被注解的内容已过时，不建议使用 @SuppressWarnings：压制警告，一般传递参数all 自定义注解 注解通过@interface定义，例如public @interface MyAnnotation{} 本质是接口：public interface MyAnnotation extends java.lang.annotation.Annotation{} 注解的属性：接口中的抽象方法 属性的返回值类型 基本数据类型 String 枚举 注解 以上类型的数组 使用注解时，需要对属性赋值，例@SuppressWarning(&quot;all&quot;)；亦可以在定义注解时使用default设置默认值，使用时就不用赋值；如果只有一个属性需要赋值，且属性名为value，则value可以省略可直接赋值，上述压制警告就是这种情形。 123public @interface MyAnno&#123; int a() default 5; &#125; 元注解：可以注释到注解上的注解，一共有五种。 @Retention：描述注解被保留的阶段 12345public enum RetentionPolicy&#123; SOURCE,//注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视 CLASS,//注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 RUNTIME//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时才能获取到它们（常用）&#125; 使用示例： 123@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno&#123;&#125; @Documented：描述注解是否被抽取到doc文档中 @Target：当一个注解被 @Target 注解时，这个注解就被限定了运用的场景 ElementType.ANNOTATION_TYPE：可以给一个注解进行注解 ElementType.CONSTRUCTOR：可以给构造方法进行注解 ElementType.FIELD：可以给成员变量进行注解 ElementType.LOCAL_VARIABLE：可以给局部变量进行注解 ElementType.METHOD：可以给方法进行注解 ElementType.PACKAGE：可以给一个包进行注解 ElementType.PARAMETER：可以给一个方法内的参数进行注解 ElementType.TYPE：可以给一个类型进行注解，比如类、接口、枚举 @Inherited：描述注解是否被子类继承 @Repeatable 在程序中使用（解析）注解：获取注解中定义的属性值 例如在反射中的自定义框架，使用注解后便不需要使用配置文件传参数，通过更改注解的属性值即可实现创建不同的对象、使用对象的方法。 1234567891011121314151617package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 描述需要执行的类名和方法名 * */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String methodName();&#125; 12345678910111213141516171819202122232425262728293031package annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Method;@Pro(className = \"model.Person\",methodName=\"eat\")public class MyFrame2 &#123; public static void main(String[] args) throws Exception &#123; //1.获取注解对象 Class&lt;MyFrame2&gt; myFrame2Class = MyFrame2.class; Pro anno = myFrame2Class.getAnnotation(Pro.class);//在内存中生成了一个该注解接口的子类的实现对象 //2.调用注解对象中定义的抽象方法，获取返回值 String className = anno.className(); String methodName = anno.methodName(); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance(); Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125; 使用注解方式创建DBUtil工具类（降低耦合度） 1234567891011121314151617181920212223package anno;import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.ElementType.TYPE;import java.lang.annotation.Documented;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;METHOD,TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface JDBCConfig &#123; String ip(); int port() default 3306; String database(); String encoding(); String loginName(); String password(); &#125; 12345678910111213141516171819202122232425262728293031323334353637package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import anno.JDBCConfig;@JDBCConfig(ip = \"127.0.0.1\", database = \"test\", encoding = \"UTF-8\", loginName = \"root\", password = \"admin\")public class DBUtil &#123; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException &#123; JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);//通过反射获取DBUtil类上的注解对象 String ip = config.ip(); int port = config.port(); String database = config.database(); String encoding = config.encoding(); String loginName = config.loginName(); String password = config.password(); String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException &#123; Connection c = getConnection(); System.out.println(c); &#125;&#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"反射","slug":"反射","date":"2020-03-24T09:08:10.000Z","updated":"2020-09-07T11:35:50.293Z","comments":true,"path":"Java基础/反射/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"概述反射概念 反射就是把Java类中的各个成分（成员变量、构造器、成员方法）映射成一个个的Java对象。 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个属性和方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。 反射的好处：解耦，提高程序的可扩展性。（例如Spring框架的依赖注入） Class类 Class类存在于JDK的java.lang包中，手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的信息，这个Class对象保存在同名.class的文件中。Class类的对象作用是运行时提供或获得某个对象的类型信息。 反射的使用获取Class类对象 Class对象中将类的成员变量封装到Field[]中，将类的构造方法封装到Constructor[]中，将类的方法封装到Method[]中。 三种方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。此种方式多用于配置文件，将类名定义在配置文件中，通过读取文件加载类。 类名.class：通过类名的class属性获取。多用于参数的传递。 对象.getClass() ：getClass()方法在Object类中定义。通过对象获取类的字节码。 注：不论使用哪种方式，同一个.class文件在一次程序运行中只会被加载一次，因此在一次运行中即使使用三种方式各获取一次，获取的都是同一个对象。 注：获取类的Class对象是Java程序对类的主动使用，会初始化该类（静态代码块，静态变量）。 注：静态synchronized方法的同步对象是：静态同步方法所在类的Class对象。 Class类的一些方法 getName(): 获取全类名 getSimpleName(): 获取类名 newInstance(): 创建实例化对象 Constructor Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。 通过类的Class对象的方法获取Constructor对象： Constructor&lt;?&gt; [] getConstructors(): 返回所有public修饰的Constructor对象的数组 Constructor&lt;?&gt; [] getDeclaredConstructors(): 返回所有的Constructor对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes): 返回指定参数类型、public修饰的Constructor对象 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes): 返回指定参数类型的所有Constructor对象 Constructor对象本身的方法 String getName(): 获取构造方法名称 T newInstance(): 创建实例化对象。Class对象的newInstance()方法也是调用构造器对象的该方法。 Field Field类提供有关类或接口的单个字段的信息，以及对它的动态访问权限。 通过类的Class对象的方法获取Field对象： Field[] getFields(): 只获取public修饰的Field字段, 包括继承自父类的字段 Field[] getDeclaredFields(): 获取类的所有字段，但是不包括继承自父类的 Field getField(String name): 获取指定的public修饰的字段，包括继承字段 Field getDeclaredFields(String name): 获取指定的字段，不包括继承字段 Field对象本身的方法 void set(Object obj, Object value): 设置指定对象上此字段的新值 Object get(Object obj): 返回指定对象上此字段的值 Class&lt;?&gt; getType(): 返回一个Class对象，它标识了此Field表示字段的声明类型 String getName(): 返回此Field对象表示的字段的名称 void setAccessible(boolean flag): 设置该字段是否可被访问。对于getDeclaredFields()和getDeclaredFields(String name)方法来说，若返回的Field中有由private修饰的字段，那么需要field.setAccessible(true)以表示其可以被访问。（暴力反射） Method Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。 通过类的Class对象的方法获取Method对象： Method[] getMethods(): 返回public修饰的方法对应Method的数组，包括继承自父类的 Method[] getDeclaredMethods(): 返回所有的方法对应Method的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt; …parameterTypes): 返回指定名称和参数列表的public修饰的方法对应Method Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes): 返回指定名称和参数列表的方法对应Method Method对象本身的方法 Object invoke(Object obj, Object… args): 对指定对象调用此Method表示的方法 Class&lt;?&gt; getReturnType(): 返回的Class对象描述了此Method表示方法的返回类型 String getName(): 返回Method 对象表示的方法名称，即返回方法的名称 练习写一个“框架”，可以创建任意类的对象，并能够执行其中任意方法 思路：使用反射，不需要更改框架的代码，只需更改配置文件的参数，就可以体现泛用性。（平时创建不同的对象是需要不同的代码的，比如 new Person(), new Student()） 步骤：1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中 ​ 2.在框架程序中读取配置文件 ​ 3.使用反射技术来加载要创建的对象的类文件进内存 ​ 4.创建对象（使用newInstance()方法） ​ 5.执行方法（使用invoke()方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package reflect;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;public class MyFrame &#123; public static void main(String[] args) throws Exception &#123; //1.加载配置文件 Properties properties = new Properties(); ClassLoader classLoader = MyFrame.class.getClassLoader(); InputStream iStream = classLoader.getResourceAsStream(\"pro.properties\"); properties.load(iStream); //2.获取配置文件中定义的数据 String className = properties.getProperty(\"className\"); String methodName = properties.getProperty(\"methodName\"); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance();本质仍然是调用Constructor对象的newInstance()方法 Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125;//Person类package model;public class Person &#123; public void eat() &#123; System.out.println(\"eating...\"); &#125;&#125;//pro.properties配置文件内容className=model.PersonmethodName=eat","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-03-07T08:01:05.000Z","updated":"2020-09-07T11:38:39.793Z","comments":true,"path":"Java基础/JDBC/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JDBC/","excerpt":"","text":"JDBC概念：官方定义的一套操作所有关系型数据库的接口，各个数据库厂商实现这套接口，提供数据库驱动jar包。 基础 初始化驱动类：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 建立与数据库的连接： 123456789static String ip = \"127.0.0.1\";static int port = 3306;static String database = \"tmall\";static String encoding = \"UTF-8\";static String loginName = \"root\";static String password = \"admin\";//mysql数据库url写法：jdbc:mysql://ip:端口号/数据库名称String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding);Connection connection = DriverManager.getConnection(url, loginName, password); 创建Statement并执行sql语句： 123Statement statement = connection.createStatement();String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\";statement.execute(sql); 使用try-with-resource自动关闭连接： 123456try (Connection connection = DriverManager.getConnection(url, loginName, password);Statement statement = c.createStatement();)&#123; String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\"; statement.execute(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; PreparedStatement 12345678910111213String sql = \"insert into hero values(null,?,?,?)\";try (Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\",\"root\", \"admin\"); // 根据sql语句创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql);) &#123; // 设置参数 ps.setString(1, \"提莫\"); ps.setFloat(2, 313.0f); ps.setInt(3, 50); // 执行 ps.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 使用预编译statement优点： 参数设置，可读性好，不需要进行字符串拼接 预编译机制性能比Statement好 可防止SQL注入攻击 execute/executeQuery/executeUpdate executeQuery: 返回一个结果集，这个方法用来执行select语句. 12345678ResultSet rs = statement.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt(\"id\");// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat(\"hp\"); int damage = rs.getInt(4); System.out.printf(\"%d\\t%s\\t%f\\t%d%n\", id, name, hp, damage); &#125; executeUpdate:用于执行insert，delete，update等SQL语句，executeupdate返回的值是一个整数，表示受影响的行数，对于create table等不操作行的语句，executeupdate的返回值为0。 execute: 可执行任何sql语句，其返回值为布尔类型，是true时，表示执行的是查询语句，可以通过getResultSet方法获取结果；返回值为false时，执行的是更新语句或DDL语句，getUpdateCount方法获取更新的记录数量 获取自增长ID：在执行完插入语句后，为获取新增记录的id 1234567// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id// JDBC通过getGeneratedKeys获取该idResultSet rs = prepareStatement.getGeneratedKeys();if (rs.next()) &#123; int id = rs.getInt(1); System.out.println(id);&#125; 使用事务：在mysql中，只有当表的类型是innodb时才支持事务 12345connection.setAutoCommit(false);//事务代码块connection.commit();//回滚事务:connection.rollback() ORM：Object Relationship Database Mapping，即对象与关系数据库的映射，对象中的各成员变量值与关系数据库里一条记录相对应。 DAO：Database Access Object，数据库访问对象，把对数据库某张表相关的操作都封装在这个类里面 数据库连接池 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package jdbc; import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import java.util.ArrayList;import java.util.List; public class ConnectionPool &#123; List&lt;Connection&gt; cs = new ArrayList&lt;Connection&gt;(); int size; public ConnectionPool(int size) &#123; this.size = size; init(); &#125; public void init() &#123; //这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是\"活\"的，不要被自动关闭了 try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); for (int i = 0; i &lt; size; i++) &#123; Connection c = DriverManager .getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\", \"root\", \"admin\"); cs.add(c); &#125; &#125; catch (ClassNotFoundException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; catch (SQLException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; public synchronized Connection getConnection() &#123; while (cs.isEmpty()) &#123; try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; // TODO Auto-generated catch block e.printStackTrace(); &#125; &#125; Connection c = cs.remove(0); return c; &#125; public synchronized void returnConnection(Connection c) &#123; cs.add(c); this.notifyAll(); &#125; &#125;","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"字符串","slug":"字符串","date":"2020-02-15T11:33:53.000Z","updated":"2020-09-07T11:33:25.825Z","comments":true,"path":"面试刷题/字符串/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"leetcode面试题01.09.字符串轮转： 给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。（同leetcode：796） 12345678910111213141516171819202122232425262728class Solution &#123; //只需要判断s2是否是s1s1的子串，并且s2.length == s1.length两个条件即可。 public boolean isFlipedString(String s1, String s2) &#123; if(s1.length() != s2.length()) return false;//长度不相等直接返回false else if(s1.length() == 0) return true;//长度相等但是都为空，返回true String s1s1 = s1+s1; if(isSubString(s1s1, s2)) return true;//判断s2是否为s1+s1的子串，是则为true return false; &#125; private boolean isSubString(String s1, String s2)&#123; int i = 0, j = 0; while(i &lt; s1.length())&#123; int k = i; while(k &lt; s1.length() &amp;&amp; j &lt; s2.length() &amp;&amp; s1.charAt(k) == s2.charAt(j) )&#123; k++; j++; &#125; if(j == s2.length()) return true; else j = 0; i++; &#125; return false; &#125;&#125;//一行代码版：//return s1.length() == s2.length &amp;&amp; (s1+s1).indexOf(s2) != -1; 面试题58 - ll左旋转字符串（类似于189.旋转数组）： 12输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出: &quot;cdefgab&quot; 1234567891011121314151617class Solution &#123; public String reverseLeftWords(String s, int n) &#123; char[] chars = s.toCharArray(); reverseString(chars, 0, n-1); reverseString(chars, n, chars.length-1); reverseString(chars, 0, chars.length-1); return new String(chars); &#125; private void reverseString(char[] s, int start, int end)&#123; while(start &lt; end)&#123; char temp = s[start]; s[start++] = s[end]; s[end--] = temp; &#125; &#125;&#125; 翻转字符串里的单词：151 12输入: &quot; a good example &quot;输出: &quot;example good a&quot; 123456789101112131415161718192021222324252627282930//翻转每个单词后再翻转整个字符串class Solution &#123; public String reverseWords(String s) &#123; s = s.trim();//去除首尾空格 s = s.replaceAll(\"\\\\s+\", \" \");//去除多余空格 char[] chars = s.toCharArray(); int i = 0, start = 0; while(i &lt; chars.length)&#123;//遇到空格即翻转每个单词 if(chars[i] == ' ')&#123; reverse(chars, start, i-1); start = i+1; &#125; i++; &#125; reverse(chars, start, --i);//翻转最后一个单词 reverse(chars, 0, i);//翻转整个字符串 return new String(chars); &#125; private void reverse(char[] c, int start, int end)&#123; while(start &lt; end)&#123; char temp = c[start]; c[start++] = c[end]; c[end--] = temp; &#125; &#125;&#125; 有效的字母异位词：242 12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125; for(char c : t.toCharArray())&#123; if(!charFrequency.containsKey(c)) return false; else charFrequency.put(c, charFrequency.get(c)-1); &#125; for( char c : charFrequency.keySet())&#123; if(charFrequency.get(c) != 0) return false; &#125; return true; &#125; /* 用数组实现更快 public boolean isAnagram(String s, String t) &#123; int[] cnts = new int[26]; for (char c : s.toCharArray()) cnts[c - 'a']++; for (char c : t.toCharArray()) cnts[c - 'a']--; for (int cnt : cnts) if (cnt != 0) return false; return true; &#125; */&#125; 最长回文串：409 1234567891011121314151617181920212223242526272829303132class Solution &#123; //使用数组 public int longestPalindrome(String s) &#123; int[] charFrequency = new int[256]; for (char c : s.toCharArray()) charFrequency[c]++; int result = 0; for (int freq : charFrequency) result += (freq / 2) * 2; return result == s.length() ? result : result+1; &#125; &#125;/* 使用哈希表 public int longestPalindrome(String s) &#123; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125;//HashMap记录所有字母的频率 int result = 0; for(char c : charFrequency.keySet())&#123; int freq = charFrequency.get(c); result += (freq/2)*2;//为偶数则直接加，为奇数则-1 &#125; return result == s.length() ? result : result+1; &#125;*/ 同构字符串：205 123456789101112131415161718class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; return isIsomorphicSinglePass(s, t) &amp;&amp; isIsomorphicSinglePass(t, s); //必须双向验证 //例如\"bar\" -&gt; \" foo\"满足唯一映射，但是反之则不满足 &#125; //单方向判断s -&gt; t, s中的每个字母是否唯一映射t中的每个字母 private boolean isIsomorphicSinglePass(String s, String t)&#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; char charS = s.charAt(i); char charT = t.charAt(i); if(!map.containsKey(charS)) map.put(charS, charT); else if(map.get(charS) != charT) return false; &#125; return true; &#125;&#125; 回文数：9 1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x == 0) return true; if(x &lt; 0 || x % 10 == 0) return false; return x == reverse(x); &#125; //反转整数 private int reverse(int x)&#123; int result = 0; while(x &gt; 0)&#123; result = result*10; result += x%10; x = x/10; &#125; return result; &#125;&#125; 计数二进制子串：696 123输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 123456789101112131415161718class Solution &#123; //先统计连续的0和1分别有多少个，如：111100011000，得到4、3、2、3；在4323中的任意相邻两个数字，取小的一个加起来，就是3+2+2 = 7. public int countBinarySubstrings(String s) &#123; int res = 0; int i = 0, count = 1, precount = 0;//count记录相同数字连续子串的长度，precount记录前一个连续子串的长度 while(i &lt; s.length()-1)&#123; if(s.charAt(i) == s.charAt(i+1)) count++; else &#123; res += precount &gt; count ? count : precount;//取小的一个 precount = count; count = 1; &#125; i++; &#125; res += precount &gt; count ? count : precount; return res; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2020-02-14T14:43:29.000Z","updated":"2020-09-07T11:33:50.834Z","comments":true,"path":"面试刷题/栈与队列/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"用栈实现队列：232 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; stack; /** Initialize your data structure here. */ public MyQueue() &#123; stack = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; stack.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.pop(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Get the front element. */ public int peek() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.peek(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack.empty(); &#125;&#125; 用队列实现栈：225 1234567891011121314151617181920212223242526272829303132class MyStack &#123; private Queue&lt;Integer&gt; queue; /** Initialize your data structure here. */ public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; /** Push element x onto stack. */ public void push(int x) &#123; queue.offer(x); int size = queue.size(); while(size-- &gt; 1)&#123; queue.offer(queue.poll()); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; return queue.poll(); &#125; /** Get the top element. */ public int top() &#123; return queue.peek(); &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; 最小栈：155 12345678910111213141516171819202122232425262728293031323334class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack;//minStack的栈顶元素即是当前stack的最小值 /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.empty())&#123; minStack.push(x); &#125;else&#123; if(x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; &#125; public void pop() &#123; int pop = stack.pop(); if(pop == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; 有效的括号：20 12345678910111213class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //遍历字符串，每遇到一种类型的左括号，则将其对应的右括号入栈；若不是左括号，且栈不为空，则出栈，出栈的有括号应与遍历到的右括号一致。 for(char c: s.toCharArray())&#123; if(c == '(') stack.push(')'); else if(c == '[') stack.push(']'); else if((c== '&#123;')) stack.push('&#125;'); else if(stack.empty() || c != stack.pop()) return false; &#125; return stack.empty(); &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"链表","slug":"链表","date":"2020-02-13T12:45:27.000Z","updated":"2020-09-07T11:35:23.245Z","comments":true,"path":"面试刷题/链表/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"找出两个链表的交点：160 1234567891011121314151617181920public class Solution &#123; /*设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。*/ public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while(pA != pB)&#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; 反转链表：206 123456789101112131415//原地翻转三个主要变量，当前节点cur，前一个节点pre,后一个节点nextTempclass Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125;&#125; 合并两个有序链表：21 1234567891011121314151617181920212223class Solution &#123; //类似于归并排序中的merge过程 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode newList = new ListNode(0); ListNode cur = newList; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; cur.next = l1; cur = cur.next; l1 = l1.next; &#125;else&#123; cur.next = l2; cur = cur.next; l2 = l2.next; &#125; &#125; if(l1 == null) cur.next = l2;//任一链表为空，直接连接另一条链表 else cur.next = l1; return newList.next; &#125;&#125; 删除排序链表中的重复元素：83 123456789101112class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null &amp;&amp; cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125;else cur = cur.next; &#125; return head; &#125;&#125; 删除链表的倒数第N个节点：19 1234567891011121314151617class Solution &#123; //先使快指针移动n个节点，然后快慢指针同时移动直到快指针达到链表尾部，此时慢指针即指向要删除的节点的前一个节点 public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode first = head, second = head; for(int i = 0; i &lt; n; i++) second = second.next; if(second == null) return head.next;//若n等于链表节点数，直接返回head.next while(second.next != null)&#123; first = first.next; second = second.next; &#125; first.next = first.next.next; return head; &#125;&#125; 两两交换链表中的节点：24 123456789101112class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode firstNode = head, secondNode = head.next; firstNode.next = swapPairs(secondNode.next);//swapParis交换一对节点，并返回第二个节点 secondNode.next = firstNode; return secondNode; &#125;&#125; 两数相加：445 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; //两栈用于存储两个数，另一个栈存储和 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; first = new Stack&lt;&gt;(); Stack&lt;Integer&gt; second = new Stack&lt;&gt;(); while(l1 != null)&#123; first.push(l1.val); l1 = l1.next; &#125; while(l2 != null)&#123; second.push(l2.val); l2 = l2.next; &#125; Stack&lt;Integer&gt; sumStack = new Stack&lt;&gt;(); int carry = 0;//进位 while(!first.empty() &amp;&amp; !second.empty())&#123; int sum = first.pop() + second.pop() + carry; carry = 0;//进位用完归0 if(sum &gt;= 10)&#123; carry = 1; sum = sum % 10; &#125; sumStack.push(sum); &#125; while(!first.empty())&#123; if(carry == 1)&#123; int sum = first.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(first.pop()); &#125; while(!second.empty())&#123; if(carry == 1)&#123; int sum = second.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(second.pop()); &#125; if(carry == 1) sumStack.push(1);//和的第二位有进位的情况 ListNode sumList = new ListNode(sumStack.pop()); ListNode cur = sumList; while(!sumStack.empty())&#123; cur.next = new ListNode(sumStack.pop()); cur = cur.next; &#125; return sumList; &#125;&#125; 判断一个链表是否为回文链表：234（要求O（n）和O（1）） 1234567891011121314151617181920212223242526272829303132333435363738394041424344sclass Solution &#123; //该算法使用快慢指针找到链表中间节点，然后将链表切分，将后半部分翻转，再进行比较 public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) return true; ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125;//使用快慢指针使slow指针到达链表中间 if(fast != null) slow = slow.next;//链表节点个数为奇数，slow指针右移离开中间节点 ListNode cur = head; while(cur.next != slow)&#123; cur = cur.next; &#125; cur.next = null;//切分链表为两部分，后半部分第一个节点为slow return isEqual(head, reverseList(slow)); &#125; private ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125; private boolean isEqual(ListNode l1, ListNode l2) &#123; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; &#125; return true; &#125;&#125; 将链表奇数节点和偶数节点分别放在一起：328 （O（n）和O（1）） 1234567891011121314151617class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null) return head; ListNode odd = head, even = head.next; ListNode evenHead = even; while(even != null &amp;&amp; even.next != null)&#123; odd.next = even.next; odd = odd.next; even.next = odd.next; even = even.next; &#125; odd.next = evenHead; return head; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-02-12T07:23:45.000Z","updated":"2020-09-07T11:36:04.638Z","comments":true,"path":"面试刷题/二分查找/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"求开方：69 1234567891011121314151617class Solution &#123; public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int start = 1, end = x; while(start &lt;= end)&#123; int mid = start + (end - start)/2; int sqrt = x/mid;//不使用square与mid*mid判断是因为可能整型溢出 if(sqrt == mid) return mid; else if(sqrt &lt; mid) end = mid - 1; else start = mid + 1; &#125; return end; &#125;&#125; 寻找比目标字母大的最小字母：744 123456789101112131415161718class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; if(target &lt; letters[0] || target &gt;= letters[letters.length-1]) return letters[0]; int start = 0, end = letters.length - 2; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(letters[mid] == target)&#123; int i = mid+1; while(letters[i] == target) i++; return letters[i]; &#125; else if(letters[mid] &lt; target) start = mid + 1; else end = mid - 1; &#125; return letters[end+1]; &#125;&#125; 有序数组中的单一元素：540（时空复杂度要求为O（logn）和O(1)） 12345678910111213class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int start = 0, end = nums.length - 1; while(start &lt; end)&#123; int mid = start + (end - start)/2; if(mid%2 == 1) mid--;//只对偶数索引进行二分查找 //以[3,3,7,7,10,11,11]为例，只有当单一元素出现后，其后的数组部分，偶数索引mid处才不满足nums[mid] == nums[mid+1] if(nums[mid] == nums[mid+1]) start = mid + 2;//单一元素一定在mid后 else end = mid;//单一元素为mid或者在mid之前 &#125; return nums[start]; &#125;&#125; 寻找第一个错误的版本：278 1234567891011public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int low = 1, high = n; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(isBadVersion(mid)) high = mid;//第mid个版本错误，之后全是错的，向前继续找第一个错误的版本 else low = mid + 1;//第mid个版本正确，向后找 &#125; return low; &#125;&#125; 寻找旋转排序数组中的最小值：153 12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= nums[high]) high = mid; else low = mid+1; &#125; return nums[low]; &#125; /*时间复杂度O(n) public int findMin(int[] nums) &#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i+1]) return nums[i+1]; &#125; return nums[0]; &#125; */&#125; 在排序数组中查找元素的第一个和最后一个位置：34 1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length == 0) return new int[]&#123;-1,-1&#125;; int firstIndex = findFirst(nums, target); if(nums[firstIndex] != target) return new int[]&#123;-1,-1&#125;; int lastIndex = findLast(nums,target); if(nums[nums.length-1] == target) return new int[]&#123;firstIndex,nums.length-1&#125;; return new int[]&#123;firstIndex, firstIndex &lt; lastIndex ? lastIndex : firstIndex&#125;; &#125; private static int findFirst(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &gt;= target) high = mid;//向左逼近，找左边界 else low = mid + 1; &#125; return low; &#125; private static int findLast(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= target) low = mid + 1;//向右逼近，找右边界，注意若最后一个数为target，则low不用-1 else high = mid; &#125; return low-1; &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"排序","slug":"排序","date":"2020-02-11T08:07:19.000Z","updated":"2020-09-10T03:09:04.344Z","comments":true,"path":"数据结构与算法/排序/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"常见排序算法 排序的稳定性：排序过程中，具有相同关键字经过排序后，相对的顺序保持不变，则是稳定的；意义：在对象排序中，对其某个属性进行排序后，希望保持其他属性的顺序不发生改变，则需要稳定的排序算法。 选择排序从数组开始处遍历，找到剩余未遍历数组中的最小值，与本次遍历第一个数交换，重复此过程，每一次内层循环找到未遍历数组的最小值，外层循环中将一个最小值排好序。 1234567891011public static void sort(int[] nums)&#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; int minPostion = i; for(int j = i+1; j &lt; nums.length; j++)&#123; minPostion = nums[minPostion] &gt; nums[j] ? j :minPostion; &#125; swap(nums, minPostion, i); &#125; &#125; 冒泡排序内层循环两两比较，将大的数放在后面，最终结果是一次内层循环将一个最大的数排好顺序，与选择排序恰好相反。 1234567public static void sort(int[] nums)&#123; for(int i = nums.length-1; i &gt; 0; i--)&#123;//外层循环决定最大的数的位置 for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &gt; nums[j+1]) swap(nums, j, j+1); &#125; &#125; &#125; 插入排序外层循环遍历数组（选择某张牌），内层循环将外层循环选择的牌插入到前面已经排好序的牌中。 1234567public static void sort(int[] nums)&#123; for(int i = 1; i &lt; nums.length; i++)&#123; for(int j = i; j &gt; 0; j--)&#123; if(nums[j] &lt; nums[j-1]) swap(nums, j, j-1); &#125; &#125; &#125; 插入排序在样本较小且基本有序时效率较高。 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HeapSort &#123; //堆：满足“任一非叶子节点均大于（小于）等于其孩子节点”条件的完全二叉树，分为大根堆和小根堆 public static void main(String[] args) &#123; int[] test = &#123;3,2,5,6,4,7,0,1,10,9,8&#125;; sort(test); for(int num:test)&#123; System.out.print(\" \"+num); &#125; &#125; public static void sort(int[] tree)&#123; buildHeap(tree); for(int j = tree.length - 1; j &gt; 0; j--)&#123; swap(tree,0,j);//将堆顶元素与末尾元素进行交换 adjustHeap(tree,0,j);//重新对堆进行调整 &#125; &#125; /** * 创建大根堆 * @param tree */ public static void buildHeap(int[] tree) &#123; for(int i = tree.length/2 - 1; i &gt;= 0; i--)//从第一个非叶子结点（完全二叉树中必为n/2-1）从下至上，从右至左调整结构 adjustHeap(tree, i, tree.length); &#125; /** * 堆化操作，将第i个节点与其孩子节点进行比较，将最大值放在位置i上； * 递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 * @param tree * @param i * @param length */ public static void adjustHeap(int[] tree,int i,int length)&#123; if(i &gt;= length) return;//递归出口，孩子的下标大于等于数组长度返回 int leftChildIndex = 2*i + 1;//左孩子下标 int rightChildIndex = 2*i + 2;//右孩子下标 int maxIndex = i;//用一个变量来记录i, 2*i+1, 2*i+2三者中的最大值的下标 if(leftChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[leftChildIndex]) maxIndex = leftChildIndex; if(rightChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[rightChildIndex]) maxIndex = rightChildIndex; if(maxIndex != i)&#123; swap(tree, i, maxIndex); adjustHeap(tree, maxIndex, length);//递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 &#125; &#125; private static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 归并排序 Java对象排序使用，对象排序要求稳定性 12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 对数组的left至right这部分进行排序 * @param nums * @param left * @param right */public static void sort(int[] nums, int left, int right)&#123; if(left == right) return; int mid = left + (right - left)/2;//防止整型溢出 sort(nums, left, mid);//对数组的左半部分排序 sort(nums, mid+1, right);//对数组的右半部分排序 merge(nums, left, mid+1, right);//合并数组的两半部分&#125;/** * 合并数组的任意两半部分（均有序的情况下） * @param nums */private static void merge(int[] nums, int left, int mid, int right)&#123; int[] result = new int[right - left + 1]; int i = left, j = mid; int k = 0; while(i &lt; mid &amp;&amp; j &lt;= right)&#123; if(nums[i] &lt;= nums[j])&#123; result[k++] = nums[i++]; &#125;else result[k++] = nums[j++]; &#125; while(i &lt; mid)&#123; result[k++] = nums[i++]; &#125; while(j &lt;= right)&#123; result[k++] = nums[j++]; &#125; k = 0; for(i = left; i &lt;= right; i++)&#123; nums[i] = result[k++]; &#125;&#125; 快速排序Java基础类型数据排序使用双轴快排 1234567891011121314151617181920212223242526272829public static void sort(int[] nums, int leftBound, int rightBound)&#123; if(leftBound &gt;= rightBound) return; int pivotIndex = partition(nums, leftBound, rightBound);//得到每一次划分后轴的位置 sort(nums, leftBound, pivotIndex-1);//对轴左边的部分继续进行划分 sort(nums, pivotIndex+1, rightBound);//对轴右边的部分进行划分 &#125; /** * 一次划分将小于轴的数放在其左边，大于轴的数放在其右边 * @param nums * @param leftBound * @param rightBound * @return pivotIndex(轴的位置) */ private static int partition(int[] nums, int leftBound, int rightBound)&#123; int pivot = nums[rightBound];//将右边界的数定义为轴 int left = leftBound, right = rightBound - 1; while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &lt;= pivot) left++;//从左往右找到第一个比轴大的数 while(left &lt;= right &amp;&amp; nums[right] &gt; pivot) right--;//从右往左找到第一个比轴小的数 if(left &lt; right) swap(nums, left, right);//交换 &#125; swap(nums, left, rightBound);//交换nums[left]与轴则完成一次划分 return left; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"双指针","slug":"双指针","date":"2020-02-09T11:05:21.000Z","updated":"2020-09-07T11:35:01.457Z","comments":true,"path":"面试刷题/双指针/","link":"","permalink":"http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"升序数组的TwoSum:167 1234567891011121314class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers == null) return null; int start = 0, end = numbers.length - 1; while(start &lt; end)&#123; if(numbers[start] + numbers[end] == target)&#123; return new int[]&#123;start+1, end+1&#125;; &#125; else if(numbers[start] + numbers[end] &lt; target)&#123; start++; &#125; else end--; &#125; return null; &#125;&#125; 判断某个数是否为平方数之和：633 12345678910111213class Solution &#123; public boolean judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int start = 0, end = (int)Math.sqrt(c); while(start &lt;= end)&#123; int squareSum = start*start + end*end; if(squareSum == c) return true; else if(squareSum &lt; c) start++; else end--; &#125; return false; &#125;&#125; 反转字符串中的元音字母：345 123456789101112131415161718192021222324class Solution &#123; public String reverseVowels(String s) &#123; HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); int start = 0, end = s.length() - 1; char[] result = new char[s.length()]; while(start &lt;= end)&#123; char startC = s.charAt(start); char endC = s.charAt(end); if(!vowels.contains(startC))&#123; result[start++] = startC; &#125; else if(!vowels.contains(endC))&#123; result[end--] = endC; &#125; else &#123; result[start++] = endC; result[end--] = startC; &#125; &#125; return new String(result); &#125;&#125; 给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串:680 1234567891011121314151617181920212223class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0, right = s.length() - 1; while(left &lt;= right)&#123; if(s.charAt(left) == s.charAt(right))&#123; left++; right--; &#125;else return isPalindrome(s, left+1, right) || isPalindrome(s, left, right-1);//如果左右不对称，则判断删除s.charAt(left)或者s.charAt(right)后的子字符串是否为回文串 &#125; return true; &#125; private boolean isPalindrome(String s, int left, int right)&#123; while(left &lt;= right)&#123; if(s.charAt(left) != s.charAt(right)) return false; else &#123; left++; right--; &#125; &#125; return true; &#125;&#125; 合并两个有序数组：88 12345678910111213141516class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1, j = n - 1; int k = m+n-1; while(i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(nums2[j] &gt; nums1[i]) nums1[k--] = nums2[j--]; else nums1[k--] = nums1[i--]; &#125;//从两个数组尾部开始比较大小 //将剩余的某个数组中未比较的元素写入nums1 while(i &gt;= 0) nums1[k--] = nums1[i--]; while(j &gt;= 0) nums1[k--] = nums2[j--]; &#125;&#125; 判断链表中是否有环：141（快慢指针） 12345678910111213public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(slow != null &amp;&amp; fast!= null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(fast == slow) return true; &#125; return false; &#125;&#125; 通过删除字母匹配到字典里最长单词：524 1234567891011121314151617181920212223242526272829class Solution &#123; public String findLongestWord(String s, List&lt;String&gt; d) &#123; String result = \"\"; int maxLength = 0; for(String target : d)&#123; int targetLen = target.length(); if(isSubStr(s, target))&#123; if(maxLength &lt; targetLen)&#123; maxLength = targetLen; result = target; &#125;else if(maxLength == targetLen)&#123; if(result.compareTo(target) &lt; 0) continue;//比较字符串之间的字典顺序使用compareTo方法 else result = target; &#125; &#125; &#125; return result; &#125; private boolean isSubStr(String s, String target)&#123; int i = 0, j = 0; //遍历字符串s,每匹配一个target的字符j加1 while(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123; if(s.charAt(i) == target.charAt(j)) j++; i++; &#125; return j == target.length();//若j等于target.length(),说明target是s的一部分 &#125;&#125;","categories":[{"name":"面试刷题","slug":"面试刷题","permalink":"http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"leetcode","slug":"leetcode","permalink":"http://thmasterplan.cn/tags/leetcode/"}]},{"title":"进程管理","slug":"进程管理","date":"2019-12-09T05:54:57.000Z","updated":"2020-09-07T11:35:29.949Z","comments":true,"path":"Linux/进程管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/","excerpt":"","text":"进程管理工具 lscpu：显示cpu信息 pstree -p：打印进程树 ps：(process state)，Linux系统各进程的相关信息均保存在/proc/PID下 BSD选项，选项前没有-： a：打印所有终端中的进程 STAT： x：与终端无关的进程，例如守护进程 u：额外显示进程的USER，CPU/MEM占比，RSS（常驻内存集，不包括交换分区）与VSZ（分配给进程的虚拟内存，包括交换分区），START（开始运行的时间）。 f：显示进程父子关系 k -%cpu：倒序排序显示cpu占比，-表示倒序 o：只显示某些选项，后面跟要显示的选项；例如ps axo psr：显示命令使用哪个CPU核 Linux优先级：o ni,pri,rtprio 搜索进程 按预定义的模式：pgrep [options] pattern： -u uid：有效用户 -U uid：运行命令者 -t terminal：与指定终端相关的进程 -l：显示进程名，例如pgrep -l &#39;^ba.*&#39; -a：显示完整格式的进程名 -P pid：显示指定进程的子进程 按程序名称: pidof 程序名 进程管理工具：top，内置命令： 排序：P：按%CPU；M：按%MEM；T：按累积占据CPU时长(TIME+) 首部信息显示： uptime信息：l tasks及cpu信息：t cpu内核分别显示：1 内存信息：m 退出：q 修改刷新时间间隔：s 终止进程：k 保存当前进程信息：W 栏位信息： us：用户空间 sy：内核空间 ni：调整nice时间 id：空闲 wa：等待IO时间 hi：硬中断 si：软中断 st：虚拟机偷走的时间 选项： -b：显示所有进程（默认只显示前一部分） -p：指定显示某些进程 -H：线程模式；示例：top -H -p PID，指定显示某个进程的所有线程 EPEL源的htop，功能更丰富的进程管理工具 内存空间使用状态：free -h：易读格式 -s n：指定刷新间隔为n秒 查看虚拟内存使用状态：vmstat 系统监控工具： iostat：统计CPU和设备IO信息 iftop：显示带宽使用情况，EPEL源 dstat：替代iostat,vmstat,ifstat iotop：I/O监视器 nload：查看网络实时吞吐量 lsof：list open files；恢复文件： 进程信号与计划任务实现","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"磁盘管理","slug":"磁盘管理","date":"2019-11-29T07:26:51.000Z","updated":"2020-09-07T11:36:26.810Z","comments":true,"path":"Linux/磁盘管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/","excerpt":"","text":"磁盘工作原理 不同硬盘标识：a-z，aa，ab… ​ /dev/sda，/dev/sdb 同一磁盘的不同分区：1，2，… ​ /dev/sda1，/dev/sda2，… 磁盘存储术语：head(磁头)，track(磁道)，cylinder(柱面)，sector(扇区) 磁盘使用步骤：磁盘分区 -&gt; 分区上创建文件系统 -&gt; 将分区挂载到目录 分区管理 分区原因 隔离系统和程序，可安装多个OS 采用不同文件系统 优化I/O性能 实现磁盘空间配额限制 提高修复速度 MBR分区管理 分区不超过2T 一块硬盘最多有4个主分区，也可以3主分区+1扩展分区（扩展分区包含N给逻辑分区） MBR分区结构： GPT分区管理 支持128个分区，分区可达ZB级别 GPT分区结构 分区管理命令 列出块设备：lsblk 查看块设备的UUID（通用唯一识别码）：blkid 创建分区： 创建MBR分区：fdisk fdisk -l查看当前分区情况 fdisk [device]，管理分区，常用子命令： p：分区列表 t：更改分区ID（输入L查询，不同的ID标识分区的类型） n：创建新分区 d：删除分区 v：校验分区 u：转换单位 w：保存退出 q：不保存退出 fdisk实时更改硬盘的分区，分区完成后注意与内存分区表同步（partprobe），查看内核是否已经识别新的分区cat /proc/partitions。 创建GPT分区：gdisk，用法与fdisk相似 高级分区操作：parted parted命令操作都是实时生效，需谨慎操作 parted /dev/sdb mklabel gpt：设置/dev/sdb这块磁盘为gpt类型 parted /dev/sdb print：打印/dev/sdb的分区信息 parted /dev/sdb mkpart primary 1 200：设置一个分区，从1MB到200MB，大小为199MB（注意分区需是连续空间） parted /dev/sdb rm 1：删除第一个分区 parted -l：列出所有硬盘的分区信息 重新设置内存中的内核分区表版本：partprobe 文件系统管理 查看当前OS支持的文件系统：cat /proc/filesystems 创建文件系统：mkfs -t [type] [device]：例如mkfs -t xfs /dev/sdb2，若要创建swap类型，使用mkswap /dev/xxx命令 管理文件系统： tune2fs：重新设定ext系列文件系统参数的值 -l：查看指定文件系统superblock信息 -L &#39;LABEL&#39;：修改卷标 -O：文件系统属性的启用或禁用 dumpe2fs：显示ext文件系统信息，将磁盘块分组管理 xfs_info 挂载点：显示已挂载的xfs文件系统信息 文件系统检测和修复： 文件系统故障常发生于死机或非正常关机后，注意一定要取消挂载后执行修复命令 fsck 、e2fsck、xfs_repair 常用工具： df：查看文件系统和磁盘空间使用情况，常用选项-T,-h du -h /xxx/yyy：查看某目录总体空间占用状态，--max-depth=3指定最大目录层级为3 dd：convert and copy a file 用法：dd if=/x/y of=/a/b bs=# count=# if=/x/y：从指定文件读取 of=/a/b：写入到指定文件 ibs=size：一次读size个字节 obs=size：一次写size个字节 bs=size：block size，指定块大小(既是ibs也是obs) cbs=size：一次转换size个字节 skip=blocks：从开头忽略blocks个ibs大小的块，只复制之后的内容 seek=blocks：从开头忽略blocks个obs大小的块，用if中复制的内容替换blocks个obs大小的块之后的内容。 count=n：复制n个bs 备份： dd if=/dev/sdx of=/dev/sdy：整盘备份到另一磁盘 dd if=/dev/sdx of=/xxx/image：整盘备份到文件 dd if=/dev/sdx | gzip &gt; /xxx/image.gz：整盘备份并压缩 恢复： dd if=/xxx/image of=/dev/sdx gzip -dc /xxx/image.gz | dd of=/dev/sdx 挂载设备 将分区挂载到目录，则该目录下的文件都存储于该分区中；若有其他分区挂载在该目录的子目录下，则子目录下的文件存储与另一分区中。 挂载点下原有文件在挂载完成后会被临时隐藏，因此挂载点目录一般为空。 一个分区可以同时挂载在多个目录下，一个目录只能与一个分区关联 实现永久挂载需要写入配置文件/etc/fstab，使用blkid查看UUID（也可使用设备分区名例如/dev/sda2）并按格式写入配置文件；若需要更改挂载点所属文件系统属性（是否启用acl，suid，exec等），亦可在该配置文件中更改，默认为defaults，然后mount -o remount /dev/xxx重新挂载使更改生效 swap的挂载：写入/etc/fstab，挂载点和文件系统均为swap，保存退出后键入swapon -a;swapoff命令取消交换分区。 mount /dev/sda2 /mnt：将分区sda2挂载在/mnt目录下 -r：只读挂载 -w：读写挂载，默认 mount -B 目录1 目录2：类似与软连接的效果，两个目录的文件共享。 -o options：挂载文件系统的选项 umount /mnt：取消挂载 cat /etc/mtab：查看目前的挂载情况 查看挂载情况：findmnt 挂载点/设备分区 查看正在访问指定挂载点的进程：lsof 挂载点、fuser -v 挂载点 终止所有正在访问指定挂载点的进程：fuser -km 挂载点 外围设备使用 使用光盘： 手动挂载：mount /dev/cdrom /mnt 操作光盘：eject弹出光盘；eject -t弹入光盘 创建ISO文件：cp /dev/cdrom /root/xxx.iso；mkisofs -r -o ./xxx.iso /etc… 挂载USB介质： 查看USB设备是否识别：lsusb 被内核探测为SCSI设备：/dev/sdaX、/dev/sdbX或类似的设备文件 手动挂载：mount /dev/sdbX /mnt 管理虚拟内存 swap交换分区是系统内存的补充，支持虚拟内存，当没有足够的内存保存系统处理的数据时会将数据写入swap分区 推荐系统swap空间 | 系统RAM | 推荐的swap空间 | 允许机器休眠的swap建议 || :————: | :——————: | :——————————: || 低于2GB | RAM的倍数 | RAM的三倍 || 2GB - 8GB | 等于RAM | RAM的倍数 || 8GB - 64GB | 8GB | RAM的1.5倍 || &gt; 64GB | 16GB | 不建议使用休眠功能 | free：查看内存使用情况 RAID管理 RAID：Redundant Arrays of Independent Disks（独立冗余磁盘阵列） 提高IO能力：磁盘并行读写 提高容错性 多块磁盘组织在一起工作 实现方式： 外接式：通过扩展卡提供适配能力 内接式：主板集成RAID控制器，安装OS前在BIOS里配置 软件RAID：软件实现 RAID级别： RAID-0：同一文件分块存储在多块硬盘上，读写性能提升，无容错能力 RAID-1：同一文件完全一样地存储于两块磁盘（镜像），读性能提升，写性能略有下降，有容错能力，磁盘利用率只有一半 RAID-5：读写性能提升，至少3块磁盘，有容错能力（允许最多1块磁盘损坏），每一块磁盘都划分一部分空间充当校验位 RAID-6：读写性能提升，至少4块磁盘，两个校验位，允许最多2块磁盘损坏，容错性较RAID-5高 RAID-10与RAID-01（实际使用RAID-10，RAID-10容错性较RAID-01好） RAID-50 RAID-7：自身带操作系统和管理工具，理论上性能最高的RAID模式 LVM（逻辑卷管理器） LVM：允许对卷进行方便操作的抽象层 将物理块设备指定为物理卷 用多个物理卷来创建一个卷组（物理卷是用固定大小的物理区域[PE,physical extent]来定义的） 从卷组中划分逻辑卷，可在逻辑卷上创建文件系统，逻辑卷大小可扩展。 示意图： 使用逻辑卷步骤： 将设备指定为物理卷，例如pvcreate /dev/sdb1 /dev/sdd或pvcreate /dev/sd{b1,d}，同时将分区和磁盘指定为物理卷。（如果是分区，需要将分区ID改为8e，表示Linux LVM类型） 用多个物理卷创建卷组，vgcreate [选项] vgName pv1 pv2 ...，例如vgcreate -s 16M vg0 /dev/sdb1 /dev/sdd，选项-s指定PE大小。 从卷组中划分逻辑卷，lvcreate -n mysql -L 8G vg0，-n指定逻辑卷名，-L指定大小，-l也是指定大小但是单位是PE个数。 ll /dev/vg0/mysql发现/dev/vg0/mysql为软链接，指向/dev/dm-0，其另一软链接为/dev/mapper/vg0-mysql，若继续创建逻辑卷，其真实设备名依次为/dev/dm-1、/dev/dm-2… 在逻辑卷上创建文件系统，mkfs.xfs /dev/vg0/mysql 挂载，mount /dev/vg0/mysql /mnt/mysql；将挂载写入配置文件/etc/fstab，在vim扩展命令模式下键入r!blkid /dev/vg0/mysql进行修改 列出现有的物理卷：pvs、pvdisplay 列出现有卷组：vgs、vgdisplay 列出现有逻辑卷：lvs、lvdisplay 扩展现有逻辑卷：lvextend -l +48%free /dev/vg0/mysql：剩余卷组的48%分配给逻辑卷，亦可使用PE数进行分配lvextend -l +200 /dev/vg0/mysql；此时使用lsblk或者fdisk -l查看已分配成功，但是df查看并未改变，还需要为新扩展的逻辑卷创建相同的文件系统 xfs：xfs_growfs 挂载点 ext：resize2fs 逻辑卷名（注意xfs与ext的区别） 亦可一次搞定（加上-r选项）：lvextend -r -l +xxx /dev/vg0/mysql 扩展现有的卷组：vgextend vg0 PV名 删除逻辑卷、卷组、物理卷：迁移数据 -&gt; umount /mnt/mysql -&gt; lvremove /dev/vg0/mysql -&gt; vgremove vg0 -&gt; pvremove /dev/sdb1 /dev/sdd LVM快照管理： 逻辑卷的快照需要与该逻辑卷在同一个卷组，且快照的容量小于等于逻辑卷 逻辑卷中每一个发生修改的文件都会备份到快照中 使用快照： lvcreate -n mysql_snapshot -s -L 1G /dev/vg0/mysql：创建逻辑卷mysql的快照，选项-s用于创建快照，快照上的文件系统与原逻辑卷相同 挂载快照到目录：mount -o nouuid /dev/vg0/mysql_snapshot /mnt/snap，由于快照的UUID与原逻辑卷一样，所以挂载时需要指定nouuid选项，不然挂载不上（xfs是这样，ext4不用） 还原快照到逻辑卷（逻辑卷恢复为快照）： umount /mnt/snap,umount /mnt/mysql：卸载快照和逻辑卷 lvconvert --merge /dev/vg0/mysql_snapshot：还原，此时快照已经删除 mount /dev/vg0/mysql /mnt/mysql：重新挂载","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Linux软件安装和包管理","slug":"Linux软件安装和包管理","date":"2019-11-25T04:47:01.000Z","updated":"2019-11-29T07:25:41.582Z","comments":true,"path":"Linux/Linux软件安装和包管理/","link":"","permalink":"http://thmasterplan.cn/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"","text":"软件运行环境 静态链接：libxxx.a，程序对应的依赖库复制到程序包，占用空间多,迁移容易，升级难，需重新编译。 动态链接：libxxx.so，只把依赖做一个动态链接，占用空间少。 ldd 命令：查看二进制程序所依赖的共享库文件。 ldconfig -p：查看本机已经缓存的所有可用库文件名及文件路径映射关系。 程序包的来源 管理程序包： 使用包管理器：rpm 使用前端工具：yum,dnf 获取程序包的途径：官方服务器，镜像站点，epel源（Extra Packages for Enterprise Linux） rpm包管理 rpm: redhat package manager，rpm包中是已经编译好的程序文件。 /var/lib/rpm/：数据库，其中包含了所有rpm包的名称及版本，依赖关系，功能说明，包安装后生成的各文件路径及校验码信息。 rpm -ivh [install-options] PACKAGE_FILES： -i：安装 -v：显示安装过程 -h：显示程序包管理执行进度 -q：查询包是否安装，与-l一起使用，列出包中的文件；与-f使用，查询文件的所属包；-a，查询所有安装的包 -e：卸载 -U：升级 -V：包校验 …其余查询man帮助 yum管理 YUM：Yellowdog Update Modifier，rpm的前端程序，基于C/S架构，可解决软件包相关依赖性，可在多个库之间定位软件包 配置yum源：/etc/yum.repos.d/路径下xxx.repo中配置源服务器路径，yum命令安装时，查询本地repo源 -&gt; 查询服务器端元数据 -&gt; 下载元数据到缓冲区 -&gt; 下载rpm包到缓冲区 -&gt; 按依赖顺序安装包。 使用本地光盘配置yum源 检查是否安装autofs(自动挂载服务) systemctl start autofs：启动 systemctl enable autofs：设置开机自启动 systemctl status autofs：查看服务状态 ls /misc/cd -&gt; df：光盘/dev/sr0已自动挂载到/misc/cd目录下 cd /etc/yum.repos.d/，将原有的国外源删除（备份），创建一个新的以.repo结尾的配置文件，例如创建base.repo,配置如下 1234[base]name&#x3D;cdrom basebaseurl&#x3D;file:&#x2F;&#x2F;&#x2F;misc&#x2F;cdgpgcheck&#x3D;0 yum repolist：查看可用的repo列表 网络源配置 可单独创建一个xxx.repo，也可在现有的repo中追加，例如在base.repo中追加 1234[epel]name&#x3D;aliyun epelbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;0 其中releasever变量代表当前OS发行版本，basearch代表cpu架构 yum clean all：清空yum源缓存 yum list：列出repo源所有包 yum install xxx：安装 yum remove xxx：删除 yum update pkgxxx yum info xxx：查看详细信息 定制yum仓库 使用httpd定制本地yum源 dnf管理 centos8之后默认安装 源码编译安装 首先使用wget URL下载好源码包 C/C++：make项目管理器 安装gcc 解压，进入到源码包目录中，运行./configure，通过选项传递参数指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile（安装前查看源码包中的说明帮助文档README、INSTALL等，亦可通过./configure --help查看可选项） make -j n根据Makefile文件，构建应用程序，j选项表示多线程并行编译。 make install 更改PATH Java：maven","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"压缩与解压缩","slug":"压缩与打包","date":"2019-11-23T00:43:05.000Z","updated":"2020-09-07T11:33:58.030Z","comments":true,"path":"Linux/压缩与打包/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/","excerpt":"","text":"一、压缩、解压缩工具 .Z后缀 compress：压缩后会删除原文件，可读取STDOUT内容进行压缩，支持管道 -c：结果输出至标准输出，不删除原文件。常见用法：compress -c file &gt; file.Z -v：显示详情 uncompress file.Z zcat file.Z：不显示解压缩的前提下查看文本文件内容 .gz后缀 gzip： -c：同compress -c -#：#取1-9，指定压缩比，值越大压缩比越大 gunzip file.gz zcat file.Z .bz2后缀 bzip2： -k： -#：默认为9 bunzip2 file.bz2 bzcat file.bz2 .xz xz： -k： -#：默认为6 unxz xzcat 一般来说压缩比：xz &gt; bzip2 &gt; gz &gt; compress，均不能压缩目录 .zip zip：支持压缩目录 unzip 二、打包(存档)和解包工具 tar常见用法：具体选项见man帮助 打包，保留权限：tar -cpvf xxx.tar file1 file2 file3... 追加文件至xxx.tar：tar -rf xxx.tar file1 file2..注：不支持对压缩文件追加 查看包中的文件列表：tar -tf xxx.tar 解包tar -xf xxx.tar [可选：-C /PATH] 结合压缩工具，打包并压缩： tar zcvf xxx.tar.gz [可选：/PATH]；.tar.gz也可写成.tgz tar jcvf xxx.tar.bz2 [可选：/PATH] tar Jcvf xxx.tar.xz [可选：/PATH] --eclude=/PATH/文件名：打包时排除某文件：tar -zcvf xxx.tgz --exclude=/a/b/abc.txt -T：指定打包列表；-X：指定排除列表 tar -zcvf xxx.tgz -T /a/list -X /a/excludeList split：分割一个文件为多份小文件 split -b SIZE xxx.tgz yyy：yyy为切割后的文件前缀，SIZE为每份大小 合并：cat yyy* &gt; xxx.tgz cpio：一种老的存档格式。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"文件查找工具","slug":"文件查找工具","date":"2019-11-22T07:44:54.000Z","updated":"2020-09-07T11:34:39.616Z","comments":true,"path":"Linux/文件查找工具/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/","excerpt":"","text":"文件查找 在文件系统上查找符合条件的文件 非实时查找（数据库查找）：locate 查询系统上预建的文件索引数据库/var/lib/mlocate/mlocate.db 索引构建过程需要遍历整个根文件系统，极消耗资源 查找速度快，模糊查找，非实时，搜索的是文件的全路径，可手动更新updatedb 选项： -i：不区分大小写 -n N：只列举前N个匹配项目 -r：使用基本正则表达式 实时查找：find 通过遍历指定路径完成文件查找 查找速度略慢，精确，实时 语法：find [选项] [查找路径] [查找条件] [处理动作] 选项： -maxdepth level：最大搜索目录深度，指定目录下的文件为第1级 -mindepth level：最小搜索目录深度 -depth：先搜索文件，再搜索目录；不加该选项时默认为先搜目录再搜文件 查找路径：默认为当前目录 查找条件：可以查找文件名，大小，类型，权限等，默认为找出指定路径的所有文件 根据文件名和inode -name 文件名：支持文件通配符 -iname 文件名：不区分字母大小写 -inum n：按inode号查找 -samefile 文件名：相同inode号的文件 -links n：链接数为n的文件 -regex &#39;PATTERN&#39;：匹配整个文件路径而非文件名 根据owner,group -user 用户名 -group 组名 -uid UID -gid GID -nouser：比如某个用户被删除，但其文件还存在 -nogroup 根据文件类型 -type TYPE：TYPE包括f,d,l,s,b,c,p 空文件或目录：-empty，例如find /usr -type d -empty 根据文件大小 -size SIZE，常用单位k,M,G 对于SIZE的写法，-6k代表[0,5k]，6k代表(5k,6k]，+6k代表(6k,+∞) 根据时间 -atime/-mtime/-ctime -amin/-mmin/-cmin find ./ -mtime -3，代表[0,3）天内被修改，find ./ -mtime 3代表第3天被修改，find ./ -mtime +3代表被修改3天以上。 根据权限 -perm (/|-) MODE0配 MODE：精确权限匹配 /MODE：u,g,o中只要匹配到一个即可 -MODE：u,g,o必须同时满足指定权限 例如find ./ -perm -222指u,g,o均要有写权限才满足条件 不想搜索某目录时：使用-path &#39;目录&#39; -a -prune，例如find / -path &#39;/etc&#39; -a -prune -o -name passwd在根目录下除/etc外搜索文件名为passwd的文件。 组合条件：与：-a；或：-o；非：-not/!。即将以上各种条件组合使用查找。当需要使用括号时要转义。例如find /usr \\(-name &quot;f*&quot; -o -type f\\) -ls。 处理动作：对符合条件的文件做操作，默认输出至屏幕 -print：默认的处理动作，显示至屏幕 -ls：类似于对查找到的文件执行ls -l命令 -delete：删除查找到的文件 -fls file：查找到的所有文件的长格式信息保存至指定文件中。等价于-ls &gt; file -ok cmd {} \\;：对查找到的每个文件执行由cmd指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认 -exec cmd {} \\;：对查找到的每个文件执行由cmd指定的命令 {}用于引用查找到的文件名称自身，包含路径名。 xargs：cmd1 | xargs [选项] cmd2 xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。 xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。 xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。 之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令 具体选项见man帮助 举例：find linux-5.1.4/ -name &quot;*.c&quot; | xargs -n1 cat | wc -l统计出linux内核一共有多少行c代码；cat `find linux-5.1.4/ -name &quot;*.c&quot;`|wc -l实际运行更快。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"正则表达式","slug":"正则表达式","date":"2019-11-20T07:16:10.000Z","updated":"2020-09-07T11:33:43.881Z","comments":true,"path":"Linux/正则表达式/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/","excerpt":"","text":"元字符分类：字符匹配、匹配次数、位置锚定、分组字符匹配 .：匹配任意单个字符 \\：转义字符，例如\\.表示匹配.本身而非任意单个字符。 []：匹配指定范围内任意单个字符 [^]：匹配指定范围外的任意单个字符 [:alnum:]：字母和数字 [:alpha:]：任何英文大小写字符 [:lower:]：小写字母 [:upper:]：大写字母 [:digit:]：十进制数字 [:xdigit:]：十六进制数字 [:blank:]：空白字符（空格和制表符） [:space:]：水平和垂直的空白字符 [:cntrl:]：不可打印的控制字符（退格、删除等） [:graph:]：可打印的非空白字符 [:print:]：可打印字符 [:punct:]：标点符号 匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数 *：匹配前面的字符0或多次。注意与文件名通配符里*的区别。 .*：任意长度的任意字符。 \\?：匹配前面的字符0或1次。 \\+：匹配前面的字符至少1次。 \\{n\\}：匹配前面的字符n次。 \\{m,n\\}：匹配前面的字符至少m次，至多n次。 \\{,n\\}：匹配前面的字符至多n次。 \\{n,\\}：匹配前面的字符至少n次。 位置锚定：定位出现的位置 ^：行首锚定，用于模式的最左侧。例如grep ^[^#] xxx表示显示xxx中所有非#开头的行，即显示非注释行。 $：行尾锚定，用于模式的最右侧。 ^PATTERN$：用于模式匹配整行。^$可表示空行。 \\b：词首或词尾锚定，用于单词模式的左/右侧。 分组：\\(\\) \\(string\\)：其中string会被正则表达式引擎记录与内部的变量中，这些变量的命名方式为：\\1,\\2,\\3,...。 示例：\\(string1\\(string2\\)\\)：\\1：string1\\(string2\\)；\\2：string2。 例如：\\(root\\)\\{1,3\\}：可匹配1-3个root字符串。 扩展的正则表达式： 去掉\\","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"常见文本处理命令","slug":"常见文本处理命令","date":"2019-11-19T11:49:20.000Z","updated":"2020-09-07T11:36:40.053Z","comments":true,"path":"Linux/常见文本处理命令/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%B8%B8%E8%A7%81%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/","excerpt":"","text":"查看文本内容： cat：适合查看小文本 -E：显示行结束符$ -n：对显示的每一行编号 -A：显示所有控制符 tac：从最后一行向前反向显示 rev：每一行都是反向显示 more、less：分页查看 文本截取： head -c#：获取前#字节 -#：获取前#行 tail -c#：获取后#字节 -#：获取后#行 -f：可用于日志监控，例如tail -f /var/log/messages，即时显示日志追加文本的变化。 按列抽取： cut：cut -d# -f1,3：以#作为分隔符，截取第1列和第3列 -d：指明分隔符 -f：指明字段 练习：获取网卡ip地址：ifconfig ens33 | head -2 | tail -1 | tr -s &quot; &quot; | cut -d&quot; &quot; -f3 排序和统计： 文本排序sort：把排序后的文本显示在STDOUT，不改变原始文件 -n：按照数字大小排序 -r：反向排序 -u：删除重复行 -t#：#作为字段界定符 -kX：选项按照使用#分隔的第X列来排序 uniq：删除连续重复的行 -c：显示重复出现的行的次数，常与sort命令一起使用；sort a.txt| uniq -c。 文本数据统计wc： wc test.txt：依次输出行数，单词数，字节数 -l：只计数行数 -w：只计数单词数 -c：只计数字节数 -m：只计数字符总数 -L：显示文件中最长行的长度 比较文件：diff和patch 按关键字抽取： grep：grep [选项] 模式 file文本搜索工具，根据指定模式[由正则表达式字符及文本字符所编写的过滤条件]对目标文本逐行进行匹配检查，打印匹配到的行。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"Java位运算","slug":"Java位运算","date":"2019-11-19T10:25:55.000Z","updated":"2020-09-07T11:38:44.833Z","comments":true,"path":"Java基础/Java位运算/","link":"","permalink":"http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"Java位运算符 &amp; ：按位与。同时为1才为1，否则为0。 | ：按位或。有一个为1则为1。 ~ ：按位取反。例如3：补码：0b00000000000000000000000000000011。~3—&gt;得:0b11111111111111111111111111111100。(依旧为补码)。减一后取反得原码(原码-&gt;补码的逆运算)：0b1000000000000000000000000000100。故3取反后为-4。 ^ ：按位异或。不同为1，相同为0。 0与任何数字异或都等于它本身 一个数据对相同的数据异或两次，值不变,常应用于加密。即a^b^b == a。 使用异或实现两个变量值交换。a = a^b; b = a^b; a = a^b。 &lt;&lt; ：左移。左操作数乘以2的n次幂。n是右操作数，即左移的位数。右边空出两位补0，左边两位被挤掉。 &gt;&gt; ：右移。左操作数除以2的n次幂。n是右操作数，即右移的位数。左边空出两位用符号位填充，右边两位被挤掉。 例如：-32 &gt;&gt; 2 ：原码：10000000000000000000000000100000，反码：11111111111111111111111111011111，补码：11111111111111111111111111100000。右移后为：11111111111111111111111111111000。求得原码为：10000000000000000000000000001000。得-8。 &gt;&gt;&gt; ：无符号右移。左边空出的位置用0补全。例如-32 &gt;&gt;&gt; 2变成一个很大的正数。 位运算均针对补码进行。正数的符号位为0，原、反、补码均为其本身；负数的符号位为1，其反码为对原码除符号位其余所有位求反，补码为对反码+1。 对于有符号数，计算机中存储的是补码。","categories":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"}],"tags":[{"name":"Java基础","slug":"Java基础","permalink":"http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"}]},{"title":"网络安全总结","slug":"网络安全总结","date":"2019-11-19T10:21:36.000Z","updated":"2020-09-07T11:34:47.674Z","comments":true,"path":"Others/网络安全总结/","link":"","permalink":"http://thmasterplan.cn/Others/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"Security一、 介绍 网络安全五个特征： 保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。 完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。 可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需网络安全解决措施的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击； 可控性：对信息的传播及内容具有控制能力。 不可否认性：出现的安全问题时提供依据与手段。 安全机制: 加密机制 数字签名机制 访问控制机制 数据完整性机制 认证交换机制 通信业务流填充 路由控制 公证机制 普遍性安全机制 网络攻击方法: 被动攻击 主动攻击 物理临近攻击 内部人员攻击 软硬件装配攻击 二、 古典加密技术 代替密码：明文中的每个字符被替换成密文中的另一个字符 凯撒码 将明文转换为数字，使用加密函数E（m）=m+k(mod 26)得密文。解密函数D（c）=c-k(mod 26)。（只是字母简单的偏移） 维吉尼亚密码 密钥：一个字符串，对应一个数表 暴力破解需要26的k次方 代替密码特点： 单字母代换密码 ：明文中字母的出现频度、重复字母的模式和字母相互之间的结合模式等统计特性不变，安全性差。 多字母代替密码 ：字符块被成组加密 ，有利于抗击统计分析。 置换密码：又称换位密码（transposition cipher） ，并没有改变明文字母，只改变了这些字母的出现顺序。在对密文进行统计之后，易于判断该密文是否使用了置换密码加密方案。 Kerckhoffs假设：假定密码分析者知道对方所使用的密码系统，包括明文的统计特性，加密体制（操作方式、处理方法和加/解密算法）、密钥空间及其统计特性。但是，不知道密钥。在设计一个密码系统时，目标是在Kerckhoffs假设的前提下实现安全。 密码分析方法：尝试发现明文或密钥的过程 唯密文攻击：知道部分密文试图恢复明文，并试图推算密钥 已知明文攻击：知道部分消息密文及对应明文，试图推导密钥或算法 选择明文攻击：事先选择部分明文让被攻击者加密，并得到相应密文，试图推导出密钥或算法。 选择密文攻击：密码分析者需要掌握的内容包括：加密算法、截获的部分密文、自己选择的密文消息以及相应的被解密的明文。密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。由此能够计算出加密者的私钥或者分解模数，运用这些信息，攻击者可以恢复所有的明文。 维吉尼亚密码的密码分析 字母频率统计用于猜测 Kasiski测试法确定密钥长度 重合指数法破译密文 三、 对称加密 分组密码的设计原则 混乱原则：密码设计应保证明文与密文之间的依赖关系足够复杂。 扩散原则：密码设计应保证密钥的每位数字能够影响密文中的多位数字（避免对密钥逐段破译），同时应保证明文的每位数字能够影响密文中的多位数字（隐藏明文的统计特性）。 分组密码特点 优点：易于标准化，易于实现同步 缺点：不善于隐藏明文的数据模式，对于重放、插入、删除等攻击方式的抵御能力不强。 对称加密算法：DES/AES 分组密码工作模式 ECB（Electronic Codebook）: 电码本 用相同的密钥分别对明文分组独立加密 对长明文不安全，因为重复的明文块在密文中也是重复的 CBC（Cipher Block Chaining）：密文分组链接 加密算法的输入是上一个密文组和下一个明文组的异或 优点：能够隐蔽明文的数据模式；能够一定程度上防止分组的重放、插入和删除攻击。 缺点：易导致错误传播。任意一个明文或密文组出错会导致其后的密文分组出错。 CFB（Cipher Feedback）:密文反馈 一次处理s位（明文和密文均是），加密算法的输入是上一块密文，加密后产生的伪随机数输出与明文异或作为下一单元的密文。 实质是一种自同步流密码 适用于必须按比特或字符对明文进行加密的情况 OFB（Output Feedback）：输出反馈 与CFB类似，只是加密算法的输入是上一次加密算法的输出，且使用整个分组 优点：能够克服错误传播 缺点：很难发现密文被篡改；不具备自同步能力 CTR计数器 每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增 并行加密效率高 分组密码典型攻击方法 依据攻击者所掌握的信息：唯密文攻击、已知明文攻击、选择明文攻击 根据采用的技术方法 强力攻击（适用于任何分组密码算法）：穷尽密钥搜索、字典、查表、时间-存储权衡 差分密码分析 线性密码分析 差分-线性密码分析 攻击复杂度：数据复杂度（实施攻击所需输入的数据量）和处理复杂度（处理数据所需的计算量）。 对称密钥编码问题：通信密钥太多，管理与分发困难 四、 公钥加密 RSA原理 计算：(a x b) mod n = [(a mod n) x (b mod n)] mod n. RSA实现上的问题在构造n时应选择p和q的长度相差不大 RSA适合低频少量数据交换，如密钥分发；不适合数据量大，实时性强的场合（因为运算量大，慢） 五、 消息鉴别 概念：消息接收者对消息进行验证（真实性：确认并非假冒）（完整性：内容未被篡改）。 网络通信安全威胁：泄露、伪造、篡改、行为抵赖 鉴别与保密：鉴别不能自动提供保密性，保密性不能自动提供鉴别功能。 报文鉴别系统功能：鉴别算法（鉴别函数f产生鉴别码），鉴别协议，鉴别函数f是决定鉴别系统特性的主要因素。 鉴别函数分类： 以整个报文的密文作为鉴别符； 对称密钥加密：加密的同时提供保密和鉴别（强制明文具有某种结构） 附加报文鉴别结构：发送端：校验码C = f（M），密文X = Ek[M || C]; 接收端：Y = Dk(X) = [M’ || C’], 若f(M’) = C’,则报文可信。 公钥加密：提供报文鉴别和签名，不提供加密功能。 报文鉴别码(MAC)：核心是一个类似于加密的算法Ck()（k为密钥）, Ck(M)输出一个较短的定长数据分组也即MAC。发送[MAC || M]。接收端同样计算MAC，比较两个MAC是否相同。PS：MAC与加密函数比较：MAC可以是单向的，而加密函数必须可逆；MAC算法不能提供保密性。 散列函数方式（采用一个公共散列函数，将任意长度的报文映射为一个定长的散列值，并以散列值作为鉴别符）。（常用SHA-3，MD5）散列函数特性： 输入任意大小数据块，输出定长 容易计算 单向性：对任意散列值h要找到一个M使得H(M) = h不可行。 弱抗冲突性：对任意给定M，要找到M’ != M,使得H(M)=H(M’)计算上不可行。该性质可防止伪造。 强抗冲突性：要找到两报文M和N使他们散列值相同不可行。该性质指出散列函数对“生日攻击”的抵抗能力。 生日悖论攻击：伪造消息报文使hash值不变 中间符合攻击概念 六、 密钥建立和管理 密钥建立的模式：点到点（通信双方直接通信，分布式）；密钥分配中心KDC（用户与KDC有共享主密钥，KDC生成并分配会话密钥，集中式）；密钥转换中心KTC（只负责转发，集中式） Diff-Hellman密钥交换 如图，双方都计算出密钥为2 公钥加密体制的密钥分配：公钥的分配；使用公钥体制来分配对称密钥密码体制的密钥。 伪随机数生成器:线性同余算法；基于密码算法的随机数生成器（循环加密方式，DES的OFB模式）；BBS生成器； 密钥控制技术：密钥标签（DES的64位密钥中的8个校验位作为控制使用这一密钥的标签）；控制矢量 七、 用户认证 身份认证：密码，令牌（磁条卡，存储卡，智能卡），生物识别（虹膜，视网膜，指纹，签名，声音，脸） 口令破解：字典攻击，密码猜测，彩虹表攻击（可见密码不能明文存储，要求哈希后加salt，盐：随机字符） 口令的脆弱性：离线字典攻击；特定账户攻击；流行密码的攻击；单个用户的密码猜测；工作站劫持；电子监控；利用用户失误 Bad Passwords:过短的密码；易猜测的密码 Countermeasures：阻止未经授权访问密码文件；入侵检测措施；帐户锁定机制；自动工作站注销；加密的网络链接 八、 身份认证协议 Kerberos身份认证协议：集中式的认证服务器结构，认证服务器的功能是实现用户与其访问的服务器间的相互鉴别；采用对称加密技术 数字签名：直接数字签名仅涉及通信双方 使用公钥算法进行数字签名 假定接收方知道发送方的公钥 发送方用私钥加密整个消息或者消息的散列码 接收方用公钥解密即可确认发送方的身份 公钥基础设施(PKI) 提供三种安全服务： 认证：身份认证，采用数字签名实现 完整性：数据完整性，采用数字签名或消息认证码 机密性：采用对称加密 包括：认证机构CA，证书库，证书撤销，密钥备份和恢复，自动密钥更新，密钥历史档案，交叉认证，时间戳… X.509认证服务： X.509协议实现基于公钥加密算法和数字签名技术 证书由CA创建，CA用其私钥对证书签名，用户可用CA的公钥验证证书有效性并提取被认证的用户的公钥 九、 互联网安全协议和标准 IPSec:提供认证、保密性、密钥管理。优点：在传输层下，因而对应用程序、用户透明；抵抗旁路攻击；保护路由架构… IPSec架构： IPv6强制，IPv4可选 安全关联SA： 发送方和接收方之间的单向的关系，为数据流提供安全保障 由三个参数定义：Security Parameters Index (SPI)；IP Destination Address；Security Protocol Identifier 有一个安全关联数据库（） SA管理： 创建：先协商SA参数，再更新SAD；可人工创建，也可动态创建 删除：有效期过期；密钥遭破坏；另一端要求删除该SA 认证头(AH)： 提供数据整合和IP包认证 有限地抗重播攻击 基于消息认证码（MAC） 重放攻击：攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。 抗重播服务： 序列号字段：创建一个新的SA时，发送者会将序列号计数器初始化为0； 每当在这一SA上发送一个数据包，序列号计数器的值就加1并将序列号字段设置成计数器的值； 当达到其最大值2³²-1时，就应建立一个新的SA。 一种滑动窗口机制：IP是无连接的、不可靠的 ，需设立窗口；窗口的最左端对应于窗口起始位置的数据包序列号N，则最右端对应于可以接收的合法分组的最高序号N+WindowSize-1 ESP:提供保密性和抗重播服务 密钥管理:密钥生成和分发；AH和ESP各一对密钥； 安全套接层SSL： SSL的两个重要概念： SSL连接： 一个连接是一个提供一种合适类型服务的传输 SSL连接是端对端的 连接是暂时的 SSL会话： 一个SSL会话是在客户端和服务器之间的一个关联 会话由Handshake Protocal创建。会话定义了一组可供多个连接共享的加密安全参数 会话用以：避免为每一个连接提供新的安全参数所需的昂贵的谈判代价 十、 Hacking 攻击思路：信息收集，获取权限，安装后门（木马），扩大影响（攻击该网络其他主机），清除痕迹 安全评估 TCSEC，CC 十一、 信息收集（选择题） Web与搜索引擎服务 目标：获取目标网络或公司的URL，获取目标网络的拓扑结构 扫描目的：查看目标网络中哪些主机是存活的，查看存活的主机运行了哪些服务，查看主机提供的服务有无漏洞 IP扫描：判断目标网络有多少台主机存活（ping）（ping使用ICMP协议） 端口扫描：判断目标主机有哪些端口是打开的(TCP端口和UDP端口)（端口是入侵的通道） TCP扫描：TCP Connect，SYN，FIN UDP扫描 漏洞扫描 操作系统类型探测 十二、 缓冲区溢出 缓冲区：应用程序保存用户输入数据，程序临时数据的内存空间。缓冲区本质：数组。位置：堆、栈、数据段 溢出：用户输入数据长度超出了程序为其分配的内存空间，这些数据会覆盖其他程序数据的内存空间。 危害：程序异常，系统崩溃，程序跳到恶意代码，控制权被窃 溢出种类：堆溢出、栈溢出、整型溢出、格式化字符串溢出、其他溢出 溢出的共性：大对象向小对象复制数据，容纳不下造成溢出 避免缓冲区溢出漏洞： 人编写正确的代码 编译器进行数组边界检查 使用类型安全语言 RunTime保护 操作系统 硬件 十三、 Web脚本攻击 SQL注入攻击 ：把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令。步骤 绕过认证：conditions：账号密码的查询是同一条查询语句；密码没有加密保护 判断能否进行SQL注入 判断数据库类型及注入方法 猜测表名和字段名 猜测用户名和密码 预防 过滤关键字 限制输入长度 秘密字段使用散列函数保护 XSS跨站脚本攻击：通过在链接中插入恶意代码就能盗取用户信息。 预防 对动态生成页面的字符进行编码 对输入进行过滤限制 对动态内容使用HTML和URL编码 设置浏览器不执行任何脚本下载 十四、 DOS攻击 概念：利用网络协议漏洞或其他系统以及应用软件的漏洞耗尽被攻击目标资源，使得被攻击目标无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式。 原理：攻击者向服务器发送众多的带有虚假地址的请求，服务器发送回复信息后无限等待进而无法释放资源，连接超时后攻击者再度发送虚假请求。 DOS分类：SYN Flood（请求方不发送ACK），ping of death（ping请求数据包声称超过64K，接收方TCP/IP堆栈崩溃），teardrop… 发现僵尸网络：IDS（提取僵尸程序指纹信息），行为监测（僵尸程序行为模式），蜜獾捕获（捕获僵尸程序样本） 十五、 恶意代码、病毒、蠕虫 计算机病毒：是一个指令序列，能够把自身拷贝插入到其他主程序中 病毒模块：引导、传染、表现 病毒按链接方式分类： 操作系统病毒：用自己的运行逻辑取代系统的正常逻辑模块 外壳型：将病毒本身包围在宿主程序周围，对原来程序不作修改 入侵型：将病毒插入攻击目标之中，一旦感染难以发现清除 源码病毒：利用java, VBS等网络语言编写放在e-mail附件或HTML主页中。 按传染对象分类：磁盘引导型（磁盘引导区），文件型（可执行文件），宏病毒（office系列） 检测病毒方法： 特征代码法：采样，提取特征代码，特征代码纳入病毒特征数据库，打开被检测文件检索，若出现新病毒重复1-3步 校验和法：在文件被感染前根据文件内容计算校验和保存在其他文件中。优点：既可发现已知病毒又可发现未知病毒；缺点：只能判断文件是否被修改，而不能识别病毒种类和名称，且对隐蔽性病毒无效。 行为监测法：利用病毒的特有行为来监测病毒的方法。 蠕虫：一种可以通过网络连接进行自身复制的程序，与以往病毒方式不同，文件型病毒、宏病毒需要在计算机的硬盘、软盘或文件系统中繁殖，而典型的蠕虫只会在内存中维持一个活动副本，甚至根本不向硬盘写入任何信息。 十六、 防火墙 概念：防火墙指应用于内部网络和外部网络之间的，用来保护内部网络免受非法访问和破坏的网络安全系统。 主要功能： 过滤进出网络的数据 防止不安全的协议和服务 管理进出网络的访问行为 记录通过防火墙的信息内容与活动 对网络攻击进行检测与告警 防止外部对内部网络信息的获取 提供与外部连接的集中管理 不能防范的攻击：内部威胁、病毒、应用程序漏洞、木马、社会工程、不当配置 防火墙分类：按实现技术（包过滤型（静态，动态），代理型（应用代理，电路代理，NAT））；按体系结构（双宿/多宿主机，屏蔽主机（双重保护安全性更高），屏蔽子网，混合结构）。 静态包过滤（传输层和网络层）：对包头内容进行简单过滤（源和目的IP，IP选项，IP上层协议，TCP和UDP源及目的端口，ICMP报文类型和代码）。 防火墙规则制定策略：a.拒绝任何访问，除非被规则特别允许。b.允许任何访问，除非规则特别禁止 过滤的两种基本方式：按服务过滤（如Telnet，SMTP，FTP等等）；按规则过滤。 静态包过滤的优缺点：速度快，价格低，对用户透明；配置难把握，防范能力低，没有用户身份验证机制。 动态包过滤（网络层）（状态检测防火墙）：不仅以一个数据包的内容作为过滤依据，还根据这个数据包在信息流位置加以判断 动态包过滤优缺点：基于应用程序信息验证一个包状态的能力，记录通过的每个包的详细信息；造成网络连接的迟滞，系统资源要求较高。 应用代理防火墙（应用层）：对所有规则内允许的应用程序作中转转发；牺牲了对应用程序的透明性。 应用代理优缺点：可以隐藏内部网络信息，具有强大的日志审核，实现内容过滤；价格高，速度慢，失效时造成网络瘫痪。 电路级代理（传输层）优缺点：隐藏内部网络信息，配置简单（无需为每个应用程序配置一个代理）；多数电路级网关都是基于TCP端口配置，不对数据包检测可能会有漏洞。 NAT优缺点：管理方便并且节约IP地址资源，隐藏内部IP地址信息；外部应用程序不能方便地与NAT网关后的应用程序联系。- 理解防火墙的四种体系结构 十七、 入侵检测IDS 由于防火墙无法发现和阻止:a.对合法服务的攻击。b.源自其他入口的攻击。c.来自内部网络的攻击。d.来自木马的威胁。入侵检测技术通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现网络或系统中是否有违反安全策略行为和被攻击迹象的一种安全技术。 IDS任务：从系统正常运行产生的和攻击者进行攻击时产生的混合数据中找出入侵痕迹。 通用入侵检测框架CIDF：体系结构；组件通信（事件产生器（数据获取）；事件分析器（数据分析）；事件数据库（数据管理）；响应单元（行为响应））；语言规范；编程接口。 小结：入侵检测技术收集主机日志及网络流量等信息，通过模式匹配、统计分析或完整性分析，能够有效发现入侵行为。入侵检测形成了网络的纵深防御，成为防火墙技术的有益补充。网络技术的发展给入侵检测带来各种新的困难，同时也带来机遇。","categories":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/categories/Others/"}],"tags":[{"name":"Others","slug":"Others","permalink":"http://thmasterplan.cn/tags/Others/"}]},{"title":"文件权限与用户组管理","slug":"文件权限与用户组管理","date":"2019-11-17T16:16:20.000Z","updated":"2020-09-07T11:34:14.104Z","comments":true,"path":"Linux/文件权限与用户组管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"Linux的文件权限与用户组管理 文件权限：-rw-r--r-- 1 root root 4.0K 07-19 01:02 abc.log: 第1位： -：表示普通文件； d：目录 b：设备文件（块文件，即可以用来存储的设备文件） c：设备文件（字符文件，不能用来存储的设备文件） l：软链接（快捷方式） p：管道文件pipe s：套接字文件socket 后9位：r可读，w可写，x可执行。 2-4位：用户的权限范围 5-7位：组的权限范围 8-10位：其余人的权限范围 1表示该文件的硬链接数 第一个root表示该文件的所有者 第二个root表示该文件所属的组 4.0K表示该文件的大小 后面为最后一次修改的时间戳和文件名 r/w/x权限对于目录的意义： r权限：可读取目录结构列表，即可查看目录下的文件名和子目录名。[注：不能查看文件内容] w权限：可创建文件和目录，可删除，可重命名，可转移 x权限：可进入该目录。 更改权限：chmod chmod u+x,g+w,o-r abc.log：abc.log权限由-rw-r--r--变为：-rwxrw---- chmod a=r file或者chmod +r file:表示对file的u,g,o同时都赋予可读权限 另一种更简单的权限赋予方式，令r = 4, w = 2, x = 1,则u,g,o的权限分别可用一个整数表示，例如chmod 741 file表示file的u,g,o权限为-rwxr----x 参数-R：R及recursive（递归）；chmod -R 741 directory，表示改变目录及目录下所有文件的权限为741。 更改文件的所有者：chown chown user file:将file的所有者改为user chown user.group file:将file的所有者改为user,同时更改其组为group chown -R user directory：若要更改目录的权限，则需要加-R才能将其里面所有内容的权限更改 更改文件的所有组：chgrp chgrp root file: 将file的所有组改为root Linux组的类别： 用户的主要组：用户必须属于一个且只有一个主组，组名同用户名，且仅包含用户自己。 用户的附加组：一个用户可属于0或多个附加组。 id 用户名：查看用户的uid、gid（主组）、groups的id。管理员root的uid和gid为0。 用户和组的配置文件： /etc/passwd：用户及其属性信息(名称、UID、主组ID)。 /etc/group：组及其属性信息。 /etc/shadow：用户密码及其相关属性。 /etc/gshadow：组密码及其相关信息。 用户、组的增删改： useradd，userdel，usermod groupadd，groupdel，groupmod /etc/default/useradd：创建用户时的默认设置 文件与目录的默认权限与隐藏权限 文件预设权限:在没有umask的情况下，目录默认权限为777，文件默认权限为666；umask 022，表示创建文件和目录，g和o都过滤掉写(2)权限。 lsattr -a:显示所有隐藏属性 chattr [-RV][-v][+/-/=&lt;属性&gt;] [文件或目录]: -R：递归处理，将指定目录下的所有文件及子目录一并处理 -v：&lt;版本编号&gt; 设置文件或目录版本 -V： 显示指令执行过程 +&lt;属性&gt;： 开启文件或目录的该项属性 -&lt;属性&gt; ：关闭文件或目录的该项属 =&lt;属性&gt;： 指定文件或目录的该项属性 属性： a：让文件或目录只能加数据。 i：不得任意更动文件或目录。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 例如chattr +a /var/log/messages:让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件 文件特殊权限 SUID（最常用）：chmod u+s file：使file文件x权限上显示为s，非用户(u)执行者可以获得u的所有权限 SUID权限仅对二进制程序有效，不能用在脚本和目录上 执行者对于该程序有x的可执行权限 SUID权限仅在执行程序的过程中有效 让本没有相应权限的用户运行该程序时，可以获得其原本没有权限访问的资源 SGID：非组(g)成员获得该组的权限 非组成员对于该程序需要具备x的权限 SGID主要用于目录, 在该目录下创建的任何文件及子目录属于该目录所拥有的组 。 SBIT: 目前只针对目录有效，切只能分配给其他人（o）;对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除，例如/tmp。 SUID/SGID/SBIT权限设置 ： 文字法 ：SUID: u+s ，SGID: g+s，SBIT: o+t 数字法：将原来的三位数扩展为四位数即可，SUID为4，SGID为2，SBIT为1，把它们放在权限数字的最开头。例如设置SUID，可以写成4777，设置SGID可以写成，2777* 。 ACL(Access Control List)实现灵活权限控制： setfacl -m u/g:用户名/组名:权限 file。例如setfacl -m u:Tom:rw abc.txt，即Tom对abc.txt具有r和w权限，若不给权限则权限写0。 setfacl -x u/g:用户名/组名 file：删除权限。 setfacl -R -b dir/：删除dir下所有的ACL权限。 getfacl file：显示file的ACL权限。 权限优先级：所有者&gt;ACL权限(用户&gt;组&gt;other) 权限与指令间的关系(在用户模式下) 用户能进入某目录：需要权限x 进入目录后能利用ls查阅:需要权限r 进入目录后能够创建文件和目录:需要权限w 用户在目录内打开读取文件： 目录需要权限x 文件需要权限r","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"文件链接","slug":"文件链接","date":"2019-11-17T16:15:31.000Z","updated":"2020-09-07T11:34:21.902Z","comments":true,"path":"Linux/文件链接/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/","excerpt":"","text":"文件链接 硬链接：一个inode号对应多个文件名，硬链接也即同一个文件使用了多个别名，由命令ln oldfile newfile创建。 文件有相同的inode和data block 只能对已存在的文件进行创建，链接计数加1 不能交叉文件系统进行硬链接的创建 不能对目录进行创建，只可对文件创建 删除一个硬链接文件并不影响其他有相同inode号的文件 软链接（符号链接）：软链接的data block中存放的内容是另一文件的路径名的指向。软链接有自己的inode号和data block。由命令ln -s oldfile newfile创建，其中oldfile的相对路径为相对于newfile的，而newfile的相对路径是相对于当前工作目录的。rm -rf a.link/删除的是链接指向的文件，而rm -rf a.link删除的才是链接。 软链接有自己的文件属性及权限 可对不存在的文件或目录创建软链接 软链接可交叉文件系统 软链接可对文件或目录创建 创建软链接时，链接计数不会增加 删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"目录配置与文件目录管理","slug":"目录配置与文件目录管理","date":"2019-11-17T16:14:20.000Z","updated":"2020-09-07T11:35:16.850Z","comments":true,"path":"Linux/目录配置与文件目录管理/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录配置与文件目录管理 目录配置：可参考FHS标准 /bin:存放二进制文件，常用命令 /boot：系统启动项文件,内核 /dev:设备文件，硬盘等 /etc：配置文件 /home:用户家目录，每一个用户在/home下都有一个文件夹 /lib：链接库文件 /media：媒体自动挂载点，比如U盘，光盘等 /mnt：媒体挂载点，手动挂载 /opt：自定义软件安装处，默认安装处为/usr/local /root：超级用户目录 /sbin：存放系统管理员所能执行的命令 /tmp：临时文件 /usr：类似于二层根目录 /var:存放缓存，日志，数据库文件；该文件夹需要分配的空间较大，因此在磁盘分区时挂载在/var的分区要大一些。 /proc：内存中的进程信息 /sys：硬件相关信息 文件与目录管理 常用命令： cd ~:切换到home;cd -:切换到上一次所在目录 pwd：打印当前目录 basename 和 dirname：分别获取当前路径的文件名和目录名 touch xx:若xx不存在，则创建一个新文件xx。若xx存在，把xx的修改时间改为当前。 &gt; xx：若文件不存在，则创建一个空文件xx；若文件存在，则清空现有文件xx(可用于清空大文件)。 mkdir 目录名 目录名 目录名 ... mkdir -p test/{a,b,c}/{d,e}:递归创建目录，分别在a,b,c三个目录下创建d,e两个目录。 rmdir 目录名:只能删除空目录 rm -rf目录:删除目录下所有东西（慎用rm） cp [选项] /PATH1/xx /PATH2/yy:若yy是一个目录，则把文件xx拷贝到yy下；若yy不是一个目录，则把文件xx拷贝到PATH2目录下并重命名为yy。cp不能直接拷贝目录，需要加选项参数，cp -rfp /目录1 /目录2 == cp -a /目录1 /目录2：将目录1及其所有子目录及文件拷贝到目录2。参数：-r即递归，-f即强制,-p同时复制属性信息。 mv [选项] /PATH1/xx /PATH2/yy：若yy是一个目录，则把文件xx剪切到yy下；若yy不是一个目录，则把文件xx剪切到PATH2目录下并重命名为yy。例如mv xx yy:就是把xx重命名为yy。 rename .log .logabc *：重命名，把所有文件名中的.log改为.logabc 关于执行文件路径的变量：执行程序必须在其所在目录下才能执行，亦可使用绝对路径调用，若要直接敲命令就可以执行，则需要设置PATH，把命令所在目录添加在PATH后面。 文件的三个时间属性: atime:access time mtime:modify time ctime:change time 文件名规则： 文件名最长255字节 蓝色—&gt;目录；绿色—&gt;可执行文件；红色—&gt;压缩文件；浅蓝色—&gt;链接文件；黄色—&gt;设备文件；粉色—&gt;套接字文件；棕色—&gt;管道文件；灰色—&gt;其他文件 文件通配符： *：匹配0个或多个字符 ?：匹配任意一个字符 [1-5]：匹配字符1,2,3,4,5 [a-c]：匹配字符a、A、b、B、c(没有C)。 [A-C]：匹配A，b，B，c，C [^abcd]：匹配除abcd外的所有单个字母 文件内容查阅 cat 文件名:显示所有文件内容，适合查看小文件，参数-n显示行数。cat -n 文件名== nl 文件名。 tac：从最后一行显示，倒数显示。 more/less 文件名:按空格一屏一屏地显示，按回车一行一行地显示。同时在文档下方输入/字符串即可查找文档中的字符串。 head -n 21 文件名:查看文件的前21行 tail -n 21 文件名:查看文件的尾21行；参数-f,监测日志，实时监测日志的变化。 od:查看非文本文档，比如二进制文件。 命令与文件的查询： which -a 命令:在PATH路径中搜寻命令位置 whereis 命令:返回命令路径及其帮助文档的路径；参数-b只返回命令路径。 locate 字符串:在/var/lib/mlocate/mlocate.db中查询所有文件名中包含该字符串的文件并返回，该数据库每天定时更新，亦可通过updatedb更新。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"磁盘与文件系统简介","slug":"磁盘与文件系统简介","date":"2019-11-17T16:12:54.000Z","updated":"2020-09-07T11:36:19.405Z","comments":true,"path":"Linux/磁盘与文件系统简介/","link":"","permalink":"http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/","excerpt":"","text":"Linux磁盘与文件系统简介(centOS7之后使用xfs，centOS6使用ext4) 文件系统特性 索引式文件系统：对于linux，文件的权限和属性放置到inode中，文件的实际数据放在data block中。 superblock:记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量,以及文件系统的格式与相关信息等。 inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。 block:实际记录文件的内容，若文件过大一般会占用多个block。 linux的EXT2 ext2文件系统示意图 data clock：ext2文件系统所支持的block大小有1K,2K和4K三种 | Block大小 | 1KB | 2KB | 4KB || :————————: | —— | ——- | —— || 最大单一文件限制 | 16GB | 256GB | 2TB || 最大文件系统总容量 | 2TB | 8TB | 16TB | 除非重新格式化，block的大小与数量在格式化完就不能再改变 每个blcok内最多只能放置一个文件的数据 若文件大于block,则一个文件占用多个block；若文件小于block，则该blcok的剩余容量就不能再被使用。 inode table:记录文件的权限，拥有者与群组，容量，建立、最近一次读取、更改的时间。。。 每个inode大小均为固定128字节（ext4和xfs可设定到256字节） 每个文件仅占用一个inode 系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合。 superblock：一般为1024字节 dumpe2fs：查询EXT系列superblock信息的指令 文件系统与目录树的关系 目录：当在linux下的文件系统建立一个目录时，文件系统会分配一个inode与至少一块block给该目录，其中inode记录该目录的相关权限和属性，并记录分配的那块block号码，而block则记录在这个目录下的文件名与该文件名占用的inode号；ls -i查询当前目录下文件的inode号码。 文件:在ext2建立一个文件时，ext2会分配一个inode和相对于该文件大小的block数量。 目录树:例如读取/etc/passwd过程:/的inode -&gt; /的block -&gt; etc/的inode -&gt; etc/的block -&gt; passwd的inode -&gt; passwd的block。 日志式文件系统 挂载点的意义：挂载点一定是目录，该目录为进入该文件系统的入口。 Linux VFS用于管理所有类型的filesystem","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"常用命令入门","slug":"常用命令入门","date":"2019-11-17T16:11:48.000Z","updated":"2020-09-07T11:36:33.317Z","comments":true,"path":"Linux/常用命令入门/","link":"","permalink":"http://thmasterplan.cn/Linux/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/","excerpt":"","text":"常用命令入门 Xwindow与命令行界面的切换：ctrl + alt + f1...f7，其中只有f7为图形化界面，启动图形化界面也可以用startx命令。 命令帮助： whatis 命令：列出命令的作用以及man帮助的章节。 命令 --help：命令用法 man 章节号 命令：命令更详细的用法 info 命令 man -k 字符串:查找所有包含该字符串的命令 help：列出所有的内部命令 常见命令与快捷键： ls -a/-l:列出当前目录所有文件；ls -l == ll;ls -d .*/：列出所有目录 date:获取当前日期 cal:获取日历 bc:进入计算器,scale = n,n表示计算的精度 [Tab]:命令、文件名、选项、参数补全，连续两次Tab键可列出所有选项 ctrl c:终止目前程序 ctrl d :等同于输入exit shift pageup/pagedown:翻页 nano:一个简单的文本编辑器 reboot/shutdown -r:重启；shutdown/poweroff:关机；shutdown -h 1:定时1分钟关机；shutdown -h 8:20:8:20关机 su -/su root：获取root权限 sync：将内存中的数据写入磁盘，防止丢失 clear:清屏 file 文件名:查看文件类型 tree:查询当前目录的树形结构,需要安装；选项-d只显示目录；选项-L显示指定层级；例如tree -d /boot -L 1。 passwd：更改密码 hostname：查看主机名；hostnamectl set-hostname 名字：更改主机名。 ls -l $(which passwd)：命令的嵌套执行，用$()表示。 修改提示符颜色:修改PS1变量的值，并保存在配置文件/etc/profile.d/env.sh中。 type 命令：查看命令类型，内部命令集成在shell中。 enable：查看所有内部命令；enable -n 命令:禁用内部命令 Hash缓存表:系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将该命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先查看hash表，存在则执行命令，不存在则去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率。 hash：显示hash缓存 将外部命令路径添加到/etc/profile文件的PATH=$PATH:/xxx/yy中，再用source /etc/profile即可在任意路径下使用该外部命令。 alias 别名 = &#39;常用命令&#39;：设立别名；在centos7中，需在/root/.bashrc中保存。 alias可列出所有别名。 命令执行优先级:别名&gt;内部命令&gt;外部命令hash表&gt;$PATH。 若别名与原命令同名，可通过\\命令名执行原命令。 编辑配置文件不会立即生效，可通过. 配置文件名使bash进程重新读取配置文件使编辑生效。 多个命令可以用;分开一起执行，一个长命令可以用\\分成多行。 echo：回显字符串；显示变量 单引号：单引号中的内容就是字符串 反向单引号：其中的内容命令和变量均能识别。例如：touch `date +%F`.log：创建以当前时间命名的文件。反向单引号等价于$()。 双引号：能识别变量不能识别命令 {}：打印重复字符串；例如touch file{1..10}：创建了10个文件分别为file1,file2,,,file10。 Alt 数字n:重复显示字符n次","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"标准IO和重定向","slug":"标准IO和重定向","date":"2019-11-17T16:09:31.000Z","updated":"2020-09-07T11:36:46.764Z","comments":true,"path":"Linux/标准IO和重定向/","link":"","permalink":"http://thmasterplan.cn/Linux/%E6%A0%87%E5%87%86IO%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/","excerpt":"","text":"标准IO和重定向 三种I/O设备 标准输入(STDIN)：（文件描述符0） 默认接收来自键盘的输入 标准输出（STDOUT）：（文件描述符1） 默认输出到终端窗口 标准错误（STDERR）：（文件描述符2） 默认输出到终端窗口 I/O重定向至文件 标准输出重定向：&gt;；例如hostname &gt; /dev/pts/2将输出重定向至另一设备；若为文件，则清空文件再写入。&gt;&gt;则是追加，而不清空原文件；例如hostname &gt;&gt; /data/abc.log。 标准错误重定向：2&gt;；&gt;&gt;则是追加。 &amp;&gt;：标准输出和标准错误一起重定向。 标准输入重定向：&lt;；例如bc &lt; bc.txt，将bc.txt文件作为输入用bc计算。 tr [选项] set1 set2 ：将输入的文本中所有的s1替换为s2。· -d：删除所有属于set1的字符。 -s：把连续重复的字符以单独一个字符表示。 -t：把set1对应字符转换为set2对应字符。 cat &gt; abc.log：标准输入单行重定向到文件；cat &lt;&lt;EOF &gt;abc.log标准输入多行重定向至文件，输入EOF才写入文件。 使用管道 管道命令1 | 命令2 | 命令3 | ...：将命令1的STDOUT发送给命令2的STDIN，再将命令2的STDOUT发送给命令3的STDIN。。。 STDERR默认不能通过管道转发，可利用|&amp;实现。 管道线后面的命令在一个subbash中执行，执行完就退出该subbash。 例子：echo {1..100} | tr &#39; &#39; + | bc：计算1到100的和。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]},{"title":"VIM的简单使用","slug":"VIM的简单使用","date":"2019-11-17T16:08:02.000Z","updated":"2020-09-07T11:37:08.150Z","comments":true,"path":"Linux/VIM的简单使用/","link":"","permalink":"http://thmasterplan.cn/Linux/VIM%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/","excerpt":"","text":"VIM：一个模式编辑器 三种主要模式： Normal（命令）模式：默认模式，可移动光标，剪切/粘贴文本。 -&gt; Insert模式：输入i,a,o,I,A,O任意一个； -&gt; extended command模式:输入:； h:左; l:右; j:下; k:上； )：下一句；(：上一句 }：下一段；{：上一段 ctrl d：向下翻半屏 ctrl u：向上翻半屏 /字符串：全文查找字符串 Insert(编辑)模式：可修改文本。 -&gt; Normal模式:ESC键； 扩展命令(extended command)模式：保存，退出等。 -&gt; Normal模式：ESC键； wq：存盘退出； q!：不存盘退出； w：临时保存，类似于win下的ctrl+s； r filename：将filename的文件内容读到当前文件中； w filename：将当前文件内容写入filename文件中； !命令：在不退出vim的情况下执行命令； r!命令：在不退出vim的情况下，将执行命令的结果写入当前文件。 set number：显示行号；输入数字再输入+或-则向下或向上跳相应行数。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/tags/Linux/"}]}]}