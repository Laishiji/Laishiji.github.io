{"meta":{"title":"TheMasterplan","subtitle":"TheMasterplan","description":"","author":"LSJ","url":"http://thmasterplan.cn","root":"/"},"pages":[{"title":"分类","date":"2019-11-18T06:42:54.196Z","updated":"2019-11-18T06:42:54.196Z","comments":false,"path":"categories/index.html","permalink":"http://thmasterplan.cn/categories/index.html","excerpt":"","text":""},{"title":"关于","date":"2020-11-23T15:39:01.567Z","updated":"2020-11-23T15:39:01.567Z","comments":false,"path":"about/index.html","permalink":"http://thmasterplan.cn/about/index.html","excerpt":"","text":"常用站点DocJavaEE7 Doc，JavaSE8 Doc，Spring Doc, MyBatis Doc，Spring Boot 2.1.17.RELEASE全局搜索，Spring Boot 2.1.17.RELEASE目录，Srping Data Redis，MySQL Doc BlogJava全栈，JavaGuide，CS-Notes，DreamCats，LeetCode All in One， JULY算法，xieyuooo，兰亭风雨，赵伊凡，五月的仓颉 SiteStack Overflow，React Learning，美团tech 联系方式Mail：laishiji86@gmail.com"},{"title":"友情链接","date":"2020-09-03T15:20:27.746Z","updated":"2020-04-08T10:56:53.574Z","comments":true,"path":"links/index.html","permalink":"http://thmasterplan.cn/links/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2020-09-05T13:38:03.477Z","updated":"2019-11-18T05:58:22.890Z","comments":false,"path":"repository/index.html","permalink":"http://thmasterplan.cn/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2020-09-05T13:38:09.506Z","updated":"2019-11-18T06:43:04.379Z","comments":false,"path":"tags/index.html","permalink":"http://thmasterplan.cn/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"Spring原理","slug":"Spring原理","date":"2021-01-21T06:33:27.000Z","updated":"2021-01-22T13:57:35.012Z","comments":true,"path":"JavaWeb/Spring原理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Spring%E5%8E%9F%E7%90%86/","excerpt":"","text":"Spring重要模块 Spring Test : 提供了对 JUnit 和 TestNG 测试的支持。 Spring Beans：包含访问配置文件，创建和管理Bean（BeanFactory），依赖注入相关的类。 Spring Core： 定义并提供资源定位方式，基本核心工具类，其他组件都会使用该模块。 Spring Context：IoC容器实现，构建于Beans和Core模块之上。 Spring AOP ：提供了面向切面的方法级别的编程实现，最小化的动态代理实现。运行时织入。 Spring Aspects ： 该模块为与AspectJ的集成提供支持。编译期织入。 Inversion of ControlIoC图解 Spring核心类和接口BeanDefinition接口Spring通过定义BeanDefinition接口来管理bean对象以及它们之间的依赖关系。 根据配置，Spring运行时生成用来描述Bean对象的BeanDefinition实现类对象，在BeanDefinition的抽象实现类AbstractBeanDefinition中定义了许多属性，常用属性配置有： 作用范围：XML配置方式scope，注解方式@Scope。 是否懒加载：XML配置方式lazy-init，注解方式@Lazy。 是否优先实现：XML配置方式primary，注解方式@Primary。设置为true的bean会是优先的实现类。 工厂Bean：XML配置方式factory-bean和factory-method，注解方式则需要工厂类实现FactoryBean接口并结合@Bean注解。 Spring2.5后源码中常用的实现类为GenericBeanDefinition，取代之前的RootBeanDefinition和ChildBeanDefinition。 容器Spring的IoC容器接口设计图如下： 由图可知，Spring主要有以下两个容器系列： 实现BeanFactory接口的简单容器系列，它们只实现了容器的最基本功能。如下：BeanFactory =&gt; HierarchicalBeanFactory =&gt; ConfigurableBeanFactory ApplicationContext应用上下文，它作为容器的高级形态而存在，它通过继承以下接口实现了附加功能： MessageSource：信息源。可以支持国际化的实现，为开发多语言版本的应用提供服务。 ResourceLoader（新版本Spring为ResourcePatternResolver）：资源定位加载器，用于加载配置文件。若不继承该接口，用户需要像使用BeanFactory那样手动加载。 ApplicationEventPublisher：应用事件。 BeanFacory与FactoryBeanFactoryBean接口的实现类对象是一个由IoC容器管理的Bean对象，只不过它是一个可以生成对象的工厂Bean。而BeanFactory是Spring中最基本的IoC容器，在该接口中定义了一个静态常量：转义符&amp;，可以使用getBean(“&amp;XXXFactoryBean”)获取XXXFactoryBean本身，而若是调用getBean(“XXXFactoryBean”)其返回的是工厂Bean生产的对象。 DefaultListableBeanFactory该类是一个简单IoC容器实现类，其他的容器都是通过持有一个该容器的实例并在此基础上扩展功能实现，如XmlBeanFactory，以及ApplicationContext的诸多实现类。 DefaultListableBeanFactory扩展了AbstractAutowireCapableBeanFactory，并实现了ConfigurableListableBeanFactory和BeanDefinitionRegistry接口，它维护了一个ConcurrentHashMap实例beanDefinitionMap，这就是容器的存储结构，另外BeanDefinitionRegistry接口的实现就是用于向容器中注册BeanDefinition的。 AbstractApplicationContext这是一个重要的抽象类，它实现了ConfigurableApplicationContext，实现了一些方法，并定义了许多应用上下文的模板方法，如publishEvent、registerListeners和refresh方法等。同时该类继承了DefaultResourceLoader类，实现了资源路径的获取。 Resource/ResourceLoaderResource接口是Spring用来封装I/O操作的类，它是一个资源描述器，在容器创建时给出Bean定义信息的路径，如文件，类路径等。而ResourceLoader实现不同的Resource加载策略，接口中定义了一个getResource方法，按需返回特定类型的Resource。 BeanDefinitionReader该接口中定义了一系列用于读取BeanDefinition的重载方法loadBeanDefinitions，Spring就是在该方法中使用ResourceLoader读取bean的定义信息。该接口还定义了一个重要方法getRegistry，其返回一个BeanDefinitionRegistry，该接口中定义了方法registerBeanDefinition，用于注册BeanDefinition到IoC容器中。由此可总结，BeanDefinition的注册可分为如下三个过程： Resource定位：Bean配置信息的资源定位。 BeanDefinition的载入和解析：把用户定义好的Bean信息抽象为BeanDefinition。 BeanDefinition注册到IoC容器。 PostProcessor后置处理器本身也是一种需要注册到容器里的Bean对象： 其里面的方法会在特定的时机被容器调用； 其作用是在不改变容器或Bean核心逻辑的情况下对Bean进行增强。 Spring中有如下的后置处理器： 容器级别：BeanDefinitionRegistryPostProcessor和BeanFactoryPostProcessor。 普通的Bean后置处理器：BeanPostProcessor。该接口的两个方法分别在每个普通Bean初始化前后被调用。 Aware子接口所有的 Bean 对 Spring 容器的存在是没有感知的，但是在实际项目中，我们不可避免的要用到 Spring 容器本身提供的资源，这时候要让 Bean 主动意识到 Spring 容器的存在，才能调用 Spring 所提供的资源，这就是Aware的作用。不过Aware只在框架内部使用，若在Bean中使用，那么就紧耦合了。常见的Aware如下： Aware子接口 描述 BeanNameAware 获取容器中 Bean 的名称 BeanFactoryAware 获取当前 BeanFactory ，这样可以调用容器的服务 ApplicationContextAware 同上。 MessageSourceAware 获取 Message Source 相关文本信息。 ApplicationEventPublisherAware 使Bean可以发布事件。 ResourceLoaderAware 获取资源加载器，这样获取外部资源文件。 事件监听器监听器将监听感兴趣的事件，一旦事件发生便做出响应。Spring的事件驱动模型三大组成部分如下： 事件：ApplicationEvent抽象类。 事件监听器：ApplicationListener接口。 事件发布器：ApplicationEventPublisher和ApplicationEventMulticaster接口。发布与广播。 容器的初始化refresh方法12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public void refresh() throws BeansException, IllegalStateException &#123; synchronized (this.startupShutdownMonitor) &#123; StartupStep contextRefresh = this.applicationStartup.start(\"spring.context.refresh\"); // 1.准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符 prepareRefresh(); //2.获得ApplicationContext的子类BeanFactory。步骤如下： //2.1.如果已经有了BeanFactory就销毁它里面的单例Bean并关闭这个BeanFactory。 //2.2.创建一个新的BeanFactory。 //2.3.对这个BeanFactory进行定制（customize),如allowBeanDefinitionOverriding等参数 //2.4.转载BeanDefinitions(读取配置文件，将xml转换成对应得BeanDefinition) //2.5.检查是否同时启动了两个BeanFactory。 ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory(); // 3.为容器注册必要的系统级的Bean prepareBeanFactory(beanFactory); try &#123; // 4.允许容器的子类去注册后置处理器 postProcessBeanFactory(beanFactory); StartupStep beanPostProcess = this.applicationStartup.start(\"spring.context.beans.post-process\"); // 5.调用容器级的后置处理器 invokeBeanFactoryPostProcessors(beanFactory); // 6.向容器注册bean级别的后置处理器 registerBeanPostProcessors(beanFactory); beanPostProcess.end(); // 7.初始化国际化配置 initMessageSource(); // 8.初始化事件发布器 initApplicationEventMulticaster(); // 9.单例bean初始化之前预留给子类初始化其他特殊bean的模板方法 onRefresh(); // 10.向事件发布器注册事件监听器 registerListeners(); // 11.设置系统级别的服务，初始化所有非懒加载的单例bean finishBeanFactoryInitialization(beanFactory); // 12.触发初始化完成的回调方法，并发布容器刷新完成的事件给监听器 finishRefresh(); &#125; catch (BeansException ex) &#123; if (logger.isWarnEnabled()) &#123; logger.warn(\"Exception encountered during context initialization - \" + \"cancelling refresh attempt: \" + ex); &#125; // Destroy already created singletons to avoid dangling resources. destroyBeans(); // Reset 'active' flag. cancelRefresh(ex); // Propagate exception to caller. throw ex; &#125; finally &#123; // 重置Spring内核中的共用缓存 resetCommonCaches(); contextRefresh.end(); &#125; &#125; &#125; 容器初始化总结 刷新容器，并注册系统级的Bean，如系统环境Bean。 注册并调用系统级的后置处理器，注册普通Bean的后置处理器。 初始化国际化配置、事件发布器、注册事件监听器。 初始化特殊的bean和所有非懒加载的单例bean。 清除资源缓存，初始化生命周期处理器，发布最终事件。 Bean的创建（生命周期）如图所示： 单例Bean的生命周期如上图所示。而多例Bean是不会由容器管理的，多例Bean只能由GC回收，因此其定义的销毁方法不会被容器调用。 如何解决循环依赖？ 方法调用栈：refresh -&gt; finishBeanFactoryInitialization -&gt; preInstantiateSingletons -&gt; getBean -&gt; doGetBean。 AbstractBeanFactory：doGetBean方法中 a. 第一处getSingleton：尝试从三级缓存中获取Bean对象。-&gt; DefaultSingletonRegistry：getSingleton方法源代码如下： 12345678910111213141516171819202122232425262728293031323334protected Object getSingleton(String beanName, boolean allowEarlyReference) &#123; // 尝试从一级缓存singletonObjects从获取Bean Object singletonObject = this.singletonObjects.get(beanName); // 如果一级缓存中没有并且Bean正在创建中 if (singletonObject == null &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123; //尝试从二级缓存earlySingletonObjects获取还未进行属性赋值的Bean singletonObject = this.earlySingletonObjects.get(beanName); //如果二级缓存中也没有，且Bean允许被循环引用 if (singletonObject == null &amp;&amp; allowEarlyReference) &#123; synchronized (this.singletonObjects) &#123; //加锁同步后再次重新尝试从一级和二级缓存中获取Bean（double-check） singletonObject = this.singletonObjects.get(beanName); if (singletonObject == null) &#123; singletonObject = this.earlySingletonObjects.get(beanName); if (singletonObject == null) &#123; //若依然都没有，则尝试从三级缓存singletonFactories中获取Bean ObjectFactory&lt;?&gt; singletonFactory = this.singletonFactories.get(beanName); if (singletonFactory != null) &#123; singletonObject = singletonFactory.getObject(); //若从三级缓存中获取到Bean，则将Bean放入二级缓存，并从三级缓存中移除 this.earlySingletonObjects.put(beanName, singletonObject); this.singletonFactories.remove(beanName); &#125; &#125; &#125; &#125; &#125; &#125; return singletonObject;&#125; 三级缓存都是HashMap。其中singletonObjects里存放的是实例化并且已完成属性赋值之后的单例对象，earlySingletonObjects中存放的是已完成实例化未属性赋值的早期单例对象，而singletonFactories中存放的是ObjectFactory对象，此对象的getObject方法返回值即是刚完成实例化还未属性赋值的单例对象。因此，单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后属性赋值完成后放入singletonObjects中。 b. createBean：根据不同的作用域创建Bean实例。-&gt; AbstractAutowireCapableBeanFactory： createBean，创建bean实例的准备： 123456789protected Object createBean(String beanName, RootBeanDefinition mbd, @Nullable Object[] args) throws BeanCreationException &#123; // 省略无关代码 try &#123; Object beanInstance = doCreateBean(beanName, mbdToUse, args); return beanInstance; &#125; // 省略无关代码&#125; doCreateBean，创建bean实例： 12345678910111213141516171819202122232425protected Object doCreateBean(final String beanName, final RootBeanDefinition mbd, final @Nullable Object[] args) throws BeanCreationException &#123; BeanWrapper instanceWrapper = null; // 省略代码 if (instanceWrapper == null) &#123; // 重点！实例化bean instanceWrapper = createBeanInstance(beanName, mbd, args); &#125; Object bean = instanceWrapper.getWrappedInstance(); //省略代码 boolean earlySingletonExposure = (mbd.isSingleton() &amp;&amp; this.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName)); if (earlySingletonExposure) &#123; //省略代码 // 重点！将实例化的对象添加到三级缓存singletonFactories中 addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean)); &#125; // 初始化bean Object exposedObject = bean; try &#123; populateBean(beanName, mbd, instanceWrapper);//重点!注入属性值（依赖注入） exposedObject = initializeBean(beanName, exposedObject, mbd); &#125; // 省略无关代码 return exposedObject;&#125; populateBean：给bean实例注入属性值（依赖注入） Java中的循环依赖分两种，一种是构造器的循环依赖，另一种是属性的循环依赖。构造器循环依赖是指：两个类在它们的构造器参数中互相依赖（多个类则是成环）。构造器循环依赖是无法解决的，属于严重的代码设计问题。Spring只能解决属性的循环依赖，假设类A与类B存在属性循环依赖，Spring先创建A的对象。在Bean的创建过程中，当执行到doGetBean方法时： 在第一处getSingleton方法中，一二三级缓存map均为空，获取不到A的实例； 执行到createBean-&gt;doCreatBean方法中，通过createBeanInstance方法创建对象A； addSingletonFactory方法将还未进行属性赋值的对象A放入三级缓存singletonFactories中，完成对象A的早期暴露。 接着执行populateBean方法对A进行属性注入。此时发现需要对A注入B的实例，触发getBean方法对B进行初始化。 B的初始化流程首先重复步骤1、2、3，接着执行populateBean对B进行属性注入，发现它有一个属性A，触发getBean方法对A进行初始化。 再次来到步骤1，此时三级缓存singletonFactories已经存在A的实例了，将A放入二级缓存并从三级缓存中删除，属性注入，完成对B的初始化。 回溯到对A的初始化流程（步骤4结尾），对A中注入B的实例。 参考文章：https://www.cnblogs.com/zzq6032010/p/11406405.html Spring有线程安全问题？多例：每次使用都是新的对象，无线程安全问题。 单例：对象中有实例变量，是线程不安全的，可以使用ThreaLocal解决。 @Autowired原理 @Autowired注解的实现是通过后置处理器AutowiredAnnotationBeanPostProcessor类的postProcessPropertyValues方法实现的。 自动装配时，从容器中如果发现有多个同类型的属性时，@Autowired注解会先根据类型判断，然后根据@Primary、@Priority注解判断，最后根据名称来判断，如果还是不能决定注入哪一个bean时，就会抛出NoUniqueBeanDefinitionException异常。 Aspect Oriented ProgrammingAOP的三种织入方式 编译期织入：需要特殊的Java编译器，如AspectJ。 类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkz。 运行时织入：Spring采用的方式，通过动态代理实现。 Spring AOP原理待补充。 Spring事务默认采用数据库的隔离级别，InnoDB为可重复读。 事务的传播机制所谓事务传播机制，是指若一个方法存在事务，且在该方法内部调用了其他方法，那么其他方法是否存在事务呢？Spring中的事务传播如下表： 事务传播行为类型 说明 PROPAGATION_REQUIRED 如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。（默认） PROPAGATION_SUPPORTS 支持当前事务，如果当前没有事务，就以非事务方式执行。 PROPAGATION_MANDATORY 使用当前的事务，如果当前没有事务，就抛出异常。 PROPAGATION_REQUIRES_NEW 新建事务，如果当前存在事务，把当前事务挂起。 PROPAGATION_NOT_SUPPORTED 以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。 PROPAGATION_NEVER 以非事务方式执行，如果当前存在事务，则抛出异常。 PROPAGATION_NESTED 如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。 @Transactional @Transactional注解只能应用到public修饰符上，其它修饰符不起作用，但不报错。 默认情况下此注解会对unchecked异常进行回滚，对checked异常不回滚。如果是checked异常也想回滚的话，注解上需写明rollbackFor属性，即@Transactional(rollbackFor=Exception.class)。 12[checked异常]：表示无效，不是程序中可以预测的。比如无效的用户输入，文件不存在，网络或者数据库链接错误。这些都是外在的原因，都不是程序内部可以控制的。[unchecked异常]：表示错误，程序的逻辑错误。是RuntimeException的子类，比如IllegalArgumentException, NullPointerException和IllegalStateException。 事务不回滚解决方案 检查方法是不是public。 检查异常是不是unchecked异常。 如果是checked异常，注解@Transactional(rollbackFor=Exception.class)。 Spring MVC执行流程如图所示： SpringMVC执行流程: 用户发送请求至前端控制器DispatcherServlet。 DispatcherServlet收到请求调用处理器映射器HandlerMapping。 HandlerMapping根据请求url找到具体的处理器，生成处理器执行链HandlerExecutionChain(包括处理器对象和处理器拦截器)返回给DispatcherServlet。 DispatcherServlet请求处理器适配器HandlerAdapter进行适配，并执行参数封装，数据格式转换，数据验证等操作。 执行处理器Handler(Controller，也叫页面控制器)。 Handler执行完成返回ModelAndView。 HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet。 DispatcherServlet将ModelAndView传给ViewReslover视图解析器。 ViewReslover解析后返回具体View。 DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）后响应用户。 Spring Boot自动装配注：该部分完全总结自掘金小册”SpringBoot源码解读与原理分析”。 主启动类上的@SpringBootApplication注解的作用如下图： @ComponentScan源代码如下： 12@ComponentScan(excludeFilters = &#123; @Filter(type = FilterType.CUSTOM, classes = TypeExcludeFilter.class), @Filter(type = FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter.class) &#125;) Spring Boot默认扫描主启动类所在包及子包里所有组件，并指定排除逻辑： TypeExcludeFilter：用户可自定义Filter继承该类，包扫描时Spring就会调用match方法执行我们自定义的过滤逻辑。 AutoConfigurationExcludeFilter：排除自动配置类。 @SpringBootConfiguration与@Configuration的作用相同，被其标注的类会被 Spring 的IOC容器认定为配置类。 @EnableAutoConfigurationSpring的手动装配Bean的方式有： 使用模式注解 @Component 等（Spring2.5+） 使用配置类 @Configuration 与 @Bean （Spring3.0+） 使用模块装配 @EnableXXX 与 @Import （Spring3.1+） 模式注解只能在自己编写的代码中标注，无法装配jar包中的组件。为此可以使用 @Configuration 与 @Bean，手动装配组件。但这种方式一旦注册过多，会导致编码成本高，维护不灵活等问题。而模块装配适合批量装配组件。 模块装配的使用方式为：给配置类标注自定义注解@EnableXXX。自定义注解@EnableXXX的代码如下： 12345@Documented@Retention(RetentionPolicy.RUNTIME)@Target(ElementType.TYPE)@Import(普通类/配置类/ImportSelector的实现类/ImportBeanDefinitionRegistrar的实现类)public @interface EnableTest &#123; &#125; @Import注解的使用方式如下：创建几个颜色的实体类，如Red，Yellow，Blue，Green，Black等。 配置类： 12345@Configurationpublic class ColorRegistrarConfiguration &#123; @Bean public Yellow yellow() &#123;return new Yellow();&#125; &#125; ImportSelector的实现类： 1234567//返回要注册的类的全类名数组public class ColorImportSelector implements ImportSelector &#123; @Override public String[] selectImports(AnnotationMetadata importingClassMetadata) &#123; return new String[] &#123;Blue.class.getName(), Green.class.getName()&#125;; &#125; &#125; ImportBeanDefinitionRegistrar的实现类： 1234567public class ColorImportBeanDefinitionRegistrar implements ImportBeanDefinitionRegistrar &#123; //手动注册Bean @Override public void registerBeanDefinitions(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry) &#123; registry.registerBeanDefinition(\"black\", new RootBeanDefinition(Black.class)); &#125; &#125; 自定义装配类： 12@Import(&#123;Red.class, ColorRegistrarConfiguration.class, ColorImportSelector.class, ColorImportBeanDefinitionRegistrar.class&#125;)public @interface EnableColor &#123;&#125; 全局配置类： 123@EnableColor@Configurationpublic class ColorConfiguration &#123; &#125; Spring Boot的自动装配就是模块装配： 12345@AutoConfigurationPackage@Import(AutoConfigurationImportSelector.class)public @interface EnableAutoConfiguration&#123; 省略...&#125; @AutoConfigurationPackage该注解的源码如下： 12@Import(AutoConfigurationPackages.Registrar.class)public @interface AutoConfigurationPackage 而AutoConfigurationPackages.Registrar的源码如下： 12345678910111213static class Registrar implements ImportBeanDefinitionRegistrar, DeterminableImports &#123; @Override public void registerBeanDefinitions(AnnotationMetadata metadata, BeanDefinitionRegistry registry) &#123; register(registry, new PackageImports(metadata).getPackageNames().toArray(new String[0])); &#125; @Override public Set&lt;Object&gt; determineImports(AnnotationMetadata metadata) &#123; return Collections.singleton(new PackageImports(metadata)); &#125;&#125; 由此可知@AutoConfigurationPackage的作用本质上是通过@Import注解注册主启动类所在包下的类。 AutoConfigurationImportSelector12public class AutoConfigurationImportSelector implements DeferredImportSelector, BeanClassLoaderAware, ResourceLoaderAware, BeanFactoryAware, EnvironmentAware, Ordered DeferredImportSelector 处理自动配置，其执行时机是在 @Configuration 注解中的其他逻辑被处理完毕之后（包括对 @ImportResource、@Bean 这些注解的处理）再执行。 现在来看核心方法selectImports： 12345678@Overridepublic String[] selectImports(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return NO_IMPORTS; &#125; AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata); return StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());&#125; 该方法的核心就是getAutoConfigurationEntry，它获取了需要自动装配的所有类的全类名： 123456789101112131415protected AutoConfigurationEntry getAutoConfigurationEntry(AnnotationMetadata annotationMetadata) &#123; if (!isEnabled(annotationMetadata)) &#123; return EMPTY_ENTRY; &#125; AnnotationAttributes attributes = getAttributes(annotationMetadata); // 【核心】加载候选的自动配置类 List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes); configurations = removeDuplicates(configurations); Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes); checkExcludedClasses(configurations, exclusions); configurations.removeAll(exclusions); configurations = getConfigurationClassFilter().filter(configurations); fireAutoConfigurationImportEvents(configurations, exclusions); return new AutoConfigurationEntry(configurations, exclusions);&#125; 该方法的核心则是通过getCandidateConfigurations获取候选的自动配置类的全类名： 12345protected List&lt;String&gt; getCandidateConfigurations(AnnotationMetadata metadata, AnnotationAttributes attributes) &#123; List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader()); Assert.notEmpty(configurations, \"No auto configuration classes found in META-INF/spring.factories. If you \" + \"are using a custom packaging, make sure that file is correct.\"); return configurations;&#125; SpringFactoriesLoader.loadFactoryNames()加载了指定常量路径META-INF/spirng.factories下的资源，该文件在spring-boot-autoconfiguration包中。spring.factories文件内容节选： 1234567891011121314151617181920212223242526# Initializersorg.springframework.context.ApplicationContextInitializer=\\org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\\org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener# Application Listenersorg.springframework.context.ApplicationListener=\\org.springframework.boot.autoconfigure.BackgroundPreinitializer# Auto Configuration Import Listenersorg.springframework.boot.autoconfigure.AutoConfigurationImportListener=\\org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener# Auto Configuration Import Filtersorg.springframework.boot.autoconfigure.AutoConfigurationImportFilter=\\org.springframework.boot.autoconfigure.condition.OnBeanCondition,\\org.springframework.boot.autoconfigure.condition.OnClassCondition,\\org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition# Auto Configureorg.springframework.boot.autoconfigure.EnableAutoConfiguration=\\org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\\org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\\org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\\org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\\org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\\ 到此Spring Boot的自动装配机制已经显而易见了。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"MySQL之锁","slug":"MySQL之锁","date":"2020-11-24T11:05:46.000Z","updated":"2020-11-24T15:48:38.347Z","comments":true,"path":"数据库/MySQL之锁/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E4%B9%8B%E9%94%81/","excerpt":"","text":"锁概述 读写锁 锁粒度 意向锁 悲观锁和乐观锁 悲观锁 乐观锁 查看MySQL中的锁信息 并发一致性问题 丢失修改 脏读 不可重复读 InnoDB存储引擎中的锁 一致性非锁定读 一致性锁定读 加行锁的3种算法 幻读问题在InnoDB中是如何解决的？ 死锁 参考 锁概述读写锁读锁：读锁是共享锁（S Lock）。多个用户在同一时刻可同时读取同一资源，互不干扰。 写锁：写锁是排他锁（X Lock）。一个写锁会阻塞其他的写请求和读请求。写锁的优先级高于读锁，因此一个写请求可能会被插入到读请求队列的前面，反之则不行。 锁粒度应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。 但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。 在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。 MySQL的Server层中实现了表锁，而存储引擎层则部分支持行锁（如InnoDB和XtraDB，行锁又分为S锁和X锁），部分支持表锁。 意向锁InnoDB存储引擎支持多粒度锁定，它允许事务在行级上的锁和在表级上的锁上同时存在，由此引发一个问题：假如现有事务T₁对某表中的一行添加了行级S锁，与此同时事务T₂申请该表的表级X锁，显然T₁持有的S锁与T₂申请的锁冲突，那么T₂如何知道这个冲突呢？如果采用遍历整张表的每一行来查看是否某行有锁存在，显然得不偿失。 因此，为了支持多粒度加锁操作，InnoDB支持表级别的意向锁（Intention Lock）： 意向共享锁（IS Lock）：事务想要获得一张表中某几行的共享锁。 意向排他锁（IX Lock）：事务想要获得一张表中某几行的排他锁。 如果事务需要对行记录X加锁，那么它应先对行所在的表加意向锁IX，如果该表已有锁存在，那么该事务需要等待。 回到开始的问题，事务T₁对表某行添加了行级S锁，那么必须先添加表级IS锁，事务T₂申请表级X锁，由于不兼容，因此需要等待。 InnoDB存储引擎中锁的兼容性如下表所示： T₁/T₂ IS IX S X IS Y Y Y IX Y Y S Y Y X 悲观锁和乐观锁悲观锁悲观锁对数据被外界修改持悲观态度，因此，在整个数据处理过程中，将数据处于锁定状态。读取数据时需要一致性锁定读，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。 乐观锁相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。 而乐观锁机制在一定程度上解决了这个问题，InnoDB中乐观锁通过一致性非锁定读实现。注意，乐观锁机制并不是真的锁。 查看MySQL中的锁信息可通过命令SHOW ENGINE INNODB STATUS;以及information_schema架构下的INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS来观察锁的信息。 并发一致性问题丢失修改事务T₁修改数据后还未提交，事务T₂覆盖数据，两个事务依次提交，则T₁的修改丢失了。只有串行化执行事务才能避免丢失修改（最高的隔离级别或手动加写锁（即for update））。 脏读脏读是指一个事务读取了另一个事务未提交的数据。事务T₁修改一个数据但未提交，事务T₂随后读取这个数据。如果T₁撤销了这次修改，那么T₂读取的数据是脏数据。 不可重复读不可重复读是指在一个事务内多次执行相同的查询得到的结果不一致。事务T₂读取一个数据，事务T₁对该数据做了修改。如果T₂再次读取这个数据，此时读取的结果和第一次读取的数据不一致。 InnoDB存储引擎中的锁一致性非锁定读一致性非锁定读（consistent nonlocking read）（又叫快照读）指InndoDB存储引擎通过多版本并发控制（Multi Version Concurrency Control）的方式来读取行数据。 举例：如果事务T₁正在对某行执行写操作，该行上有X锁，此时事务T₂要读取该行数据，那么T₂并不会等待T₁释放锁，而是读取该行的一个快照数据。如图所示： 快照数据是指该行之前版本的数据，通过undo段（undo segment，位于共享表空间内）实现。undo段用于在事务中回滚数据，因此快照数据本身没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史数据进行修改操作。 InnoDB存储引擎在READ COMMITTED和REPEATABLE READ隔离级别下都是采用一致性非锁定读实现。然而它们读取的快照数据版本是不同的： READ COMMITTED：若T₁被锁定行提交，T₂读取被锁定行的最新一份快照数据。 REPEATABLE READ：若T₁被锁定行提交，T₂读取当前事务开始时的行数据版本。 一致性锁定读在数据逻辑一致性要求较高时，用户需要显式地对数据库读取操作加锁。InnoDB对于SELECT语句支持两种一致性锁定读（locking read）操作： SELECT...FOR UPDATE;：对读取的行记录加一个X锁（悲观锁）。 SELECT...LOCK IN SHARE MODE;：对读取的行记录加一个S锁（悲观锁）。 注意以上两个语句必须要在事务中，因此务必使用BEGIN、START TRANSACTION或SET AUTOCOMMIT=0。 加行锁的3种算法 Record Lock：锁定单个行记录，通过锁定索引（一般为主键）实现。在RC隔离级别下，InnoDB采用Record Lock。 Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。 Next-Key Lock：Record Lock+Gap Lock，锁定一个范围，并且锁定记录本身。当查询的列是唯一索引时，InnoDB不再采用Next-Key Lock而是Record Lock。 创建表： 123456CREATE TABLE z(a INT, b INT, PRIMARY KEY(a), KEY(b)); -- a是唯一索引，b是非唯一索引INSERT INTO z SELECT 1,1;INSERT INTO z SELECT 3,1;INSERT INTO z SELECT 5,3;INSERT INTO z SELECT 7,6;INSERT INTO z SELECT 10,8; 在会话A中进行事务T₁： 12BEGIN;SELECT * FROM z WHERE b=3 FOR UPDATE; -- 对5,3这一行加一个X锁，采用Next-Key Lock算法，锁定a=5,b=[1,6] 在会话B中： 1SELECT * FROM z WHERE a=5 LOCK IN SHARE MODE; --对5,3这一行加一个S锁 结果为阻塞： 1INSERT INTO z SELECT 6,1; 结果为阻塞： 1INSERT INTO z SELECT 6,6; 结果为阻塞： 1INSERT INTO z SELECT 6,7; 可正常插入： 由此实验可见，对于唯一索引，Next-Key Locking降级为Record Lock，本例中只锁定a=5；对于非唯一索引，则锁定一个范围，本例中锁定b的闭区间为[1,6]。 幻读问题在InnoDB中是如何解决的？所谓幻读，指的是当事务A在读取某个范围的记录时，事务B又在该范围内插入或删除了一条记录，事务A再次读取该范围的记录时出现了幻行。幻读问题示例： 对于上述示例而言，在事务T₁中，假如将隔离级别改为RC：SET SESSION tx_isolation=&#39;READ-COMMITTED;&#39;，然后执行： 12BEGIN;SELECT * FROM z WHERE b&gt;3 LOCK IN SHARE MODE;-- RC级别采用Record Lock算法，只锁定5,3一行 在另一会话中执行INSERT INTO z SELECT 11,11;，那么显然可以插入成功，此时再次在事务T₁中执行SELECT * FROM z WHERE b&gt;3 LOCK IN SHARE MODE;，返回的结果比第一次多了一行数据(11,11)，这就是幻读问题（也是不可重复读问题）。而若隔离级别为RR，对于b而言锁定的是[3,+∞]，在另一个事务中根本无法插入数据。 InnoDB的RC和RR隔离级别都通过一致性非锁定读（乐观锁机制）实现，RR是InnoDB的默认隔离级别。 在RC级别下，由于事务读的是最新版本的快照版本，有不可重复读和幻读问题。若改用悲观锁，由于RC级别采用Record Lock算法，因此只能解决读取一行情况下的不可重复读问题，若是读取多行依然会前后不一致，即不可重复读问题。至于幻读问题更是无法解决了。 在RR级别下，事务A读取数据行DATA，其他事务可以修改行DATA，但事务A读的是其自身开始时行DATA的快照版本，不会有不可重复读问题和幻读问题。若改用悲观锁，那么数据的一致性比使用乐观锁时更高，由于采用Next-Key Lock算法锁住了DATA及其周围的数据，其它事务甚至根本不能修改DATA及其范围内的数据而会被阻塞，更不会有不可重复读和幻读问题了。 总结来说，InnoDB默认使用乐观锁机制，通过多版本并发控制（MVCC）解决了幻读问题；而人为使用悲观锁时，通过Next-Key Lock算法解决了幻读问题，并且相对乐观锁机制提高了数据一致性。 死锁当多个事务在同一资源上相互占用，并请求锁定对方占用的资源时，产生死锁。例如如下两个事务同时处理stock_price表并同时执行完第一条更新语句： 1234567891011-- 事务1START TRANSACTION;UPDATE stock_price SET close=45 WHERE stock_id=4;UPDATE stock_price SET close=20 WHERE stock_id=3;COMMIT;-- 事务2START TRANSACTION;UPDATE stock_price SET close=100 WHERE stock_id=3;UPDATE stock_price SET close=10 WHERE stock_id=4;COMMIT; 死锁检测：超时机制，超时则回滚；等待图（wait-for graph）方式，InnoDB就采用这种方式。等待图是指：数据库保存锁的信息链表和事务等待链表，通过上述链表构造一张图，若存在回路就代表存在死锁。 死锁解决：死锁发生以后，只有部分或完全回滚其中一个事务才能打破死锁。InnoDB处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。 参考 http://www.cyc2018.xyz/ MySQL技术内幕:InnoDB存储引擎[M].姜承尧著.北京:机械工业出版社,2013.6","categories":[{"name":"数据库","slug":"数据库","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://thmasterplan.cn/tags/MySQL/"}]},{"title":"MySQL基础","slug":"MySQL基础","date":"2020-11-18T04:30:33.000Z","updated":"2020-11-25T05:49:17.125Z","comments":true,"path":"数据库/MySQL基础/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/","excerpt":"","text":"一.基础 二.增删改 三.查询 DISTINCT LIMIT 四.排序 五.过滤 六.通配符 七.正则表达式 八.计算字段 九.函数 十.分组 十一.子查询 十二.JOIN 内连接 自连接 外部连接 十三.UNION 十四.视图 十五.事务管理 十六.安全管理 十七.范式 参考 一.基础 注释： 1234## 注释-- 注释/* 注释 注释*/ 查看数据库和表信息： 12345678SHOW DATABASES; -- 查询所有数据库SHOW TABLES; -- 查看所有表-- 以下语句效果相同：查看单表的信息SHOW COLUMNS FROM my_table;DESC my_table;EXPLAIN my_table;DESCRIBE my_table; 创建和使用数据库： 12CREATE DATABASE test;USE test; SHOW命令： 12345SHOW STATUS; -- 显示服务器状态信息SHOW GRANTS; -- 显示授权用户的权限SHOW ERRORS;SHOW WARNINGS; -- 显示错误与警告信息HELP SHOW; -- 查看所有SHOW的用法 创建和操纵表： 12345678910111213141516171819202122-- 实际生产中，所有字段最好都设置为NOT NULL,以避免NPECREATE TABLE my_table ( -- int 类型，不为空，自增 id INT NOT NULL AUTO_INCREMENT, -- int 类型，不可为空，默认值为 1，不为空 col1 INT NOT NULL DEFAULT 1, -- 变长字符串类型，最长为 45 个字符，可为空 col2 VARCHAR(45) NULL, -- 日期类型，可为空 col3 DATE NULL, -- 设置主键为 id PRIMARY KEY (id))ENGINE=InnoDB;-- 添加列ALTER TABLE my_table ADD col4 CHAR(45);-- 删除列ALTER TABLE my_table DROP COLUMN col4;-- 删除表DROP TABLE my_table;-- 重命名表RENAME TABLE my_table TO my_table2; 二.增删改 插入 12345678-- 插入完整一行INSERT INTO my_table VALUES(null, 2, 'col2', '2020-11-11');-- 插入行的部分字段数据INSERT INTO my_table(col1,col2) VALUES(2, 'col2');-- 插入多行, 用逗号分割即可INSERT INTO my_table VALUES(null, 2, 'col2', '2020-11-11'),(null, 3, 'col2', '2020-12-12');-- 插入查询结果CREATE TABLE new_table AS my_table SELECT * FROM my_table; 更新 1UPDATE my_table SET col1=10, col2='hhh' WHERE id=1; 删除 12345DELETE FROM my_table WHERE id=1;-- 删除整张表DELETE FROM my_table;TRUNCATE TABLE my_table; 两者的区别：DELETE是删除表的所有行，TRUNCATE是直接删除整张表再新建一张空表，因此后者更快。 三.查询DISTINCT去重。它作用于列出的所有列，只有所有列的值完全相同才会被去重。 1SELECT DISTINCT col1,col2 FROM my_table; LIMIT限制返回结果的函数。 12345-- 只有一个参数SELECT * FROM my_table LIMIT 5; -- 只返回前5行，即1，2，3，4，5行-- 有两个参数SELECT * FROM my_table LIMIT 5,5; -- 返回从第6行开始的5行，即6，7，8，9，10行 四.排序使用ORDER BY子句。ASC，升序（默认）；DESC，降序。 1SELECT * FROM my_table ORDER BY col1 DESC, COL2 ASC; 五.过滤不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。 1SELECT * FROM my_table WHERE col1 BETWEEN 2 AND 10; WHERE子句操作符如下表： 操作符 说明 = 等于 &lt;&gt;或!= 不等于 &lt; 小于 &gt; 大于 &lt;= 小于等于 &gt;= 大于等于 BETWEEN … AND … 在两个值之间 IS NULL 匹配NULL值 AND 和 OR 用于连接多个过滤条件。默认AND的优先级更高，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。 IN 用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。 1SELECT * FROM my_table WHERE col1 IN(1,2,3,4,5); NOT 用于否定一个条件。MySQL支持使用其对 IN、BETWEEN 和 EXISTS子句取反。 六.通配符LIKE 操作符指示MySQL其后跟的搜索模式利用通配符匹配而非直接相等匹配。注意根据MySQL的配置方式，匹配可以是区分大小写的。 % 表示任何字符出现任意次数。注意单个% 无法匹配NULL。 _ 表示匹配任意单个字符。 1SELECT * FROM my_table WHERE col2 LIKE '%abc%'; -- 匹配列col2所有含有abc片段的列值 七.正则表达式MySQL仅支持正则表达式的一个子集，使用 REGEXP 操作符。 MySQL中的正则表达式匹配不区分大小写，若要区分，可在 REGEXP 后使用 BINARY 关键字。 基本字符匹配 1SELECT * FROM my_table WHERE col2 REGEXP BINARY '.abc'; .表示匹配任意单个字符。 OR匹配 1SELECT * FROM my_table WHERE col2 REGEXP BINARY '.abc | ABC'; 使用|表示条件或。 匹配几个字符之一 1SELECT * FROM my_table WHERE col2 REGEXP '[abc]'; 使用[abc]定义一组字符，它的含义是匹配a或匹配b或匹配c。 可在[]开头使用^表示匹配除了[]中指定字符以外的所有字符。例如[^abc]表示匹配除了这三个字符以外的所有字符。 匹配范围 12SELECT * FROM my_table WHERE col2 REGEXP '[1-3]'; -- 匹配1或2或3SELECT * FROM my_table WHERE col2 REGEXP '[a-f]'; -- 匹配a到f 在[]中使用-表示匹配一个范围。 匹配特殊字符 为了匹配特殊字符，需要使用\\\\作为转义字符。例如\\\\-匹配-，\\\\.匹配.。 定位符 使用^锚定文本的开始，使用$锚定文本的结尾。 1SELECT * FROM my_table WHERE col2 REGEXP '^[ab]bug$'; -- 匹配以a或b开头，以g结尾的值 匹配多个实例 元字符 说明 * 匹配前面的子表达式零次或多次。例如，zo 能匹配 “z” 以及 “zoo”。 等价于{0,}。 + 匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。 {n} n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。 {n,m} m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。 八.计算字段在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。 计算字段通常需要使用 AS 来取别名，否则输出的时候字段名为计算表达式。 1SELECT column1 * column2 AS alias FROM my_table; -- MySQL支持+, -, *, / CONCAT() 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 TRIM() 可以去除首尾空格。 1SELECT CONCAT(TRIM(col1), '(', TRIM(col2), ')') AS concat_col FROM mytable; 九.函数MySQL函数可分为文本处理函数，日期和时间处理函数，数值处理函数，聚集函数等。 其中聚集函数是运行在行组上，计算和返回单个值的函数，如下表所示： 函 数 说 明 AVG() 返回某列的平均值，忽略NULL COUNT() 返回某列的行数 MAX() 返回某列的最大值 MIN() 返回某列的最小值 SUM() 返回某列值之和 使用 DISTINCT 可以汇总不同的值。 1SELECT AVG(DISTINCT col1) AS avg_col FROM my_table; 其余函数可参考：MySQL函数|菜鸟教程。 十.分组使用 GROUP BY子句指定某列，该列相同的值则划为一组。 可以对同一分组数据使用聚集函数进行处理，例如求同一分组中某列的平均值等。 1SELECT AVG(col1) AS col1_avg FROM mytable GROUP BY col2; 使用 HAVING 子句指定分组的过滤条件。WHERE 过滤行，优先级高于 HAVING。 分组规定： GROUP BY子句可以包含任意数目的列，这使得能对分组进行嵌套，进行更细致的分组。 如果嵌套了分组，数据将在最后规定的分组上进行汇总。 GROUP BY子句中列出的每个列都必须是检索列或有效的表达式。 除聚集函数计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。 如果分组中有NULL值，则NULL将作为一个分组。 关键字的顺序：WHERE &gt; GROUP BY &gt; HAVING &gt; ORDER BY &gt; LIMIT。 十一.子查询子查询中只能返回一个字段的数据。 可以将子查询的结果作为 WHRER 语句的过滤条件： 12SELECT * FROM my_table1 WHERE col1 IN (SELECT col2 FROM my_table2); 子查询作为计算字段：下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次。 12345SELECT cust_name, (SELECT COUNT(*) FROM Orders WHERE Orders.cust_id = Customers.cust_id) AS orders_numFROM Customers ORDER BY cust_name; 也可以将子查询的结果作为UPDATE语句的插入值。 十二.JOIN使用 JOIN 关键字连接多张表，并且条件语句使用 ON 而不是 WHERE。 连接可以替换子查询，并且比子查询的效率一般会更快。 可以用 AS 给列名、计算字段和表名取别名（AS可省略），给表名取别名是为了简化 SQL 语句以及连接相同表。 内连接内连接又称等值连接，使用 INNER JOIN 关键字。 123SELECT A.value, B.valueFROM tablea AS A INNER JOIN tableb AS BON A.key = B.key; 也可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。 123SELECT A.value, B.valueFROM tablea A, tableb BWHERE A.key = B.key; 自连接自连接可以看成内连接的一种，只是连接的表是自身而已。 一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。 子查询版本 12345SELECT name FROM employeeWHERE department = ( SELECT department FROM employee WHERE name = \"Jim\"); 自连接版本 1234SELECT e1.name FROM employee e1 INNER JOIN employee e2ON e1.department = e2.department AND e2.name = \"Jim\"; 应使用自连接而非子查询。 外部连接外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接。MySQL不支持全外连接，需要左外连接和右外连接结合UNION实现全外连接的效果。 左外连接：LEFT OUTER JOIN 右外连接：RIGHT OUTER JOIN。其中OUTER可省略。 检索所有顾客的订单信息，包括还没有订单信息的顾客。 123SELECT Customers.cust_id, Customer.cust_name, Orders.order_idFROM Customers LEFT OUTER JOIN OrdersON Customers.cust_id = Orders.cust_id; 十三.UNION使用 UNION 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。 每个查询必须包含相同的列、表达式和聚集函数。 默认会去除相同行，如果需要保留相同行，使用 UNION ALL。 只能包含一个 ORDER BY 子句，并且必须位于语句的最后。 实现全外连接： 12345678-- 由于不存在有订单信息却没有没有顾客信息的情况，因此该例没有实际意义，仅作全外连接实现的演示SELECT Customers.cust_id, Customer.cust_name, Orders.order_idFROM Customers LEFT JOIN OrdersON Customers.cust_id = Orders.cust_idUNIONSELECT Customers.cust_id, Customer.cust_name, Orders.order_idFROM Customers RIGHT JOIN OrdersON Customers.cust_id = Orders.cust_id; 十四.视图视图是虚拟的表，它由一个SQL查询来定义，可以当作表使用。与持久表不同的是，视图中的数据没有实际的物理存储，因此不能对其进行索引操作。 1CREATE VIEW myview AS SELECT语句; 视图的作用： 可只使用实际表的一部分数据。 通过只给用户访问视图的权限，保证数据的安全性。 十五.事务管理事务术语： 事务（transaction）：指一组SQL语句。 回退（rollback）：指撤销指定SQL语句的过程。 提交（commit）：指将未存储的SQL语句结果写入数据库表。 保留点（savepoint）：指事务处理中设置的临时占位符，可以对它发布回退。 标识事务的开始： 1START TRANSACTION; 回退： 1ROLLBACK; 事务处理用来管理INSERT, UPDATE和DELETE，你不能回退SELECT语句，CREATE语句和DROP操作。 在事务块中，需要手动提交： 1COMMIT; 为了支持回退部分事务处理，必须在事务处理块中合适的位置放置占位符，这样，如果需要回退，可以回退到某个占位符。创建占位符： 123SAVEPOINT delete1;-- Some SQL statements;ROLLBACK TO delete1; -- 回退到保留点delete1 保留点在事务处理完成后自动释放，也可明确释放保留点： 1RELEASE SAVEPOINT delete1; 十六.安全管理MySQL 的账户信息保存在 mysql 这个数据库中。 查看用户 12USE mysql;SELECT user FROM user; 创建账户 新创建的账户没有任何权限。 1CREATE USER myuser IDENTIFIED BY 'mypassword'; 修改账户名 1RENAME USER myuser TO newuser; 删除账户 1DROP USER myuser; 查看权限 1SHOW GRANTS FOR myuser; 授予权限 账户用 username@host 的形式定义，username@% 使用的是默认主机名。 12-- 授权myuser对数据库mydatabase的所有表有select和insert权限GRANT SELECT, INSERT ON mydatabase.* TO myuser; 删除权限 GRANT 和 REVOKE 可在几个层次上控制访问权限： 整个服务器，使用 GRANT ALL 和 REVOKE ALL； 整个数据库，使用 ON database.*； 特定的表，使用 ON database.table； 特定的列； 特定的存储过程。 1REVOKE SELECT, INSERT ON mydatabase.* FROM myuser; 具体有哪些权限可参照MySQL必知必会表28-1。 更改密码 必须使用 Password() 函数进行加密。 12SET PASSWROD FOR myuser = Password('new_password');SET PASSWROD = Password('new_password'); --不指定用户名则更新当前登录用户的密码 十七.范式作用 减少数据冗余。 消除插入、更新和删除异常。 总结1NF 表的每一个字段都是最小单元，不可再分。 实践：数据库设计画ER图时对实体做好分析可满足1NF。 2NF 满足1NF，且表中的字段必须完全依赖于全部主键而非部分主键。 实践：一张表只设一个主键，若该表满足1NF，则一定满足2NF。 3NF 满足2NF，且非主键外的所有字段必须互不依赖，即消除了依赖传递，例如：主键决定字段A，字段A决定字段B，则主键可决定字段B，这就是依赖传递。 实践：若存在相互依赖的字段，则它们应单独在一张表中，比如前面例子中字段A, B应单独在一张表中。 BCNF 满足3NF，且每张表中只有一个唯一索引（一般为主键）。 实践：MySQL中一般不用。以user表为例，假设该user表有手机号tel字段，每个人的手机号都是唯一的，显然用手机号做主键是不合适的，此时一般还是需要自定义一个自增id。原因如下： 由于InnoDB引擎是基于B+树的索引组织表，若使用自增主键，每次插入新的行记录，记录就会顺序添加到当前主键索引叶节点中页的后续位置，当一页写满，就会自动开辟一个新的页，当一个叶节点中不能再开辟新的页，则自动开辟一个新的叶节点。（一个叶节点是一个区（extent），一个区包含多个页，一个页包含多条行记录）。若使用非自增主键，如手机号、身份证号、学号等，由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，此时MySQL不得不为了将新记录插到合适位置而移动数据，甚至目标页面可能已经被回写到磁盘上而从缓存中清掉，此时又要从磁盘上读回来，这增加了很多开销，同时频繁的移动、分页操作造成了大量的碎片，得到了不够紧凑的索引结构，后续不得不通过OPTIMIZE TABLE来重建表并优化填充页面。 那么为了满足BCNF，我们需要单独建表存储一个id号和手机号tel字段，这样查询性能会降低。 4NF 满足3NF，且消除表中字段的多值依赖。 参考 MySQL 必知必会 / (英) Forta, B 著；刘晓霞，钟铭译. -北京：人民邮电出版社，2009.1 CS-Notes 索引：https://segmentfault.com/q/1010000003856705","categories":[{"name":"数据库","slug":"数据库","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"MySQL","slug":"MySQL","permalink":"http://thmasterplan.cn/tags/MySQL/"}]},{"title":"Redis入门","slug":"Redis入门","date":"2020-11-13T14:04:39.000Z","updated":"2020-11-24T11:30:49.389Z","comments":true,"path":"数据库/Redis入门/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%85%A5%E9%97%A8/","excerpt":"","text":"简介 启动Redis 基础命令 管理 数据类型 字符串(String) 哈希(Hash) 列表(List) 集合(Set) 有序集合(ZSet) Redis进阶 事务 命令 事务中的错误处理 过期时间 命令 实现缓存 排序 管道 持久化 RDB(Redis DataBase)方式 配置文件 SAVE/BGSAVE FLUSHALL 复制 快照原理 AOF(Append Only File)方式 同步硬盘数据 集群 主从复制 主从复制的原理 哨兵机制 简介 使用 原理 部署 集群 Spring Data Redis 常见面试问题 简介Redis(Remote Dictionary Server)即远程字典服务器，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容。Redis与传统数据库不同的是其数据库是存在内存中，所以读写速度非常快，因此Redis被广泛应用于缓存方向。另外，redis也可用来做分布式锁（推荐使用Zookeeper），redis提供了多种数据类型来支持不同的业务场景。除此之外，Redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 附：Redis命令参考及文档。 启动RedisRedis的可执行文件及其含义如下表： 文件名 说明 redis-server 启动Redis服务器 redis-cli Redis命令行客户端 redis-benchmark 性能测试工具 redis-check-aof AOF文件修复工具 redis-check-dump RDB文件检查工具 redis-sentinel Sentinel服务器 直接运行redis-server即可以默认配置文件redis.conf启动服务器，可选参数--port 6380指定端口号，默认端口号为6379。 生产环境中，应以初始化脚本启动Redis。在utils目录下有一个名为redis_init_script的脚本文件，用于配置Redis的运行方式、持久化/日志文件的存储位置等。步骤： 将redis_init_script复制到/etc/init.d目录下，修改文件名为redis_端口号，修改脚本文件中的REDISPORT变量为相同的端口号。 将redis.conf复制到/etc/redis目录下，以端口号.conf命名，按需求修改配置文件参数： 参数 取值 说明 daemonize yes 以守护进程模式运行 pidfile /var/run/redis_端口号.pid 设置PID文件位置 port 端口号 设置监听端口号 dir /var/redis/端口号 设置持久化文件存放位置 基础命令 SELECT [n]：Redis默认有16个数据库，可以通过配置参数databases修改。该命令用于选择数据库，n取0到15。 DBSIZE：查看当前数据库键值对数量。 FLUSHDB：清空当前数据库。 FLUSHALL：清空所有数据库。 TYPE key：查询value的数据类型。 KEYS [pattern]：模糊匹配符合条件的key。 EXISTS key：判断key是否存在。 管理 配置文件中bind参数指定可以访问Redis服务器的IP。 requirepass参数指定密码，客户端每次连接Redis都需要发送密码；发送密码的命令：AUTH 密码。在主从系统中若master设置了密码，slave的配置文件中需要配置参数masterauth指定主服务器的密码。 数据类型Redis一共有字符串，哈希，列表，集合和有序集合五种数据类型。 Redis的数据类型都不支持数据类型嵌套，比如集合类型的每个元素都只能是字符串，不能是另一个集合或哈希表。 字符串字符串类型能存储任何形式的字符串，包括二进制数据，一个字符串的最大容量为512MB。常用命令如下： 123456SETGET&#x2F;DEL&#x2F;APPEND&#x2F;STRLENINCR&#x2F;DECR&#x2F;INCRBY&#x2F;DECRBY：整数的加减。GETRANGE&#x2F;SETRANGE key 0 5：获取&#x2F;设置字符串下标0到5的片段。SETEX&#x2F;SETNX：赋值的同时设置过期时间。MSET&#x2F;MGET&#x2F;MSETNX：同时获取&#x2F;设置多个键值对。GETSET：先GET再SET。 哈希散列类型是字段和字段值的映射，字段值只能是字符串，一个散列类型最多支持2³²-1个字段。 散列类型适合存储对象。常用命令如下： 123456HSET&#x2F;HGET&#x2F;HMSET&#x2F;HMGET&#x2F;HGETALL&#x2F;HDELHLEN：获取哈希表键值对个数。HEXISTSHKEYS&#x2F;HVALSHINCRBY&#x2F;HINCYBYFLOATHSETNX 列表列表类型内部实现为一个双向链表，常用操作是向两端添加元素或列表的一个片段，也可以把列表当作队列使用，一个列表类型最多支持2³²-1个元素。 使用列表的代价是通过索引访问元素比较慢。 另外可以通过LRANGE命令，就是从某个元素开始读取多少个元素，可以基于List实现分页查询，这个很棒的一个功能，基于Redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。常用命令如下： 123456LPUSH&#x2F;RPUSH&#x2F;LRANGE&#x2F;LPOP&#x2F;RPOPLINDEX&#x2F;LLEN&#x2F;LREMLTRIM key startindex endindexRPOPLPUSH 源列表 目的列表LSET key index valueLINSERT key before&#x2F;after value 集合集合对外提供的功能与列表类似，特殊之处在于集合是可以自动排重的。当你需要存储一个列表数据，又不希望出现重复数据时，集合是一个很好的选择。多个集合之间可以进行并集、交集和差集运算。 集合在Redis内部是使用值为空的哈希表实现的。 比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。常用命令如下： 1234567SADD&#x2F;SMEMBERS&#x2F;SISMEMBERSCARDSREMSRANDMEMBERSPOPSMOVESDIFF&#x2F;SINTER&#x2F;SUNION：差集&#x2F;交集&#x2F;并集。 有序集合和集合相比，有序集合增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。 举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用有序集合存储。常用命令如下： 12345678ZADD&#x2F;ZRANGEZRANGEBYSCOREZREM key e [e...]：删除一个或多个元素。ZCARD：获得集合中元素的数量ZCOUNT key min max：获得指定分数范围的元素个数。ZREVRANKZREVRANGEZREVRANGEBYSCORE Redis进阶事务命令如下表所示： 命令 作用 MULTI 标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个队列当中，最后由 EXEC命令原子性地执行。 EXEC 执行所有事务块内的命令。 WATCH 监视一个(或多个) key ，如果在事务执行(EXEC)之前这个(或这些) key 被其他命令所改动，那么事务将被打断。 DISCARD 取消事务，放弃执行事务块内的所有命令。如果正在使用 WATCH命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 UNWATCH。 UNWATCH 取消 WATCH命令对所有 key 的监视。 事务中的错误处理如果事务中的命令有语法错误，那么Redis执行EXEC命令后会直接返回错误，所有命令都不会执行； 如果事务中的命令语法没有错误，在执行EXEC命令后运行中出错（比如使用使用散列类型的命令操作集合类型的数据），那么其他正确的命令依旧会被执行。 注意，Redis中的事务不支持回滚，因此如果发生运行时错误，那么程序员就需要手动操作了，因此一定要注意命名规范避免运行时错误。 过期时间命令如下表所示： 命令 作用 EXPIRE/EXPIREAT 为给定key设置过期时间，单位：秒；后者为接受的时间参数为Unix时间戳 PEXPIRE/PEXPIREAT 为给定key设置过期时间，单位：毫秒；后者为接受的时间参数为Unix时间戳 TTL 返回给定key的剩余生存时间，单位：秒。当 key 不存在时，返回 -2 ；当 key 存在但没有设置剩余生存时间时，返回 -1 。 PTTL 除了返回值单位为毫秒以外，其余同TTL。 PERSIST 取消key的过期时间设置。 实现缓存为了提高网站的负载能力，常常需要将一些访问频率较高并且对CPU/IO资源消耗较大的操作结果缓存起来，并希望让这些缓存过一段时间自动过期。 实际开发中会发现很难为缓存键设置合理的过期时间，为此可以通过限制Redis能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在只将Redis用作缓存数据库时非常实用。 具体的设置方法为：修改redis.conf中的maxmemory参数(单位为字节)，当超出限制后Redis会根据maxmemory-policy参数指定的策略来删除键，直到Redis占用的内存小于指定的值。maxmemory-policy支持的规则如下表所示： 内存淘汰规则 说明 volatile-lru 使用LRU算法删除一个设置了过期时间的键。 allkeys-lru 使用LRU算法删除一个键 volatile-random 随机删除一个设置了过期时间的键 allkeys-random 随机删除一个键 volatile-ttl 删除过期时间最近的一个键 noeviction 不删除键，只返回错误 注：对于LRU算法，事实上Redis并不会准确地将整个数据库中最久未使用的键删除，而是每次从数据库中随机选3个键并删除这三个键中最久未使用的键。volatile-ttl规则也是如此。“3”这个数字可以通过参数maxmemory-samples配置。 排序使用SORT命令：SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination]。参考：SORT. 管道由于客户端和Redis服务器使用TCP连接，网络传输是有时延的，在执行多个命令时每条命令都要等待上一条命令执行完才能执行，即使命令不需要上一条命令的执行结果，这样的话总时延是很高的，会对性能产生很大的影响。因此Redis底层通信协议对管道提供了支持，通过管道可以一次性发送多条命令并在执行完后一次性将结果返回。 Spring Data Redis对管道的支持： If you do not care about the results of the pipelined operations, you can use the standard execute method, passing true for the pipeline argument. The executePipelined methods run the provided RedisCallback or SessionCallback in a pipeline and return the results, as shown in the following example: 1234567891011//pop a specified number of items from a queueList&lt;Object&gt; results = stringRedisTemplate.executePipelined( new RedisCallback&lt;Object&gt;() &#123; public Object doInRedis(RedisConnection connection) throws DataAccessException &#123; StringRedisConnection stringRedisConn = (StringRedisConnection)connection; for(int i=0; i&lt; batchSize; i++) &#123; stringRedisConn.rPop(\"myqueue\"); &#125; return null; &#125;&#125;); 持久化Redis支持RDB和AOF两种持久化方式，实际生产中常一起使用。一起使用时重启Redis会优先采用AOF文件恢复。 RDB方式Redis会在以下几种情况下自动将内存中的所有数据生产一份副本并存储在硬盘上，这个过程称为快照： 根据配置文件指定的规则进行自动快照； 用户执行了SAVE或BGSAVE命令； 执行FLUSHALL命令； 执行复制(replication)时。 Redis默认将快照文件存储在Redis当前进程的工作目录中的dump.rdb文件中，可以通过配置dir和dbfilename两个参数分别修改。 RDB文件是经过压缩的二进制格式，可以通过配置rdbcompression参数禁用压缩节省CPU资源。 Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。 配置文件配置文件中自动快照的条件由两个参数构成：时间窗口M和改动的键的个数N，每当M秒内被更改的键个数大于N个时，Redis进行自动快照。redis.conf默认设置了三个条件，它们之间是或的关系： 123save 900 1 #900秒内有一个或一个以上的键被更改则进行快照save 300 10save 60 10000 SAVE/BGSAVE当进行服务重启、手动迁移以及备份时我们也需要手动执行快照操作。 SAVE：同步进行快照操作，快照执行过程中阻塞所有来自客户端的请求。尽量避免在生产环境中使用该命令。 BGSAVE：后台异步进行快照操作，快照执行过程中可以继续响应来自客户端的请求。可以通过LASTSAVE命令获取最近一次成功执行快照的时间，以此判断后台快照是否执行完成。推荐使用该方式。 FLUSHALL如果配置文件中没有配置自动快照条件，执行FLUSHALL则不会进行快照；否则就算FLUSHALL没有触发配置的条件，依旧会执行一次快照。 复制主从复制过程中的复制初始化阶段会进行自动快照。 快照原理快照的流程： Redis调用linux的fork函数复制一份当前进程（父进程）的副本（子进程）； 父进程继续接受并处理客户端发送的命令，子进程开始将内存中的数据写入硬盘中的临时文件； 当子进程写入完毕后，用临时文件替换旧的RDB文件，至此一次快照操作完成。 注意：在执行fork函数时Linux会采用写时复制策略，即fork函数发生的一刻父子进程共享同一内存数据，快照过程中若父进程要更改某片数据，操作系统会将该片数据复制一份，共享内存中的数据不会被修改，因此新RDB文件不会受快照过程中的修改的影响。 AOF方式通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据，因此开发者除了需要通过组合配置自动快照的条件以外，最好结合AOF一起使用。 AOF可以将Redis执行的每一条写命令追加到硬盘文件中，默认文件名为appendonly.aof，可通过参数appendfilename修改。Redis启动时会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入速度较RDB文件慢一些。 默认情况下Redis是没有开启AOF方式的，我们可以通过配置appendonly yes参数来启动。 考虑以下三条写命令： 123SET foo 1SET foo 2SET foo 3 最终内存中键foo的值为3，前两条命令是冗余的，为避免AOF文件太大，Redis进行了优化，每当达到一定条件时就自动重写AOF文件，配置如下： 12auto-aof-rewrite-percentage 100 #若当前aof文件超过上次重写的aof文件大小的100%，则再次重写，若之前未重写过则以启动时的aof文件为依据auto-aof-rewrite-min-size 64mb #只有当aof文件超过64mb时才允许重写 另外，我们也可通过BGREWRITEAOF命令手动执行重写。 同步硬盘数据由于硬盘缓存的存在，操作系统默认每30秒才执行一次同步操作，将缓存数据真正写入硬盘，这对启用AOF持久化的应用是无法忍受的，因此需要在写入AOF文件后主动要求系统进行同步。在配置文件中设置： 123#appendfsync always #每次写入都同步appendfsync everysec #每秒#appendfsync no #不主动进行同步 Redis默认每秒执行一次同步操作。 集群主从复制为避免单点故障，可采用主从复制的部署模式。主（master）服务器可以进行读写操作，当写操作导致数据变化时会自动将数据同步给从（slave）服务器。而从服务器一般是只读的。一个master可以拥有多个slave，而一个slave只能有一个master。 主从复制配置方式有以下三种，其中主服务器无需任何配置： 从服务器配置文件添加：slaveof MASTER_IP MASTER_PORT 从服务器启动时命令行添加：redis-server --port SLAVE_PORT --slaveof MASTER_IP MASTER_PORT 从服务器运行时设置：SLAVEOF MASTER_IP MASTER_PORT，如果执行该命令时该服务器已经是另一个master的slave，则停止和原master的同步，转而和新的master进行同步。另外，还可使用SLAVEOF NO ONE命令终止主从关系，甚至自身成为其他slave的master。 主从复制的原理复制初始化：当一个slave启动后，会向master发送SYNC内部命令，master接收到命令后在后台进行快照（RDB持久化），并将保存快照期间接受的命令缓存起来。快照完成后，Redis会将快照文件和缓存的命令发送给slave，slave收到后载入快照文件并执行缓存的命令。 复制同步阶段：复制初始化结束后，master每当收到写命令时就会将命令同步给slave，从而保证主从服务器数据一致。 断线重连：主从服务器之间的连接断开重连后，Redis2.6及之前会重新进行复制初始化，而Redis2.8之后开始支持增量数据传输，即master只将断线期间执行的命令发送给slave。断线期间执行的命令存储在一个积压队列中，它是一个固定长度的循环队列，默认大小为1MB，可通过参数repl-backlog-size设置。 初步配置解决master和slave之间的数据不一致问题： 12min-slaves-to-write 3 #只有当3个或以上的slave连接到master时，master才是可写的min-slaves-max-lag 10 #允许slave断连的最长时间为10秒，超过10秒则master拒绝写入 Tips： slave不仅可以接收master的同步数据，自身也可以作为其他slave的master。 通过设置master只写、slave只读实现读写分离，适用于读多写少的场景。 为了提高性能，可禁用master的持久化功能，只开启slave的持久化功能。注意，这种情况下master一定不能用进程管理工具设置Redis崩溃后自动重启，否则master的数据丢失了，slave的数据也会被覆盖清空。 无硬盘复制：repl-diskless-sync yes；开启后，复制初始化时不再将数据存储在硬盘上，而是直接通过网络发送给slave。 哨兵机制简介在一个典型的一主多从的Redis系统中，slave起到了数据冗余备份和读写分离的作用，当master宕机后，需要人工介入才能恢复系统。为此，Redis2.8之后提供了哨兵机制来实现自动化的系统监控和故障恢复。 哨兵是一个独立的进程，功能主要有两个： 监控master和slave是否正常运行； master故障时自动将slave转换为新master。 一个主从系统中可以有多个哨兵，一个哨兵也可以监控多个主从系统，哨兵之间可以互相监控，以保证系统足够稳健。 使用 新建配置文件sentinel.conf： 12sentinel monitor MASTER_NAME MASTER_IP MASTER_PORT 最低通过票数（执行故障恢复至少需要几个哨兵节点同意） 例如：sentinel monitor mymaster 127.0.0.1 6379 1 启动哨兵进程：redis-sentinel /PATH/sentinel.conf 其他哨兵配置参数参考。 原理哨兵和master建立连接后，会定时执行以下三个操作，贯穿哨兵进程的整个生命周期： 每10秒向master和slave发送 INFO 命令来获取信息更新并进行相应的操作，比如与新增的slave建立连接并加入监控列表，对主从服务器角色变化进行信息更新等。 每2秒向master和slave的_sentinel_:hello频道发送自己的信息，该频道用以获取其他同样监控master/slave的哨兵节点的信息，或向它们分享自己的信息。 每1秒向master、slave和其他哨兵节点发送PING命令，用于监控数据库和其他哨兵节点有没有停止服务。时间间隔可通过down-after-milliseconds配置，若其值小于1000ms，则按指定的间隔发送PING，若值大于1000ms，则每隔1秒发送。 若超过down-after-milliseconds指定时间后PING的节点未回复，则哨兵认为其主观下线（subjectively down）。如果该节点是主服务器，哨兵会进一步判断是否需要对其进行故障恢复：发送SENTINEL is-master-down-by-addr命令询问其他哨兵是否也认为该服务器主观下线。若返回结果计数达到sentinel.conf中配置的最低通过票数，则哨兵认为主服务器客观下线（objectively down），接下来使用Raft算法选举领头的哨兵对主从系统发起故障恢复。选举领头哨兵可以保证同一时间内只有一个哨兵节点来执行故障恢复。 故障恢复就是从多个slave中挑选优先级最高的作为新的master，优先级可通过slave-priority配置。 部署相对稳妥的哨兵部署方案是： 为每个节点部署一个哨兵。 使每个哨兵与其对应的节点的网络环境相同或相互近。 设置最低通过投票数为(N/2 + 1)，N为哨兵个数。 集群集群与哨兵的区别在于，集群着眼于水平扩展容量，哨兵着眼于高可用性，哨兵可以属于集群的子集。 Redis 集群不支持那些需要同时处理多个键的 Redis 命令（如MGET）， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。 Redis 集群通过分区（partition）来提供一定程度的可用性）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。 Redis 集群使用数据分片（sharding）而非一致性哈希（consistency hashing）来实现 。 详细配置过程与原理见：Redis集群教程。 Spring Data Redis参考：Spring官方文档. 常见面试问题参考：DreamCats.","categories":[{"name":"数据库","slug":"数据库","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"}],"tags":[{"name":"Redis","slug":"Redis","permalink":"http://thmasterplan.cn/tags/Redis/"}]},{"title":"(三)秒杀项目优化之多级缓存","slug":"(3)秒杀项目优化之多级缓存","date":"2020-11-12T09:35:07.000Z","updated":"2020-11-23T14:23:20.925Z","comments":true,"path":"项目优化/(3)秒杀项目优化之多级缓存/","link":"","permalink":"http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(3)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/","excerpt":"","text":"Redis缓存 本地热点缓存 Nginx代理服务器缓存 Redis缓存使用Redis缓存可分为单机模式，sentinel哨兵模式，和cluster集群模式，区别仅仅在于吞吐量的提升，由于条件有限本实验仅采用单机模式。 将商品详情页的数据缓存在Controller层，下次访问相同数据则不再调用Service和Dao访问数据库。 12345678910111213141516171819202122/** * 获取商品详情页 * @return */@RequestMapping(\"/get\")@ResponseBodypublic CommonReturnType getItem(@RequestParam(name = \"id\")Integer id)&#123; //根据商品的id到redis获取ItemModel,记住ItemModel及其成员变量一定要实现Serializable接口 ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get(\"item_\"+id); //若redis内不存在对应的ItemModel，则访问下游service if(itemModel == null) &#123; itemModel = itemService.getItemById(id); //设置itemModel到Redis内 redisTemplate.opsForValue().set(\"item_\"+id,itemModel); //设置缓存失效时间 redisTemplate.expire(\"item_\"+id, 10, TimeUnit.MINUTES); &#125; ItemVO itemVO = convertVOFromModel(itemModel); return CommonReturnType.create(itemVO);&#125; 本地热点缓存使用Redis缓存需要通过网络IO访问Redis服务器，因此使用本地热点缓存进一步提升吞吐量。本地热点缓存的特点： 仅缓存热点数据（指那些频繁被访问，变化频率小，在内存中生命周期短的数据，本项目中主要是秒杀活动中的商品详情页）； 脏读非常不敏感（即使有脏读问题也不大）； 内存可控（JVM堆栈的内存）。 我们使用Guava cache做本地缓存，它： 使用哈希表作为容器； 线程安全； 可控制key的数量和超时时间； 可配置LRU算法。 引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;18.0&lt;/version&gt;&lt;/dependency&gt; 业务层实现 123456789101112131415161718192021222324252627282930313233343536/** * 封装本地缓存操作类 */public interface CacheService &#123; //存方法 void setCommonCache(String key, Object value); //取方法 Object getFromCommonCache(String key);&#125;@Service(\"cacheService\")public class CacheServiceImpl implements CacheService &#123; private Cache&lt;String,Object&gt; commonCache = null; //cacheService生命周期中的初始化方法 @PostConstruct public void init()&#123; commonCache = CacheBuilder.newBuilder() .initialCapacity(10)//设置缓存容器的初始容量为10 .maximumSize(100)//设置缓存最多100个key，超过后按照LRU算法移除缓存项 .expireAfterWrite(30, TimeUnit.SECONDS)//设置写缓存后多少秒过期 .build(); &#125; @Override public void setCommonCache(String key, Object value) &#123; commonCache.put(key,value); &#125; @Override public Object getFromCommonCache(String key) &#123; return commonCache.getIfPresent(key); &#125;&#125; 修改获取商品详情页的方法： 1234567891011121314151617181920212223242526272829303132/** * 获取商品详情页，使用本地缓存和Redis缓存 * @return */ @RequestMapping(\"/get\") @ResponseBody public CommonReturnType getItem(@RequestParam(name = \"id\")Integer id)&#123; ItemModel itemModel = null; //1. 先取本地缓存 itemModel = (ItemModel)cacheService.getFromCommonCache(\"item_\"+id); //2. 若本地缓存内不存在对应的ItemModel，则访问Redis缓存 if(itemModel == null) &#123; //2.1. 根据商品的id到redis获取ItemModel,记住ItemModel及其成员变量一定要实现Serializable接口 itemModel = (ItemModel) redisTemplate.opsForValue().get(\"item_\"+id); //2.2. 若redis内不存在对应的ItemModel，则访问下游service if(itemModel == null) &#123; itemModel = itemService.getItemById(id); //设置itemModel到Redis内 redisTemplate.opsForValue().set(\"item_\"+id,itemModel); //设置缓存失效时间 redisTemplate.expire(\"item_\"+id, 10, TimeUnit.MINUTES); &#125; //2.3. 设置itemModel到本地缓存 cacheService.setCommonCache(\"item_\"+id,itemModel); &#125; ItemVO itemVO = convertVOFromModel(itemModel); return CommonReturnType.create(itemVO); &#125; Nginx代理服务器缓存Nginx作为反向代理服务器配置缓存时，缓存内容以文件的形式存储在磁盘中，文件的地址则存储在内存中。在配置文件nginx.conf中配置proxy_cache： 123456#配置缓存数据的路径以及和缓存索引相关的内容#levels:设置在相对于path指定目录的第2级目录中缓存数据，目录名称根据请求URL通过哈希算法得到。#keys_zone:设置存放缓存索引的内存区域的名称与大小（100MB）。#inactive:缓存数据失效时间，过期则删除，再次请求时重新从后端服务器获取。#max_size:缓存数据最大容量，超过则根据LRU算法删除部分缓存。proxy_cache_path /usr/local/openresty/nginx/tmp_cache levels=1:2 keys_zone=tmp_cache:100m inactive=7d max_size=10g; 123456789101112location / &#123; proxy_pass http://backend_server; proxy_cache tmp_cache;#配置一块公用的内存区域的名称，该区域可存放缓存的索引数据 proxy_cache_key $uri;#配置在内存中为缓存建立索引时使用的key，使用uri proxy_cache_valid 200 206 304 302 7d;#缓存HTTP状态码为200/206/304/302的响应数据 proxy_set_header Host $http_host; proxy_set_header X-Real-IP $remote_addr; proxy_set_header X-Forwarded-For %proxy_add_x_forwarded_for; proxy_http_version 1.1; proxy_set_header Connection \"\"; &#125; 由于缓存内容存于磁盘中，效率其实还不如Redis缓存和本地热点缓存，因此不推荐使用proxy cache，实际开发中可以使用openresty的shared dict作为前置缓存，或者使用openresty对Redis的支持。","categories":[{"name":"项目优化","slug":"项目优化","permalink":"http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"项目优化","slug":"项目优化","permalink":"http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"}]},{"title":"(二)秒杀项目优化之Nginx反向代理与分布式会话","slug":"(2)秒杀项目优化之Nginx反向代理与分布式会话","date":"2020-11-11T15:21:00.000Z","updated":"2020-11-23T14:51:23.228Z","comments":true,"path":"项目优化/(2)秒杀项目优化之Nginx反向代理与分布式会话/","link":"","permalink":"http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(2)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8BNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/","excerpt":"","text":"水平扩展 Spring Boot应用部署 MySQL授权给远端连接 Nignx反向代理 安装OpenResty 静态资源部署 动态请求转发 设置upstream server 设置动态请求location为proxy pass路径 开启tomcat access log 考虑局域网连接的建立与释放的消耗 Nginx高性能原因 分布式会话管理 Cookie方式 Token方式 水平扩展Spring Boot应用部署之前的压测MySQL与Tomcat在同一台主机上，因此我们需要分布式扩展服务器，引入Nginxx做动静分离和负载均衡，静态请求由Nginx处理（注意企业级应用一般会使用NAS存储），动态请求转发给Tomcat，MySQL单独占用一台主机。其结构图如下： 本实验使用阿里云ECS服务器，如图所示： 修改阿里云安全组，添加开放端口号： 接着配置好各台主机的开发环境。 部署好开发环境后，将项目jar包上传到各台应用服务器上，在application配置文件中配置数据库连接池地址，覆盖我们开发时配置的本机地址： 1spring.datasource.url=jdbc:mysql://172.30.215.166:3306/miaosha?useUnicode=true&amp;characterEncoding=UTF-8 使用telnet命令测试能否连接数据库：telnet 172.30.215.166 3306，结果显示连接不被允许： 1234Trying 172.30.215.166...Connected to 172.30.215.166.Escape character is &#39;^]&#39;.HHost &#39;172.30.19.131&#39; is not allowed to connect to this MariaDB serverConnection closed by foreign host. MySQL授权给远端连接我们需要MySQL授权给应用服务器，切换至MySQL服务器进入MySQL： grant all privileges on *.* to USERNAME@&#39;%&#39; identified by &#39;PASSWORD&#39;;，只要用户名和密码正确，授权来自任何域名的数据库访问。 flush privileges;：刷新权限。 Nignx反向代理OpenResty是一个基于 Nginx与 Lua 的高性能 Web 平台，参考OpenResty中文官网。 安装OpenResty 安装依赖库：yum install pcre-devel openssl-devel gcc curl 下载预编译包：wget https://openresty.org/download/openresty-1.17.8.2.tar.gz 解包：tar -xvzf openresty-1.17.8.2.tar.gz 编译：./configure -&gt; make 安装：make install，默认安装路径为/usr/local/openresty 启动服务器： cd /usr/local/openresty/nginx 指定以nginx.conf配置启动，sbin/nginx -c conf/nginx.conf 启动后若修改配置文件，sbin/nginx -s reload可无缝重启 静态资源部署将前端相关资源上传到//usr/local/openresty/nginx/html目录下，新建目录resources，将html目录下所有静态资源移动到resources目录下。 修改nginx.conf： 12345678910location / &#123; root html; index index.html index htm;&#125;#修改为location /resources/ &#123; #当访问路径命中/resources/时，将路径替换为以下路径 alias /usr/local/openresty/nginx/html/resources/; index index.html index htm;&#125; 动态请求转发所有的静态页面都由Nnigx处理，例如访问http://nginxserver/resources/templates/register.html；所有的动态请求都转发给Tomcat，例如访问http://nginxserver/item/get?id=1。 设置upstream server123456#设置两台应用服务器的地址，轮流访问#weight即权重，两台服务器各承担一半的请求upstream backend_server &#123; server 172.30.215.165 weight=1; server 172.30.19.131 weight=1;&#125; 设置动态请求location为proxy pass路径123456location / &#123; proxy_pass http://backend_server; #反向代理 proxy_set_header Host $http_host:$proxy_port; #设置Http的host字段 proxy_set_header X-Real-IP $remote_addr; #设置客户端访问的IP，不设置则应用服务器拿到的是nginx服务器的地址 proxy_set_header X-Forwarded-For %proxy_add_x_forwarded_for;&#125; 开启tomcat access log开启tomcat访问日志记录，修改application配置文件： 123server.tomcat.accesslog.enabled=trueserver.tomcat.accesslog.directory=/var/www/miaosha/tomcatserver.tomcat.accesslog.pattern=%h %l %u %t \"%r\" %s %b %D 考虑局域网连接的建立与释放的消耗由于Nginx反向代理服务器默认配置与后端服务器的连接是没有配置keepAlive的，因此大量动态资源请求时，Nginx与Tomcat的连接是短连接，会有大量连接的建立与释放，而Druid管理下应用服务器与数据库服务器之间连接则默认保持长连接。 Nginx配置keepalive： 12345678910111213141516171819upstream backend_server &#123; server 172.30.215.165 weight=1; server 172.30.19.131 weight=1; keepalive 30;&#125;server&#123; 其他配置... location / &#123; proxy_pass http://backend_server; #反向代理 proxy_set_header Host $http_host:$proxy_port; #设置Http的host字段 proxy_set_header X-Real-IP $remote_addr; #设置客户端访问的IP，不设置则应用服务器拿到的是nginx服务器的地址 proxy_set_header X-Forwarded-For %proxy_add_x_forwarded_for; proxy_http_version 1.1;#Nginx默认采用http1.0，http1.1才有keepalive proxy_set_header Connection \"\";#Connection为空就表示设置keepalive &#125; Nginx高性能原因 epoll多路复用 master worker进程模型 协程机制 分布式会话管理我们通过将session保存到Redis服务器来实现分布式会话，有两种实现方式： 基于Cookie传输JSESSIONID：Tomcat容器session实现迁移到Redis。 基于Token传输类似sessionid：Java代码session实现迁移到Redis。 Windows下安装Redis用于调试程序： 下载地址 安装完成后切换到安装目录，启动cmd 启动Redis服务器：redis-server.exe redis.windows.conf 启动客户端：redis-cli -h 127.0.0.1 -p 6379 Cookie方式 导入依赖： 123456789&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-redis&lt;/artifactId&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework.session&lt;/groupId&gt; &lt;artifactId&gt;spring-session-data-redis&lt;/artifactId&gt;&lt;/dependency&gt; 配置application.properties： 123456789#配置SpringBoot对Redis的依赖spring.redis.host=127.0.0.1spring.redis.port=6379#Redis默认16个数据库，指定其中某一个spring.redis.database=10#spring.redis.password=#设置Jedis连接池连接数量spring.redis.jedis.pool.max-active=50spring.redis.jedis.pool.min-idle=20 添加RedisConfig配置类： 1234@Component@EnableRedisHttpSession(maxInactiveIntervalInSeconds = 3600) //设置session失效时间，默认30min，修改为1hpublic class RedisConfig &#123;&#125; Session存储的对象需要实现Serializable接口： 12345request.getSession().setAttribute(\"LOGIN_USER\", userModel);public class UserModel implements Serializable &#123; //......&#125; 本地调试登录功能，查看Redis服务器10号数据库是否有数据。 调试完没有问题后，重新生成jar包上传到应用服务器，然后云端搭建Redis服务器（为节省成本，这里Redis与MySQL使用同一台服务器）： yum安装或编译安装均可，yum安装会将相关命令放入/usr/bin，可以直接在任何地方访问，并且配置文件redis.conf在/etc/目录下。 修改redis.conf的server地址为服务器的局域网地址，以该配置文件启动：redis-server /etc/redis.conf &amp; 修改两台应用服务器的application配置文件，配置spring.redis.host=redis所在服务器地址，启动应用。 Token方式企业开发中应该使用这种方式，考虑到客户端的多平台特性，某些客户端可能不支持Cookie方式。 UserController的login方法中，原来的方式： 123request.getSession().setAttribute(\"IS_LOGIN\",true);request.getSession().setAttribute(\"LOGIN_USER\", userModel);return CommonReturnType.create(uuidToken); 改为： 12@Autowiredprivate RedisTemplate redisTemplate; 123456789//3.修改为使用token的方式，将token和用户模型一起存入redis中//生成登录凭证tokenString uuidToken = UUID.randomUUID().toString().replace(\"-\",\"\");//建立token和用户登录态之间的联系redisTemplate.opsForValue().set(uuidToken, userModel);//设置超时时间redisTemplate.expire(uuidToken, 1, TimeUnit.HOURS);return CommonReturnType.create(uuidToken); 前端代码修改： login.html，登录的ajax请求success回调函数中，若登录成功添加token： 12var token = data.data;window.localStorage[\"token\"] = token; 获取商品下单时判断是否持有token： 12345678var token = window.localStorage[\"token\"];if(token == null)&#123; alert(\"没有登录，不能下单\"); window.location.href=\"login.html\"; return false;&#125;//修改ajax请求url，添加token登录凭证url:\"http://\"+g_host+\"/order/create?token=\"+token, 下单的Controller验证token： 123456String token = request.getParameterMap().get(\"token\")[0];if(StringUtils.isEmpty(token)) throw new BusinessException(EnumBusinessError.USER_NOT_LOGIN,\"用户未登录，无法下单\");UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);if(userModel == null) throw new BusinessException(EnumBusinessError.USER_NOT_LOGIN,\"用户未登录，无法下单\");","categories":[{"name":"项目优化","slug":"项目优化","permalink":"http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"项目优化","slug":"项目优化","permalink":"http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"}]},{"title":"(一)秒杀项目优化之定制化Tomcat配置","slug":"(1)秒杀项目优化之定制化Tomcat配置","date":"2020-11-09T14:21:23.000Z","updated":"2020-11-23T14:23:20.907Z","comments":true,"path":"项目优化/(1)秒杀项目优化之定制化Tomcat配置/","link":"","permalink":"http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(1)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AE%9A%E5%88%B6%E5%8C%96Tomcat%E9%85%8D%E7%BD%AE/","excerpt":"","text":"云端部署 安装JDK 安装MySQL 安装 启动服务 开机启动 查看端口 登录 备份本地数据库到云端 本地备份 上传 云端恢复 本地应用程序打包部署到云端 性能压测 性能初步调优-定制化内嵌Tomcat配置 修改全局配置文件 修改源码 MySQL的QPS问题 云端部署项目地址. 安装JDK yum -y install java yum -y install java-1.8.0-openjdk-devel.x86_64 安装MySQL安装 yum install -y mysql* yum install -y mariadb-server 启动服务systemctl start mariadb.service 开机启动systemctl enable mariadb.service 查看端口netstat -anp | grep 3306 登录 初始化MySQL用户名和密码：mysqladmin -u USERNAME password &#39;PASSWORD&#39; 登录：mysql -u USERNAME -p 备份本地数据库到云端本地备份使用mysqldump命令根据已有数据库创建SQL文件：mysqldump -u USERNAME --databases 数据库名 -p &gt; /路径/miaosha.sql。 上传使用scp命令上传SQL文件到云端tmp目录下：scp /路径/miaosha.sql USERNAME@IP:/tmp 云端恢复重定向IO即可：mysql -u USERNAME -p &lt; ../tmp/miaosha.sql。 本地应用程序打包部署到云端 mvn clean package或直接IDE右侧运行maven命令，target目录中生成Spring Boot的jar包。 scp命令上传到云端。 防火墙添加端口：firewall-cmd --zone=public --add-port=8080/tcp --permanent 更新防火墙规则：firewall-cmd --reload 新建配置文件appication.properties，该配置文件优先级大于项目中的。 编写deploy.sh脚本部署：./deploy.sh &amp; 1nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addtion-location=/var/www/miaosha/application.properties 性能压测使用JMeter进行性能压测，测试环境：1核2g内存。简单入门： 创建线程组 添加取样器：HTTP请求。（一定要勾选KeepAlive，此处指HTTP的connection选项而非TCP的keepAlive机制，TCP的keepAlive机制用于检测死连接，HTTP的则是为了在一个TCP连接发送多个HTTP请求） 添加监听器：察看结果树 添加监听器：聚合报告 聚合报告列表的含义： 样本：表示进行了20次请求 平均值：平均响应时间，单位ms 中位数：中位数响应时间，单位ms 百分位：百分之多少的请求的响应时间 吞吐量：TPS, Throughput Percent Second 查看Tomcat默认维护的线程池中线程数量： 获取SpringBoot程序pid：ps -ef | grep miaosha 计算线程数量：pstree -p 4073 | wc -l，结果为28 性能初步调优-定制化内嵌Tomcat配置压测：调整线程组线程数为5000，Ramp-Up时间为15秒，循环次数100，查看服务器线程数量，结果为218，压测结果显示有大量请求被拒绝。压测过程可使用top -H查看实时的进程动态。 压测：调整线程组线程数为1000，Ramp-Up时间为15秒，循环次数50，查看服务器线程数量，结果为218，压测结果显示已经没有请求被拒绝。压测过程可使用top -H查看实时的进程动态。 修改全局配置文件通过查看spring-configuration-metadata.json，查看Spring Boot内嵌Tomcat的默认配置，主要有以下几点： server.tomcat.accept-count：Maximum queue length for incoming connection requests when all possible request processing threads are in use. 等待队列长度，默认为100 server.tomcat.max-connections：最大可被连接数，默认8192 server.tomcat.max-threads：最大工作线程数，默认200 server.tomcat.min-spare-threads：最小工作线程数，默认10 由此得知，默认配置下连接超过8192后出现拒绝连接情况；默认配置下，触发的请求超过最大工作线程数200+最大等待队列长度100后即300，拒绝处理。 在application.properties中配置以上参数以覆盖默认设置， 123server.tomcat.accept-count=1000server.tomcat.max-threads=400server.tomcat.min-spare-threads=100 一般来说4核8g内存最大线程数设置为800较为合理。杀掉进程重新部署后计算常驻线程数为118。 再次压测：调整线程组线程数为1000，循环次数50，查看服务器线程数量，发现已经变为418，压测结果如下图： 由图可知，修改tomcat默认配置之后已经压测结果已经有所提升，但是单机TPS依旧只有309，响应时间依旧很长。 在实际开发中，以上四个参数需要视单个服务器具体的CPU和内存配置进行压测后才能得出最优配置。 修改源码使用WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;类定制化内嵌Tomcat配置： keepAliveTimeOut：多少毫秒后若客户端无请求则断开本次TCP连接。 maxKeepAliveRequests：一次TCP连接支持多少个HTTP请求后断开失效。 这两个设置可以避免DDOS攻击，以及在用户长时间不发请求时节省服务器资源。代码如下： 12345678910111213141516171819202122232425/** * 当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会加载此bean到容器 */@Componentpublic class WebServerConfiguration implements WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt; &#123; /** * 使用对应工厂类提供给我们的接口定制化Tomcat * @param factory */ @Override public void customize(ConfigurableServletWebServerFactory factory) &#123; ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(new TomcatConnectorCustomizer() &#123; @Override public void customize(Connector connector) &#123; Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler(); //定制化keepAliveTimeOut,30s内没有请求则服务端断开TCP连接 protocol.setKeepAliveTimeout(30000); //定制化maxKeepAliveRequests protocol.setMaxKeepAliveRequests(10000); &#125; &#125;); &#125;&#125; MySQL的QPS问题 主键查询：千万级别数据用时1-10ms； 唯一索引查询：千万级别数据用时10-100ms; 非唯一索引查询：千万级别数据用时100-1000ms； 无索引的普通字段查询：百万条数据用时1000ms+，全表扫描，不可接受。","categories":[{"name":"项目优化","slug":"项目优化","permalink":"http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"}],"tags":[{"name":"项目优化","slug":"项目优化","permalink":"http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"}]},{"title":"常用设计模式","slug":"常用设计模式","date":"2020-11-03T08:41:33.000Z","updated":"2021-01-21T04:31:01.155Z","comments":true,"path":"软件工程/常用设计模式/","link":"","permalink":"http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","excerpt":"","text":"概述 设计模式的目的 UML复习 类图 基础 接口与实现 聚合 可见性 时序图 创建型模式 单例（Singleton） 饿汉式（立即加载） 静态常量 静态代码块 懒汉式（延迟加载） 线程不安全 线程不安全-同步代码块 线程安全-同步方法 双重检查（Double Check） 静态内部类 枚举 简单工厂（Simple Factory） 工厂方法（Factory Method） 抽象工厂（Abstract Factory） 原型（Prototype） Shallow Copy Deep Copy 结构型模式 适配器（Adapter） 类适配器 对象适配器 接口适配器 装饰器（Decorator） 代理（Proxy） 行为模式 模板方法（Template Method） 策略（Strategy） 观察者（Observer） 责任链（Chain Of Responsibility） Spring中的设计模式总结 概述软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由Erich Gamma等人在1990年代从建筑设计领域引入到计算机科学的。 设计模式的目的编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)具有更好的： 代码重用性 (即：相同功能的代码，不用多次编写) 可读性 (即：编程规范性, 便于其他程序员的阅读和理解) 可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) 可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) 使程序呈现高内聚，低耦合的特性 UML复习类图基础UML中的类图用于表示类、接口、实例之间相互的静态关系。如图： 该图中实线空心三角箭头表示继承关系。下划线表示这是一个静态字段或静态方法，斜体表示这是一个抽象类或抽象方法。 接口与实现 该图中虚线空心三角箭头表示实现关系。接口会在类图中使用&lt;&lt;interface&gt;&gt;表明。 聚合 聚合是一种“持有”关系，比如Basket类中持有多个Fruit实例。实际上关联、聚合、组合都是一种持有关系，依赖则属于“半持有”的关系，它们的区别如下： UML中：关联、聚合、组合、依赖的区别. 可见性 该图标识了方法和字段的可见性： “+”表示public “-“表示private “#”表示protect “~”表示包可见 时序图UML的时序图用于表示程序在工作时其内部方法的调用顺序，以及事件的发生顺序。例： 时序图上方的长方形表示类的实例，长方形向下延伸的虚线表示时间的流逝。黑色实线箭头表示方法调用，虚线箭头表示方法返回。 创建型模式单例（Singleton）作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。 单例模式的使用场景：需要频繁进行创建和销毁的对象、创建对象耗时过多或耗费资源过多（重量级对象）但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象。例如：Spring中bean对象的创建默认就是singleton。 饿汉式（立即加载）静态常量12345678910111213141516171819public class StaticFinal &#123; //1.构造方法私有化，其他类不能new private StaticFinal()&#123;&#125; //2.私有静态常量，创建类实例，连接-准备阶段赋值 private static final StaticFinal INSTANCE = new StaticFinal(); //3.公有静态方法，获取实例 public static StaticFinal getInstance()&#123; return INSTANCE; &#125; public static void main(String[] args) &#123; StaticFinal staticFinal = StaticFinal.getInstance(); StaticFinal staticFinal1 = StaticFinal.getInstance(); System.out.println(staticFinal == staticFinal1); //true &#125;&#125; 优点：类加载（static final变量在连接-准备阶段赋值）时就完成了对象的实例化，避免了线程同步问题。 缺点：如果从始至终没有用到该实例，会造成内存浪费。 静态代码块1234567891011121314151617181920212223public class StaticBlock &#123; //1.构造方法私有化，其他类不能new private StaticBlock()&#123;&#125; //2.私有静态常量 private static final StaticBlock INSTANCE; //3.静态代码块中，初始化阶段赋值 static &#123; INSTANCE = new StaticBlock(); &#125; //4.公有静态方法，获取实例 public static StaticBlock getInstance()&#123; return instance; &#125; public static void main(String[] args) &#123; StaticBlock staticBlock = StaticBlock.getInstance();//调用类的静态方法-&gt;类初始化-&gt;静态代码块中创建实例 StaticBlock staticBlock1 = StaticBlock.getInstance(); System.out.println(staticBlock == staticBlock1); //true &#125;&#125; 优缺点同上。 懒汉式（延迟加载）线程不安全1234567891011121314public class NoSync &#123; //1.构造方法私有化，其他类不能new private NoSync()&#123;&#125; //2.私有静态变量 private static NoSync instance; //3.公有静态方法，调用该方法时才创建实例 public static NoSync getInstance()&#123; if(instance == null) instance = new NoSync(); return instance; &#125;&#125; 优点：延迟加载，调用getInstance方法时才创建对象，不会出现浪费内存的情况。 缺点：不能保证线程安全。在多线程情况下，一个线程进入if(instance == null)判断语句块，还未来得及往下执行，另一个线程也正在判断该语句，此时便会产生多个实例。 实际开发中，不能使用该方式。 线程不安全-同步代码块123456789101112131415161718public class SyncBlock &#123; //1.构造方法私有化，其他类不能new private SyncBlock()&#123;&#125; //2.私有静态变量 private static SyncBlock instance; //3.公有静态方法，调用该方法时才创建实例 public static SyncBlock getInstance()&#123; //3.1.同步操作在条件判断之后 if(instance == null)&#123; synchronized (SyncBlock.class)&#123; instance = new SyncBlock(); &#125; &#125; return instance; &#125;&#125; 不能保证线程安全，原因同上。 线程安全-同步方法1234567891011121314public class SyncMethod &#123; //1.构造方法私有化，其他类不能new private SyncMethod()&#123;&#125; //2.私有静态变量 private static SyncMethod instance; //3.公有静态同步方法，调用该方法时才创建实例 public static synchronized SyncMethod getInstance()&#123; if(instance == null) instance = new SyncMethod(); return instance; &#125;&#125; 优点：延迟加载，保证了线程安全。 缺点：效率低。实例化只需要执行一次就够了，但是以后每个线程每次调用getInstance都要进行同步加锁。 实际开发中，不推荐该方式。 双重检查（Double Check）123456789101112131415161718public class DoubleCheck &#123; //1.构造方法私有化，其他类不能new private DoubleCheck()&#123;&#125; //2.私有静态volatile变量 private static volatile DoubleCheck instance; //3.公有静态方法，调用该方法时才创建实例 public static DoubleCheck getInstance()&#123; if(instance == null)&#123; synchronized (DoubleCheck.class)&#123; if(instance == null) instance = new DoubleCheck(); &#125; &#125; return instance; &#125;&#125; 双重检查是”线程不安全-同步代码块“与”线程安全-同步方法“的改进，volatile修饰变量保证可见性，即使有多个线程同时进行”第一个条件判断“，在同步代码块中也有第二个条件判断保证只会创建一个实例。同时解决了使用同步方法效率低的问题，因为线程多次调用getInstance只是第一次有同步加锁操作。 实际开发中，推荐使用。 静态内部类123456789101112131415public class StaticInnerClass &#123; //1.构造方法私有化，其他类不能new private StaticInnerClass()&#123;&#125; //2.私有静态内部类 private static class Instance&#123; //2.1.私有静态常量，创建对象 private static final StaticInnerClass INSTANCE = new StaticInnerClass(); &#125; //3.公有静态方法，调用该方法时调用内部类的静态常量， public static StaticInnerClass getInstance()&#123; return Instance.INSTANCE; &#125;&#125; 由于外部类加载时不会同时加载内部类，因此只有再调用getInstance方法时才会加载内部类，并在内部类类加载阶段的连接-准备阶段赋值。 该方式是对饿汉式的改进，既能避免线程同步问题，又能做到延迟加载，避免内存的浪费。 实际开发中，推荐使用。 枚举123456789public enum EnumSingleton &#123; INSTANCE; public static void main(String[] args) &#123; EnumSingleton enumSingleton = EnumSingleton.INSTANCE; EnumSingleton enumSingleton1 = EnumSingleton.INSTANCE; System.out.println(enumSingleton == enumSingleton1);//true &#125;&#125; 最简单最推荐的方式。该方式不仅能避免线程同步问题，还能防止反序列化重新创建新的对象。 简单工厂（Simple Factory）简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。 场景：假设现在我们要实现一个登录功能，需要满足多种登录方式，那么自然的方式就是建立一个各种登录方式都适用的接口，使用的时候再判断具体创建哪种登录方式的实现类。如图： 源代码： 123public interface Login &#123; public boolean verify(String telPhone , String password);&#125; 123456789public class DomainLogin implements Login &#123; @Override public boolean verify(String telPhone, String password) &#123; /** * 业务逻辑 */ return true; &#125;&#125; 123456789public class PasswordLogin implements Login &#123; @Override public boolean verify(String telPhone, String password) &#123; /** * 业务逻辑 */ return true; &#125;&#125; 我们还需要一个工厂类LoginFactory，根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。 12345678910public class LoginFactory &#123; public static Login getLogin(String loginType)&#123; if(\"password\".equals(loginType)) return new PasswordLogin(); else if(\"passcode\".equals(loginType)) return new DomainLogin(); else throw new RuntimeException(\"没有找到登录类型\"); &#125;&#125; 测试类： 123456789101112131415161718192021/** * 模拟servlet接收前端请求，由工厂获取具体登录类型 */public class Test &#123; public static void main(String[] args) &#123; String loginType = \"password\"; String telPhone = \"13799990808\"; String password = \"password\"; Login login = LoginFactory.getLogin(loginType); boolean bool = login.verify(telPhone, password); if (bool) &#123; /** * 业务逻辑 */ &#125; else &#123; /** * 业务逻辑 */ &#125; &#125;&#125; 简单工厂模式的结构如下图： 优点：模式的核心是工厂类。这个类含有必要的逻辑判断，可以决定在什么时候创建哪一个登录验证类的实例，而调用者则可以免除直接创建对象的责任。简单工厂模式通过这种做法实现了对责任的分割，当系统引入新的登录方式的时候无需修改调用者。 缺点：工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。 转载自：java_my_life. 工厂方法（Factory Method）工厂方法模式：定义一个创建产品对象的工厂接口，将实际创建工作推迟到工厂子类中。 场景：某财务系统需要支持对数据库中的员工薪资进行导出，并且支持多种格式如：HTML、PDF等，每种格式导出的文件结构不同，比如有标准结构和财务需要的结构两种。 如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求支持n种导出的格式以及2种导出的结构，那工厂类则需要2*n个if else语句来创建2*n种不同的类型。如果日后需求不断增加，则后果不堪设想。 这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。 这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，引进一个新的产品则再创建一个新的工厂即可。这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计UML图： 从上图可以看出，这个使用工厂方法模式的系统涉及到以下角色： 抽象工厂（ExportFactory）角色：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。 具体工厂（ExportHtmlFactory、ExportPdfFactory）角色：担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。假如我们新增了一个需求：导出CSV格式，则只需要新建一个实现ExportFactory接口的ExportCsvFactory工厂类即可。 抽象导出（ExportFile）角色：具体工厂角色所创建对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。 具体导出（ExportStandardHtmlFile等）角色：这个角色实现了抽象导出（ExportFile）角色所声明的接口，具体工厂角色所创建的每一个对象都是某个具体导出角色的实例。 源代码参见GitHub. 简单工厂模式可以看作是工厂方法模式的特例，设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。 转载自：java_my_life. 抽象工厂（Abstract Factory）工厂方法模式中一个工厂类只能生产一种抽象产品类，比如上面的例子每一个具体工厂只能生产导出文件对象，而抽象工厂模式中一个具体工厂可以生产多种产品。还是以上面的场景为例，假设现在我们新增一个需求：该财务系统不仅要实现导出薪资文件功能，还要实现导入财务报表功能，假设财务报表有HTML和PDF两种格式，该怎么做？ 我们只需要将ExportFactory接口与ExportHtmlFactory、ExportPdfFactory实现类改名为Factory接口与HtmlFactory、PdfFactory，然后在接口与实现类种添加getImportFile方法； 创建ImportFile接口与对应的ImportHtmlFile、ImportPdfFile实现类； 在工厂类的getImportFile方法中创建ImportHtmlFile、ImportPdfFile实现类对象。 源代码参考GitHub. 以下是一个更容易理解的例子： 简单工厂模式：现有一个鼠标工厂，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。 工厂方法模式：将简单工厂模式的方法中的判断逻辑抽取出来成为工作子类，实现解耦。 当新增需求比如该鼠标工厂接了联想的订单，只需要新增一个LenovoMouseFactory即可，如果使用简单工厂模式的话则需要修改工厂类的代码，不符合开闭原则。 抽象工厂：假设我们的鼠标工厂越发红火，拓展了业务，不再只生产鼠标，同时还生产键盘等其他PC外设，那么我们只需要在原有的工厂中新增产品线即可。 原型（Prototype）原型模式：通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。 Object类提供了一个clone()方法，该方法可以将一个对象复制一份，但是需要实现了clone方法的Java类必须实现接口Cloneable，此时在另一个类中就可以通过调用该Java类的clone方法获取克隆对象了（浅拷贝）。我们可以使用该特性实现原型模式。 关于深拷贝与浅拷贝： Shallow Copy B对A的浅拷贝：创建新对象B，将A的字段值复制到B。 如果该字段值是对对象（例如，存储器地址）的引用，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。 如果该字段值是基本数据类型，则复制值。 Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法， then A B = (A) new A().clone(); 示例： 123456789101112131415161718192021222324252627282930313233class C&#123; int a; int b; C(int a, int b)&#123; this.a = a; this.b = b; &#125;&#125;class A implements Cloneable&#123; int val; C object; A(int val, C obj)&#123; this.val = val; this.object = obj; &#125; @Override public Object clone()&#123; try&#123; return super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); return null; &#125; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; A aObj = new A(1, new C(2,3)); A bObj = (A) aObj.clone(); &#125;&#125; 如上代码中，如果bObj修改了引用类型C object中b的值为10，那么对象aObj中引用类型C object中b的值也是10，因为浅拷贝只是拷贝了aObj中object的引用（地址）给bObj。 Deep Copy B对A的深拷贝：创建新对象B，对于A的引用类型字段，在B中创建该引用类型对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。 要实现深拷贝，不仅A需要实现Cloneable接口并重写clone方法，A中的引用类型C也需要实现Cloneable接口并重写clone方法。 深拷贝也可通过对象序列化的方式实现ByteArrayInputStream、ByteArrayOutputStream、ObjectInputStream、ObjectOutputStream。 示例： 123456789101112131415161718192021222324252627282930313233343536373839class C implements Cloneable&#123; int a; int b; C(int a, int b)&#123; this.a = a; this.b = b; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;class A implements Cloneable&#123; int val; C object; A(int val, C obj)&#123; this.val = val; this.object = obj; &#125; @Override public Object clone()&#123; try&#123; A a = (A) super.clone(); a.object = (C) object.clone(); return a; &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); return null; &#125; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; A aObj = new A(1, new C(2,3)); A bObj = (A) aObj.clone(); &#125;&#125; Spring中原型模式的应用：当指定bean的scope为prototype时，表示bean对象的创建是多例的，每次调用getBean方法都会复制一份。（深拷贝） 结构型模式适配器（Adapter）适配器模式将某个类的接口转换为客户端期望的另一个接口表示（现实生活中的转接头，充电头都是适配器），主要目的是解决兼容性问题，让原本因接口不匹配不能一起工作的两个类可以协同工作。 从用户的角度来看，用户是看不到被适配者目标的，感觉只是和适配器接口交互。 类适配器实现方式：Adapter类（适配器类）通过：继承src类（被适配类），实现dst接口（目标接口），完成src到dst的适配。 场景：以电源适配器为例，我们需要将220V（被适配类）的电压转换为5V（目标接口）： 12345678910111213/** * 被适配类 */public class Voltage220V &#123; /** * 输出220V的电压 * @return */ public int output220V()&#123; int src = 220; return src; &#125;&#125; 123456/** * 目标接口 */public interface Voltage5V &#123; public int output5V();&#125; 1234567891011/** * 适配器类继承自被适配类，实现目标接口 */public class VoltageAdapter extends Voltage220V implements Voltage5V &#123; @Override public int output5V() &#123; int src = super.output220V(); int dst = src / 44;//模拟变压操作 return dst; &#125;&#125; 12345678910111213141516171819/** * 模拟使用5V电压充电的手机 */public class Phone &#123; public void charge(Voltage5V voltage5V)&#123; int voltage = voltage5V.output5V(); if(voltage == 5) System.out.println(\"充电中...\"); else if(voltage &gt; 5) throw new RuntimeException(\"电压过高，不能充电！\"); &#125;&#125;public class Test &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); phone.charge(new VoltageAdapter()); &#125;&#125; 对象适配器实现方式：Adapter类（适配器类）通过：持有src类（被适配类）的实例，实现dst接口（目标接口），完成src到dst的适配。 根据“组合/聚合复用原则”，在系统中尽量使用聚合关系来替代继承关系，对象适配器模式是对类适配器的改进。 123456789101112131415161718/** * 适配器类持有被适配类对象，实现目标接口 */public class VoltageAdapter implements Voltage5V &#123; Voltage220V voltage220V; public VoltageAdapter(Voltage220V voltage220V)&#123; this.voltage220V = voltage220V; &#125; @Override public int output5V() &#123; int src = voltage220V.output220V(); int dst = src / 44;//模拟变压操作 return dst; &#125;&#125; 123456public class Test &#123; public static void main(String[] args) &#123; Phone phone = new Phone(); phone.charge(new VoltageAdapter(new Voltage220V())); &#125;&#125; 接口适配器又叫默认适配器模式，适用情景：使用者只想使用一个接口的部分方法，此时我们就需要一个默认适配器。 当不需要全部实现接口提供的方法时，可先设计一个抽象类适配器，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。 12345public interface ALotOfMethod &#123; public void m0(); public void m1(); public void m2();&#125; 12345678910public abstract class DefaultAdapter implements ALotOfMethod &#123; @Override public void m0() &#123;&#125; @Override public void m1() &#123;&#125; @Override public void m2() &#123;&#125;&#125; 12345678910111213public class Test &#123; public static void main(String[] args) &#123; DefaultAdapter defaultAdapter = new DefaultAdapter()&#123; //该匿名内部类是抽象类DefaultAdapter的子类 @Override public void m1()&#123; System.out.println(\"只使用m1方法\"); &#125; &#125;; defaultAdapter.m1(); &#125;&#125; Spring MVC中的HandlerAdapter就使用了适配器模式： HandlerAdapter的实现子类使得每一种Controller都有对应的适配器实现类。 装饰器（Decorator）装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式动态扩展对象的功能，是继承关系的一个替代方案。 装饰模式的类图： 在装饰模式中的角色有： 抽象构件(Component)角色：给出一个抽象接口，以规范准备接收增强功能的对象。 具体构件(ConcreteComponent)角色：定义一个将要接收增强的类。 装饰(Decorator)角色：持有一个抽象构建角色，并通过构造器注入具体构件角色。 具体装饰(ConcreteDecorator)角色：负责给构件对象附加增强功能。 例如，我们可以通过覆盖Http请求的方法来对数据进行转义，这里使用了装饰器模式。HttpServletRequest接口属于抽象构件角色；各服务器厂商的Request实现类属于具体构件角色；装饰角色为官方提供的HttpServletRequestWrapper类，其持有厂商的Request实现类；作为用户，我们只需要继承HttpServletRequestWrapper类作为具体装饰角色，重写Wrapper类的方法即可。 装饰模式在JDK中的应用有I/O标准库的设计，以InputStream为例： 上图中： 抽象构件(Component)角色：由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。 具体构件(ConcreteComponent)角色：由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。 抽象装饰(Decorator)角色：由FilterInputStream扮演。它实现了InputStream所规定的接口。 具体装饰(ConcreteDecorator)角色：由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。 代理（Proxy）参见：JDK动态代理. 代理模式与装饰模式在代码实现形式上几乎是一致的，区别只在于抽象层面我们分别赋予它们的含义。 行为模式模板方法（Template Method）模板方法模式：准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。 JDK中对模板方法模式最经典的应用就是J.U.C包中的AbstractQueuedSynchronizer类了。参考JUC之锁。 模板方法模式的类图如下： 这里涉及到两个角色： 抽象模板(Abstract Template)角色有如下责任： 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。 具体模板(Concrete Template)角色又如下责任： 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。 策略（Strategy）策略模式：针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。 策略模式类图： 这个模式涉及到三个角色： 环境(Context)角色：持有一个Strategy的引用。 抽象策略(Strategy)角色：这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。 具体策略(ConcreteStrategy)角色：包装了相关的算法或行为。 在客户端通过控制反转创建具体策略角色的前提下，策略模式使得客户端可以配置式地随时插入算法（新建一个ConcreteStrategy类）或更换算法。 场景：假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。 根据描述，折扣是根据以下的几个算法中的一个进行的： 算法一：对初级会员没有折扣。 算法二：对中级会员提供10%的促销折扣。 算法三：对高级会员提供20%的促销折扣。 代码如下： 12345678public interface MemberStrategy &#123; /** * 计算图书的价格 * @param booksPrice 图书的原价 * @return 计算出打折后的价格 */ public double calcPrice(double booksPrice);&#125; 1234567public class PrimaryMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println(\"对于初级会员的没有折扣\"); return booksPrice; &#125;&#125; 1234567public class IntermediateMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println(\"对于中级会员的折扣为10%\"); return booksPrice * 0.9; &#125;&#125; 1234567public class AdvancedMemberStrategy implements MemberStrategy &#123; @Override public double calcPrice(double booksPrice) &#123; System.out.println(\"对于高级会员的折扣为20%\"); return booksPrice * 0.8; &#125;&#125; 1234567891011public class Client &#123; public static void main(String[] args) &#123; //选择并创建需要使用的策略对象 MemberStrategy strategy = new AdvancedMemberStrategy(); //创建环境 Price price = new Price(strategy); //计算价格 double quote = price.quote(300); System.out.println(\"图书的最终价格为：\" + quote); &#125;&#125; 转载自：java_my_life. 观察者（Observer）观察者模式：观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。 一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。观察者模式是满足这一要求的各种设计方案中最重要的一种。 观察者模式类图如下： 观察者模式所涉及的角色有： 抽象主题(Subject)角色：抽象主题角色把所有对观察者对象的引用保存在一个集合（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供可以增加和删除观察者对象的方法，抽象主题角色又叫做抽象被观察者(Observable)角色。 具体主题(ConcreteSubject)角色：具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。 抽象观察者(Observer)角色：为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。 具体观察者(ConcreteObserver)角色：存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。 代码如下： 12345678910111213141516171819202122232425262728293031public class Subject &#123; /** * 用来保存注册的观察者对象 */ private List&lt;Observer&gt; list = new ArrayList&lt;Observer&gt;(); /** * 注册观察者对象 * @param observer 观察者对象 */ public void attach(Observer observer)&#123; list.add(observer); System.out.println(\"Attached an observer\"); &#125; /** * 删除观察者对象 * @param observer 观察者对象 */ public void detach(Observer observer)&#123; list.remove(observer); &#125; /** * 通知所有注册的观察者对象 */ public void nodifyObservers(String newState)&#123; for(Observer observer : list)&#123; observer.update(newState); &#125; &#125;&#125; 1234567public interface Observer &#123; /** * 更新接口 * @param state 更新的状态 */ public void update(String state);&#125; 12345678910111213public class ConcreteObserver implements Observer&#123; //观察者的状态 private String observerState; @Override public void update(String state) &#123; /** * 更新观察者的状态，使其与目标的状态保持一致 */ observerState = state; System.out.println(\"状态为：\"+observerState); &#125;&#125; 1234567891011121314public class ConcreteSubject extends Subject&#123; private String state; public String getState() &#123; return state; &#125; public void change(String newState)&#123; state = newState; System.out.println(\"主题状态为：\" + state); //状态发生改变，通知各个观察者 this.nodifyObservers(state); &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; ConcreteSubject subject = new ConcreteSubject(); Observer observer = new ConcreteObserver(); subject.attach(observer); subject.change(\"new State\"); &#125;&#125; 拉模型与推模型 在观察者模式中，又分为推模型和拉模型两种方式。 推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。 拉模型：主题对象在通知观察者时，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，会把主题对象自身的引用通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。 很显然上述的代码示例是推模型。 JAVA提供的对观察者模式的支持 在JAVA语言的java.util库里面，提供了一个Observable类以及一个Observer接口，构成JAVA语言对观察者模式的支持。 Observer接口 这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。 所有的观察者类都需要实现该接口。 123public interface Observer &#123; void update(Observable o, Object arg);&#125; Observable类 被观察者类（主题类）都是java.util.Observable类的子类。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是setChanged()，另一个是notifyObservers()。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。 责任链（Chain Of Responsibility）责任链模式：在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。 UML类图： 责任链模式涉及到的角色如下所示： 抽象处理者(Handler)角色：定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。 具体处理者(ConcreteHandler)角色：具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。 场景：公司申请聚餐费用的管理。 ​ 申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。 不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。 也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。 ​ 可以使用责任链模式来实现上述功能：当某人提出聚餐费用申请的请求后，该请求会在 项目经理—〉部门经理—〉总经理 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。 类图如下： 源代码参考GitHub. Spring MVC中的HandlerExecutionChain就使用到了责任链模式。 Spring中的设计模式总结参考：https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring-Design-Patterns","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://thmasterplan.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]},{"title":"SpringBoot","slug":"SpringBoot","date":"2020-10-28T01:26:07.000Z","updated":"2021-01-21T04:32:59.526Z","comments":true,"path":"JavaWeb/SpringBoot/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/SpringBoot/","excerpt":"","text":"配置SpringBoot使用一个全局的配置文件，文件名是固定的application。有两种格式的配置文件： property：application.properties yaml：application.yml 该配置文件用于修改SpringBoot自动配置的默认值。SpringBoot会扫描以下位置的全局配置文件，优先级从高到低如下：项目根目录/config/， 项目根目录/，resources/config/， resources/，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置。Spring Boot还支持多种外部配置方式。 YAML 属性: 值表示一对键值对，冒号后的空格是必须的。 使用空格的缩进表示层级关系，只要是左对齐的一列属性都是同一层级的。 属性和值大小写敏感。 值的类型可以有： 基本数据类型与字符串：可以不使用单引号或双引号。 对象，Map。例如： 123456#写法1user: name: zhangsan age: 20#写法2user: &#123;name: zhangsan, age: 18&#125; 数组, Set, List。例如： 1234567#写法1array: - a - b - c#写法2array: [a, b, c] 注意：YAML不支持使用注解@PropertySource导入配置。 获取配置文件中的值YAML文件： 12345age: 20name: zhangsanuser: name: zhaosi age: 24 实体类User： 12345678@Setter@ToString@Component@ConfigurationProperties(prefix = \"user\")public class User &#123; private String name; private int age;&#125; 测试类： 12345678910111213141516171819202122@SpringBootTest//指定入口类或测试环境@RunWith(SpringRunner.class)public class YamlTest &#123; @Value(\"$&#123;age&#125;\")//自动注入 private int age; @Value(\"$&#123;name&#125;\")//自动注入 private String name; @Autowired private User user; @Test public void getProperty()&#123; System.out.println(name+\":\"+age); &#125; @Test public void getUser()&#123; System.out.println(user.toString()); &#125;&#125; @ConfigurationProperties注解：把同类配置信息自动封装成一个实体类，其属性prefix指定配置文件配置项的前缀。 另一种使用@ConfigurationProperties该注解的方式是，不需要在实体类上注解@Component和@ConfigurationProperties，而是在配置类使用@Bean注解： 12345@Bean@ConfigurationProperties(prefix=\"user\")public User getUserBean()&#123; return new User();&#125; 导入配置文件处理器，配置文件值绑定时就会有提示： 1234&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt;&lt;/dependency&gt; @ConfigurationProperties只能用于SpringBoot的全局配置文件application，而@PropertySource可以用于加载指定的配置文件，但是后者不支持yaml格式。 @Value只能用于基本数据类型的注入，且支持#{SpEL}表达式。 @ImportReSource：用于加载Spring的XML配置文件。SpringBoot不推荐使用这种方式，而是使用全注解的方式，即创建配置类。 配置文件占位符RandomValuePropertySource可以在配置文件中使用该类的随机数。使用方式：${random.value}, ${random.uuid}, ${random.int}, ${random.long}, ${random.int(10)},${random.(10,100)}。 属性配置占位符可以在配置文件中引用前面配置过的属性，例如： 1234app.name=MyAppapp.description=$&#123;app.name&#125; is a Spring Boot App.#或者如果前面没有配置，也可配置默认值app.description=$&#123;app.name: DefaultAppName&#125; is a Spring Boot App. 配置多环境在实际项目的开发过程中，经常需要配置多个环境（比如开发环境和生产环境），以便不同的环境使用不同配置参数。 多配置文件方式在resources目录下创建三个配置文件： application-dev.yml： 123456server: port: 8080 tomcat: uri-encoding: UTF-8env: name: development application-prod.yml： 123456server: port: 8888 tomcat: uri-encoding: UTF-8env: name: produce application.yml： 123spring: profiles: active: development #指定当前活动的配置文件为application-dev.yml properties格式同理：spring.profiles.active=development 文档块方式123456789101112131415161718server: port: 8080 #默认为8080spring: profiles: active: dev #激活dev则使用8081---server: port: 8081spring: profiles: dev ---server: port: 8082spring: profiles: prod 命令行方式加入选项--spring.profiles.active=prod即可。 application配置文件可以配置哪些属性？参照官方文档。 日志SLF4J(Simple Logging Facade for Java)：抽象层日志框架。 LogBack：具体的日志框架实现。 spring-boot-starter-logging采用了SLF4J + LogBack实现日志功能，我们在开发的时候应该使用抽象层框架SLF4J，而LogBack的实现则是用于配置，这是依赖倒置原则与里氏替换原则的体现。 当我们引入其他依赖时，该依赖使用的日志框架可能与Spring Boot的实现方案不同，比如可能是JUL，log4j, log4j2等等。为了统一日志框架，SLF4J提供了常见日志框架实现的转换方案。我们唯一要做的就是在引入其他依赖时，排除掉其使用的日志框架即可，以此来避免SLF4J提供的转换jar包与之冲突。比如，Spring使用的就是commons-logging日志框架，在引入spring-core时，我们需要如此做： 12345678910&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;exclusions&gt; &lt;exclusion&gt; &lt;groupId&gt;commons-logging&lt;/groupId&gt; &lt;artifactId&gt;commons-logging&lt;/artifactId&gt; &lt;/exclusion&gt; &lt;/exclusions&gt; &lt;/dependency&gt; SLF4J的使用基本使用12345678910//日志记录器 Logger logger = LoggerFactory.getLogger(getClass());//日志级别//由低到高：trace &lt; debug &lt; info &lt; warn &lt; errorlogger.trace(\"trace...\");logger.debug(\"debug...\");logger.info(\"info...\");logger.warn(\"warn...\");logger.error(\"error...\"); Spring Boot默认使用info级别及以上的日志级别，所以trace和debug日志信息是不会输出到控制台的。我们可以在application配置文件中调整日志级别： 1logging.level.com.example=trace 以上配置的含义是：com.example包下的所有代码日志级别调整为trace及以上。 常见日志配置如果我们不指定日志输出文件和路径，日志只会在控制台中输出。 在application配置文件中： 12345678910111213#默认生成日志文件到当前项目根目录下logging.file=mylog.log#也可指定路径logging.file=G:/mylog.log#或者在当前磁盘下生成a目录，a目录下生成b目录，b目录下默认生成spring.log日志文件logging.path=/a/b# [从左显示的] #指定控制台输出的日志格式 [ 时间 ] [ 线程名 ][字符宽度][最长50个字符] [日志消息与换行符]logging.pattern.console=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n#指定文件中日志输出的格式logging.pattern.file=%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; *** [%thread] *** %-5level *** %logger&#123;50&#125; ： %msg%n 我们也可在resources下放入各个日志框架自己的配置文件，Spring Boot就不会使用默认配置了。 Logging System Customization Logback logback-spring.xml, logback-spring.groovy, logback.xml, or logback.groovy Log4j2 log4j2-spring.xml or log4j2.xml JDK (Java Util Logging) logging.properties 切换日志框架假设要替换为log4j： 在pom.xml中选中spring-boot-starter-logging，右键Diagrams打开依赖树； 选中logback-classic，右键Exclude; 选中log4j-over-slf4j，右键Exclude，也即删除SLF4J的覆盖方案； 导入SLF4J对log4j的适配方案依赖slf4j-log4j12。 JSR 303 – Bean ValidationJSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。JSR - 303 为 JavaBean 验证定义了相应的元数据模型和 API。 在任何时候，当你要处理一个应用程序的业务逻辑，数据校验是你必须要考虑和面对的事情。应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在通常的情况下，应用程序是分层的，不同的层由不同的开发人员来完成。很多时候同样的数据验证逻辑会出现在不同的层，这样就会导致代码冗余和一些管理的问题，比如说语义的一致性等。为了避免这样的情况发生，最好是将验证逻辑与相应的域模型进行绑定。 Hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。 Bean Validation中的constraint Constraint 被注解的属性： @Valid 是一个对象，需要检查此对象的所有字段值（级联验证） @Null 必须为 null @NotNull 必须不为 null @AssertTrue 必须为 true @AssertFalse 必须为 false @Min(value) 必须是一个数字，其最小值为value @Max(value) 必须是一个数字，其最大值为value @DecimalMin(value) 必须是一个数字，其最小值为value @DecimalMax(value) 必须是一个数字，其最大值为value @Size(max, min) 大小必须在指定的范围内 @Digits (integer, fraction) 必须是一个数字，其值必须在可接受的范围内 @Past 必须是一个过去的日期 @Future 必须是一个将来的日期 @Pattern(value) 必须符合指定的正则表达式 Hibernate Validator 附加的 constraint Constraint 被注解的属性： @Email 必须是电子邮箱地址 @Length(min=, max=) 必须是字符串，其大小必须在指定的范围内 @NotEmpty 若是字符串，则必须不为null；若是集合，则集合size &gt; 0 @Range(min=, max=) 必须在合适的范围内 @NotBlank 必须是字符串，且trim()后的length &gt; 0 @URL 必须是字符串，且是一个有效的url @CreditCardNumber 必须是字符串，且是合法的银行卡/信用卡 @ScriptAssert 要有JSR 223 - Java Scripting API的实现 @SafeHtml classpath中要有jsoup包 随着Hibernate Validator版本的迭代，也更新了一些其他的constraint，可在IDEA右侧工具栏的Bean Validation中查看。 使用Hibernate Validator可以写一个统一的校验类，然后在service层或controller层中调用校验类的校验方法。若有参数不合法，则可使用自定义的异常类抛出参数不合法的异常信息。参考 自定义constraint 自定义注解，参考Hibernate实现的注解。 自定义validator实现ConstraintValidator接口，并实现isValid方法。 将自定义validator赋值给@Constraint的validateBy属性。 示例：自定义constraint, 校验参数必须是3的倍数。 1234567891011@Target(&#123;ElementType.Field&#125;)@Retention(RetentionPolicy.RUNTIME)@Documented@Constraint(validateBy = &#123;MultipleOfThreeForInteger.class&#125;)public @interface MultipleOfThree&#123; String message() default \"必须是3的倍数\"; Class&lt;?&gt;[] groups() default &#123;&#125;; Class&lt;? extends Payload&gt;[] payload() default &#123;&#125;;&#125; 1234567891011public MultipleOfThreeForInteger implements ConstraintValidator&lt;MultipleOfThree, Integer&gt;&#123; @Override public void initialize(MultipleOfThree constraintAnnotation)&#123; &#125; @Override public boolean isValid(Integer value, ConstraintValidatorContext context)&#123; return value % 3 == 0; &#125;&#125; 至此，@MultipleOfThree就可以用于参数验证了。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"SpringBoot","slug":"SpringBoot","permalink":"http://thmasterplan.cn/tags/SpringBoot/"}]},{"title":"IDEA使用技巧","slug":"IDEA使用技巧","date":"2020-10-25T07:25:43.000Z","updated":"2021-01-07T06:10:42.207Z","comments":true,"path":"杂项/IDEA使用技巧/","link":"","permalink":"http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","excerpt":"","text":"IDEA插件推荐 Material Theme UI Lombok Alibaba Java Coding Guidelines Generate SerialVersionUID Maven Helper Codota SequenceDiagram Stack trace to UML 快捷键 自定义高复用代码块 设置代码模板 Debug 条件断点 IDEA插件推荐Material Theme UI该插件可更改IDEA的主题，默认的主题就很吼看啦： 五彩斑斓的黑！Ohhhhhhhhhhhhhhhhh~ 该插件可结合插件Atom Materail Icons修改UI图标。 Lombok使用该插件可以在编辑器中简化冗长的代码，尤其是POJO类。使用Lombok需要添加依赖： 1234&lt;dependency&gt; &lt;groupId&gt;org.projectlombok&lt;/groupId&gt; &lt;artifactId&gt;lombok&lt;/artifactId&gt;&lt;/dependency&gt; Lombok使用注解来开启相应的功能： @Data：自动生成Getter/Setter/toString/equals/hashCode方法，以及不带参数的构造方法。 @NonNull：帮助处理NPE异常。 @CleanUp：自动管理资源，不用再在finally中添加资源的close方法。 @Setter/@Getter：自动生成Setter/Getter方法。 @ToString：自动生成toString方法。 @EqualsAndHashCode：从对象的字段中重写hashCode和equals方法。 @NoArgsConstructor/RequiredArgsConstructor/@AllArgsConstructor：自动生成构造方法。 @Value：用于注解final类。 @Builder：产生复杂的构建器API类。 SneakyThrows：用于异常处理。 @Synchronized：同步方法的转化。 @Log：支持使用各种日志对象。 Alibaba Java Coding Guidelines与”阿里巴巴Java开发规范手册”对应的插件，可自动检测代码中不符合规范的地方。 Generate SerialVersionUID当你的一个类实现了序列化接口后，按Alt+Insert就可以自动生成序列化ID了。 Maven Helper该插件可自动检测Maven依赖是否有jar包冲突，帮助我们进行依赖管理。 Codota该插件支持： 智能代码自动提示，该功能可以增强 IDEA 的代码提示功能。 JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。 SequenceDiagram该插件可根据代码调用链路自动生成时序图。光标停止在调用函数上，右键’Sequence Diagram’即可生成时序图。 Stack trace to UML该插件可根据 JVM 异常堆栈画 UML时序图和通信图。使用方式： Analyze &gt; Open Stack trace to UML plugin 。 快捷键修改快捷键：File -&gt; Settings -&gt; Keymap. 自动代码补全：Ctrl+Shift+Space。 查看类的源码：在光标所在的类名上Ctrl+B。 搜索类并查看源码：Ctrl+N。 自动生成setter/getter/构造器/测试方法/Copyright/SerialVersionUID等：Alt+Insert。 提示方法参数列表：Ctrl+P。 快速修复错误：Alt+Enter。（超常用，比如导入光标所在类的包） 提交修改到新版本（Git）：Ctrl+K。 自定义高复用代码块File -&gt; Settings -&gt; Editor -&gt; Live Templates -&gt; 右键+，Abbreviation代表添加缩写语句。IDEA内置常用的高复用代码块如下： psvm/main：生成public static void main(String[] args) {} sout/soutp：生成System.out.println();，区别是后者光标在;后面。 fori：生成for (int i = 0; i &lt; ; i++) {} foreach：for (:) {} psf/psfi/psfs：public static final/public static final int/public static final String prsf：private static final ifn：if ( == null) {} 设置代码模板File -&gt; Settings -&gt; Editor -&gt; File and Code Template. Includes中可以添加注释信息，之后每一个新生成的Java类头部都会生成该注释。例如： 12345/** * @author: lsj * @date: $&#123;DATE&#125; $&#123;TIME&#125; * Description: */ Debug调试栏的按钮用处如下表： 按钮 说明 (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行 (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。 (F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内，不会进入官方类库的方法。 (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。 (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。 回退断点。 (Alt + F9)：运行到光标处，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。 (Alt + F8)：计算表达式。可以输入对象调用其set方法设置值，而不用修改源码或重新请求。 跳转到下一个断点处。 查看并设置所有断点信息。 禁止所有断点。 获取线程的运行状态、标识和调用的堆栈信息。 条件断点右键单击断点处即可设置条件断点，通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。 多线程调试时，需要调整断点挂起级别为Thread。 CMD切换编码 chcp命令：chcp 65001 -&gt; 切换为UTF-8；chcp 936 -&gt; 切换为GBK。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"Git","slug":"Git","date":"2020-10-25T06:33:13.000Z","updated":"2020-11-23T14:23:21.002Z","comments":true,"path":"杂项/Git/","link":"","permalink":"http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/Git/","excerpt":"","text":"版本控制 本地版本控制系统 集中化版本控制系统 分布式版本控制系统 Git配置 Git的原理 Git三大区域 实体、引用与索引 实体 引用 索引 Git项目搭建 本地新建 远程克隆 Git文件操作 文件的四种状态 常用命令 忽略文件 为注释 Git分支 分支合并 Idea集成Git 克隆云端项目到IDEA 版本控制版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便查看更改历史记录，备份以便恢复以前的版本的软件工程技术。最重要的是可以实现跨区域多人协同开发。 本地版本控制系统最流行的是RCS。 记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件（补丁指文件修订前后的变化），适合个人用。 集中化版本控制系统最流行的是SVN。 所有的版本数据都保存在服务器上，用户在服务器上同步更新或上传自己的修改。用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。 管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。 缺点是服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。当然可以在服务端进行主从备份。 分布式版本控制系统最流行的是Git。 客户端拥有代码仓库的完整镜像，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。 对于数据权限敏感性高的公司来说不适用。 Git配置使用git config命令查看所有的配置选项。其中： 查看系统配置：git config --system -l，其配置文件所在：安装路径\\Git\\etc\\gitconfig。 查看用户配置：git config --global -l ，其配置文件所在：C:\\Users\\用户名\\.gitconfig。 设置用户名与邮箱（必要）：每次提交都会用到该用户标识。 12git config --global user.name \"zhangsan\"git config --global user.email \"1234@126.com\" Git的原理Git三大区域 工作区：存放项目代码的地方。 暂存区：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。 本地版本库：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据，每提交一次修改就会有一个新的版本。其中HEAD指向最新放入仓库的版本。 三大区域与远程库交互的图示如下： 实体、引用与索引实体 提交到本地仓库中的所有文件，包括每个提交的说明信息，目录结构等都会转换成实体。 所有实体均存在于.git/objects/目录中。 git中每一个实体以一个40字符长度的十六进制字符串来唯一标识。 git中包括四种类型的实体： blob：文件内容。 tree：文件名与目录结构。 commit：提交的作者、日期与说明等。 tag：指向某提交对象的引用。 引用 Git 中，一个分支（branch）、远程分支（remote branch）或一个标签（tag）仅是指向一个实体的一个指针，这里的实体通常是一个commit实体。这些引用以文本文件的形式存储在目录 .git/refs/ 中。 Git 有一种特殊的引用，称为符号引用。它并不直接指向一个实体，而是指向另一个引用。比如，.git/HEAD就是一个符号引用。它指向你正在工作的当前分支的最新版本，初始为main分支。 索引 索引是一个暂存区，以二进制文件的形式存储为文件 .git/index 中。当git add 一个文件，git 将该文件的信息添加到索引中；当git commit时，git 仅提交索引文件中列出的文件到 git 本地仓库。 实体、引用与索引的关系如图： Git项目搭建本地新建 在项目根目录下：git init，就会生成.git目录。 本地生成SSH公钥：ssh-keygen rsa命令生成公钥，生成目录为用户目录下的.ssh文件夹，拷贝公钥id_rsa.pub的文本到github/gitee/gitlab对应处，即可无需密码登录。 git branch -M main：重命名默认分支名master为主分支main。 在项目根目录下：git remote add origin [远程仓库地址]，给远程仓库地址命名为origin，方便后续使用。远程仓库地址SSH方式示例：git@github.com:Github用户名/项目名.git。 在项目根目录下：git push -u origin main，将main分支push到远程仓库。 远程克隆 在本地没有项目的情况下初次克隆：git clone [url]。 在本地已有项目的情况下：git pull origin main。 Git文件操作文件的四种状态版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态。 使用git status查看文件状态。 Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。 Staged：暂存状态。 Committed：文件已经提交到本地仓库。 Modified： 工作目录中文件若已修改，通过git add可进入暂存staged状态，git commit提交修改到本地仓库；也可使用git checkout丢弃修改，即从仓库中取出之前的版本覆盖当前修改。 git状态转换如图所示： 常用命令 git add .：添加当前目录所有文件到暂存区。 git commit -m &quot;提交信息&quot;：提交。 忽略文件有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等 在主目录下建立.gitignore文件(IDEA项目会自动生成)，此文件有如下规则： 空行或以#开始的行将会被忽略。 可以使用Linux通配符。例如：*代表任意多个字符，?代表一个字符，[abc]代表可选字符范围，{string1,string2,...}代表可选的字符串等。 如果名称的最前面有一个感叹号!，表示例外规则，将不被忽略。 例： 123456#为注释*.txt #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！!lib.txt #但lib.txt除外&#x2F;temp #忽略temp同级目录其他文件和目录，不忽略temp目录build&#x2F; #忽略build&#x2F;目录下的所有文件doc&#x2F;*.txt #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt Git分支每个分支有多个版本，每提交一次修改就会有一个新的版本，HEAD指向当前分支的最新版本。 Git默认创建分支master，使用git branch查看当前所有分支。 在商业项目开发中，不会轻易在主分支上操作，而是建立一个开发用的分支，最后将成熟的代码添加到主分支上。 创建新分支：git branch 分支名。新分支与当前分支指向同一个提交点（版本），切换到新分支后的提交才是新分支独有的。 切换到另一个分支：git checkout 分支名。 查看分支提交日志：git log --oneline或git log。 分支合并 快速合并： 假设某时刻在main分支，git branch dev创建dev分支，git checkout dev切换到dev分支，此时main和dev都指向最新的同一个版本，如图所示： 添加某个文件test，git add test-&gt;git commit -m &quot;test merge&quot;提交形成新版本后，dev指向了新版本而main还在前一个版本，如何让main分支与dev合并呢？如图所示： git checkout main先切回main分支，然后git merge dev，此时Git的实际操作是将main指针指向dev指向的同一个版本实体，因此称为快速合并。 快速合并前提：一个分支没有变化，另一个分支有新版本的情况。如果两个分支都有修改则不适用。 三方合并： 适用于两个分支都有新版本的情况。 假设某时刻在main分支，git branch dev创建dev分支，git checkout dev切换到dev分支，此时main和dev都指向最新的同一个版本； 添加某个文件test，git add test-&gt;git commit -m &quot;test merge&quot;提交形成新版本，dev指向了新版本； git checkout main切换回main分支，修改某个文件，提交形成新版本，main指向了新版本； git merge dev，创建新版本，该版本是main分支的修改版本与dev修改版本的合并，main指针指向该新版本，dev则不变，依旧指向其修改的那个版本。 合并冲突：两个分支都对以前相同版本的某个文件进行了修改，如何合并呢？ Git会将两个分支的修改都保留下，由用户协商进行保留。 Idea集成GitIDEA在顶部菜单栏VCS选项下集成了版本控制功能，选择Import into Version Control，选择Create Git Repository即可。 项目目录中，红色表示该文件状态为Untracked，蓝色表示文件被修改（Modified），否则则是被忽略。 VCS-&gt;Git-&gt;Push-&gt;Define remote设置远程仓库URL，即可push本地仓库到云端。 克隆云端项目到IDEAVCS-&gt;Checkout from Version Control-&gt;Git，填入URL","categories":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"Git","slug":"Git","permalink":"http://thmasterplan.cn/tags/Git/"}]},{"title":"MyBatis","slug":"MyBatis","date":"2020-10-21T04:12:46.000Z","updated":"2020-11-23T14:23:21.066Z","comments":true,"path":"JavaWeb/MyBatis/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/MyBatis/","excerpt":"","text":"全局配置文件 约束 properties标签（不常用） settings标签 typeAliases标签 typeHandlers标签 enviroments标签 事务管理器（transactionManager） 数据源（DataSource） databaseIdProvider标签 mappers标签 mapper子标签 package子标签 plugins标签 objectFactory标签 映射文件 约束 select, insert, update和delete标签 sql标签 DAO接口方法参数值与SQL语句字段值的传递 结果映射(ORM)) 自动映射 自定义结果集映射: resultMap 动态SQL if标签 trim标签 choose标签 set标签 foreach标签 script bind标签 缓存 一级缓存 二级缓存 缓存相关配置 逆向工程 全局配置文件MyBatis官方文档 约束1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt; properties标签（不常用）使用该标签可引入外部properties配置文件的内容，或在子标签property中进行配置： 1234&lt;properties resource=\"org/mybatis/example/config.properties\"&gt; &lt;property name=\"username\" value=\"dev_user\"/&gt; &lt;property name=\"password\" value=\"F2Fa3!33TYyg\"/&gt;&lt;/properties&gt; 设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如： 123456&lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt;&lt;/dataSource&gt; settings标签 设置名 描述 cacheEnabled 全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。 lazyLoadingEnabled 延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 fetchType 属性来覆盖该项的开关状态。 aggressiveLazyLoading 开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 lazyLoadTriggerMethods)。 multipleResultSetsEnabled 是否允许单个语句返回多结果集（需要数据库驱动支持）。 useColumnLabel 使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。 useGeneratedKeys 允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。 autoMappingBehavior 指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。 autoMappingUnknownColumnBehavior 指定发现自动映射目标未知列（或未知属性类型）的行为。NONE: 不做任何反应WARNING: 输出警告日志（&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39; 的日志等级必须设置为 WARN）FAILING: 映射失败 (抛出 SqlSessionException) defaultExecutorType 配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。 defaultStatementTimeout 设置超时时间，它决定数据库驱动等待数据库响应的秒数。 defaultFetchSize 为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。 defaultResultSetType 指定语句默认的滚动策略。（新增于 3.5.2） safeRowBoundsEnabled 是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。 safeResultHandlerEnabled 是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。 mapUnderscoreToCamelCase 是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。 localCacheScope MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 jdbcTypeForNull 当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。 lazyLoadTriggerMethods 指定对象的哪些方法触发一次延迟加载。 defaultScriptingLanguage 指定动态 SQL 生成使用的默认脚本语言。 defaultEnumTypeHandler 指定 Enum 使用的默认 TypeHandler 。（新增于 3.4.5） callSettersOnNulls 指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。 returnInstanceForEmptyRow 当返回行的所有列都是空时，MyBatis默认返回 null。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2） logPrefix 指定 MyBatis 增加到日志名称的前缀。 logImpl 指定 MyBatis 所用日志的具体实现，未指定时将自动查找。 proxyFactory 指定 Mybatis 创建可延迟加载对象所用到的代理工具。 vfsImpl 指定 VFS 的实现 useActualParamName 允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 -parameters 选项。（新增于 3.4.1） configurationFactory 指定一个提供 Configuration 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为static Configuration getConfiguration() 的方法。（新增于 3.2.3） shrinkWhitespacesInSql 从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5) defaultSqlProviderType Specifies an sql provider class that holds provider method (Since 3.5.6). This class apply to the type(or value) attribute on sql provider annotation(e.g. @SelectProvider), when these attribute was omitted. 使用示例： 1234567891011121314151617&lt;settings&gt; &lt;setting name=\"cacheEnabled\" value=\"true\"/&gt; &lt;setting name=\"lazyLoadingEnabled\" value=\"true\"/&gt; &lt;setting name=\"multipleResultSetsEnabled\" value=\"true\"/&gt; &lt;setting name=\"useColumnLabel\" value=\"true\"/&gt; &lt;setting name=\"useGeneratedKeys\" value=\"false\"/&gt; &lt;setting name=\"autoMappingBehavior\" value=\"PARTIAL\"/&gt; &lt;setting name=\"autoMappingUnknownColumnBehavior\" value=\"WARNING\"/&gt; &lt;setting name=\"defaultExecutorType\" value=\"SIMPLE\"/&gt; &lt;setting name=\"defaultStatementTimeout\" value=\"25\"/&gt; &lt;setting name=\"defaultFetchSize\" value=\"100\"/&gt; &lt;setting name=\"safeRowBoundsEnabled\" value=\"false\"/&gt; &lt;setting name=\"mapUnderscoreToCamelCase\" value=\"false\"/&gt; &lt;setting name=\"localCacheScope\" value=\"SESSION\"/&gt; &lt;setting name=\"jdbcTypeForNull\" value=\"OTHER\"/&gt; &lt;setting name=\"lazyLoadTriggerMethods\" value=\"equals,clone,hashCode,toString\"/&gt;&lt;/settings&gt; typeAliases标签 为Java的全类名设置缩短的别名： 123&lt;typeAliases&gt; &lt;typeAlias alias=\"Author\" type=\"domain.blog.Author\"/&gt;&lt;/typeAliases&gt; 也可以指定一个包名(批量设置别名)，MyBatis 会在包名下面搜索需要的 Java Bean。每一个在包 domain.blog 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 domain.blog.Author 的别名为 author；若有注解，则别名为其注解值： 123&lt;typeAliases&gt; &lt;package name=\"domain.blog\"/&gt;&lt;/typeAliases&gt; 1234@Alias(\"author\")public class Author &#123; // ...&#125; 注意：我们设置的别名不能与MyBatis的内置别名（见文档）冲突。 typeHandlers标签MyBatis在设置PreparedStatement中的参数或从结果集取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。在官方文档中描述了一些默认的类型处理器。 我们可以重写已有的类型处理器或自己创建类型处理器来处理不支持的或非标准的类型：实现 org.apache.ibatis.type.TypeHandler接口， 或继承 org.apache.ibatis.type.BaseTypeHandler， 并且可以（可选地）将它映射到一个 JDBC 类型。 1234567891011121314151617181920212223@MappedJdbcTypes(JdbcType.VARCHAR)public class ExampleTypeHandler extends BaseTypeHandler&lt;String&gt; &#123; @Override public void setNonNullParameter(PreparedStatement ps, int i, String parameter, JdbcType jdbcType) throws SQLException &#123; ps.setString(i, parameter); &#125; @Override public String getNullableResult(ResultSet rs, String columnName) throws SQLException &#123; return rs.getString(columnName); &#125; @Override public String getNullableResult(ResultSet rs, int columnIndex) throws SQLException &#123; return rs.getString(columnIndex); &#125; @Override public String getNullableResult(CallableStatement cs, int columnIndex) throws SQLException &#123; return cs.getString(columnIndex); &#125;&#125; 1234&lt;!-- mybatis-config.xml --&gt;&lt;typeHandlers&gt; &lt;typeHandler handler=\"org.mybatis.example.ExampleTypeHandler\"/&gt;&lt;/typeHandlers&gt; 使用上述的类型处理器将会覆盖默认的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。 enviroments标签MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。例如： 1234567891011121314151617181920&lt;environments default=\"development\"&gt; &lt;！--指定默认使用哪种环境 --&gt; &lt;!--测试使用的环境--&gt; &lt;environment id=\"test\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; ..... &lt;/dataSource&gt; &lt;/environment&gt; &lt;!--开发使用的环境--&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"&gt;&lt;/transactionManager&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"$&#123;driver&#125;\"/&gt; &lt;property name=\"url\" value=\"$&#123;url&#125;\"/&gt; &lt;property name=\"username\" value=\"$&#123;username&#125;\"/&gt; &lt;property name=\"password\" value=\"$&#123;password&#125;\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt;&lt;/environments&gt; 不过，尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。所以，需要连接N个数据库，就需要创建N个SqlSessionFactory实例，每个数据库对应一个SqlSessionFactory。 事务管理器（transactionManager）在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）。如果使用 Spring + MyBatis，则没有必要配置事务管理器，因为 Spring 模块会使用自带的管理器来覆盖MyBatis的配置。 数据源（DataSource）dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）: UNPOOLED：不使用连接池，每次请求时打开和关闭连接。 POOLED：使用连接池。该别名对应的类为PooledDataSourceFactory，其构造方法如下： 123public PooledDataSourceFactory() &#123; this.dataSource = new PooledDataSource(); &#125; 常用属性见官方文档。 JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。 使用自定义数据源：实现接口org.apache.ibatis.datasource.DataSourceFactory或者继承org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory，dataSource标签的type属性指定实现类的全类名。 databaseIdProvider标签 为支持多厂商特性，MyBatis 可以根据不同的数据库厂商执行不同的语句。示例： 12345678&lt;!--DB_VENDOR：VendorDatabaseIdProvider的别名，其作用是得到数据库厂商的标识--&gt;&lt;databaseIdProvider type=\"DB_VENDOR\"&gt; &lt;!--为不同的数据库厂商取别名--&gt; &lt;property name=\"MySQL\" value=\"mysql\"&gt;&lt;/property&gt; &lt;property name=\"SQL Server\" value=\"sqlserver\"/&gt; &lt;property name=\"Oracle\" value=\"oracle\" /&gt; &lt;property name=\"DB2\" value=\"db2\"/&gt;&lt;/databaseIdProvider&gt; 同时在映射文件具体的SQL语句配置中指定数据库厂商别名(databaseId属性)： 123&lt;select id=\"getUserById\" resultType=\"org.example.pojo.User\" databaseId=\"mysql\"&gt; select id, last_name lastName, gender,email from user where id = #&#123;id&#125;&lt;/select&gt; mappers标签该标签告诉MyBatis去哪里找映射文件。 mapper子标签有如下属性： resource：引用相对类路径下的映射文件。 url：引用网络或磁盘路径下的映射文件。 class：使用DAO接口的全类名。（注解配置） package子标签name属性指定DAO所在的包名：将包内的所有DAO接口实现全部注册为映射器（所谓映射器就是dao接口的代理对象）。(注解配置) plugins标签MyBatis 允许我们在映射语句执行过程中的某一点进行拦截调用（动态代理）。默认情况下，MyBatis 允许使用插件来拦截的方法有： Executor ：update, query, flushStatements, commit, rollback, getTransaction, close, isClosed. ParameterHandler ：getParameterObject, setParameters. ResultSetHandler ：handleResultSets, handleOutputParameters. StatementHandler ：prepare, parameterize, batch, update, query. objectFactory标签每次 MyBatis 创建结果对象的新实例时，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。具体使用参见文档。 使用场景：比如在学校系统中，学生除了有基础信息，我们还想临时添加一个总成绩的属性用来表示最近一次成绩总分。这个时候我们就可以通过自定义ObjectFactory来实现了。在创建好对象后在去查询数据进行填充。 映射文件MyBatis官方文档 约束1234&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt; select, insert, update和delete标签CRUD Demo。mapper.xml示例： 1234567891011121314151617181920212223242526&lt;mapper namespace=\"org.example.dao.IUserMapper\"&gt; &lt;!--增--&gt; &lt;insert id=\"addUser\"&gt; insert into user(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; &lt;!--使用useGeneratedKeys和keyProperty属性获取自增长ID并将其封装给pojo对应的成员变量id，这两个属性仅适用于insert和update标签 &lt;insert id=\"addUser\" useGeneratedKeys=\"true\" keyProperty=\"id\"&gt; insert into user(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;) &lt;/insert&gt; --&gt; &lt;!--删--&gt; &lt;delete id=\"deleteUserById\"&gt; delete from user where id=#&#123;id&#125; &lt;/delete&gt; &lt;!--改--&gt; &lt;update id=\"updateUser\"&gt; update user set last_name=#&#123;lastName&#125;, gender=#&#123;gender&#125;, email=#&#123;email&#125; where id=#&#123;id&#125; &lt;/update&gt; &lt;!--查--&gt; &lt;select id=\"getUserById\" resultType=\"org.example.pojo.User\"&gt; select id, last_name, gender,email from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 测试方法示例： 12345678910111213141516171819202122232425@Testpublic void testCRUD() throws IOException &#123; InputStream inputStream = Resources.getResourceAsStream(\"MyBatisConfig.xml\"); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); //sqlSessionFactory.openSession(true);表示自动提交 SqlSession openSession = sqlSessionFactory.openSession();//需要手动提交 try&#123; IUserMapper userMapper = openSession.getMapper(IUserMapper.class); //增 //userMapper.addUser(new User(null, \"张三\", \"abd@gmail.com\", \"男\")); //删 //userMapper.deleteUserById(5); //改 //userMapper.updateUser(new User(1, \"Tom\", \"abcdefg@126.com\",\"男\")); //查 System.out.println(userMapper.getUserById(2)); //手动提交 openSession.commit(); &#125;finally &#123; openSession.close(); &#125;&#125; 另外，MyBatis允许增删改的DAO接口方法定义以下类型返回值（不需要在mapper.xml中定义返回属性）：Integer/Long/Boolean/void。 sql标签用于定义可重用的sql片段，方便后面引用。 123&lt;sql id=\"insertColumn\"&gt; id,last_name,email,gender&lt;/sql&gt; 引用： 123456&lt;insert id=\"addUser\"&gt; insert into user( &lt;include refid=\"insertColumn\"&gt;&lt;/include&gt; ) values .....&lt;/insert&gt; DAO接口方法参数值与SQL语句字段值的传递 dao接口方法只有一个参数：#{参数名}直接取出参数的值。 dao接口方法有多个参数： 默认情况下：多个参数会被MyBatis封装成一个map，其key是MyBatis指定的固定形式：param1, param2, …paramN；value才是传入的参数值。SQL语句通过固定形式#{param1}, #{param2}, …取值。 我们也可以明确指定key的值：在DAO接口方法参数列表的每一个参数前使用Param(&quot;key&quot;)注解 。 若多个参数正好是POJO的成员变量，则直接传入POJO。 也可以传入一个Map，然后在SQL语句中使用#{key}来取值。 示例： 接口方法：public User getUser(@Param(&quot;id&quot;)Integer id, String lastName); SQL语句取值：id==&gt;#{id}/#{param1}, lastName==&gt;#{param2} 接口方法：public User getUser(Integer id, User user); SQL语句取值：id==&gt;#{param1}, lastName==&gt;#{param2.lastName} 接口方法：public User getUser(List&lt;Integer&gt; ids); SQL语句取值（固定形式）：#{list[0]}, #{list[1]}… 注意：若参数列表是集合类型或数组，取值都是固定形式。比如#{list[0]}, #{array[0]}。 SQL语句中也可使用${key}取值，它与#{key}的区别是：前者取值后直接赋值给SQL语句对应字段，后者是以预编译（PreparedStatement）的形式将参数设置到SQL语句中。${key}的使用场景是：SQL不支持占位符的地方（非字段）使用。 #{}使用时可以指定一些规则：jdbcType, javaType等，参见文档。 结果映射(ORM)自动映射全局配置中setting标签有一个属性autoMappingBehavior，其值默认为PARTIAL，开启自动映射的功能，唯一的要求是表的列名和POJO成员变量名一致。另外，可以通过设置mapUnderscoreToCamelCase=true来使数据库字段命名规范中的A_COLUMN自动映射为Java中的驼峰命名法aColumn。 以下是一些自动映射的例子： DAO接口方法返回POJO类或List 1public List&lt;User&gt; getUserByLastNameLike(String lastName); 123&lt;select id=\"getUserByLastNameLike\" resultType=\"org.example.pojo.User\"&gt; select * from user where last_name like #&#123;lastName&#125;&lt;/select&gt; DAO接口方法返回单条记录的Map，key是字段名，值是记录对应的值。 1public Map&lt;String, Object&gt; getUserByIdReturnMap(Integer id); 123&lt;select id=\"getUserByIdReturnMap\" resultType=\"map\"&gt; select * from user where id=#&#123;id&#125;&lt;/select&gt; DAO接口方法返回多条记录的Map，key是记录的主键，值是POJO。 12@MapKey(\"id\")//该注解用于指定keypublic Map&lt;Integer, User&gt; getUserByLastNameLikeReturnMap(String lastName); 123&lt;select id=\"getUserByLastNameLikeReturnMap\" resultType=\"org.example.pojo.User\"&gt; select * from user where last_name like #&#123;lastName&#125;&lt;/select&gt; 自定义结果集映射: resultMapresultMap属性和resultMap标签用于自定义结果集映射规则，resultMap和resultType属性只能选择一个使用。mapper.xml示例： 1234567891011121314151617181920212223&lt;mapper namespace=\"org.example.dao.IUserMapper\"&gt; &lt;!--自定义某个POJO类的封装规则 type: 自定义规则的POJO全类名 id: 用于引用 --&gt; &lt;resultMap type=\"org.example.pojo.User\" id=\"myMap\"&gt; &lt;!--指定主键列的封装规则 column: 指定哪一列 property: 指定对应的POJO类成员变量 --&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;!--定义普通列的封装规则--&gt; &lt;result column=\"last_name\" property=\"lastName\"&gt;&lt;/result&gt; &lt;result column=\"email\" property=\"email\"&gt;&lt;/result&gt; &lt;result column=\"gender\" property=\"gender\"&gt;&lt;/result&gt; &lt;!--其他不指定的列会自动封装，建议都指定--&gt; &lt;/resultMap&gt; &lt;select id=\"getUserById\" resultMap=\"myMap\"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 使用场景示例： 查询User的同时查询其对应的Department。demo IUserMapper.xml 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.example.dao.IUserMapper\"&gt; &lt;!--自定义User类的封装规则1, 使用级联属性的方式--&gt; &lt;resultMap id=\"myMap\" type=\"org.example.pojo.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"last_name\" property=\"lastName\"&gt;&lt;/result&gt; &lt;result column=\"gender\" property=\"gender\"&gt;&lt;/result&gt; &lt;result column=\"email\" property=\"email\"&gt;&lt;/result&gt; &lt;!--以下是Department的映射,使用级联属性的方式--&gt; &lt;result column=\"dept_id\" property=\"department.id\"&gt;&lt;/result&gt; &lt;result column=\"dept_name\" property=\"department.departmentName\"&gt;&lt;/result&gt; &lt;/resultMap&gt; &lt;!--自定义User类的封装规则2, 使用association标签--&gt; &lt;resultMap id=\"myMap2\" type=\"org.example.pojo.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"last_name\" property=\"lastName\"&gt;&lt;/result&gt; &lt;result column=\"gender\" property=\"gender\"&gt;&lt;/result&gt; &lt;result column=\"email\" property=\"email\"&gt;&lt;/result&gt; &lt;!--以下是Department的映射，使用association标签 property: 指定User中哪个属性是联结的对象 javaType: 指定该属性对象的类型 --&gt; &lt;association property=\"department\" javaType=\"org.example.pojo.Department\"&gt; &lt;id column=\"dept_id\" property=\"id\"/&gt; &lt;result column=\"dept_name\" property=\"departmentName\"/&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"getUserAndDept\" resultMap=\"myMap2\"&gt; select u.id, u.last_name, u.gender, u.email, u.dept_id, d.dept_name from user u , dept d where u.dept_id=d.id and u.id=#&#123;id&#125; &lt;/select&gt; &lt;!--自定义User类的封装规则3, 使用association进行分步查询 1.使用User的id查询User所有信息 2.根据返回信息中的dept_id值去dept表查询Department信息 3.将Department信息设置到User中 --&gt; &lt;resultMap id=\"myMap3\" type=\"org.example.pojo.User\"&gt; &lt;id column=\"id\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"last_name\" property=\"lastName\"&gt;&lt;/result&gt; &lt;result column=\"gender\" property=\"gender\"&gt;&lt;/result&gt; &lt;result column=\"email\" property=\"email\"&gt;&lt;/result&gt; &lt;!--select属性：表明当前User的属性department是通过getDepartmentById方法查询得到 column属性：将dept_id列的值作为参数传递给getDepartmentById方法 当column要传递多个参数时，可使用&#123;key1=column1,key2=column2..&#125; 的形式。 --&gt; &lt;association property=\"department\" select=\"org.example.dao.IDepartmentMapper.getDepartmentById\" column=\"dept_id\"&gt; &lt;/association&gt; &lt;/resultMap&gt; &lt;select id=\"getUserById\" resultMap=\"myMap3\"&gt; select * from user where id=#&#123;id&#125; &lt;/select&gt; &lt;!--使用分步查询的好处是，可以使用延迟加载，我们只在需要查询部门信息的时候再去查询它，大大提升了效率。 实现延迟加载：只需要再分步查询的基础上在全局配置文件的setting中设置lazyLoadingEnabled为true， aggressiveLazyLoading为false即可；或者在association/collection标签中配置fetchType=\"lazy\"。 --&gt;&lt;/mapper&gt; IDepartmentMapper.xml 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;mapper namespace=\"org.example.dao.IDepartmentMapper\"&gt; &lt;select id=\"getDepartmentById\" resultType=\"org.example.pojo.Department\"&gt; select id, dept_name departmentName from dept where id=#&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 在Department中添加成员变量List&lt;User&gt; users，查询一个Department时查询对应的users。demo IDepartmentMapper.xml 12345678910111213141516171819202122&lt;resultMap id=\"MyDeptMap\" type=\"org.example.pojo.Department\"&gt; &lt;id column=\"did\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"dept_name\" property=\"departmentName\"&gt;&lt;/result&gt; &lt;!--collection标签定义关联集合类型的属性的封装规则 property: 指定集合类型的成员变量 ofType: 指定集合内元素类型 select: 用于分步查询，参考association --&gt; &lt;collection property=\"users\" ofType=\"org.example.pojo.User\"&gt; &lt;!--定义集合中元素的封装规则--&gt; &lt;id column=\"uid\" property=\"id\"&gt;&lt;/id&gt; &lt;result column=\"last_name\" property=\"lastName\"&gt;&lt;/result&gt; &lt;result column=\"email\" property=\"email\"&gt;&lt;/result&gt; &lt;result column=\"gender\" property=\"gender\"&gt;&lt;/result&gt; &lt;/collection&gt;&lt;/resultMap&gt; &lt;select id=\"getDepartmentById2\" resultMap=\"MyDeptMap\"&gt; select d.id did, d.dept_name, u.id uid, u.last_name, u.email, u.gender from dept d left join user u on d.id=u.dept_id where d.id=#&#123;id&#125;&lt;/select&gt; discriminator鉴别器：resultMap子标签，使用该标签可根据某列（column）的值改变封装行为。例： 1234567891011&lt;!--某列字段的类型--&gt;&lt;discriminator javaType=\"String\" column\"gender\"&gt; &lt;case value=\"女\" resultType=\"org.example.pojo.User\" &gt; &lt;association property=\"\" select=\"\" column=\"\"&gt;&lt;/association&gt; &lt;/case&gt; &lt;case value=\"男\" resultType=\"org.example.pojo.User\"&gt; &lt;id column=\"\" property=\"\"&gt;&lt;/id&gt; &lt;result column=\"\" property=\"\"&gt;&lt;/result&gt; ...... &lt;/case&gt;&lt;/discriminator&gt; 动态SQLMyBatis官方文档 if标签用于动态拼接SQL语句。 test属性：值为判断表达式（OGNL），从DAO接口方法参数列表中取值进行判断。特殊符号需要转义&quot; -&gt; &amp;quot;, &#39; -&gt; &amp;apos;, &amp; -&gt; &amp;amp;, &lt; -&gt; &amp;lt;, &gt; -&gt; &amp;gt;。 123456789101112131415161718192021&lt;mapper namespace=\"org.example.dao.IUserMapper\"&gt; &lt;select id=\"getUserByConditionIf\" resultType=\"org.example.pojo.User\"&gt; select * from user &lt;where&gt; &lt;if test=\"id!=null\"&gt; id=#&#123;id&#125; &lt;/if&gt; &lt;if test=\"lastName!=null and lastName.trim()!=''\"&gt; &lt;!--多余的and--&gt;and last_name like #&#123;lastName&#125; &lt;/if&gt; &lt;if test=\"email!=null and email!=''\"&gt; and email=#&#123;email&#125; &lt;/if&gt; &lt;if test=\"gender=='男' or gender=='女'\"&gt; and gender=#&#123;gender&#125; &lt;/if&gt; &lt;/where&gt; &lt;/select&gt;&lt;/mapper&gt; 1List&lt;User&gt; list = userMapper.getUserByConditionIf(new User(null, \"Tom\", \"abcdefg@126.com\", null)); 对于调用方法参数中第一个条件为null的情况，可以使用where标签消除第一个and关键字，避免SQL语句错误。 trim标签属性： prefix：给trim标签中拼接后的字符串添加一个前缀。 prefixOverrides：去掉trim标签中拼接后的字符串前面多余的字符。 suffix：给trim标签中拼接后的字符串添加一个后缀。 suffixOverrides：去掉trim标签中拼接后的字符串后面多余的字符。 例如： 123456789101112131415161718&lt;select id=\"getUserByConditionTrim\" resultType=\"org.example.pojo.User\"&gt; select * from user &lt;trim prefix=\"where\" suffixOverrides=\"and\"&gt; &lt;if test=\"id!=null\"&gt; id=#&#123;id&#125; and &lt;/if&gt; &lt;if test=\"lastName!=null and lastName.trim()!=''\"&gt; last_name like #&#123;lastName&#125; and &lt;/if&gt; &lt;if test=\"email!=null and email!=''\"&gt; email=#&#123;email&#125; and &lt;!--多余的and--&gt; &lt;/if&gt; &lt;if test=\"gender=='男' or gender=='女'\"&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/trim&gt; &lt;/select&gt; 1List&lt;User&gt; list = userMapper.getUserByConditionTrim(new User(1, \"Tom\", \"abcdefg@126.com\", null)); choose标签分支选择，类似于switch-case。 1234567891011121314151617&lt;select id=\"getUserByConditionChoose\" resultType=\"org.example.pojo.User\"&gt; select * from user &lt;where&gt; &lt;choose&gt;&lt;!--switch--&gt; &lt;when test=\"id!=null\"&gt; &lt;!--case--&gt; id=#&#123;id&#125; &lt;/when&gt; &lt;when test=\"lastName!=null\"&gt; last_name like #&#123;lastName&#125; &lt;/when&gt; &lt;!--前面的条件都不满足则--&gt; &lt;otherwise&gt; 1=1 &lt;/otherwise&gt; &lt;/choose&gt; &lt;/where&gt; &lt;/select&gt; set标签用于update的SQL语句，去除多余的,。 1234567891011121314&lt;update id=\"updateUser\"&gt; update user &lt;set&gt; &lt;if test=\"lastName!=null\"&gt; last_name=#&#123;lastName&#125;, &lt;/if&gt; &lt;if test=\"email!=null\"&gt; email=#&#123;email&#125;, &lt;/if&gt; &lt;if test=\"gender!=null\"&gt; gender=#&#123;gender&#125; &lt;/if&gt; &lt;/set&gt; &lt;/update&gt; foreach标签动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如： 123456&lt;select id=\"getUserByConditionForeach\" resultType=\"org.example.pojo.User\"&gt; select * from user where id in &lt;foreach item=\"item_id\" index=\"index\" collection=\"ids\" open=\"(\" separator=\",\" close=\")\"&gt; #&#123;item_id&#125; &lt;/foreach&gt;&lt;/select&gt; 1public List&lt;User&gt; getUserByConditionForeach(@Param(\"ids\")List&lt;Integer&gt; idList); 可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 foreach。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是key，item 是value。 foreach标签也常用于批量insert操作。 123456&lt;insert id=\"addUsers\"&gt; insert into user(last_name, email, gender) values &lt;foreach item=\"user\" collection=\"users\" separator=\",\"&gt; (#&#123;user.lastName&#125;, #&#123;user.email&#125;, #&#123;user.gender&#125;) &lt;/foreach&gt;&lt;/insert&gt; 1public void addUsers(@Param(\"users\")List&lt;User&gt; users); script注解方式配置dao接口方法。 1234567891011@Update(&#123;\"&lt;script&gt;\", \"update Author\", \" &lt;set&gt;\", \" &lt;if test='username != null'&gt;username=#&#123;username&#125;,&lt;/if&gt;\", \" &lt;if test='password != null'&gt;password=#&#123;password&#125;,&lt;/if&gt;\", \" &lt;if test='email != null'&gt;email=#&#123;email&#125;,&lt;/if&gt;\", \" &lt;if test='bio != null'&gt;bio=#&#123;bio&#125;&lt;/if&gt;\", \" &lt;/set&gt;\", \"where id=#&#123;id&#125;\", \"&lt;/script&gt;\"&#125;) void updateAuthorValues(Author author); bind标签该标签可以将OGNL表达式的值绑定到一个变量中，方便后面引用该变量的值。 1&lt;bind name=\"变量名\" value=\"OGNL表达式\"&gt;&lt;/bind&gt; 缓存MyBatis官方文档 Mybatis 的缓存是针对SQL语句查询的优化，极大地提升了查询效率。实际开发中使用Redis实现缓存。 MyBatis默认定义了两级缓存： 默认情况下，只开启了一级缓存（SqlSession级别，也称本地缓存）。 二级缓存需要手动开启和配置（基于命名空间，全局缓存）。 为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存。MyBatis中的缓存就是一个HashMap。 一级缓存与数据库同一次会话期间查询到的数据会放在本地缓存中，下次获取相同的数据时（需要SqlSession, mapper方法和参数，SQL语句都相同）直接从缓存中获取。 两次相同的查询之间若执行了增删改操作，清除缓存。 可以使用openSession.clearCache()方法清除一级缓存。 二级缓存一个namespace对应一个二级缓存。一个会话查询一条数据，该数据会被放在当前会话的一级缓存中。若会话关闭，则一级缓存数据会被保存到二级缓存中，新的会话查询数据会先参照二级缓存。二级缓存的使用：在映射文件中添加&lt;cache/&gt;即可，缓存只作用于该映射文件下的SQL语句，该标签有如下属性： eviction：缓存的清除策略。有如下取值： LRU – 最近最少使用：移除最长时间不被使用的对象。 FIFO – 先进先出：按对象进入缓存的顺序来移除它们。 SOFT – 软引用：当系统将要发生OOM异常时，软引用指向的对象才被真正回收。 WEAK – 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。 flushInterval：缓存刷新间隔，即多长时间清空一次缓存，单位ms。默认不清空。 size：缓存引用数目。默认1024。 readOnly：是否只读。默认false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化，POJO类需要实现Serializable接口）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。 type：自定义缓存的全类名。 &lt;cache/&gt;标签的效果默认如下： 映射语句文件中的所有 select 语句的结果将会被缓存。 映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。 缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。 缓存不会定时进行刷新（也就是说，没有刷新间隔）。 缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。 缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。 缓存相关配置 全局配置文件：&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&gt;, 默认开启二级缓存。一级缓存默认开启无法关闭。 全局配置文件：&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;&gt;。MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。 select标签的属性useCache，默认为true，为false则关闭二级缓存。 insert, update, delete标签的属性flushCache, 默认为true，即增删改后默认清除一级缓存和二级缓存。 逆向工程mybatis generator doc. 使用mybatis generator根据数据库表自动生成POJO类，DAO接口以及映射文件。 注意：生成的只包含单表查询，多表联查需要自行编写。 使用步骤： 导入依赖 12345&lt;dependency&gt; &lt;groupId&gt;org.mybatis.generator&lt;/groupId&gt; &lt;artifactId&gt;mybatis-generator-core&lt;/artifactId&gt; &lt;version&gt;1.3.5&lt;/version&gt;&lt;/dependency&gt; 与pom.xml同级目录下编写myBatisGenerator.xml 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;!DOCTYPE generatorConfiguration PUBLIC \"-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN\" \"http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd\"&gt;&lt;!--使用逆向工程生成数据库对应表的POJO类、DAO接口和映射文件--&gt;&lt;generatorConfiguration&gt; &lt;context id=\"DB2Tables\" targetRuntime=\"MyBatis3\"&gt; &lt;!--不生成注释--&gt; &lt;commentGenerator&gt; &lt;property name=\"suppressAllComments\" value=\"true\"/&gt; &lt;/commentGenerator&gt; &lt;!--配置数据库连接--&gt; &lt;jdbcConnection driverClass=\"com.mysql.cj.jdbc.Driver\" connectionURL=\"jdbc:mysql://localhost:3306/ssm_crud?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC\" userId=\"root\" password=\"admin\"&gt; &lt;/jdbcConnection&gt; &lt;javaTypeResolver &gt; &lt;property name=\"forceBigDecimals\" value=\"false\" /&gt; &lt;/javaTypeResolver&gt; &lt;!--指定POJO类生成位置--&gt; &lt;javaModelGenerator targetPackage=\"org.example.bean\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;property name=\"trimStrings\" value=\"true\" /&gt; &lt;/javaModelGenerator&gt; &lt;!--指定SQL映射文件生成位置--&gt; &lt;sqlMapGenerator targetPackage=\"mapper\" targetProject=\".\\src\\main\\resources\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/sqlMapGenerator&gt; &lt;!--指定DAO接口生成位置--&gt; &lt;javaClientGenerator type=\"XMLMAPPER\" targetPackage=\"org.example.dao\" targetProject=\".\\src\\main\\java\"&gt; &lt;property name=\"enableSubPackages\" value=\"true\" /&gt; &lt;/javaClientGenerator&gt; &lt;!--指定数据库每个表的生成策略--&gt; &lt;table tableName=\"employee\" domainObjectName=\"Employee\" /&gt; &lt;table tableName=\"department\" domainObjectName=\"Department\"/&gt; &lt;/context&gt;&lt;/generatorConfiguration&gt; 创建MBGTest.java并运行 123456789101112public class MBGTest &#123; public static void main(String[] args) throws Exception&#123; List&lt;String&gt; warnings = new ArrayList&lt;&gt;(); boolean overwrite = true; File configFile = new File(\"myBatisGenerator.xml\"); ConfigurationParser cp = new ConfigurationParser(warnings); Configuration config = cp.parseConfiguration(configFile); DefaultShellCallback callback = new DefaultShellCallback(overwrite); MyBatisGenerator myBatisGenerator = new MyBatisGenerator(config, callback, warnings); myBatisGenerator.generate(null); &#125;&#125; 生成的类中包含XXXExample.java的，表示条件查询。条件查询使用方法如下： 1234567//要求：查询雇员名字中包含e字母并且性别为1EmployeeMapper mapper = openSession.getMapper(EmployeeMapper.class);EmployeeExample example = new EmployeeExample();Criteria criteria = example.createCriteria();//Criteria对象封装查询的条件criteria.andLastNameLike(\"%e%\");criteria.andGenderEqualTo(\"1\");List&lt;Employee&gt; list = mapper.selectByExample(example);","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://thmasterplan.cn/tags/MyBatis/"}]},{"title":"SpringMVC","slug":"SpringMVC","date":"2020-10-18T06:42:34.000Z","updated":"2020-11-23T14:23:21.096Z","comments":true,"path":"JavaWeb/SpringMVC/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/SpringMVC/","excerpt":"","text":"B/S三层架构与MVC模型 三层架构 MVC模型 环境搭建 简单案例 案例代码 简单案例的执行流程 Spring MVC九大组件 HandlerMapping HandlerAdapters ViewResolver HandlerExceptionResolver MultipartResolver LocaleResolver ThemeResolver RequestToViewNameTranslator FlashMapManager 请求参数的绑定 基本数据类型与字符串对象的绑定 POJO类及其关联类对象的绑定 集合类型对象的绑定 请求参数中文乱码解决 POST请求方式 GET请求方式 自定义类型转换器 在控制器中使用原生的ServletAPI 常用注解 @RequestMapping @RequestParam @RequestBody @PathVarible @RequestHeader @CookieValue @ModelAttribute @SessionAttributes @CrossOrigin 前端解决方案) 后端Spring MVC解决方案) 控制器方法返回值类型与结果视图 返回字符串 返回类型为void 返回类型为ModelAndView 转发与重定向 转发 重定向 @ResponseBody响应JSON 文件上传 本服务器文件上传 跨服务器文件上传 异常处理 自定义异常类 自定义异常处理器并配置 @ExceptionHandler 拦截器 自定义拦截器 HandlerInterceptor接口方法 preHandle postHandle afterCompletion B/S三层架构与MVC模型SpringMVC Doc. 三层架构 表现层：WEB层，用来和客户端进行数据交互。表现层一般会采用MVC的设计模型 。 业务层：处理公司具体的业务逻辑 。 持久层：用来操作数据库。 MVC模型 MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 Model：数据模型，JavaBean的类，用来进行数据封装。 View：指JSP、HTML用来展示数据给用户。 Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。 环境搭建 选择原型maven-archetype-webapp，创建工程。 补全工程目录结构如下： 导入maven依赖： 12345678910111213141516171819202122232425262728293031323334353637383940&lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;spring.version&gt;5.2.5.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-web&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;servlet-api&lt;/artifactId&gt; &lt;version&gt;2.5&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet.jsp&lt;/groupId&gt; &lt;artifactId&gt;jsp-api&lt;/artifactId&gt; &lt;version&gt;2.0&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 在web.xml中配置Servlet控制器： 123456789&lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; 配置tomcat服务器： web路径：不以/开始的相对路径，以当前资源所在目录为基准；以/开始的相对路径，以服务器的路径（http://localhost:3306）为基准。可通过设置服务器路径到变量APP_PATH： 1&lt;% pageContext.setAttribute(\"APP_PATH\", request.getContextPath()); %&gt; 然后通过${APP_PATH}/某路径来设置路径。 简单案例案例代码 配置DispatcherServlet(前端控制器) 1234567891011121314151617181920&lt;web-app&gt; &lt;display-name&gt;Archetype Created Web Application&lt;/display-name&gt; &lt;servlet&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;!--加载spring配置文件并创建IoC容器--&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:springmvc.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;!--Tomcat启动时加载DispatcherServlet--&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;/servlet&gt; &lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcherServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/&lt;/url-pattern&gt;&lt;!--拦截所有请求--&gt; &lt;/servlet-mapping&gt;&lt;/web-app&gt; 配置springmvc.xml 12345678910111213141516171819202122232425&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:mvc=\"http://www.springframework.org/schema/mvc\" xmlns:context=\"http://www.springframework.org/schema/context\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd\"&gt; &lt;context:component-scan base-package=\"org.example\"&gt;&lt;/context:component-scan&gt; &lt;!--创建视图解析器对象--&gt; &lt;bean id=\"internalResourceViewResolver\" class=\"org.springframework.web.servlet.view.InternalResourceViewResolver\"&gt; &lt;property name=\"prefix\" value=\"/WEB-INF/pages/\"&gt;&lt;/property&gt; &lt;property name=\"suffix\" value=\".jsp\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;!--开启SpringMVC框架注解的支持--&gt; &lt;!--使用该标签自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter--&gt; &lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;&lt;/beans&gt; 编写index.jsp和HelloController控制器类 1234&lt;body&gt;&lt;h3&gt;入门案例&lt;/h3&gt;&lt;a href=\"hello\"&gt;入门案例&lt;/a&gt;&lt;/body&gt; 123456789@Controllerpublic class HelloController &#123; @RequestMapping(path = \"/hello\") public String hello()&#123; System.out.println(\"hello world!\"); return \"success\"; &#125;&#125; 在WEB-INF目录下创建pages目录，编写success.jsp页面 123&lt;body&gt; &lt;h3&gt;Success!&lt;/h3&gt;&lt;/body&gt; 启动Tomcat测试 简单案例的执行流程 当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件。 开启了注解扫描，那么HelloController对象就会被创建，另外springmvc.xml中配置的InternalResourceViewResolver也会被创建，这两个对象进入IoC容器。 从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法。 根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 。 Tomcat服务器渲染页面，做出响应。 Spring MVC九大组件 用户请求到达dispatcherServlet，它就相当于 mvc 模式中的 c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。Handler即我们编写的Controller类，由 dispatcherServlet把用户请求转发到 Handler， Handler再对具体的用户请求进行处理。 HandlerMapping处理器映射器。HandlerMapping 负责根据用户请求URI找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。 HandlerAdapters处理器适配器。通过 HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。 ViewResolver视图处理器。ViewResolver负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。 HandlerExceptionResolver异常处理器。 MultipartResolver文件处理器，用于处理上传的文件。 LocaleResolver当前环境处理器。这就相当于配置数据库的方言一样，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。 ThemeResolver主题处理器，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源，如图片、css样式等。 RequestToViewNameTranslator视图名称翻译器。有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。 FlashMapManager参数传递管理器。用于管理FlashMap，FlashMap主要用在redirect重定向中传递参数。 请求参数的绑定基本数据类型与字符串对象的绑定要求前端页面的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写) 前端页面代码： 1&lt;a href=\"account/findAccount?accountId=10&amp;accountName=zhangsan\"&gt;查询账户&lt;/a&gt; 控制器代码： 12345@RequestMapping(\"/findAccount\")public String findAccount(Integer accountId,String accountName) &#123; System.out.println(\"查询了账户\"+accountId+\",\"+accountName); return \"success\";&#125; POJO类及其关联类对象的绑定要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。 POJO类代码： 123456789101112public class Account implements Serializable &#123; private Integer id; private String name; private Float money; private Address address; //getters and setters&#125;public class Address implements Serializable &#123; private String provinceName; private String cityName; //getters and setters&#125; jsp代码： 1234567&lt;form action=\"account/saveAccount\" method=\"post\"&gt; 账户名称：&lt;input type=\"text\" name=\"name\" &gt;&lt;br/&gt; 账户金额：&lt;input type=\"text\" name=\"money\" &gt;&lt;br/&gt; 账户省份：&lt;input type=\"text\" name=\"address.provinceName\" &gt;&lt;br/&gt; 账户城市：&lt;input type=\"text\" name=\"address.cityName\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;/form&gt; 控制器代码： 12345@RequestMapping(\"/saveAccount\")public String saveAccount(Account account) &#123; System.out.println(\"保存了账户。。。。\"+account); return \"success\";&#125; 集合类型对象的绑定 要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。 接收的请求参数是 json 格式数据。需要借助注解@RequestParam或@RequestBody实现。 pojo类包含集合类型： 12345678public class User implements Serializable &#123; private String username; private String password; private Integer age; private List&lt;Account&gt; accounts; private Map&lt;String,Account&gt; accountMap; //getters, setters and toString&#125; jsp代码： 1234567891011121314&lt;form action=\"account/updateAccount\" method=\"post\"&gt; 用户名称：&lt;input type=\"text\" name=\"username\" &gt;&lt;br/&gt; 用户密码：&lt;input type=\"password\" name=\"password\" &gt;&lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" &gt;&lt;br/&gt; 账户1名称：&lt;input type=\"text\" name=\"accounts[0].name\" &gt;&lt;br/&gt; 账户1金额：&lt;input type=\"text\" name=\"accounts[0].money\" &gt;&lt;br/&gt; 账户2名称：&lt;input type=\"text\" name=\"accounts[1].name\" &gt;&lt;br/&gt; 账户2金额：&lt;input type=\"text\" name=\"accounts[1].money\" &gt;&lt;br/&gt; 账户3名称：&lt;input type=\"text\" name=\"accountMap['one'].name\" &gt;&lt;br/&gt; 账户3金额：&lt;input type=\"text\" name=\"accountMap['one'].money\" &gt;&lt;br/&gt; 账户4名称：&lt;input type=\"text\" name=\"accountMap['two'].name\" &gt;&lt;br/&gt; 账户4金额：&lt;input type=\"text\" name=\"accountMap['two'].money\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;/form&gt; 控制器代码： 12345@RequestMapping(\"/updateAccount\")public String updateAccount(User user) &#123; System.out.println(\"更新了账户。。。。\"+user); return \"success\";&#125; 请求参数中文乱码解决POST请求方式在web.xml中配置过滤器来转换请求数据的编码。 1234567891011121314&lt;filter&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filterclass&gt; &lt;!-- 指定字符集 --&gt; &lt;init-param&gt; &lt;param-name&gt;encoding&lt;/param-name&gt; &lt;param-value&gt;UTF-8&lt;/param-value&gt; &lt;/init-param&gt;&lt;/filter&gt; &lt;!--过滤所有请求--&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 在 springmvc的配置文件中可以配置，静态资源不过滤： 1234&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;&lt;mvc:resources location=\"/css/\" mapping=\"/css/**\"/&gt;&lt;mvc:resources location=\"/images/\" mapping=\"/images/**\"/&gt;&lt;mvc:resources location=\"/scripts/\" mapping=\"/javascript/**\"/&gt; GET请求方式Tomacat 对 GET 和 POST 请求处理方式是不同的，GET 请求的编码问题，要改 Tomcat 的 server.xml 配置文件： 12&lt;Connector connectionTimeout=\"20000\" port=\"8080\" protocol=\"HTTP/1.1\" redirectPort=\"8443\"useBodyEncodingForURI=\"true\"/&gt; 如果遇到 ajax 请求仍然乱码，把 useBodyEncodingForURI=”true”改为 URIEncoding=”UTF-8”即可。 自定义类型转换器表单提交的任何数据类型全部都是字符串类型，假如后台定义Integer类型，数据也可以封装上，说明 Spring框架内部会默认进行数据类型转换。 如果想自定义数据类型转换，可以实现Converter接口并重写convert方法。比如表单提交”2020/11/11”，Spring可以正常转换为Date类型，但是表单提交的是”2020-11-11”，这时就需要我们自定义类型转换器了： 1234567891011121314151617181920212223242526import java.text.DateFormat;import java.text.SimpleDateFormat;import java.util.Date;import org.springframework.core.convert.converter.Converter;/*** 把字符串转换成日期的转换器*/public class StringToDateConverter implements Converter&lt;String, Date&gt;&#123; /** * 进行类型转换的方法 */ public Date convert(String source) &#123; if(source == null) throw new RuntimeException(\"参数不能为空\"); try &#123; DateFormat df = new SimpleDateFormat(\"yyyy-MM-dd\"); // 解析字符串 Date date = df.parse(source); return date; &#125; catch (Exception e) &#123; throw new RuntimeException(\"类型转换错误\"); &#125; &#125;&#125; 在springmvc.xml中配置StringToDateConverter对象： 12345678910111213&lt;!--创建类型转换器工厂--&gt;&lt;bean id=\"conversionService\" class=\"org.springframework.context.support.ConversionServiceFactoryBean\"&gt; &lt;!--给工厂注入一个新的类型转换器--&gt; &lt;property name=\"converters\"&gt; &lt;set&gt; &lt;!--创建自定义类型转换器--&gt; &lt;bean class=\"cn.itcast.utils.StringToDateConverter\"/&gt; &lt;/set&gt; &lt;/property&gt;&lt;/bean&gt;&lt;!-- 开启Spring对MVC注解的支持 --&gt;&lt;mvc:annotation-driven conversion-service=\"conversionService\"/&gt; 在控制器中使用原生的ServletAPI在控制器的方法参数中使用HttpServletRequest、HttpServletResponse、HttpSession等即可。 常用注解@RequestMapping 作用：是建立请求URL和处理方法之间的对应关系。 属性 path/value: 指定请求路径的url method: 指定该方法的请求方式（post,get…） headers: 发送的请求中必须包含请求头 params: 限制请求参数的条件，它支持简单的表达式，要求请求参数的 key和value 必须和配置的一模一样。例如： params = {“accountName”}，表示请求参数必须有 accountName；params = {“moeny!100”}，表示请求参数中 money 不能是 100。 RequestMapping注解可以作用在方法和类上：作用在类上，path属性表示第一级的访问目录；作用在方法上，path属性表示第二级的访问目录。 @RequestParam 作用：作用于参数。把请求中指定名称的参数给控制器中的形参赋值。 属性 value/name: 请求参数中的名称。 required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。 示例 jsp代码： 1&lt;a href=\"springmvc/useRequestParam?name=test\"&gt;requestParam 注解&lt;/a&gt; 控制器代码： 123456@RequestMapping(\"/useRequestParam\")public String useRequestParam(@RequestParam(\"name\")String username, @RequestParam(value=\"age\",required=false)Integer age)&#123; System.out.println(username+\",\"+age); return \"success\";&#125; @RequestBody 作用：作用于参数。用于获取请求体内容，并将其绑定到Bean上或者分别绑定到对应的变量上。直接使用得到是 key=value&amp;key=value…结构的数据。 get 请求方式不适用。 属性：required。是否必须有请求体。默认值是：true。当取值为 true 时，get 请求方式会报错。如果取值 为 false，get 请求得到的是 null。 @PathVarible 作用：作用于参数。用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。 属性 value/name：指定url中占位符名称。 required：请求url中是否必须提供占位符。 示例 jsp代码： 1&lt;a href=\"springmvc/usePathVariable/100\"&gt;pathVariable 注解&lt;/a&gt; 控制器代码： 12345@RequestMapping(\"/usePathVariable/&#123;id&#125;\")public String usePathVariable(@PathVariable(\"id\") Integer id)&#123; System.out.println(id); return \"success\";&#125; RESTful编程风格 HTTP 协议里，四个表示操作方式的动词：GET 、POST 、PUT、 DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来 删除资源。 @RestController：创建处理http请求的对象。Spring4之后加入的注解，原来在@Controller中返回json需要@ResponseBody来配合，如果直接用@RestController替代@Controller就不需要再配置@ResponseBody，默认返回json格式。 RESTful在SpringMVC里的应用：请求同一个Controller，具体到每个方法method上的路径path一样(不再是每个方法上都配置一个具体的路径来进行匹配)，但每个method请求方式不一样，根据GET、PUT、POST 和 DELETE的不同方式，匹配不同的method。 示例： 123456public class User &#123; private Long id; private String name; private Integer age; // 省略setter和getter&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748@RestController@RequestMapping(value=\"/users\") // 通过这里配置使下面的映射都在/users下public class UserController &#123; // 创建线程安全的Map static Map&lt;Long, User&gt; users = Collections.synchronizedMap(new HashMap&lt;Long, User&gt;()); @RequestMapping(value=\"/\", method=RequestMethod.GET) public List&lt;User&gt; getUserList() &#123; // 处理\"/users/\"的GET请求，用来获取用户列表 // 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递 List&lt;User&gt; r = new ArrayList&lt;User&gt;(users.values()); return r; &#125; @RequestMapping(value=\"/\", method=RequestMethod.POST) public String postUser(@ModelAttribute User user) &#123; // 处理\"/users/\"的POST请求，用来创建User // 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数 users.put(user.getId(), user); return \"success\"; &#125; @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.GET) public User getUser(@PathVariable Long id) &#123; // 处理\"/users/&#123;id&#125;\"的GET请求，用来获取url中id值的User信息 // url中的id可通过@PathVariable绑定到函数的参数中 return users.get(id); &#125; @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.PUT) public String putUser(@PathVariable Long id, @ModelAttribute User user) &#123; // 处理\"/users/&#123;id&#125;\"的PUT请求，用来更新User信息 User u = users.get(id); u.setName(user.getName()); u.setAge(user.getAge()); users.put(id, u); return \"success\"; &#125; @RequestMapping(value=\"/&#123;id&#125;\", method=RequestMethod.DELETE) public String deleteUser(@PathVariable Long id) &#123; // 处理\"/users/&#123;id&#125;\"的DELETE请求，用来删除User users.remove(id); return \"success\"; &#125;&#125; HiddenHttpMethodFilter 由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添 加了该过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与 DELETE 请求。 @RequestHeader 作用：作用于参数。用于获取请求消息头。 属性： value：提供消息头名称。 required：是否必须有此消息头。 @CookieValue 作用：作用于参数。用于把指定 cookie 名称的值传入控制器方法参数。 属性 value：指定cookie名称。 required：是否必须有此cookie。 @ModelAttribute 作用：该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。 修饰方法：当前方法会在控制器的每个方法执行之前先执行一次。 修饰参数：获取指定的数据给参数赋值。 属性：value/name。：用于获取数据的 key。key 可以是 POJO的属性名称，也可以是 map 结构的 key。 应用场景：当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据时肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解修饰方法解决问题。 基于 Map 的应用场景示例 1：ModelAttribute 修饰方法带返回值 1234567&lt;!-- 修改用户信息 --&gt;&lt;form action=\"springmvc/updateUser\" method=\"post\"&gt; 用户名称：&lt;input type=\"text\" name=\"username\" &gt;&lt;br/&gt; 用户年龄：&lt;input type=\"text\" name=\"age\" &gt;&lt;br/&gt; &lt;input type=\"submit\" value=\"保存\"&gt;&lt;/form&gt; 123456789101112131415161718192021@ModelAttributepublic User showModel(String username) &#123; //模拟去数据库查询并设置表单中没有的字段password User abc = findUserByName(username); System.out.println(\"执行了 showModel 方法\"+abc); return abc;&#125;private User findUserByName(String username) &#123; User user = new User(); user.setUsername(username); user.setAge(19); user.setPassword(\"123456\"); return user;&#125;@RequestMapping(\"/updateUser\")public String testModelAttribute(User user) &#123; System.out.println(\"控制器中处理请求的方法：修改用户：\"+user); return \"success\";&#125; 基于 Map 的应用场景示例 2：ModelAttribute 修饰方法不带返回值 12345678910111213@ModelAttributepublic void showModel(String username,Map&lt;String,User&gt; map) &#123; //模拟去数据库查询并设置表单中没有的字段password //使用map来传递user对象 User user = findUserByName(username); System.out.println(\"执行了 showModel 方法\"+user); map.put(\"abc\",user);&#125;@RequestMapping(\"/updateUser\")public String testModelAttribute(@ModelAttribute(\"abc\")User user) &#123; System.out.println(\"控制器中处理请求的方法：修改用户：\"+user); return \"success\";&#125; @SessionAttributes 作用：作用于类上。@SessionAttributes is used to store model attributes in the HTTP Servlet session between requests. 属性 name/value：存入Session域的属性名称，可以存入多个。 types：指定存入的数据类型。 示例 jsp代码： 12345&lt;a href=\"springmvc/testPut\"&gt;存入 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"springmvc/testGet\"&gt;取出 SessionAttribute&lt;/a&gt;&lt;hr/&gt;&lt;a href=\"springmvc/testClean\"&gt;清除 SessionAttribute&lt;/a&gt; 控制器代码： 123456789101112131415161718192021222324252627282930@Controller(\"sessionAttributeController\")@RequestMapping(\"/springmvc\")@SessionAttributes(value =&#123;\"username\",\"password\"&#125;,types=&#123;Integer.class&#125;)public class SessionAttributeController &#123;/*** 把数据存入Servlet session* @param model* @return* Model是spring提供的一个接口，该接口有一个实现类 ExtendedModelMap* 该类继承了ModelMap，而 ModelMap就是LinkedHashMap子类*/@RequestMapping(\"/testPut\")public String testPut(Model model)&#123; model.addAttribute(\"username\", \"tom\"); model.addAttribute(\"password\",\"123456\"); model.addAttribute(\"age\", 31); return \"success\"; &#125; @RequestMapping(\"/testGet\")public String testGet(ModelMap model)&#123; System.out.println(model.get(\"username\")+\";\"+model.get(\"password\")+\";\"+model.get(\"age\")); return \"success\";&#125; @RequestMapping(\"/testClean\") public String complete(SessionStatus sessionStatus)&#123; sessionStatus.setComplete(); return \"success\"; &#125;&#125; @CrossOrigin当我们使用前后端分离的方式开发项目，前端使用XMLHttpReques，也即AJAX请求页面时，浏览器访问的URI与AJAX请求的URI（我们RequestMapping定义的虚拟地址）是不同的，因此请求会报错。 CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出XMLHttpRequest请求，从而克服了AJAX只能同源使用的限制。CORS需要浏览器和服务器同时支持。 前端解决方案 JSONP CORS【推荐】 HTML5 API：postMessage Web Sockets 后端Spring MVC解决方案 细粒度方式，仅限于类或方法：@CrossOrigin 跨域：@CrossOrigin(origins = {&quot;*&quot;},allowedHeaders = &quot;*&quot;) 跨域传递Cookie：@CrossOrigin(origins = {&quot;*&quot;},allowCredentials = &quot;true&quot;,allowedHeaders = &quot;*&quot;) 全局配置：Java类+注解配置，或XML配置。 过滤器方式：使用内置的CorsFilter。 控制器方法返回值类型与结果视图返回字符串控制器方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。例如： 123456//指定逻辑视图名，经过视图解析器解析为物理路径：/WEB-INF/pages/success.jsp@RequestMapping(\"/testReturnString\")public String testReturnString() &#123; System.out.println(\"AccountController的testReturnString 方法执行了。。。。\"); return \"success\";&#125; 返回类型为void使用Servlet的request和response对象返回页面： 12345678910public void testReturnVoid(HttpServletRequest request,HttpServletResponse response) throws Exception &#123; //使用request跳转 request.getRequestDispatcher(\"/WEB-INF/pages/success.jsp\").forward(request, response); //使用response重定向 response.sendRedirect(\"index.jsp\"); //使用response指定响应结果,例如JSON数据 response.setCharacterEncoding(\"utf-8\"); response.setContentType(\"application/json;charset=utf-8\"); response.getWriter().write(\"json 串\");&#125; 返回类型为ModelAndViewModelAndView是SpringMVC的内置对象。通过该对象的addObject方法添加对象，setViewName方法设置逻辑视图名称，视图解析器会根据名称返回指定的页面。 1234567@RequestMapping(\"/testReturnModelAndView\")public ModelAndView testReturnModelAndView() &#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"username\", \"张三\"); mv.setViewName(\"success\"); return mv;&#125; 12345678910111213&lt;!--success.jsp--&gt;&lt;%@ page language=\"java\" contentType=\"text/html; charset=UTF-8\" pageEncoding=\"UTF-8\"%&gt;&lt;!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.01 Transitional//EN\" \"http://www.w3.org/TR/html4/loose.dtd\"&gt;&lt;html&gt; &lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\"&gt; &lt;title&gt;执行成功&lt;/title&gt; &lt;/head&gt; &lt;body&gt; 执行成功！ $&#123;requestScope.username&#125; &lt;/body&gt;&lt;/html&gt; 转发与重定向转发控制器方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成： 12345@RequestMapping(\"/testForward\")public String testForward() &#123; System.out.println(\"AccountController 的 testForward 方法执行了。。。。\"); return \"forward:/WEB-INF/pages/success.jsp\";&#125; 需要注意的是，如果用了formward则路径必须写成实际视图 url，不能写逻辑视图(不会交给视图解析器解析)。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，既可以转发到 jsp，也可以转发到其他的控制器方法。 重定向12345@RequestMapping(\"/testRedirect\")public String testRedirect() &#123; System.out.println(\"AccountController 的 testRedirect 方法执行了。。。。\"); return \"redirect:testReturnModelAndView\";//重定向到另一个控制器方法&#125; 它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不 能写在 WEB-INF 目录中，否则无法找到。 @ResponseBody响应JSON该注解用于将控制器方法的返回值对象，通过HttpMessageConverter接口转换为指定格式的数据如json, xml等响应给客户端，而不再需要视图渲染。SpringMVC默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入如下jackson的包： 123456789101112131415&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-core&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt; &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt; &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt; jsp代码： 12345678910111213141516171819&lt;script type=\"text/javascript\" src=\"$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js\"&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; $(function()&#123; $(\"#testJson\").click(function()&#123; $.ajax(&#123; type:\"post\", url:\"$&#123;pageContext.request.contextPath&#125;/testResponseJson\", contentType:\"application/json;charset=utf-8\", data:'&#123;\"id\":1, \"name\":\"test\", \"money\":999.0&#125;', dataType:\"json\", success:function(data)&#123; alert(data); &#125; &#125;); &#125;); &#125;)&lt;/script&gt;&lt;!-- 测试异步请求 --&gt;&lt;input type=\"button\" value=\"测试ajax, 请求json和响应json\" id=\"testJson\"/&gt; 12345678@Controller(\"jsonController\")public class JsonController &#123; @RequestMapping(\"/testResponseJson\") public @ResponseBody Account testResponseJson(@RequestBody Account account) &#123; System.out.println(\"异步请求：\"+account); return account; &#125;&#125; 文件上传本服务器文件上传前端页面form表单的enctype属性（表示表单请求正文的类型）的默认值是application/x-www-form-urlencoded，要实现文件上传必须将该属性的值设置为multipart/form-data，并且表单的method属性必须是POST，同时提供一个文件选择域&lt;input type=&quot;file&quot;/&gt;。 SpringMVC实现文件上传需要导入以下包，会用到commons-fileupload包的文件上传解析器，而该包依赖于commons-io： 12345678910&lt;dependency&gt; &lt;groupId&gt;commons-fileupload&lt;/groupId&gt; &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt; &lt;version&gt;1.3.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;commons-io&lt;/groupId&gt; &lt;artifactId&gt;commons-io&lt;/artifactId&gt; &lt;version&gt;2.4&lt;/version&gt;&lt;/dependency&gt; jsp页面： 123456789&lt;%@ page contentType=\"text/html;charset=UTF-8\" language=\"java\" %&gt;&lt;html&gt;&lt;body&gt; &lt;form action=\"test/fileUpload\" method=\"post\" enctype=\"multipart/form-data\"&gt; 图片：&lt;input type=\"file\" name=\"uploadFile\"&gt; &lt;input type=\"submit\" value=\"上传\"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; 控制器代码： 1234567891011121314151617181920@Controller@RequestMapping(\"/test\")public class FileUploadController &#123; @RequestMapping(\"/fileUpload\") //SpringMVC提供了MultipartFile类来接收上传文件 public String testFileUpload(MultipartFile uploadFile, HttpServletRequest request) throws Exception&#123; String fileName = uploadFile.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace(\"-\",\"\").toUpperCase(); fileName = uuid + \"_\" + fileName; String path = request.getSession().getServletContext().getRealPath(\"/uploads/\"); File file = new File(path); if(!file.exists()) file.mkdirs(); //transferTo(File file)方法写入文件到路径 uploadFile.transferTo(new File(path,fileName)); return \"success\"; &#125;&#125; 123456789&lt;!-- 配置文件上传解析器 --&gt;&lt;!-- 注意id的值是固定的--&gt;&lt;bean id=\"multipartResolver\" class=\"org.springframework.web.multipart.commons.CommonsMultipartResolver\"&gt;&lt;!-- 设置上传文件的最大尺寸为 5MB --&gt;&lt;property name=\"maxUploadSize\"&gt; &lt;value&gt;5242880&lt;/value&gt;&lt;/property&gt;&lt;/bean&gt; 跨服务器文件上传在实际开发中，会有很多处理不同功能的服务器。例如： 应用服务器：负责部署应用。数据库服务器：运行数据库。缓存和消息服务器：负责处理大并发访问的缓存和消息。文件服务器：负责存储用户上传文件的服务器。 (注意：此处说的不是服务器集群）此时我们就需要将用户上传的文件从应用服务器上传到文件服务器。 导入依赖： 12345678910&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-core&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.sun.jersey&lt;/groupId&gt; &lt;artifactId&gt;jersey-client&lt;/artifactId&gt; &lt;version&gt;1.18.1&lt;/version&gt;&lt;/dependency&gt; 控制器代码如下： 1234567891011121314151617181920@Controller@RequestMapping(\"/test\")public class FileUploadController &#123; @RequestMapping(\"/fileUpload\") //SpringMVC提供了MultipartFile类来接收上传文件 public String testFileUpload(MultipartFile uploadFile) throws Exception&#123; String path = \"文件服务器的存储路径/\"; String fileName = uploadFile.getOriginalFilename(); String uuid = UUID.randomUUID().toString().replace(\"-\",\"\").toUpperCase(); fileName = uuid + \"_\" + fileName; //创建客户端对象 Client client = Client.create(); //和文件服务器连接 WebResource webResource = client.resource(path+fileName); //上传 webResource.put(uploadFile.getBytes()); return \"success\"; &#125;&#125; 异常处理一旦产生异常则向上抛出，持久层DAO -&gt; 业务层Service -&gt; 表现层Controlller ，最终由SpringMVC的DispatherServlet匹配异常处理器组件进行处理。 自定义异常类1234public class MyException extends Exception&#123; private Stirng message; //构造器.setter and getter&#125; Controller方法中抛出该自定义异常，由我们定义的异常处理器捕获并处理。 自定义异常处理器并配置自定义异常处理器需要实现HandlerExceptionResolver接口，该接口提供了resolveException(Exception, Hanlder)方法的一个实现，方法会返回一个ModelAndView。 另外，我们也可以使用框架已有的异常处理器实现类SimpleMappingExceptionResolver。 1234567public class MyExceptionResolver implements HandlerExceptionResolver&#123; public ModelAndView resolveException(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)&#123; ModelAndView mv = new ModelAndView(); mv.addObject(\"errorMsg\", ex.getMessage()); mv.setViewName(\"error\");//返回error.jsp &#125;&#125; 1&lt;bean id=\"myExceptionResolver\" class=\"org.example.exception.MyExceptionResolver\"&gt; &lt;/bean&gt; @ExceptionHandlerHandlerExceptionResolver接口以及SimpleMappingExceptionResolver解析器类的实现使得你能声明式地将异常映射到特定的视图上，还可以在异常被转发（forward）到对应的视图前使用Java代码做些判断和逻辑。不过在一些场景，特别是依靠@ResponseBody返回响应而非依赖视图解析机制的场景（比如Restful风格）下，直接设置响应的状态码并将客户端需要的错误信息直接写回响应体中，可能是更方便的方法。 如果@ExceptionHandler方法是在控制器内部定义的，那么它会接收并处理由控制器（或其任何子类）中的@RequestMapping方法抛出的异常。 此外，@ExceptionHandler注解还可以接受一个异常类型的数组作为参数值。若抛出了已在列表中声明的异常，那么相应的@ExceptionHandler方法将会被调用。如果没有给注解任何参数值，那么默认处理的异常类型将是方法参数所声明的那些异常。 @ExceptionHandler方法的返回值可以是String类型——这种情况下会被解析为视图名——可以是ModelAndView类型的对象，也可以是ResponseEntity。或者你还可以在方法上添加@ResponseBody注解以使用消息转换器会转换信息为特定类型的数据，然后把它们写回到响应流中。例如： 1234567891011121314151617181920@ExceptionHandler(Exception.class)@ResponseStatus(HttpStatus.OK)@ResponseBodypublic Object handlerException(HttpServletRequest request, Exception e)&#123; //直接返回e或者businessException的话, json中会包含很多虚拟机栈跟踪信息, //因此使用map取出错误状态码和错误信息即可 Map&lt;String, Object&gt; responseData = new HashMap&lt;&gt;(); if(e instanceof BusinessException)&#123; BusinessException businessException = (BusinessException)e; responseData.put(\"errorCode\", businessException.getErrorCode()); responseData.put(\"errorMessage\", businessException.getErrorMessage()); &#125;else &#123; responseData.put(\"errorCode\", EnumBusinessError.UNKNOWN_ERROR.getErrorCode()); responseData.put(\"errorMessage\", EnumBusinessError.UNKNOWN_ERROR.getErrorMessage()); &#125; //归一化处理，返回通用对象 return CommonReturnType.create(responseData, \"fail\");&#125; 拦截器Spring MVC的处理器拦截器类似于Servlet的过滤 Filter，用于对处理器进行预处理和后处理。它们的区别是：过滤器在 url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者js是不会进行拦截的。 我们也可以定义拦截器链，在访问被拦截的方法时，拦截器链 中的拦截器会按照定义的顺序执行。 拦截器是AOP思想的具体应用，由动态代理实现。要自定义拦截器，需要实现HandlerInterceptor接口。 自定义拦截器12345678910111213public class MyInterceptor implements HandlerInterceptor&#123; /** * controller方法执行前，进行拦截的方法 * return true放行 * return false拦截 * 可以使用转发或者重定向直接跳转到指定的页面。 */ public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception &#123; System.out.println(\"拦截器执行了...\"); return true; &#125;&#125; springmvc.xml中配置 12345678910&lt;!-- 配置拦截器 --&gt;&lt;mvc:interceptors&gt; &lt;mvc:interceptor&gt; &lt;!-- 哪些方法进行拦截 --&gt; &lt;mvc:mapping path=\"/user/*\"/&gt; &lt;!-- 哪些方法不进行拦截 &lt;mvc:exclude-mapping path=\"\"/&gt;--&gt; &lt;!-- 注册拦截器对象 --&gt; &lt;bean class=\"cn.itcast.demo1.MyInterceptor\"/&gt; &lt;/mvc:interceptor&gt;&lt;/mvc:interceptors&gt; HandlerInterceptor接口方法preHandle控制器方法执行前拦截的方法。 可以使用request或者response跳转到指定的页面 。 return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。 return false不放行，不会执行controller中的方法。 postHandle控制器方法执行后执行的方法，在JSP视图执行前。 可以使用request或者response跳转到指定的页面。 如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。 afterCompletion最后执行的方法，JSP视图执行后执行。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"Spring事务处理","slug":"Spring事务处理","date":"2020-10-17T01:55:38.000Z","updated":"2020-11-23T14:23:21.098Z","comments":true,"path":"JavaWeb/Spring事务处理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/","excerpt":"","text":"概述 Spring事务控制的API PlatFormTransactionManager DataSourceTransactionManager TransactionDefinition TransactionStatus Spring声明式事务控制 XML配置实现 注解配置实现 纯注解配置实现 概述JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了业务层的事务处理解决方案。 Spring为我们提供了一组事务控制的接口，在spring-txjar包中。 Spring的事务控制基于AOP，可以通过编程和配置两种方式实现。主要使用配置的方式。 Spring事务控制的APIPlatFormTransactionManager12345678910public interface PlatformTransactionManager extends TransactionManager &#123; //获取事务状态 TransactionStatus getTransaction(@Nullable TransactionDefinition var1) throws TransactionException; //提交事务 void commit(TransactionStatus var1) throws TransactionException; //回滚事务 void rollback(TransactionStatus var1) throws TransactionException;&#125; DataSourceTransactionManager真正管理事务的对象。该类继承自PlatFormTransactionManager的抽象实现类AbstractPlatformTransactionManager。 TransactionDefinition12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public interface TransactionDefinition &#123; //如果当前没有事务，则新建一个事务，如果已经存在一个事务，则加入到这个事务中。默认值 int PROPAGATION_REQUIRED = 0; //支持当前事务，如果当前没有事务，则以非事务方式运行 int PROPAGATION_SUPPORTS = 1; //使用当前的事务，若当前没有事务，则抛出异常 int PROPAGATION_MANDATORY = 2; //新建事务，如果当前在事务中，把当前事务挂起 int PROPAGATION_REQUIRES_NEW = 3; //以非事务方式执行操作，如果当前存在事务，把当前事务挂起 int PROPAGATION_NOT_SUPPORTED = 4; //以非事务方式运行，若当前存在事务，抛出异常 int PROPAGATION_NEVER = 5; //若当前存在事务，则在嵌套事务内执行。若当前没有事务，则执行REQUIRED类似的操作。 int PROPAGATION_NESTED = 6; int ISOLATION_DEFAULT = -1;//默认使用数据库的事务隔离级别，归属下别某一种 int ISOLATION_READ_UNCOMMITTED = 1;//可以读取未提交数据 int ISOLATION_READ_COMMITTED = 2;//只能读取已提交数据，解决脏读问题（Oracle默认级别） int ISOLATION_REPEATABLE_READ = 4;//是否读取其他事务提交修改后的数据，解决不可重复读问题 int ISOLATION_SERIALIZABLE = 8;//是否读取其他事务提交添加后的数据，解决幻影读问题 int TIMEOUT_DEFAULT = -1;//默认没有超时时间，正数时单位为秒 //获取事务传播行为 default int getPropagationBehavior() &#123; return 0; &#125; //获取事务隔离级别，默认使用数据库的事务隔离级别 default int getIsolationLevel() &#123; return -1; &#125; //获取事务超时时间 default int getTimeout() &#123; return -1; &#125; //事务是否只读，建议查询时设置为只读。 default boolean isReadOnly() &#123; return false; &#125; //获取事务名称 @Nullable default String getName() &#123; return null; &#125; //获取默认的事务定义信息对象 static TransactionDefinition withDefaults() &#123; return StaticTransactionDefinition.INSTANCE; &#125;&#125; TransactionStatus该接口描述了某个时间点上事务对象的状态信息，包含6个具体的操作。 void flush()：刷新事务。 boolean hasSavepoint()：是否存在存储点。 boolean isCompleted()：事务是否完成。 boolean isNewTransaction()：是否是新的事务。 boolean isRollbackOnly()：事务是否回滚。 void setRollbackOnly()：设置事务回滚。 Spring声明式事务控制XML配置实现案例代码。配置步骤如下： 导入命名空间和约束： 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt;&lt;/beans&gt; 配置事务管理器： 1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--需要先配置数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; 配置事务的通知： 1&lt;tx:advice id=\"transactionInterceptor\" transaction-manager=\"transactionManager\"&gt;&lt;/tx:advice&gt; 配置AOP中通用的切入点表达式： 1234&lt;aop:config&gt; &lt;!--配置切入点表达式--&gt; &lt;aop:pointcut id=\"pt\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;/aop:config&gt; 建立事务通知和切入点表达式的关系： 12345&lt;aop:config&gt; &lt;aop:pointcut id=\"pt\" expression=\"execution(* com.itheima.service.impl.*.*(..))\"/&gt; &lt;!--建立事务通知和切入点表达式的关系--&gt; &lt;aop:advisor advice-ref=\"transactionInterceptor\" pointcut-ref=\"pt\"&gt;&lt;/aop:advisor&gt; &lt;/aop:config&gt; 在事务通知标签内配置事务的属性： 1234567891011121314&lt;tx:advice id=\"transactionInterceptor\" transaction-manager=\"transactionManager\"&gt; &lt;!--5.配置事务的属性 isolation: 指定事务隔离级别。默认DEFAULT,表示使用数据库默认事务隔离级别 propagation: 指定事务的传播行为。默认值是REQUIRED,增删改的选择。查询可选用SUPPORTS read-only: 指定事务是否只读。只有查询才能设置为true rollback-for: 指定一个异常，产生该异常时，事务回滚；产生其他异常时，事务不回滚。不指定则任何异常都回滚。 no-rollback-for: 指定一个异常，产生该异常时，事务不回滚；产生其他异常时，事务回滚。不指定则任何异常都回滚。 timeout:指定超时时间，默认没有 --&gt; &lt;tx:attributes&gt; &lt;tx:method name=\"*\" propagation=\"REQUIRED\" read-only=\"false\"/&gt; &lt;tx:method name=\"find*\" propagation=\"SUPPORTS\" read-only=\"true\"&gt;&lt;/tx:method&gt; &lt;/tx:attributes&gt; &lt;/tx:advice&gt; 注解配置实现案例代码。配置步骤如下： 导入命名空间和约束： 12345678910111213141516&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:tx=\"http://www.springframework.org/schema/tx\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/tx https://www.springframework.org/schema/tx/spring-tx.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt;&lt;/beans&gt; 配置事务管理器： 1234&lt;bean id=\"transactionManager\" class=\"org.springframework.jdbc.datasource.DataSourceTransactionManager\"&gt; &lt;!--需要先配置数据源--&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; 纯注解方式则创建配置类： 12345678910/** * 创建事务管理器配置类 */public class TransactionConfig &#123; @Bean(name = \"transactionManager\") public PlatformTransactionManager createTransactionManager(DataSource dataSource)&#123; return new DataSourceTransactionManager(dataSource); &#125;&#125; 开启Spring对注解事务的支持： 1&lt;tx:annotation-driven transaction-manager=\"transactionManager\"&gt;&lt;/tx:annotation-driven&gt; 纯注解方式在主配置类上使用@EnableTransactionManagement来开启。 在需要事务支持的地方使用@Transactional标记。比如业务层接口实现类上或者其方法（切入点方法）之上。 纯注解配置实现案例代码","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"Spring模板类JdbcTemplate","slug":"Spring模板类JdbcTemplate","date":"2020-10-17T01:55:21.000Z","updated":"2020-11-23T14:23:21.100Z","comments":true,"path":"JavaWeb/Spring模板类JdbcTemplate/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Spring%E6%A8%A1%E6%9D%BF%E7%B1%BBJdbcTemplate/","excerpt":"","text":"JdbcTemplate概述 JdbcTemplate实现CRUD 增加（Create） 删除（Delete） 更新（Update） 检索（Retrieve） JdbcDaoSupport JdbcTemplate概述JdbcTemplate是对原始JDBC API的简单封装。除该模板类以外，Spring还提供了操作关系型数据库的HibernateTemplate，操作NoSQL数据库的RedisTemplate，操作消息队列的JmsTemplate。 Maven依赖： 1234567891011121314151617181920212223&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-tx&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;8.0.21&lt;/version&gt;&lt;/dependency&gt; JdbcTemplate实现CRUD123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;bean id=\"jdbcTemplate\" class=\"org.springframework.jdbc.core.JdbcTemplate\"&gt; &lt;property name=\"dataSource\" ref=\"dataSource\"&gt;&lt;/property&gt; &lt;/bean&gt; &lt;bean id=\"dataSource\" class=\"org.springframework.jdbc.datasource.DriverManagerDataSource\"&gt; &lt;property name=\"driverClassName\" value=\"com.mysql.cj.jdbc.Driver\"&gt;&lt;/property&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC\"&gt;&lt;/property&gt; &lt;property name=\"username\" value=\"root\"&gt;&lt;/property&gt; &lt;property name=\"password\" value=\"admin\"&gt;&lt;/property&gt; &lt;/bean&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142package com.itheima.domain;import java.io.Serializable;public class Account implements Serializable &#123; private Integer id; private String name; private Float money; public Integer getId() &#123; return id; &#125; public void setId(Integer id) &#123; this.id = id; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Float getMoney() &#123; return money; &#125; public void setMoney(Float money) &#123; this.money = money; &#125; @Override public String toString() &#123; return \"Account&#123;\" + \"id=\" + id + \", name='\" + name + '\\'' + \", money=\" + money + '&#125;'; &#125;&#125; 12345678public class JdbcTemplateDemo &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean.xml\"); JdbcTemplate jdbcTemplate =(JdbcTemplate) applicationContext.getBean(\"jdbcTemplate\"); //CRUD操作 &#125;&#125; 增加（Create）1jdbcTemplate.update(\"insert into account(name,money) values(?,?)\",\"bbb\",1000); 删除（Delete）1jdbcTemplate.update(\"delete from account where id=?\", 7); 更新（Update）1jdbcTemplate.update(\"update account set name=?,money=? where id=?\", \"aaa\", 1000, 1); 检索（Retrieve）1234567891011121314151617181920/** * 定义Account的封装策略 */ static class AccountRowMapper implements RowMapper&lt;Account&gt;&#123; /** * 将结果集的数据封装到Account中，然后Spring将Account加到List&lt;Account&gt;中 * @param resultSet * @param i * @return * @throws SQLException */ @Override public Account mapRow(ResultSet resultSet, int i) throws SQLException &#123; Account account = new Account(); account.setId(resultSet.getInt(\"id\")); account.setName(resultSet.getString(\"name\")); account.setMoney(resultSet.getFloat(\"money\")); return account; &#125; &#125; 1List&lt;Account&gt; accountList = jdbcTemplate.query(\"select * from account where money &gt; ?\",new AccountRowMapper(),1000f); 实际使用中不需要自己实现RowMapper，可使用Spring提供的BeanPropertyRowMapper类。 1List&lt;Account&gt; accountList = jdbcTemplate.query(\"select * from account where money &gt; ?\",new BeanPropertyRowMapper&lt;Account&gt;(Account.class),1000f); 使用聚合函数： 1Long count = jdbcTemplate.queryForObject(\"select count(*) from account where money &gt; ?\", Long.class, 500f); JdbcDaoSupport使DAO类继承自JdbcDaoSupport，则DAO类不再需要在代码中注入数据源和JdbcTemplate变量，而是在代码中使用super.getJdbcTemplate()获取。这样写的好处是当有大量DAO时，可以减少重复代码，适用于XML配置的方式。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"CGLib动态代理","slug":"CGLib动态代理","date":"2020-10-16T02:50:22.000Z","updated":"2020-11-23T14:23:20.987Z","comments":true,"path":"JavaWeb/CGLib动态代理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"概述 使用 JDK与CGLib动态代理区别 区别 使用注意 Spring中如何选择代理机制？ 概述CGLib是一个强大、高性能的字节码生产类库，可以实现运行期动态扩展Java类和实现Java接口，Spring在运行期间通过 CGlib继承被代理类，重写父类的方法，实现AOP面向切面编程。 使用使用Enhancer类的create方法得到代理对象，该方法的参数列表： Class ：被代理类的class对象 Callback：用于提供增强的代码，一般写该接口的实现类MethodInterceptor 1234567Object cgLibProxy = Enhancer.create(XXX.getClass(), new MethodInterceptor()&#123; //执行被代理类的任何方法都会经过该方法 @Override public Object intercept(Object o, Method method, Object[] args, MethodProxy methodProxy) throws Throwable&#123; return null; &#125;&#125;); JDK与CGLib动态代理区别区别 JDK动态代理是面向接口，通过创建代理实现类实现，创建代理速度比CGLib快。 CGLib动态代理是通过继承被代理类实现（如果被代理类被final关键字所修饰，那么会失败），创建代理没有JDK动态代理快，但是运行速度比JDK动态代理要快。 使用注意如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制） 如果被代理类不是实现类，Spring会强制使用CGLib来实现动态代理。 Spring中如何选择代理机制？12&lt;aop:config proxy-target-class=\"true\"&gt;&lt;/aop:config&gt; 通过配置Spring的中aop:config标签来显示的指定使用动态代理机制 proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK动态代理。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"开发原则","slug":"开发原则","date":"2020-10-13T07:23:38.000Z","updated":"2020-11-23T14:23:21.122Z","comments":true,"path":"软件工程/开发原则/","link":"","permalink":"http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/","excerpt":"","text":"概述 S：单一职责原则（Single-Responsibility Principle） 定义 原则分析 例子 O：开闭原则（Open - Closed Principle） 定义 原则分析 例子 L：里氏替换原则（Liskov Substitution Principle） 定义 原则分析 I：接口隔离原则（Interface Segregation Principle） 定义 原则分析 D：依赖倒置原则（Dependency-Inversion Principle） 定义 原则分析 例子 组合/聚合复用原则（Composite/Aggregate Reuse Principle） 定义 原则分析 迪米特法则（Law of Demeter） 例子 设计原则核心思想 概述在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式， 不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。 面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有 迪米特法则和合成复用原则。 S：单一职责原则（Single-Responsibility Principle）定义一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中。 原则分析 一个类(或者大到模块，小到方法)承担的职责越多，它被复用的可能性越小；如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。 类的职责主要包括两个方面: 数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。 单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。 例子单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否合理，但是“职责”和“变化原因”都是没有具体标准的，一个类到底要负责那些职责? 这些职责怎么细化? 细化后是否都要有一个接口或类? 这些都需从实际的情况考虑。因项目而异，因环境而异。 例：SpringMVC 中Entity, DAO, Service, Controller, Util等的分离。 O：开闭原则（Open - Closed Principle）定义一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭。 原则分析 当软件实体因需求要变化时, 尽量通过扩展已有软件实体，可以提供新的行为，以满足对软件的新的需求，而不是修改已有的代码，使变化中的软件有一定的适应性和灵活性 。已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性。 实现开闭原则的关键就是抽象化：在开闭原则中，不允许修改抽象类或者接口，允许扩展的是具体的实现类。抽象类和接口在开闭原则中扮演着极其重要的角色，既要预知可能变化的需求，又要预见所有可能已知的扩展，所以在这里”抽象化”是关键! 可变性的封闭原则：找到系统的可变因素，将它封装起来。 不要把可变因素放在多个类中，或者散落在程序的各个角落，应该将可变因素封装起来，并且切忌不要把所有的可变因素封装在一起，应该分块封装可变因素。 例子设计模式中模板方法模式和观察者模式都是开闭原则的极好体现。 L：里氏替换原则（Liskov Substitution Principle）定义 所有引用父类的地方必须能透明地替换为其子类的对象。 原则分析 讲的是基类和子类的关系，只有这种关系存在时，里氏替换原则才存在。正方形是长方形是理解里氏替换原则的经典例子。 里氏替换原则可以通俗表述为： 在软件中如果能够使用基类对象，那么一定能够使用其子类对象。把基类都替换成它的子类，程序将不会产生任何错误和异常，反之不成立，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。 里氏替换原则是实现开闭原则的重要方式之一【抽象类和接口（不允许修改）看作基类，实现类（允许扩展）看作子类】，由于使用基类对象的地方都可以使用子类对象，因此在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象。 I：接口隔离原则（Interface Segregation Principle）定义客户端不应该依赖那些它不需要的接口。 另一种定义：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。 注意，在该定义中的接口指的是方法。例如调用某个类的public方法。这个方法对外就是接口。 原则分析 使用多个专门的接口，而不使用单一的总接口。 使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。 D：依赖倒置原则（Dependency-Inversion Principle）定义高层模块不应该依赖（使用）低层模块，它们都应该依赖抽象。抽象不应该依赖（使用）具体，具体应该依赖（使用）抽象。 原则分析 如果说开闭原则是面向对象设计的目标，依赖倒置原则则是手段。 依赖倒置原则的中心思想是面向接口编程。 依赖倒置原则是里氏替换原则的补充。 例子依赖倒置原则的常用实现方式之一是在代码中使用抽象，而将具体类放在配置文件中。 例：Spring中的依赖注入。 组合/聚合复用原则（Composite/Aggregate Reuse Principle）定义尽量使用对象组合，而不是继承来达到复用的目的。 原则分析 组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用。 其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。 迪米特法则（Law of Demeter）系统中的类尽量不要与其他类互相作用，以减少类之间的耦合度。又叫最少知识原则(Least Knowledge Principle)。 目标：实现高内聚、低耦合。 例子设计模式Facade模式、Mediator模式。 设计原则核心思想 找出应用中可能需要变化之处，把它们独立出来，不要和那些不需要变化的代码混在一起。 针对接口编程，而不是针对实现编程。 为了交互对象之间的松耦合设计而努力。 参考：https://www.pdai.tech/md/dev-spec/spec/dev-th-solid.html","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"软件开发过程模型","slug":"软件开发过程模型","date":"2020-10-13T07:23:02.000Z","updated":"2020-11-23T14:23:21.139Z","comments":true,"path":"软件工程/软件开发过程模型/","link":"","permalink":"http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"软件开发过程模型 瀑布模型（Waterfall Model） 模型特点 模型优点 模型局限 适用场景 演化模型（Evolutionary Model） 快速原型（Rapid Prototype） 模型特点 模型优点 模型局限 适用场景 原型进化（ Prototype Evolution） 增量模型（Incremental Model） 模型特点 模型优点 模型局限 适用场景 螺旋模型（Spiral Model） 模型特点 模型优点 模型局限 适用场景 喷泉模型（Water Fountain Model） 模型优点 模型局限 基于构件的开发模型（Component-based Development Model） 具体开发流程参考 软件开发过程模型瀑布模型（Waterfall Model）瀑布模型（经典生命模型）提出了软件开发的系统化的、顺序的方法。其流程从用户需求规格说明开始，通过策划、建模、构建和部署过程，最终提供一个完整的软件并提供持续的技术支持。 模型特点 必须等前一阶段的工作完成之后，才能开始后一段的工作。 每一阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。 前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能得到正确的结果。 每个阶段结束前都要对所完成的文档进行评审，以便及早发现问题，改正错误。事实上越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正错误所需付出的代价也越高。因此，及时审查，是保证软件质量，降低软件成本的重要措施。 模型优点 强调了开发的阶段性，各阶段具有顺序性和依赖性 强调早期调研和需求分析，推迟编码实现的观点 提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。 模型局限 瀑布模型是一种线性模型，要求项目严格按规程推进，必须等到所有开发工作全部完成以后才能获得可以交付的软件产品。不能对软件系统进行快速创建，对于一些急于交付的软件系统的开发很不方便。 瀑布模型适合于需求明确，且无大的需求变更的软件开发（编译系统、操作系统等）。而对于分析初期需求模糊的项目，瀑布模型也并不适合。 适用场景适用于需求确定，无大的需求变更，工作能够采用线性的方式完成的软件。 演化模型（Evolutionary Model）快速原型（Rapid Prototype）软件开发过程中，开发初期很难得到一个完整的、准确的需求规格说明，开发者往往对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。为了适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）开发方法。 模型特点 快速原型是用来获取用户需求的，或是用来试探设计是否有效的。一旦需求或设计确定下来了，原型就将被抛弃。因此，快速原型要求快速构件、容易修改，以节约原型创建的成本、加快开发速度。 快速原型是暂时适用使用的，因此并不要求完整。它往往针对某个局部问题建立专门原型，如界面原型、工作流原型等。 快速原型不能贯穿软件的整个生命周期，它需要和其他的过程模型相结合才能产生作用。例如，在瀑布模型中应用快速原型，以解决瀑布模型在需求分析时期存在的不足。 模型优点 能渐进地启发客户提出新的要求或任务，促使开发人员和用户达成共识。 减少了开发风险，避免了因为需求不确定而在开发过程中浪费了大量的资源。 模型局限 没有考虑到软件的整体和长期的可维护性。 可能由于达不到质量要求而导致产品被抛弃，从而采用新的模型重新设计。 适用场景原型方法比较适用于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。 原型进化（ Prototype Evolution）原型进化对开发过程的考虑是，针对有待开发的软件系统，先开发一个原型系统给用户使用，然后根据用户使用情况的意见反馈，对原型系统不断修改，使它逐步接近并最终到达开发目标。跟快速原型不同的是，快速原型在完成需求定义后将被抛弃，而原型进化所要创建的原型则是一个今后将要投入应用的系统，只是所创建的原型系统在功能、性能等方面还有许多不 足，还没有达到最终开发目标，需要不断改进。 原型进化的工作流程如图 2-3 所示。 从图中可以看到，它具有以下两个特点： 原型进化模型将软件的需求细部定义、产品开发和有效性验证放在同一个工作进程中交替或并行运作。因此，在获得了软件需求框架以后，例如软件的基本功能被确定以后，就可以直接进入到对软件的开发中。 原型进化模型是通过不断发布新的软件版本而使软件逐步完善的，因此，这种开发模式特别适合于那些用户急需的软件产品开发。它能够快速地向用户交付可以投入实际运行的软件成果，并能够很好地适应软件用户对需求规格的变更。 原型进化模型能够适应软件需求的中途变更，但在应用的时候，以下问题需要得到足够的重视： 原型进化模型虽说使开发进程加快了，但不能像瀑布模型那样提供明确的里程碑管理，随着开发过程中版本的快速更新，项目管理、软件配置管理会变得复杂起来，管理者难以把握开发进度。因此，对于大型软件项目，原型进化模型缺乏有效的管理规程。 开发过程中软件版本的快速变更，还可能损伤软件的内部结构，使其缺乏整体性和稳定性。另外，用于反映软件版本变更的文档也有可能跟不上软件的变更速度。这些问题必将影响到今后软件的维护。 增量模型（Incremental Model）增量模型融合了瀑布模型的基本成分和原型进化模型的迭代特征，它对软件过程的考虑是：在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际开发中，则将软件系统按功能分解为许多增减构件，并以构件为单位逐个地创建与交付，直到全部增量构件创建完成，并都被集成到系统之中交付用户使用。 模型特点 当使用增量模型时，第一个增量往往是核心的产品。 客户对每个增量的使用和评估都作为下一个增量发布的新特性和功能。 该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。 模型优点 第一个可交付版本所需要的成本和时间很少。 开发由增量表示的小系统所承担的风险不大。 由于很快发布了第一个版本，因此可以减少用户需求的变更。 运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。 模型局限 管理发生的成本、进度和配置的复杂性可能会超出组织的能力。 如果没有对用户的变更要求进行规划，那么产生的出事增量可能会造成后来增量的不稳定。 如果需求不想早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。 适用场景项目在既定的商业要求期限之前不可能找到足够的开发人员的情况。 螺旋模型（Spiral Model）对于复杂的大型软件，开发一个原型往往达不到要求。螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析，弥补了这两种模型的不足。 螺旋线中的每个回路都被分成为四个步骤： 制定计划：确定软件的目标，选定实施方案，明确项目开发的限制条件； 风险评估：分析所选的方案，识别风险，消除风险； 实施工程：实施软件开发，验证阶段性产品； 用户评估：评价开发工作，提出修正建议，建立下一个周期的开发计划。 模型特点 与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便。 使用螺旋模型进行软件开发，需要开发人员具有相当丰富的风险评估经验和专门知识。 模型优点 关注软件的重用。 关注早期错误的消除。 将质量目标放在首位。 将开发阶段与维护阶段结合在一起。 模型局限 开发人员需要有较强的风险评估的经验。 契约开发通常需要事先指定过程模型和发布产品。 适用场景螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型适合用于庞大、复杂并且具有高风险的系统。 喷泉模型（Water Fountain Model）喷泉模型是专门针对面向对象软件开发方法而提出的。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性。 无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限，由于对象概念的引入，表达分析、设计、实现等活动只用对象类和关系，从而可以较为容易地实现活动的迭代和无间隙，使其开发自然地包括复用。 在面向对象方法中，对象既是对现实问题中实体的抽象，也是构造软件系统的基本元素。 因此，建立对象模型在面向对象方法中，既可以用于分析，也可以用于设计，而且分析阶段所获得的对象框架模型可以无缝过渡到设计阶段，以作为软件实现的依据。 开发步骤： 第一阶段软件开发的目标可以是软件的基本功能； 第二阶段可以是在第一阶段建立的软件 的基础上，对软件进行进一步的完善，并实现软件的主要功能； 第三阶段则是在第二阶段的基 础上，对软件进行更加完整的开发，并以实现软件全部功能作为创建目标。 应该说，喷泉模型能够较有效地平衡软件系统的近期需求与远期规划，因此能够较好地满足用户在软件应用上的发展需要。 模型优点喷泉模型不像瀑布模型那样，需要分析活动结束后才开始设计活动，设计活动结束后才开始编码活动。该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。其优点是可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。 模型局限由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，因此不利于项目的管理。此外这种模型要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。 基于构件的开发模型（Component-based Development Model）基于构件的开发方法是指利用预先包装的构件来构造应用系统。构件可以是组织内部开发的构件，也可以是商品化成品构件。基于构件的开发模型具有许多螺旋模型的特点，它本质上是演化模型，需要以迭代方式构件软件。其不同之处在于，基于构件的开发模型采用预先打包的软件构件开发应用。 具体开发流程参考类似于螺旋模型，结合了瀑布模型和演化模型。 本文参考： https://www.cnblogs.com/jojop/p/11801241.html https://www.cnblogs.com/youcong/p/9498489.html","categories":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}],"tags":[{"name":"软件工程","slug":"软件工程","permalink":"http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"}]},{"title":"阿里巴巴 Java 开发手册 v1.2.0","slug":"阿里巴巴Java开发手册","date":"2020-10-02T08:42:19.000Z","updated":"2020-11-25T04:16:05.563Z","comments":true,"path":"杂项/阿里巴巴Java开发手册/","link":"","permalink":"http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/","excerpt":"","text":"前言 编程规范 命名风格 常量定义 代码格式 OOP 规约 集合处理 并发处理 控制语句 注释规约 其他 异常日志 异常处理 日志规约 MYSQL 数据库 建表规约 索引规约 SQL 语句 ORM 映射 工程结构 应用分层 二方库依赖 服务器 安全规约 附 1：版本历史 附 2：本手册专有名词 前言《阿里巴巴 Java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、MySQL 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。 本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度个性化，以一种普遍认可的统一方式一起做事，提升协作效率。 《阿里巴巴 Java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。 编程规范命名风格 【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。反例： _name / __name / $Object / name_ / name$ / Object$ 【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。正例： alibaba / taobao / youku / hangzhou 等国际通用的名称，可视同英文。反例： DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3 【强制】类名使用 UpperCamelCase 风格，必须遵从驼峰形式，但以下情形例外：DO / BO / DTO / VO / AO正例： MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion反例： macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion 【强制】方法名、参数名、成员变量、局部变量都统一使用 lowerCamelCase 风格，必须遵从驼峰形式。正例： localValue / getHttpMessage() / inputUserId 【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。正例： MAX_STOCK_COUNT反例： MAX_COUNT 【强制】抽象类命名使用 Abstract 或 Base 开头；异常类命名使用 Exception 结尾；测试类命名以它要测试的类的名称开始，以 Test 结尾。 【强制】中括号是数组类型的一部分，数组定义如下：String[] args。反例： 使用 String args[] 的方式来定义。 【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。反例： 定义为基本数据类型 Boolean isDeleted；的属性，它的方法也是 isDeleted()，RPC 框架在反向解析的时候，“以为”对应的属性名称是 deleted，导致属性获取不到，进而抛出异常。 【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。正例： 应用工具类包名为 com.alibaba.open.util、类名为 MessageUtils（此规则参考 spring 的框架结构） 【强制】杜绝完全不规范的缩写，避免望文不知义。反例： AbstractClass “缩写”命名成 AbsClass；condition “缩写”命名成 condi，此类随意缩写严重降低了代码的可阅读性。 【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。说明： 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。正例： public class OrderFactory; public class LoginProxy; public class ResourceObserver; 【推荐】接口类中的方法和属性不要加任何修饰符号（public 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。正例： 接口方法签名：void f(); 接口基础常量表示：`String COMPANY = &quot;alibaba&quot;;` 反例： 接口方法定义：public abstract void f();说明： JDK8 中接口允许有默认实现，那么这个 default 方法，是对所有实现类都有价值的默认实现。 接口和实现类的命名有两套规则：1） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。 **正例：** `CacheServiceImpl` 实现 `CacheService` 接口。 2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。 **正例：** `AbstractTranslator` 实现 `Translatable`。 【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。说明： 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。正例： 枚举名字：DealStatusEnum，成员名称：SUCCESS / UNKOWN_REASON。 【参考】各层命名规约： Service/DAO 层方法命名规约1） 获取单个对象的方法用 get 做前缀。2） 获取多个对象的方法用 list 做前缀。3） 获取统计值的方法用 count 做前缀。4） 插入的方法用 save（推荐）或 insert 做前缀。5） 删除的方法用 remove（推荐）或 delete 做前缀。6） 修改的方法用 update 做前缀。 领域模型命名规约1） 数据对象：xxxDO，xxx 即为数据表名。2） 数据传输对象：xxxDTO，xxx 为业务领域相关的名称。3） 展示对象：xxxVO，xxx 一般为网页名称。4） POJO 是 DO/DTO/BO/VO 的统称，禁止命名成 xxxPOJO。 常量定义 【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。反例： String key = &quot;Id#taobao_&quot; + tradeId; cache.put(key, value); 【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。说明：Long a = 2l; 写的是数字的 21，还是 Long 型的 2? 【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。说明： 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。 【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。1） 跨应用共享常量：放置在二方库中，通常是 client.jar 中的 constant 目录下。2） 应用内共享常量：放置在一方库的 modules 中的 constant 目录下。 **反例：** 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量： 类 A 中：public static final String YES = &quot;yes&quot;; 类 B 中：public static final String YES = &quot;y&quot;; A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。 3） 子工程内部共享常量：即在当前子工程的 constant 目录下。4） 包内共享常量：即在当前包下单独的 constant 目录下。5） 类内共享常量：直接在类内部 private static final 定义。 【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。正例： public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6), SUNDAY(7);} 代码格式 【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：1） 左大括号前不换行。2） 左大括号后换行。3） 右大括号前换行。4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。 【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见第 5 条下方正例提示。 反例： if (空格 a == b 空格) 【强制】if/for/while/switch/do 等保留字与括号之间都必须加空格。 【强制】任何二目、三目运算符的左右两边都需要加一个空格。说明： 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。 【强制】缩进采用 4 个空格，禁止使用 tab 字符。说明： 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 Use tab character；而在 eclipse 中，必须勾选 insert spaces for tabs。正例： （涉及 1-5 点） public static void main(String[] args) { // 缩进 4 个空格 String say = &quot;hello&quot;; // 运算符的左右必须有一个空格 int flag = 0; // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格 if (flag == 0) { System.out.println(say); } // 左大括号前加空格且不换行；左大括号后换行 if (flag == 1) { System.out.println(&quot;world&quot;); // 右大括号前换行，右大括号后有 else，不用换行 } else { System.out.println(&quot;ok&quot;); // 在右大括号后直接结束，则必须换行 } } 【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。2） 运算符与下文一起换行。3） 方法调用的点符号与下文一起换行。4） 在多个参数超长，在逗号后换行。5） 在括号前不要换行，见反例。 正例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;); 反例： StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append (&quot;huang&quot;); //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); 【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。正例： 下例中实参的”a”,后边必须要有一个空格。method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;); 【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。 【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。正例： int a = 3; long b = 4L; float c = 5F; StringBuffer sb = new StringBuffer(); 说明： 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。 【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。说明： 没有必要插入多个空行进行隔开。 OOP 规约 【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。 【强制】所有的覆写方法，必须加@Override 注解。说明： getObject() 与 get0bject() 的问题。一个是字母的 O，一个是数字的 0，加 @Override可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。 【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 Object。说明： 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）正例： public User getUsers(String type, Integer... ids) {...} 【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 @Deprecated 注解，并清晰地说明采用的新接口或者新服务是什么。 【强制】不能使用过时的类或方法。说明： java.net.URLDecoder 中的方法 decode(String encodeStr) 这个方法已经过时，应该使用双参数 decode(String source, String encode)。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。 【强制】Object 的 equals 方法容易抛空指针异常，应使用常量或确定有值的对象来调用equals。正例： &quot;test&quot;.equals(object);反例： object.equals(&quot;test&quot;);说明： 推荐使用 java.util.Objects#equals （JDK7 引入的工具类） 【强制】所有的相同类型的包装类对象之间值的比较，全部使用 equals 方法比较。说明：对于 Integer var = ? 在-128 至 127 范围内的赋值，Integer 对象是在IntegerCache.cache 产生，会复用已有对象，这个区间内的 Integer 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 equals 方法进行判断。 关于基本数据类型与包装数据类型的使用标准如下：1） 【强制】所有的 POJO 类属性必须使用包装数据类型。2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。3） 【推荐】所有的局部变量使用基本数据类型。说明： POJO 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何NPE 问题，或者入库检查，都由使用者来保证。正例： 数据库的查询结果可能是 null，因为自动拆箱，用基本数据类型接收有 NPE 风险。反例： 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 null 值，能够表示额外的信息，如：远程调用失败，异常退出。 【强制】定义 DO/DTO/VO 等 POJO 类时，不要设定任何属性默认值。反例： POJO 类的 gmtCreate 默认值为 new Date();但是这个属性在数据提取时并没有置入具体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。 【强制】序列化类新增属性时，请不要修改 serialVersionUID 字段，避免反序列失败；如果完全不兼容升级，避免反序列化混乱，那么请修改 serialVersionUID 值。说明： 注意 serialVersionUID 不一致会抛出序列化运行时异常。 【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 init 方法中。 【强制】POJO 类必须写 toString 方法。使用 IDE 的中工具：source&gt; generate toString时，如果继承了另一个 POJO 类，注意在前面加一下 super.toString。说明： 在方法执行抛出异常时，可以直接调用 POJO 的 toString()方法打印其属性值，便于排查问题。 【推荐】使用索引访问用 String 的 split 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 IndexOutOfBoundsException 的风险。说明： String str = &quot;a,b,c,,&quot;; String[] ary = str.split(&quot;,&quot;); //预期大于 3，结果是 3 System.out.println(ary.length); 【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。 【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; getter/setter 方法。说明： 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 Service 和 DAO 的 getter/setter 方法放在类体最后。 【推荐】setter 方法中，参数名称与类成员变量名称一致，this.成员名 = 参数名。在 getter/setter 方法中，不要增加业务逻辑，增加排查问题的难度。反例： public Integer getData() { if (true) { return this.data + 100; } else { return this.data - 100; } } 【推荐】循环体内，字符串的连接方式，使用 StringBuilder 的 append 方法进行扩展。说明： 反编译出的字节码文件显示每次循环都会 new 出一个 StringBuilder 对象，然后进行 append 操作，最后通过 toString 方法返回 String 对象，造成内存资源浪费。反例： String str = &quot;start&quot;; for (int i = 0; i &lt; 100; i++) { str = str + &quot;hello&quot;; } 【推荐】final 可以声明类、成员变量、方法、以及本地变量，下列情况使用 final 关键字：1） 不允许被继承的类，如：String 类。2） 不允许修改引用的域对象，如：POJO 类的域变量。3） 不允许被重写的方法，如：POJO 类的 setter 方法。4） 不允许运行过程中重新赋值的局部变量。5） 避免上下文重复使用一个变量，使用 final 描述可以强制重新定义一个变量，方便更好地进行重构。 【推荐】慎用 Object 的 clone 方法来拷贝对象。说明： 对象的 clone 方法默认是浅拷贝，若想实现深拷贝需要重写 clone 方法实现属性对象的拷贝。 【推荐】类成员与方法访问控制从严：1） 如果不允许外部直接通过 new 来创建对象，那么构造方法必须是 private。2） 工具类不允许有 public 或 default 构造方法。3） 类非 static 成员变量并且与子类共享，必须是 protected。4） 类非 static 成员变量并且仅在本类使用，必须是 private。5） 类 static 成员变量如果仅在本类使用，必须是 private。6） 若是 static 成员变量，必须考虑是否为 final。7） 类成员方法只供类内部调用，必须是 private。8） 类成员方法只对继承类公开，那么限制为 protected。说明： 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。思考：如果是一个 private 的方法，想删除就删除，可是一个 public 的 service 方法，或者一个 public 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。 集合处理 【强制】关于 hashCode 和 equals 的处理，遵循如下规则：1） 只要重写 equals，就必须重写 hashCode。2） 因为 Set 存储的是不重复的对象，依据 hashCode 和 equals 进行判断，所以 Set 存储的对象必须重写这两个方法。3） 如果自定义对象做为 Map 的键，那么必须重写 hashCode 和 equals。说明： String 重写了 hashCode 和 equals 方法，所以我们可以非常愉快地使用 String 对象作为 key 来使用。 【强制】ArrayList 的 subList 结果不可强转成 ArrayList，否则会抛出 ClassCastException 异常：java.util.RandomAccessSubList cannot be cast to java.util.ArrayList ;说明： subList 返回的是 ArrayList 的内部类 SubList，并不是 ArrayList ，而是ArrayList 的一个视图，对于 SubList 子列表的所有操作最终会反映到原列表上。 【强制】 在 subList 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增加、删除均产生 ConcurrentModificationException 异常。 【强制】使用集合转数组的方法，必须使用集合的 toArray(T[] array)，传入的是类型完全一样的数组，大小就是 list.size()。说明： 使用 toArray 带参方法，入参分配的数组空间不够大时，toArray 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为[ list.size() ]的数组元素将被置为 null，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。 正例： List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;); list.add(&quot;bao&quot;); String[] array = new String[list.size()]; array = list.toArray(array); 反例： 直接使用 toArray 无参方法存在问题，此方法返回值只能是 Object[]类，若强转其它类型数组将出现 ClassCastException 错误。 【强制】使用工具类 Arrays.asList()把数组转换成集合时，不能使用其修改集合相关的方法，它的 add/remove/clear 方法会抛出 UnsupportedOperationException 异常。说明： asList 的返回对象是一个 Arrays 内部类，并没有实现集合的修改方法。Arrays.asList 体现的是适配器模式，只是转换接口，后台的数据仍是数组。 String[] str = new String[] { &quot;a&quot;, &quot;b&quot; }; List list = Arrays.asList(str); 第一种情况：list.add(&quot;c&quot;); 运行时异常。 第二种情况：str[0] = &quot;gujin&quot;; 那么 list.get(0)也会随之修改。 【强制】泛型通配符 &lt;? extends T&gt; 来接收返回的数据，此写法的泛型集合不能使用 add 方法，而 &lt;? super T&gt; 不能使用 get 方法，做为接口调用赋值时易出错。说明： 扩展说一下 PECS(Producer Extends Consumer Super) 原则：1）频繁往外读取内容的，适合用上界 Extends。2）经常往里插入的，适合用下界 Super。 【强制】不要在 foreach 循环里进行元素的 remove/add 操作。remove 元素请使用 Iterator 方式，如果并发操作，需要对 Iterator 对象加锁。正例： Iterator&lt;String&gt; it = a.iterator(); while (it.hasNext()) { String temp = it.next(); if (删除元素的条件) { it.remove(); } } 反例： List&lt;String&gt; a = new ArrayList&lt;String&gt;(); a.add(&quot;1&quot;); a.add(&quot;2&quot;); for (String temp : a) { if (&quot;1&quot;.equals(temp)) { a.remove(temp); } } 说明： 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？ 【强制】 在 JDK7 版本及以上，Comparator 要满足如下三个条件，不然 Arrays.sort，Collections.sort 会报 IllegalArgumentException 异常。说明：1） x，y 的比较结果和 y，x 的比较结果相反。2） x&gt;y，y&gt;z，则 x&gt;z。3） x=y，则 x，z 比较结果和 y，z 比较结果相同。反例： 下例中没有处理相等的情况，实际使用中可能会出现异常： new Comparator&lt;Student&gt;() { @Override public int compare(Student o1, Student o2) { return o1.getId() &gt; o2.getId() ? 1 : -1; } }; 【推荐】集合初始化时，指定集合初始值大小。说明： HashMap 使用 HashMap(int initialCapacity) 初始化，正例： initialCapacity = (需要存储的元素个数 / 负载因子) + 1。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。反例： HashMap 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。 【推荐】使用 entrySet 遍历 Map 类集合 KV，而不是 keySet 方式进行遍历。说明： keySet 其实是遍历了 2 次，一次是转为 Iterator 对象，另一次是从 hashMap 中取出 key 所对应的 value。而 entrySet 只是遍历了一次就把 key 和 value 都放到了 entry 中，效率更高。如果是 JDK8，使用 Map.foreach 方法。正例： values() 返回的是 V 值集合，是一个 list 集合对象；keySet() 返回的是 K 值集合，是一个 Set 集合对象；entrySet() 返回的是 K-V 值组合集合。 【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格： | 集合类 | Key | Value | Super | 说明 || :———————— | :—————— | :—————— | :————— | :————- || HashTable | 不允许为 null | 不允许为 null | Dictionary | 线程安全 || ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 分段锁技术 || TreeMap | 不允许为 null | 允许为 null | AbstractMap | 线程不安全 || HashMap | 允许为 null | 允许为 null | AbstractMap | 线程不安全 | 反例： 由于 HashMap 的干扰，很多人认为 ConcurrentHashMap 是可以置入 null 值，而事实上，存储 null 值时会抛出 NPE 异常。 【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。说明： 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次序是一定的。如： ArrayList 是 order/unsort；HashMap 是 unorder/unsort；TreeSet 是 order/sort。 【参考】利用 Set 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 List 的 contains 方法进行遍历、对比、去重操作。 并发处理 【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。说明： 资源驱动类、工具类、单例工厂类都需要注意。 【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。正例： public class TimerTaskThread extends Thread { public TimerTaskThread() { super.setName(&quot;TimerTaskThread&quot;); ... } } 【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。说明： 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。 【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。说明： Executors 返回的线程池对象的弊端如下： FixedThreadPool 和 SingleThreadPool:允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。 CachedThreadPool 和 ScheduledThreadPool:允许的创建线程数量为 Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 【强制】SimpleDateFormat 是线程不安全的类，一般不要定义为 static 变量，如果定义为 static，必须加锁，或者使用 DateUtils 工具类。正例： 注意线程安全，使用 DateUtils。亦推荐如下处理： private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() { @Override protected DateFormat initialValue() { return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;); } }; 说明： 如果是 JDK8 的应用，可以使用 Instant 代替 Date，LocalDateTime 代替 Calendar，DateTimeFormatter 代替 Simpledateformatter，官方给出的解释：simple beautiful strongimmutable thread-safe。 【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。说明： 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。 【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。说明： 线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。 【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。说明： 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。 【强制】多线程并行处理定时任务时，Timer 运行多个 TimeTask 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。 【推荐】使用 CountDownLatch 进行异步转同步操作，每个线程退出前必须调用 countDown 方法，线程执行代码注意 catch 异常，确保 countDown 方法可以执行，避免主线程无法执行至 await 方法，直到超时才返回结果。说明： 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。 【推荐】避免 Random 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。说明： Random 实例包括 java.util.Random 的实例或者 Math.random() 的方式。正例： 在 JDK7 之后，可以直接使用 API ThreadLocalRandom，而在 JDK7 之前，需要编码保证每个线程持有一个实例。 【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 volatile 型。反例： class Foo { private Helper helper = null; public Helper getHelper() { if (helper == null) synchronized(this) { if (helper == null) helper = new Helper(); } return helper; } // other functions and members... } 【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：AtomicInteger count = new AtomicInteger(); count.addAndGet(1); 如果是 JDK8，推荐使用 LongAdder 对象，比 AtomicLong 性能更好（减少乐观锁的重试次数）。 【参考】 在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。 【参考】ThreadLocal 无法解决共享对象的更新问题，ThreadLocal 对象建议使用 static 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。 控制语句 【强制】在一个 switch 块内，每个 case 要么通过 break/return 等来终止，要么注释说明程序将继续执行到哪一个 case 为止；在一个 switch 块内，都必须包含一个 default 语句并且放在最后，即使它什么代码也没有。 【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements; 【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成： if (condition) { ... return obj; } // 接着写 else 的业务逻辑代码; 说明： 如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。正例： 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下： public void today() { if (isBusy()) { System.out.println(“change time.”); return; } if (isFree()) { System.out.println(“go to travel.”); return; } System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”); return; } 【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。说明： 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？ 正例： //伪代码如下 final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) { ... } 反例： if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) { ... } 【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。 【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。 【参考】下列情形，需要进行参数校验：1） 调用频次低的方法。2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参数错误导致中间执行回退，或者错误，那得不偿失。3） 需要极高稳定性和可用性的方法。4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。5） 敏感权限入口。 【参考】下列情形，不需要进行参数校验：1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。 注释规约 【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用/**内容*/格式，不得使用 //xxx 方式。说明： 在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高阅读效率。 【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。说明： 对子类的实现要求，或者调用注意事项，请一并说明。 【强制】所有的类都必须添加创建者和创建日期。 【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/ /注释，注意与代码对齐。 【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。 【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。反例： “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。 【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。说明： 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，就失去了导航的意义。 【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。说明： 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。 【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。 【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。反例： // put elephant into fridge put(elephant, fridge); 方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。 【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。 其他 【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。说明：不要在方法体内定义：Pattern pattern = Pattern.compile(规则); 【强制】velocity 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。说明： 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。 【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。说明： 如果 var=null 或者不存在，那么${var}会直接显示在页面上。 【强制】注意 Math.random() 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。 【强制】获取当前毫秒数 System.currentTimeMillis(); 而不是 new Date().getTime();说明： 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。 【推荐】不要在视图模板中加入任何复杂的逻辑。说明： 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。 【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。 【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。 异常日志异常处理 【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： IndexOutOfBoundsException ， NullPointerException 等等。说明： 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catchNumberFormatException 来实现。正例： if (obj != null) {...}反例： try { obj.method() } catch (NullPointerException e) {...} 【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。 【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。 【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。 【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。 【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。说明： 如果 JDK7 及以上，可以使用 try-with-resources 方式。 【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。 【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。说明： 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。 【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。说明： 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。 【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。 **反例：** `public int f() { return Integer 对象}`， 如果为 null，自动解箱抛 NPE。 2） 数据库的查询结果可能为 null。3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。正例： 使用 JDK8 的 Optional 类来防止 NPE 问题。 【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 new RuntimeException()，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。 【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。说明： 关于 RPC 方法返回方式使用 Result 方式的理由：1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。 【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。说明： 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。正例： 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：private boolean checkParam(DTO dto) {...} 日志规约 【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。 import org.slf4j.Logger; import org.slf4j.LoggerFactory; private static final Logger logger = LoggerFactory.getLogger(Abc.class); 【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。 【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。正例： mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log说明： 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于通过日志对系统进行及时监控。 【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方式。说明： logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。 正例： （条件） if (logger.isDebugEnabled()) { logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol); } 正例： （占位符） logger.debug(&quot;Processing trade with id: {} symbol : {} &quot;, id, symbol); 【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。正例： &lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt; 【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。正例： logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e); 【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘撑爆，并记得及时删除这些观察日志。说明： 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？ 【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。 MYSQL 数据库建表规约 【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。说明： 任何字段如果为非负数，必须是 unsigned。正例： 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。 【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。正例： getter_admin，task_config，level3_name反例： GetterAdmin，taskConfig，level_3_name 【强制】表名不使用复数名词。说明： 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。 【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。 【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。说明： pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。 【强制】小数类型为 decimal，禁止使用 float 和 double。说明： float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。 【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。 【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。 【强制】表必备三字段：id, gmt_create, gmt_modified。说明： 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。 【推荐】表的命名最好是加上“业务名称_表的作用”。正例： tiger_task / tiger_reader / mpp_config 【推荐】库名与应用名称尽量一致。 【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。 【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：1）不是频繁修改的字段。2）不是 varchar 超长字段，更不能是 text 字段。正例： 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存储类目名称，避免关联查询。 【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。说明： 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。 【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。正例： 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。 | 对象 | 年龄区间 | 类型 | 表示范围 | | :------- | :--------- | :---------------- | :----------------------------- | | 人 | 150 岁之内 | unsigned tinyint | 无符号值：0 到 255 | | 龟 | 数百岁 | unsigned smallint | 无符号值：0 到 65535 | | 恐龙化石 | 数千万年 | unsigned int | 无符号值：0 到约 42.9 亿 | | 太阳 | 约 50 亿年 | unsigned bigint | 无符号值：0 到约 10 的 19 次方 | 索引规约 【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。 【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。说明： 即使双表 join 也要注意表索引、SQL 性能。 【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。说明： 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。 【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。说明： 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。 【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。正例： where a=? and b=? order by c; 索引：a_b_c反例： 索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。 【推荐】利用覆盖索引来进行查询操作，避免回表。说明： 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。正例： 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种效果，用 explain 的结果，extra 列会出现：using index。 【推荐】利用延迟关联或者子查询优化超多分页场景。说明： MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。正例： 先快速定位需要获取的 id 段，然后再关联： SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id 【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。说明： 1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。 2） ref 指的是使用普通的索引（normal index）。 3） range 对索引进行范围检索。 反例： explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。 【推荐】建组合索引的时候，区分度最高的在最左边。正例： 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。说明： 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;?and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。 【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。 【参考】创建索引时避免有如下极端误解：1）宁滥勿缺。误认为一个查询就需要建一个索引。2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。 SQL 语句 【强制】不要使用 count(列名)或 count(常量)来替代 count()，count()是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。说明： count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。 【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。 【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。正例： 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table; 【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。说明： 1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。 2） NULL=NULL 的返回结果是 NULL，而不是 true。 3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。 【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。 【强制】不得使用外键与级联，一切外键概念必须在应用层解决。说明： （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。 【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。 【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。 【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。 【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。说明： SELECT LENGTH(“轻松工作”)； 返回为 12 SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4 如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。 【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。说明： TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。 ORM 映射 【强制】在表查询中，一律不要使用 作为查询的字段列表，需要哪些字段必须明确写明。*说明： 1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。 【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。说明： 参见定义 POJO 类以及数据库字段定义规定，在中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。 【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。说明： 配置映射关系，使字段与 DO 类解耦，方便维护。 【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。 【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。说明： 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList取 start,size 的子集合。正例： Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;start&quot;, start); map.put(&quot;size&quot;, size); 【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。说明： resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。 【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。 【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。 【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。 【参考】中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；表示不为空且不为 null 时执行；表示不为 null 值时执行。 工程结构应用分层 【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推： 开放接口层：可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。 终端显示层：各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。 Web 层：主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。 Service 层：相对具体的业务逻辑服务层。 Manager 层：通用业务处理层，它有如下特征： 对第三方平台封装的层，预处理返回结果及转化异常信息； 对 Service 层通用能力的下沉，如缓存方案、中间件通用处理； 与 DAO 层交互，对多个 DAO 的组合复用。 DAO 层：数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。 外部接口或第三方平台：包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。 【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。 【参考】分层领域模型规约： DO（Data Object）：与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。 DTO（Data Transfer Object）：数据传输对象，Service 和 Manager 向外传输的对象。 BO（Business Object）：业务对象。可以由 Service 层输出的封装业务逻辑的对象。 Query：数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。 VO（View Object）：显示层对象，通常是 Web 向模板渲染引擎层传输的对象。 二方库依赖 【强制】定义 GAV 遵从以下规则：1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。说明： {公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。正例： com.taobao.jstorm 或 com.alibaba.dubbo.register2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。正例： dubbo-client / fastjson-api / jstorm-tool3） Version：详细规定参考下方。 【强制】二方库版本号命名方式：主版本号.次版本号.修订号1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。说明： 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0 【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。说明： 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。 【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一致，那么通过 dependency:tree 命令，找出差异点，进行排除 jar 包。 【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚举类型或者包含枚举类型的 POJO 对象。 【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。 【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的Version。说明： 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。 【推荐】所有 pom 文件中的依赖声明放在语句块中，所有版本仲裁放在语句块中。说明：里只是声明版本，并不实现引入，因此子项目需要显式的声明依赖，version 和 scope 都读取自父 pom。而所有声明在主 pom 的里的依赖都会自动引入，并默认被所有的子项目继承。 【推荐】二方库不要有配置项，最低限度不要再增加配置项。 【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用者去依赖具体版本号；无 log 具体实现，只依赖日志框架。2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。 服务器 【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上调小此等待值。正例： 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：net.ipv4.tcp_fin_timeout = 30 【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。说明： 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。 【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出dump 信息。说明： OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错非常有价值。 【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则会带来 URL 维护不一致的问题和潜在的安全风险。 安全规约 【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。说明： 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信内容、修改他人的订单。 【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。说明： 查看个人手机号码会显示成:158**9119，隐藏中间 4 位，防止隐私泄露。 【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，禁止字符串拼接 SQL 访问数据库。 【强制】用户请求传入的任何参数必须做有效性验证。说明： 忽略参数校验可能导致： page size 过大导致内存溢出 恶意 order by 导致数据库慢查询 任意重定向 SQL 注入 反序列化注入 正则输入源串拒绝服务 ReDoS 说明： Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。 【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。 【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。说明： CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户不知情情况下对数据库中用户参数进行相应修改。 【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其它用户，并造成短信平台资源浪费。 【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过滤等风控策略。 附 1：版本历史 版本号 更新日期 备注 1.0.0 2017.2.9 阿里巴巴集团正式对外发布 1.0.1 2017.2.13 1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。 1.0.2 2017.2.20 1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final 描述。5）去除 Comparator 部分描述。 1.1.0 2017.2.27 1）增加前言。2）增加&lt;? extends T&gt;描述和说明。3）增加版本历史。4）增加专有名词解释。 1.1.1 2017.3.31 修正页码总数和部分示例 1.2.0 2017.5.20 1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加 final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为 is_deleted 附 2：本手册专有名词 POJO（Plain Ordinary Java Object）：在本手册中，POJO 专指只有 setter / getter/ toString 的简单类，包括 DO/DTO/BO/VO 等。 DO（Data Object）：本手册指数据库表一一对应的 POJO 类。 GAV（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。 OOP（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。 ORM（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，本文泛指 iBATIS, mybatis 等框架。 NPE（java.lang.NullPointerException）: 空指针异常。 SOA（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。 一方库：本工程内部子项目模块依赖的库（jar 包）。 二方库：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。 三方库：公司之外的开源库（jar 包）。 本文转载自：https://github.com/mysterin/alibaba-java-specification","categories":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"JUC之常见工具类","slug":"JUC之常见工具类","date":"2020-09-30T07:57:37.000Z","updated":"2020-11-23T14:23:21.041Z","comments":true,"path":"Java并发/JUC之常见工具类/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/","excerpt":"","text":"CountDownLatch 使用案例 实现原理 构造方法 void await()) boolean await(long timeout, TimeUnit unit)) void countDown()) long getCount()) CyclicBarrier 使用案例 实现原理 构造方法 int await()) boolean await(long timeout, TimeUnit unit)) int dowait(boolean timed, long nanos)) Semaphore 使用案例 实现原理 构造方法 acquire acquire(int permits)) release release(int permits)) Phaser Exchanger CountDownLatch在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。在CountDownLatch出现之前一般都使用线程的join方法来实现这一点，但是在使用ExecutorService时我们就没办法了。 使用案例12345678910111213141516171819202122232425262728293031public class CountDownLatchTest&#123; private static CountDownLatch countDownLatch = new CountDownLatch(2); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(() -&gt; &#123; try &#123; Thread.sleep(1000); System.out.println(\"child threadOne over!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125;); executorService.submit(()-&gt;&#123; try &#123; Thread.sleep(1000); System.out.println(\"child threadTwo over!\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; countDownLatch.countDown(); &#125; &#125;); System.out.println(\"mainThread wait for all childThread over\"); countDownLatch.await(); System.out.println(\"all childThread over\"); executorService.shutdown(); &#125;&#125; 12345输出结果如下：mainThread wait for all childThread overchild threadTwo over!child threadOne over!all childThread over 在如上代码中，因为有两个子线程所以构造函数传入参数为2。主线程调用CountDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使内部计数器(state)减1，所有子线程执行完毕后计数器为0，此时主线程的await方法才会返回。 实现原理CountDownLatch基于AQS实现。 构造方法1234567891011private final Sync sync;public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException(\"count &lt; 0\"); this.sync = new Sync(count);&#125;//内部类Sync继承自AQS，其构造方法如下Sync(int count) &#123; setState(count);&#125; 由构造方法可知CountDownLatch的计数器实际就是AQS的state。 void await()调用await后当前线程被阻塞，只有当计数器值为0或者被中断该方法才会返回。 123456789101112131415public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted())//被中断则抛异常 throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0)//查看计数器是否为0，不是则进入AQS阻塞队列 doAcquireSharedInterruptibly(arg);&#125;//sync实现的AQS的模板方法protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1;&#125; boolean await(long timeout, TimeUnit unit)相比void await()多了一个超时设置，设置的timeout时间到了，因为超时而返回false。 void countDown()线程调用该方法后，计数器值减1，减1后若计数器为0则唤醒所有因调用await方法而被阻塞的线程。 123456789101112131415161718192021222324public void countDown() &#123; sync.releaseShared(1);&#125;public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared();//唤醒AQS中所有阻塞的线程 return true; &#125; return false;&#125;//sync实现的AQS的模板方法protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; //CAS更新state if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; long getCount()获取state的值，该方法一般用于测试。 CyclicBarrierCountDownLatch的计数器是一次性的，当计数器值为0后，再调用await和countdown方法均会立即返回。为了满足计数器可以重置的需要，这才有了CyclicBarrier（回环屏障）。屏障的含义是：当线程调用await方法就会被阻塞，这个阻塞点就称为屏障点，当所有线程都调用了await方法后，线程就会冲破屏障，所有线程被唤醒继续向下执行（注意：最后一个调用await的线程不会被阻塞）。回环的含义是：所有线程到达屏障点后，CyclicBarrier的状态会被重置，因此它可以被重用。 使用案例下面的例子实现的是：使用两个线程执行一个被分解的任务，两个线程并发执行任务的两个步骤后再由CyclicBarrier汇总。 12345678910111213141516171819202122232425262728293031323334public class CyclicBarrierTest&#123; private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2, new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName() + \": task merge result\"); &#125; &#125;); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": task step-1\"); System.out.println(Thread.currentThread().getName() + \": enter in barrier\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": out from barrier\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": task step-2\"); System.out.println(Thread.currentThread().getName() + \": enter in barrier\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": out from barrier\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdown(); &#125;&#125; 1234567pool-1-thread-1: task step-1pool-1-thread-1: enter in barrierpool-1-thread-2: task step-2pool-1-thread-2: enter in barrierpool-1-thread-2: task merge resultpool-1-thread-1: out from barrierpool-1-thread-2: out from barrier CyclicBarrier的构造方法参数列表中，第一个参数是计数器的初始值，第二个参数Runnable是当计数器值为0时由CyclicBarrier执行的任务。 在线程中CyclicBarrier对象调用await方法后，其计数器值-1，若此时计数器值不为0，当前线程被阻塞；若计数器值为0，则执行CyclicBarrier构造方法中传入的任务，然后唤醒条件队列中所有阻塞线程，重置计数器并新建Generation（重置broken标志）。 以下例子体现了CyclicBarrier的可复用性（所谓回环）： 以下任务被分为三个阶段，由两个线程并发执行该任务，只有当两个线程都完成了step1后才能进入step2，只有当两个线程都完成了step2才能进入step3。 12345678910111213141516171819202122232425262728293031public class CyclicBarrierTest2&#123; private static CyclicBarrier cyclicBarrier = new CyclicBarrier(2); public static void main(String[] args) throws InterruptedException &#123; ExecutorService executorService = Executors.newFixedThreadPool(2); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": step-1\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-2\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-3\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.submit(() -&gt; &#123; try &#123; System.out.println(Thread.currentThread().getName() + \": step-1\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-2\"); cyclicBarrier.await(); System.out.println(Thread.currentThread().getName() + \": step-3\"); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;); executorService.shutdown(); &#125;&#125; 123456pool-1-thread-1: step-1pool-1-thread-2: step-1pool-1-thread-2: step-2pool-1-thread-1: step-2pool-1-thread-1: step-3pool-1-thread-2: step-3 实现原理CyclicBarrier基于ReentrantLock实现。 parties用于记录线程个数，当parties个线程都调用await方法后所有线程才会冲破屏障点。count才是真正的计数器，一开始等于parties，每当有线程调用await方法后就-1，当count==0时所有线程都到了屏障点，此时会重置count的值为parties。 独占锁lock首先保证了更新计数器count的原子性，另外使用lock的条件变量trip支持线程间同步操作。 最后，在Generation对象内部有一个变量broken，用于记录当前屏障是否被打破。 构造方法12345678910public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125;public CyclicBarrier(int parties) &#123; this(parties, null);&#125; int await()12345678public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; boolean await(long timeout, TimeUnit unit)123456public int await(long timeout, TimeUnit unit) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; return dowait(true, unit.toNanos(timeout));&#125; 超时返回。 int dowait(boolean timed, long nanos)12345678910111213141516171819202122232425262728293031323334353637383940414243private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; ... int index = --count; //index==0说明所有线程都到达了屏障点 if (index == 0) &#123; // tripped boolean ranAction = false; try &#123; final Runnable command = barrierCommand; //执行任务 if (command != null) command.run(); ranAction = true; //激活其他因调用await而被阻塞的线程，并重置CyclicBarrier nextGeneration(); return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; //index!=0则阻塞当前线程（进入条件队列） for (;;) &#123; try &#123; if (!timed) trip.await(); else if (nanos &gt; 0L) nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; ... &#125; ... &#125; &#125; finally &#123; lock.unlock(); &#125;&#125; 1234567private void nextGeneration() &#123; //所有线程节点进入AQS队列并唤醒所有线程 trip.signalAll(); //重置CyclicBarrier count = parties; generation = new Generation();&#125; SemaphoreSemaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。 使用案例Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控，代码如下： 1234567891011121314151617181920212223242526public class SemaphoreTest &#123; private static final int THREAD_COUNT = 30; private static ExecutorService threadPool = Executors .newFixedThreadPool(THREAD_COUNT); private static Semaphore s = new Semaphore(10); public static void main(String[] args) &#123; for (int i = 0; i &lt; THREAD_COUNT; i++) &#123; threadPool.execute(new Runnable() &#123; @Override public void run() &#123; try &#123; s.acquire(); //存储到数据库操作 s.release(); &#125; catch (InterruptedException e) &#123; &#125; &#125; &#125;); &#125; threadPool.shutdown(); &#125;&#125; 实现原理Semaphore基于AQS实现。 构造方法12345678910111213141516171819public Semaphore(int permits) &#123; sync = new NonfairSync(permits);&#125;public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits);&#125;Sync(int permits) &#123; setState(permits);&#125;NonfairSync(int permits) &#123; super(permits);&#125;FairSync(int permits) &#123; super(permits);&#125; 构造方法传入许可证数量，许可证数量对应于AQS中的state，默认采用非公平策略。 acquire在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减1，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。 该方法可被中断。 acquire(int permits)在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减permits，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。 该方法可被中断。 release许可证个数加1，并根据公平策略在AQS阻塞队列中选择一个“许可证个数可以被满足”的线程唤醒。 release(int permits)许可证个数加permits。 PhaserPhaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。 ExchangerExchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC之线程池","slug":"JUC之线程池","date":"2020-09-30T07:52:36.000Z","updated":"2020-11-23T14:23:21.044Z","comments":true,"path":"Java并发/JUC之线程池/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/","excerpt":"","text":"FutureTask 概述 类图结构 ThreadPoolExecutor 线程池的好处 类图结构 ThreadPoolExecutor原理 概述 部分属性 线程池状态 线程池类型 execute方法 sumbit方法 shutdown与shutdownNow awaitTermination方法 为什么不建议使用Executors创建线程池？ ScheduledThreadPoolExecutor schedule scheduleWithFixedDelay scheduleAtFixedRate Fork/Join FutureTask概述FutureTask 为 Future 提供了基础实现，如获取任务执行结果(get)和取消任务(cancel)等。若任务尚未完成，获取任务执行结果时主线程将会阻塞。 FutureTask 的线程安全由CAS来保证。 类图结构 以上几个接口的源码如下： 123456789101112131415161718@FunctionalInterfacepublic interface Callable&lt;V&gt; &#123;V call() throws Exception;&#125;@FunctionalInterfacepublic interface Runnable &#123;public abstract void run();&#125;public interface Future&lt;V&gt; &#123; boolean cancel(boolean mayInterruptIfRunning); boolean isCancelled(); boolean isDone(); V get() throws InterruptedException, ExecutionException; V get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;public interface RunnableFuture&lt;V&gt; extends Runnable, Future&lt;V&gt; &#123; void run();&#125; FutureTask构造方法如下： 123456789101112public FutureTask(Callable&lt;V&gt; callable) &#123; if (callable == null) throw new NullPointerException(); this.callable = callable; this.state = NEW; &#125;public FutureTask(Runnable runnable, V result) &#123; //把传入的Runnable封装成一个Callable对象，若任务执行成功返回传入的result this.callable = Executors.callable(runnable, result); this.state = NEW;&#125; 由类图和构造方法可知，FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。 ThreadPoolExecutor线程池的好处 提供较好的性能：线程池中的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。 统一分配和管理：比如可以限制线程的个数、动态新增线程等。 类图结构 以上类图中主要接口的源码如下： 123456789101112131415161718192021222324252627282930313233343536373839public interface Executor &#123;void execute(Runnable command);&#125;public interface ExecutorService extends Executor &#123; void shutdown(); List&lt;Runnable&gt; shutdownNow(); boolean isShutdown(); boolean isTerminated(); boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task); &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result); Future&lt;?&gt; submit(Runnable task); &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException; &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException; &lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException;&#125;public interface ScheduledExecutorService extends ExecutorService &#123; public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay, TimeUnit unit); public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay, TimeUnit unit); public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit); public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit);&#125; ThreadPoolExecutor原理概述JDK实现的线程池核心主要为两大部分：一个线程集合workerSet和一个阻塞队列workQueue。当用户向线程池提交一个任务时，该任务将先被放入workQueue中，workerSet中的线程会不断从workQueue中获取线程然后执行，当workQueue中没有任务时，worker就会阻塞，直至队列中又有任务了。 部分属性123456789101112131415161718192021222324252627//存放任务的阻塞队列private final BlockingQueue&lt;Runnable&gt; workQueue;//工作线程集合private final HashSet&lt;Worker&gt; workers = new HashSet&lt;Worker&gt;();//历史达到的worker数最大值private int largestPoolSize;//创建线程的工厂private volatile ThreadFactory threadFactory;//饱和策略：当workQueue满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略private volatile RejectedExecutionHandler handler;//线程池中超出corePoolSize的闲置状态的worker的存活时间，单位为纳秒private volatile long keepAliveTime;//核心worker数量private volatile int corePoolSize;//最大worker的数量,一般当workQueue满了才会用到这个参数private volatile int maximumPoolSize;//控制新增worker线程操作的原子性private final ReentrantLock mainLock = new ReentrantLock();//条件队列，在线程调用awaitTermination时用于存放阻塞的线程private final Condition termination = mainLock.newCondition();//记录线程池状态与线程个数//对于int是32位的平台，高3位表示线程池状态,低29位记录worker数量//默认是RUNNING状态private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0)); 线程池状态1234567891011121314151617181920212223private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));//线程数量掩码位数：对于int是32位的平台，该值是29private static final int COUNT_BITS = Integer.SIZE - 3;//线程最大数量：000111...111private static final int CAPACITY = (1 &lt;&lt; COUNT_BITS) - 1;//接受新任务并处理阻塞队列中的任务：高3位111private static final int RUNNING = -1 &lt;&lt; COUNT_BITS;//拒绝新任务但是处理阻塞队列中的任务：高3位000private static final int SHUTDOWN = 0 &lt;&lt; COUNT_BITS;//拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务：高3位001private static final int STOP = 1 &lt;&lt; COUNT_BITS;//所有任务（含阻塞队列中的）都执行完后当前活动线程为0，将要调用terminated方法：高3位010private static final int TIDYING = 2 &lt;&lt; COUNT_BITS;//terminated执行完成后的状态：高3位011private static final int TERMINATED = 3 &lt;&lt; COUNT_BITS;//获取运行状态：高3位private static int runStateOf(int c) &#123; return c &amp; ~CAPACITY; &#125;//获取线程数量：低29位private static int workerCountOf(int c) &#123; return c &amp; CAPACITY; &#125;//计算ctl新值private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125; 线程池状态转换图如下： 线程池类型ThreadPoolExecutor核心构造方法如下： 123456789101112131415161718192021222324public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) &#123; if (corePoolSize &lt; 0 || maximumPoolSize &lt;= 0 || maximumPoolSize &lt; corePoolSize || keepAliveTime &lt; 0) throw new IllegalArgumentException(); if (workQueue == null || threadFactory == null || handler == null) throw new NullPointerException(); this.acc = System.getSecurityManager() == null ? null : AccessController.getContext(); this.corePoolSize = corePoolSize; this.maximumPoolSize = maximumPoolSize; this.workQueue = workQueue; this.keepAliveTime = unit.toNanos(keepAliveTime); this.threadFactory = threadFactory; this.handler = handler; &#125; Executors工厂类提供创建的线程池类型如下： newFixedThreadPool：创建一个corePoolSize和maximunPoolSize都为nThreads的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime为0说明只要有多于corePoolSize的空闲线程则回收。由于使用了无界队列，因此饱和策略失效。 1234567public static ExecutorService newFixedThreadPool(int nThreads) &#123; return new ThreadPoolExecutor(nThreads, nThreads,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;()); &#125;//使用自定义线程工厂public static ExecutorService newFixedThreadPool(int nThreads, ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(nThreads, nThreads, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory); &#125; newSingleThreadExecutor：创建一个corePoolSize和maximunPoolSize都为1的线程池，并且阻塞队列长度为Integer.MAX_VALUE。keepAliveTime为0。 123456789public static ExecutorService newSingleThreadExecutor() &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;())); &#125;public static ExecutorService newSingleThreadExecutor(ThreadFactory threadFactory) &#123; return new FinalizableDelegatedExecutorService (new ThreadPoolExecutor(1, 1,0L, TimeUnit.MILLISECONDS,new LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory)); &#125; newCachedThreadPool：创建一个按需自动创建线程的线程池，corePoolSize为0，maximunPoolSize为Integer.MAX_VALUE，阻塞队列为SynchronousQueue。keepAliveTime为60纳秒。 该类型的特殊之处在于使用了同步阻塞队列，加入队列的任务会马上执行，同步队列中最多只能有一个任务。 1234567public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;()); &#125;public static ExecutorService newCachedThreadPool(ThreadFactory threadFactory) &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE,60L, TimeUnit.SECONDS,new SynchronousQueue&lt;Runnable&gt;(),threadFactory); &#125; execute方法execute方法的作用是提交Runnable实例到线程池执行。 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; //Runnable实例为null则抛出NPE if (command == null) throw new NullPointerException(); //获取线程池状态和线程数量 int c = ctl.get(); //判断当前线程池线程个数是否小于corePoolSize，小于则新增worker if (workerCountOf(c) &lt; corePoolSize) &#123; if (addWorker(command, true)) return;//新增成功后直接返回 c = ctl.get();//新增失败则重新获取ctl &#125; //若线程池状态为RUNNING，则任务进入阻塞队列 if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123; //二次检查：添加任务时线程池状态可能已变化 int recheck = ctl.get(); //不是RUNNING则从阻塞队列删除任务，并执行拒绝策略 if (! isRunning(recheck) &amp;&amp; remove(command)) reject(command); //worker数量为0则添加一个worker else if (workerCountOf(recheck) == 0) addWorker(null, false); &#125; //阻塞队列满则新增worker，新增失败则执行拒绝策略 else if (!addWorker(command, false)) reject(command);&#125; ThreadPoolExecutor的内部类Worker源码如下： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970private final class Worker extends AbstractQueuedSynchronizer implements Runnable &#123; /** * This class will never be serialized, but we provide a * serialVersionUID to suppress a javac warning. */ private static final long serialVersionUID = 6138294804551838833L; /** Thread this worker is running in. Null if factory fails. */ final Thread thread; /** Initial task to run. Possibly null. */ Runnable firstTask; /** Per-thread task counter */ volatile long completedTasks; /** * Creates with given first task and thread from ThreadFactory. * @param firstTask the first task (null if none) */ Worker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this); &#125; /** Delegates main run loop to outer runWorker */ public void run() &#123; runWorker(this); &#125; // Lock methods // // The value 0 represents the unlocked state. // The value 1 represents the locked state. protected boolean isHeldExclusively() &#123; return getState() != 0; &#125; protected boolean tryAcquire(int unused) &#123; if (compareAndSetState(0, 1)) &#123; setExclusiveOwnerThread(Thread.currentThread()); return true; &#125; return false; &#125; protected boolean tryRelease(int unused) &#123; setExclusiveOwnerThread(null); setState(0); return true; &#125; public void lock() &#123; acquire(1); &#125; public boolean tryLock() &#123; return tryAcquire(1); &#125; public void unlock() &#123; release(1); &#125; public boolean isLocked() &#123; return isHeldExclusively(); &#125; void interruptIfStarted() &#123; Thread t; if (getState() &gt;= 0 &amp;&amp; (t = thread) != null &amp;&amp; !t.isInterrupted()) &#123; try &#123; t.interrupt(); &#125; catch (SecurityException ignore) &#123; &#125; &#125; &#125; &#125; 由源码可知，Worker继承自AQS并实现了Runnable接口，是具体承载任务的对象。Worker类实现了简单的不可重入独占锁，state=0表示锁未被获取状态，state=1表示锁已经被获取，state=-1是创建Worker实例默认的状态。 addWorker与runWorker方法源码分析（有空再看）。 sumbit方法sumbit方法在ThreadPoolExecutor的父抽象类AbstractExecutorService中实现，Runnable或Callable对象被封装为FutureTask对象传入execute方法，最终执行的是FutureTask的run方法。 123456789101112131415161718192021222324252627public Future&lt;?&gt; submit(Runnable task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, null); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result); execute(ftask); return ftask;&#125;public &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; if (task == null) throw new NullPointerException(); RunnableFuture&lt;T&gt; ftask = newTaskFor(task); execute(ftask); return ftask;&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Runnable runnable, T value) &#123; return new FutureTask&lt;T&gt;(runnable, value);&#125;protected &lt;T&gt; RunnableFuture&lt;T&gt; newTaskFor(Callable&lt;T&gt; callable) &#123; return new FutureTask&lt;T&gt;(callable);&#125; shutdown与shutdownNow shutdown方法：调用后线程池状态变为SHUTDOWN，此时拒绝新任务但是处理阻塞队列中的任务。 shutdownNow方法：调用后线程池状态变为STOP，此时拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务。 awaitTermination方法当线程调用该方法后会被阻塞，直到线程池状态变为TERMINATED才返回，或者等待时间超时才返回。 为什么不建议使用Executors创建线程池？阿里巴巴Java开发手册并发处理部分中，不允许使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 的构造方法，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。 newFixedThreadPool和newSingleThreadExecutor: 阻塞队列允许的长度为Integer.MAX_VALUE，可能会堆积大量请求，从而导致OOM。 newCachedThreadPool和newScheduledThreadPool: maximunPoolSize是Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。 ScheduledThreadPoolExecutorScheduledThreadPoolExecutor内部使用DelayQueue来存放任务。 schedule1234public ScheduledFuture&lt;?&gt; schedule(Runnable command,long delay,TimeUnit unit) &#123;&#125; public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable,long delay,TimeUnit unit)&#123;&#125; 该方法的作用是提交一个延迟执行的任务。从提交时间算起，delay时间后开始执行任务，unit为delay的时间单位。任务只执行一次。 scheduleWithFixedDelay1public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,long initialDelay,long delay,TimeUnit unit) &#123;&#125; 该方法的作用是，当任务执行完毕后，让其延迟固定时间后再次运行(fixed-delay任务)。 initialDelay表示提交任务后延迟多少时间开始执行任务command，delay表示当任务初次执行完毕后延迟多少时间后再次运行command任务，unit是initialDelay和delay的时间单位。任务会一直重复运行，直到任务运行抛出异常、被取消了、或者关闭了线程池。 scheduleAtFixedRate1public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,long initialDelay,long period,TimeUnit unit) &#123;&#125; fixed-rate任务的执行规则为：从提交时间算起，在时间点为initialDealy+n*period(n = 0, 1, 2, 3…)的时刻执行任务。若前一次任务还没执行完毕，下一次任务的执行时刻就到了，则下次任务要等到前一次任务执行完毕后才执行。 具体执行流程为：当任务提交后，initialDelay时间后执行command，然后在initialDelay+period时刻再次执行，而后在initialDelay+2*period时刻再次执行，循环往复，直到抛出异常、调用了任务的cancel方法取消了任务或关闭了线程池。 Fork/JoinFork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。 待后续补充。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC容器之并发队列","slug":"JUC容器之并发队列","date":"2020-09-27T02:30:32.000Z","updated":"2020-11-23T14:23:21.055Z","comments":true,"path":"Java并发/JUC容器之并发队列/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/","excerpt":"","text":"概述 非阻塞队列 ConcurrentLinkedQueue 类图结构 底层实现 常用方法 延迟更新策略 适用场景 阻塞队列 BlockingQueue BlockingQueue常见方法 BlockingDeque BlockingDeque常见方法 BlockingQueue实现类 LinkedBlockingQueue ArrayBlockingQueue PriorityBlockingQueue DelayQueue SynchronousQueue BlockingDeque实现类 LinkedBlockingDeque BlockingQueue实现生产者消费者 概述JUC提供了一系列场景的并发安全队列，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，后者使用CAS非阻塞算法实现。 非阻塞队列ConcurrentLinkedQueueConcurrentLinkedQueue是线程安全的无界非阻塞队列，其底层使用单向链表实现，对于入队和出队操作使用CAS来实现线程安全，因此执行该队列的方法失败不会导致线程阻塞。 类图结构 底层实现1234//默认头尾节点都是指向item为null的哨兵节点public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125; 123456789101112131415161718192021222324252627private transient volatile Node&lt;E&gt; head;private transient volatile Node&lt;E&gt; tail;private boolean casTail(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, tailOffset, cmp, val);&#125;private boolean casHead(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, headOffset, cmp, val);&#125;// Unsafe mechanicsprivate static final sun.misc.Unsafe UNSAFE;private static final long headOffset;private static final long tailOffset;static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = ConcurrentLinkedQueue.class; headOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"head\")); tailOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"tail\")); &#125; catch (Exception e) &#123; throw new Error(e); &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; Node(E item) &#123; UNSAFE.putObject(this, itemOffset, item); &#125; boolean casItem(E cmp, E val) &#123; return UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; void lazySetNext(Node&lt;E&gt; val) &#123; UNSAFE.putOrderedObject(this, nextOffset, val); &#125; boolean casNext(Node&lt;E&gt; cmp, Node&lt;E&gt; val) &#123; return UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125;// Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = Node.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"item\")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField(\"next\")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125; 常用方法 offer：通过CAS操作来控制某时只有一个线程可以添加元素到队列末尾，进行CAS竞争失败的线程会不断自旋，直至成功，其余出入队操作均是如此。相比阻塞算法，这是使用CPU资源换取阻塞所带来的开销。 add：调用offer方法。 poll：该方法在移除队首元素时，只是简单地使用CAS操作把节点的item值设置为null，然后重新设置head到下一个节点。移除的对象会在GC时被回收。 peek：peek方法的实现与poll类似，只是没有删除步骤。另外，在第一次调用peek操作时，会删除哨兵节点，并让head指向队列的第一个元素或者null。 size：该方法遍历链表计数，由于无锁策略，并发环境下结果并不准确。问：为什么不使用一个原子变量count来记录元素个数？因为这需要保证“入队操作+(count++)”或者“出队操作+(count—)”是原子操作，而ConcurrentLinkedQueue采用CAS无阻塞算法无法做到这一点。 remove：删除遍历时第一个匹配的元素。 contains：遍历链表查找元素，由于无锁策略，该方法并发环境下不准确。 延迟更新策略通过对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为： tail更新触发时机：tail的下一个节点不为null时，定位真正的队尾，找到队尾节点并完成插入之后才会通过casTail进行tail更新；当tail的下一个节点为null时，只插入节点不更新tail。 head更新触发时机：当head的item域为null时，定位真正的队头，找到队头节点并完成删除之后才会通过updateHead进行head更新；当head的item域不为null时，只删除节点不更新head。 在高并发写（大量出队入队）的情景下，通过延迟更新head和tail，减少了head和tail更新（CAS自旋）带来的CPU损耗。 适用场景ConcurrentLinkedQueue通过无锁做到了更高的并发量，在并发量特别大的情况下，是个不错的选择，性能上好很多。 阻塞队列BlockingQueueBlockingQueue通常用于生产者消费者场景。 一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。 BlockingQueue常见方法BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下: 四组不同的行为方式解释: 抛异常: 如果试图的操作无法立即执行，抛一个异常。 特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。 阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。 超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。 另外，BlockingQueue不接受null值，插入null会导致NullPointerException。 BlockingDequeBlockingDeque是一个双端队列，我们可以从队列两端进行入队和出队操作。该接口继承自BlockingQueue接口。 在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。 BlockingDeque常见方法 BlockingQueue实现类LinkedBlockingQueue LinkedBlockingQueue是一个有界链表，创建时可指定容量，默认上限为Integer.MAX_VALUE（没指定就是无界），由原子变量计数器count计数。其内部以 FIFO的顺序对元素进行存储。 如下图所示： LinkedBlockingQueue对头、尾节点的操作分别使用了单独的独占锁从而保证了并发下出入队的正确性，竞争锁失败的线程进入相应的AQS阻塞队列。头尾节点的独占锁都有一个自己的条件队列，用于存放队列空(满)时执行take(put)操作的被阻塞的线程。另外，有两个独占锁意味着该队列可以同时进行出入队操作，因此count必须要使用原子变量。 注意：LinkedBlockingQueue的remove方法执行时会同时获取takeLock和putLock。 ArrayBlockingQueue ArrayBlockingQueue是一个有界数组，创建时必须指定容量，并且一旦指定容量便不能更改。其内部以 FIFO的顺序对元素进行存储。 如下图所示： ArrayBlockingQueue只有一个独占锁，这个锁的粒度较大，只要是对数组更改就必须加锁，因此不能同时进行入队出队操作。其中offer和poll操作通过简单的加锁实现，而put和take则使用锁加条件变量实现。另外，ArrayBlockingQueue的size方法相比LinkedBlockingQueue则是完全精确的，因为计算前加了全局锁。 PriorityBlockingQueue PriorityBlockingQueue是一个无界二叉堆（数组实现），每次出队的元素都是堆的根节点，保证返回的是优先级最高(低)的元素。 默认使用对象的compareTo方法提供比较规则，因此入队元素必须实现Comparable接口。如果需要自定义比较规则，也可在创建队列时传入Comparator比较器。 PriorityBlockingQueue的数组是可自动扩容的，其默认初始容量为11。当当前元素个数&gt;=容量时会通过CAS算法扩容。allocationSpinLock是个自旋锁，其使用volatile修饰和CAS操作来保证同时只有一个线程可以扩容队列，状态为0表示当前没有进行扩容，状态为1表示正在进行扩容。 如下图所示： PriorityBlockingQueue只有一个条件变量notEmpty，存放take操作时因队列空而阻塞的线程，因为该队列是无界队列，所以可以一直put，没有notFull条件变量。 使用案例： 1234567891011121314151617181920212223242526272829303132333435public class PriorityBlockingQueueTest &#123; static class Task implements Comparable&lt;Task&gt;&#123; private int priority; private String taskName; public Task(int priority, String taskName) &#123; this.priority = priority; this.taskName = taskName; &#125; @Override public int compareTo(Task o) &#123; if(this.priority &gt;= o.priority) return 1; else return -1; &#125; public void printTask()&#123; System.out.println(taskName + \":\" + priority); &#125; &#125; public static void main(String[] args) &#123; PriorityBlockingQueue&lt;Task&gt; priorityBlockingQueue = new PriorityBlockingQueue&lt;Task&gt;(); Random random = new Random(); for (int i = 0; i &lt; 10; i++) &#123; Task task = new Task(random.nextInt(10), \"taskName\"+i); priorityBlockingQueue.offer(task); &#125; while(!priorityBlockingQueue.isEmpty())&#123; priorityBlockingQueue.poll().printTask(); &#125; &#125;&#125; 输出为： 12345678910taskName1:1taskName7:2taskName4:3taskName0:3taskName9:4taskName5:7taskName2:8taskName6:9taskName8:9taskName3:9 DelayQueue DelayQueue是一个无界阻塞延迟队列，队列中的每个元素都有一个过期时间，每个元素都必须实现java.util.concurrent.Delayed接口： 123public interface Delayed extends Comparable&lt;Delayed&gt; &#123; long getDelay(TimeUnit unit);&#125; 出队时判断元素是否过期，只有过期元素才会出队列，队列头元素是最快要过期的元素。 由类图知，DelayQueue内部使用PriorityQueue存放数据。 SynchronousQueueSynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。 BlockingDeque实现类LinkedBlockingDequeBlockingDeque唯一的一个实现类。LinkedBlockingDeque是一个有界链表双端队列，默认容量为Integer.MAX_VALUE。但与LinkedBlockingQueue不同的是，该队列不能同时进行出入队操作，因为只有一个独占锁。并且count计数器不是原子变量，size方法会在调用count时加锁，因此该方法返回值是精确的。 BlockingQueue实现生产者消费者1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162public class Test&#123; static BlockingQueue&lt;Integer&gt; blockingQueue = new ArrayBlockingQueue&lt;Integer&gt;(10); static class Producer implements Runnable&#123; BlockingQueue&lt;Integer&gt; blockingQueue; public Producer(BlockingQueue&lt;Integer&gt; blockingQueue)&#123; this.blockingQueue = blockingQueue; &#125; @Override public void run() &#123; while(!Thread.interrupted())&#123; try &#123; blockingQueue.put(0); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()+\"生产了\"+0); &#125; &#125; &#125; static class Consumer implements Runnable&#123; BlockingQueue&lt;Integer&gt; blockingQueue; public Consumer(BlockingQueue&lt;Integer&gt; blockingQueue)&#123; this.blockingQueue = blockingQueue; &#125; @Override public void run() &#123; while(!Thread.interrupted())&#123; Integer integer = null; try &#123; integer = blockingQueue.take(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName() + \"消费了\" + integer); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Producer producer1 = new Producer(blockingQueue); Consumer consumer1 = new Consumer(blockingQueue); Consumer consumer2 = new Consumer(blockingQueue); ExecutorService executorService = Executors.newCachedThreadPool(); executorService.execute(producer1); executorService.execute(consumer1); executorService.execute(consumer2); Thread.sleep(1000); executorService.shutdownNow(); &#125;&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC容器之ConcurrentHashMap","slug":"JUC容器之ConcurrentHashMap","date":"2020-09-26T09:10:01.000Z","updated":"2020-11-23T14:23:21.048Z","comments":true,"path":"Java并发/JUC容器之ConcurrentHashMap/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/","excerpt":"","text":"ConcurrentHashMap详解","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC容器之CopyOnWriteArrayList","slug":"JUC容器之CopyOnWriteArrayList","date":"2020-09-26T07:50:39.000Z","updated":"2020-11-23T14:23:21.050Z","comments":true,"path":"Java并发/JUC容器之CopyOnWriteArrayList/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/","excerpt":"","text":"概述 源码剖析 构造方法 add方法 get方法 set方法 remove方法 弱一致性的迭代器 CopyOnWriteArraySet 概述CopyOnWriteArrayList是一个线程安全的ArrayList，底层采用private transient volatile Object[] array;存储数据，使用独占锁ReentrantLock保证同时只有一个线程对array进行修改。另外，该类采用了写时复制策略，也即对array的修改操作都是在一个复制的数组上进行的。 源码剖析构造方法1234567891011121314151617181920//默认构造创建大小为0的Object数组public CopyOnWriteArrayList() &#123;setArray(new Object[0]);&#125;//使用传入数组的拷贝public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125;//使用集合元素的拷贝public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements,elements.length, Object[].class); &#125; setArray(elements); &#125; add方法12345678910111213141516171819202122public boolean add(E e) &#123; final ReentrantLock lock = this.lock;//获取独占锁 lock.lock(); try &#123; Object[] elements = getArray();//获取array int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len + 1);//复制一个新数组 newElements[len] = e;//在新数组中添加 setArray(newElements);//将引用指向新数组，旧数组等待GC return true; &#125; finally &#123; lock.unlock(); &#125;&#125;final Object[] getArray() &#123; return array;&#125;final void setArray(Object[] a) &#123; array = a;&#125; get方法123456public E get(int index) &#123; return get(getArray(), index);&#125;private E get(Object[] a, int index) &#123; return (E) a[index];&#125; 由于采用写时复制策略，即使我们在调用get方法时没有进行同步，也不会导致获取到错误的值。因为删除操作是在复制的数组上进行的，最后才会将array指向复制的数组。 set方法123456789101112131415161718192021public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; //在新数组上修改指定位置的元素值并设置新数组到array int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; remove方法12345678910111213141516171819202122232425public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; //如果要删除的是最后一个元素 if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; //复制前半段 System.arraycopy(elements, 0, newElements, 0, index); //复制后半段 System.arraycopy(elements, index + 1, newElements, index, numMoved); //设置新数组到array setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125; 弱一致性的迭代器迭代器的弱一致性是指：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。该容器迭代器源码如下： 123456789101112131415161718192021222324public Iterator&lt;E&gt; iterator() &#123; return new COWIterator&lt;E&gt;(getArray(), 0);&#125;static final class COWIterator&lt;E&gt; implements ListIterator&lt;E&gt; &#123; private final Object[] snapshot;//array的快照 private int cursor;//数组下标 private COWIterator(Object[] elements, int initialCursor) &#123; cursor = initialCursor; snapshot = elements; &#125; public boolean hasNext() &#123; return cursor &lt; snapshot.length; &#125; public E next() &#123; if (! hasNext()) throw new NoSuchElementException(); return (E) snapshot[cursor++]; &#125; //其他方法&#125; 由源码可知，迭代器的snapshot引用指向旧数组，在迭代的过程中如果有其他线程进行增删改，都是在新创建的数组中进行的，它们操作的是不同的两个数组。 CopyOnWriteArraySet该容器底层使用CopyOnWriteArrayList实现： 1234567891011121314151617private final CopyOnWriteArrayList&lt;E&gt; al;public CopyOnWriteArraySet() &#123; al = new CopyOnWriteArrayList&lt;E&gt;();&#125;public CopyOnWriteArraySet(Collection&lt;? extends E&gt; c) &#123; if (c.getClass() == CopyOnWriteArraySet.class) &#123; CopyOnWriteArraySet&lt;E&gt; cc = (CopyOnWriteArraySet&lt;E&gt;)c; al = new CopyOnWriteArrayList&lt;E&gt;(cc.al); &#125; else &#123; al = new CopyOnWriteArrayList&lt;E&gt;(); al.addAllAbsent(c); &#125;&#125;","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC之锁","slug":"JUC之锁","date":"2020-09-21T05:25:08.000Z","updated":"2020-11-23T14:23:21.047Z","comments":true,"path":"Java并发/JUC之锁/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/","excerpt":"","text":"OverView 锁概述 乐观锁与悲观锁 公平锁与非公平锁 独占锁与共享锁 可重入锁 自旋锁 LockSupport Unsafe的park和unpark方法 park()) park(Object blocker)) parkNanos(long nanos)) parkUntil(Object blocker, long deadline)) unpark(Thread thread)) AQS 类图结构 AQS概述 队列 state变量 锁的底层支持 AbstractOwnableSynchronizer 独占锁-ReentrantLock与WriteLock 共享锁-ReadLock 条件变量ConditionObejct ReentrantLock详解 类图结构 获取锁 void lock()方法方法) void lockInterruptibly()方法方法) boolean tryLock()方法方法) 释放锁 void unlock()方法方法) ReentrantReadWriteLock详解 类图结构 写锁 OverView锁相关类关系图： 锁概述乐观锁与悲观锁乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。 悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。 乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁，在事务提交时才检测是否存在冲突。乐观锁的实现一般是在表中添加version字段或者使用业务状态。 公平锁与非公平锁公平锁表示线程获取锁的顺序是按照线程请求锁的时间顺序来决定，而非公平锁则按调度策略决定。在没有公平性需求的前提下尽量使用非公平锁，因为公平锁开销较大。 ReentrantLock提供了公平锁和非公平锁。 公平锁：ReentrantLock pairLock = new ReentrantLock(true); 非公平锁：ReentrantLock pairLock = new ReentrantLock(false);。如果构造函数不传递参数，则默认为false。 独占锁与共享锁根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。 独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是独占锁。独占锁是一种悲观锁，由于读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，因此限制了并发性。 共享锁则可以同时多个线程持有，例如ReadWriteLock。共享锁是一种乐观锁，它允许多个线程同时进行读操作。 可重入锁一个线程再次获取它自己已经获取的锁时不会被阻塞，那么该锁就是可重入锁。synchronized锁和ReentrantLock均为可重入锁。 可重入锁的原理是在锁内部维护一个线程标识和一个计数器。计数器初始值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁，计数器值+1。当获取了该锁的线程再次获取锁时发现线程标识是自己，计数器值再+1。释放一次锁则计数器值-1。当计数器值为0时，线程标识置null，阻塞线程被唤醒竞争该锁。 自旋锁自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。可以通过-XX:PreBlockSpinsh设置尝试次数，默认为10次。 JDK层面的锁由java.util.concurrent.locks包提供，其接口和类如下图所示： LockSupportLockSupport类是个工具类，其主要作用是挂起和唤醒线程，它是创建锁和其他同步类的基础。 LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport的方法的线程是不持有许可证的。该类是使用Unsafe类实现的。 LockSupport的构造方法为私有构造方法，无法被实例化，其方法基本为静态方法。 Unsafe的park和unpark方法因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义: 12public native void park(boolean isAbsolute, long time);public native void unpark(Thread thread); 对两个函数的说明如下: park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，给予该线程许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。 unpark函数，给予线程许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。 park()初次调用该方法后，当前线程挂起。 由于可能存在虚假唤醒的情况，所以调用时最好也使用循环条件判断方式。 如当前线程被其他线程中断，不会抛出InterruptedException。 park(Object blocker)Thread类中有个变量volatile Object parkBlocker，用于存放该方法传递的blocker对象，也就是把blocker变量存放到了调用该方法的线程成员变量中。 使用该类的好处是，方便使用诊断工具查看阻塞原因。 parkNanos(long nanos)与park()的不同仅在于会在nanos时间之后自动返回。 parkUntil(Object blocker, long deadline)在指定的时间内阻塞线程。deadline单位是ms，表示从1970到未来某个时刻的总毫秒数。 unpark(Thread thread)调用该方法后，如果线程没有持有与LockSupport关联的许可证，则使shi线程持有。如果线程已经因park()而挂起，则唤醒线程。若unpark()调用前未调用过park()，那么由于线程持有许可证，再次调用park()后线程不会挂起并失去许可证。 注意：park()方法不会释放锁，ConditionObject的await()会释放锁，并且该await()方法挂起线程就是使用park()实现的。 AQSAQS全称抽象队列同步器(AbstractQueuedSynchronizer)，它是实现JDK层面锁的基础组件，locks包ReentrantLock和ReentrantReadWriteLock均由AQS实现，同时CountDownLatch与Semaphore也是由AQS实现。 类图结构 由该图可知AQS继承自AbstractOwnableSynchronizer，并有内部类ConditionObject和Node。AQS的核心是state变量与队列，它的所有实现类都是围绕着对此二者的操作来进行的。 12345private transient volatile Node head;private transient volatile Node tail;private volatile int state; AQS概述队列AQS是一个FIFO的双向队列，该队列用于存放竞争资源失败的线程，队列元素为Node。Node中的thread变量用来存放进入AQS队列的线程，SHARED用于标记线程是获取共享资源时失败而放入AQS队列的，EXCLUSIVE则用于标记线程是获取独占资源时失败而放入AQS队列的，waitStatus记录线程等待状态，可以取如下值： SIGNAL=-1：线程需要被唤醒。 CONDITION=-2：线程在条件队列(ConditionObject)中等待，而非AQS队列。 CANCELLED=1：线程被取消了。 PROPAGATE=-3：释放共享资源时需要通知其他节点。 0：线程新加入队列。 state变量在AQS中维持了一个状态值state变量，AQS的不同实现中对state含义的定义均不同。JUC中的实现主要如下： ReentrantLock：state为0表示没有线程获取锁，大于1的整数表示线程获取锁的可重入次数。 ReentrantReadWriteLock：state的高16位表示读锁的的个数，低16位表示线程获取写锁的可重入次数。 Semaphore：state表示当前可用信号的个数。 CountDownLatch：state表示计数器当前的值。 操作state的方式分为独占方式和共享方式，两种方式获取和释放资源使用的方法分别为： 独占：void acquire(int arg); void acquireInterruptibly(int arg); boolean release(int arg)。 共享：void acquireShared(int arg); void acquireSharedInterruptibly(int arg); boolean release(int arg)。 在上述方法中调用了一系列需要实现类自己实现的模板方法，一共有以下五个： 锁的底层支持AbstractOwnableSynchronizer该抽象类中定义了一个变量 1private transient Thread exclusiveOwnerThread; 表示独占模式下当前占有锁和资源的线程。 独占锁-ReentrantLock与WriteLock对于AQS独占锁，当多个线程同时调用lock.lock()获取锁，只有一个线程获取到锁，其他线程会被转换为Node节点插入到lock锁对应的AQS队列中，并做自旋CAS尝试获取锁，尝试失败后阻塞。“自旋CAS/阻塞”的操作在acquireQueued()和doAcquire*()系列方法中实现。 线程通过调用acquire(int arg)获取独占资源，void acquire(int arg)源码如下： 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire()尝试CAS修改state值获取锁，若成功则表达式!tryAcquire(arg)为false，&amp;&amp;后的表达式无需继续执行，方法直接结束；若失败，则addWaiter()将当前线程封装为类型为NODE.EXCLUSIVE的Node节点插入AQS队列末尾，acquireQueued()方法中节点自旋CAS尝试获取锁，失败则阻塞。 addWaiter方法源码如下： 1234567891011121314151617private Node addWaiter(Node mode) &#123; Node node = new Node(Thread.currentThread(), mode); //判断尾节点是否为null Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; //通过CAS完成“tail = node”操作 pred.next = node; return node; &#125; &#125; //如果tail为null, 说明当前节点为AQS队列第一个节点，再调用enq入AQS队列 //或CAS设置tail失败，调用enq方法重新入队 enq(node); return node; &#125; enq方法源码如下： 123456789101112131415161718private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize //tail为空则设置当前节点为头(尾)节点 if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; //addWaiter中CAS设置tail失败，说明有其他线程竞争进入AQS队列 //由for循环知，该方法会不断自旋直到当前节点入队成功 node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125; &#125; acquireQueued方法源码如下: 123456789101112131415161718192021222324final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; //获取当前节点的前驱节点 final Node p = node.predecessor(); //只有当前节点是队列中第二个节点时才重新tryAcquire if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) //满足一定条件则阻塞当前线程，停止自旋 interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法源码如下： 12345678910111213141516171819202122232425262728293031323334private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus;//获取前驱节点的等待状态 if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true;//只有当前驱节点等待状态为SIGNAL时才能阻塞当前线程 if (ws &gt; 0) &#123;//取消前驱节点，跳过 /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123; /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); //设置前驱节点的等待状态为SIGNAL，下一次当前节点线程就会阻塞，说明只会自旋一次 &#125; return false; &#125;private final boolean parkAndCheckInterrupt() &#123; //shouldParkAfterFailedAcquire返回true，阻塞当前线程，停止自旋，被唤醒后继续执行for循环 LockSupport.park(this); return Thread.interrupted(); &#125; 接下来讲release方法，该方法释放独占方式获取的锁和资源： 1234567891011public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; //释放成功并且头节点不为空，头节点等待状态不为0 //则唤醒后继节点 if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false; &#125; 共享锁-ReadLock线程通过调用acquireShared方法获取共享资源： 12345678910111213141516171819202122232425262728293031public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg); &#125;private void doAcquireShared(int arg) &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125; &#125; 由源码可知，共享方式与独占方式实现类似。tryAcquireShared成功则直接返回，失败则入AQS阻塞队列尾部，自旋一次后阻塞挂起自己。releaseShared源码如下： 1234567public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false; &#125; 释放锁成功则调用doReleaseShared唤醒阻塞队列的所有线程。 条件变量ConditionObejctConditionObject实现了Condition接口，是AQS的内部类，其含义是条件变量，用于结合锁实现同步。 ConditionObject通过AQS锁对象的newCondition()创建(该方法是Lock接口的方法，需要实现类实现)，它可以直接访问AQS对象内部的变量，比如state值和队列。每个ConditionObject对应一个条件队列（单向链表队列），用于存放调用await()方法后被阻塞的线程，而signal()/signalAll()方法用于唤醒条件队列中阻塞的线程并将节点加入AQS队列。条件队列的队头、尾分别为firstWaiter和lastWaiter。 与synchronized内置锁不同，synchronized只能与一个共享变量的wait()或notify()方法实现同步，而AQS实现的一个锁可以创建多个ConditionObject。与wait()和notify()类似，调用条件变量的await()和signal()之前，必须先获取条件变量对应的锁，否则也会抛出IllegalMonitorStateException。条件变量使用示例： 1234567891011121314151617181920212223242526public static void main(String[] args)&#123; ReentrantLock lock = new ReentrantLock(); Condition condition = lock.newCondition(); new Thread(()-&gt;&#123; lock.lock(); try &#123; System.out.println(\"begin wait\"); condition.await(); System.out.println(\"end wait\"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125;).start(); new Thread(()-&gt;&#123; lock.lock(); System.out.println(\"begin signal\"); condition.signal(); System.out.println(\"end signal\"); lock.unlock(); &#125;).start(); &#125; 运行结果： 1234begin waitbegin signalend signalend wait 注意，await()方法会释放锁，而signal()方法不会释放锁，必须手动调用锁对象的unlock()方法释放锁。await()源码如下： 1234567891011121314151617181920212223public final void await() throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); //创建类型为Node.CONDITION的节点并加入条件队列 Node node = addConditionWaiter(); //释放当前线程的锁 int savedState = fullyRelease(node); int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //阻塞当前线程 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0) break; &#125; //线程被唤醒后在AQS队列中，自旋CAS尝试获取锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // clean up if cancelled unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125; 调用await()后，在内部会构造一个类型为Node.CONDITION的节点并插入条件队列末尾，之后当前线程会释放锁（修改state的值），然后通过LockSupport阻塞当前线程。另一个线程调用signal()后，条件队列队头节点出队放入AQS队列的队尾，然后唤醒线程，该线程继续执行await()方法中LockSupport.park(this)之后的代码，调用acquireQueued()方法自旋CAS尝试获取锁。 最后总结如下图：一个锁对应一个AQS队列，对应多个条件变量，每个条件变量有自己的一个条件队列。 ReentrantLock详解类图结构 123456public ReentrantLock() &#123; sync = new NonfairSync();&#125;public ReentrantLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync();&#125; 由构造方法可知，默认是创建非公平锁。 获取锁void lock()方法123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public void lock() &#123;sync.lock();&#125;//非公平锁final void lock() &#123; //获取锁成功则设置当前线程为独占线程，失败则调用AQS的acquire方法 if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1);&#125;public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125;protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires);&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState();//获取state if (c == 0) &#123; //非公平锁的体现：如果state为0，不考虑是否有前驱节点，直接CAS获取锁 if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; //state不为0，但是当前线程是独占线程，则仅仅+1 int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125;//公平锁final void lock() &#123;acquire(1);&#125;protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; //公平锁体现：先检测是否有前驱节点 if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error(\"Maximum lock count exceeded\"); setState(nextc); return true; &#125; return false;&#125; void lockInterruptibly()方法该方法对中断进行响应，也即当前线程调用该方法时，如果其他线程调用了当前线程的interrupt方法，则当前线程会抛出InterruptedException异常。 1234567891011public void lockInterruptibly() throws InterruptedException&#123;sync.acquireInterruptibly(1);&#125;public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125; boolean tryLock()方法尝试获取锁。若该方法失败当前线程不会入AQS队列，也不会阻塞。 释放锁void unlock()方法12345678910111213141516public void unlock() &#123; sync.release(1);&#125;protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; ReentrantReadWriteLock详解ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，来满足实际中写少读多的场景。 类图结构 123456789public ReentrantReadWriteLock() &#123; this(false);&#125;public ReentrantReadWriteLock(boolean fair) &#123; sync = fair ? new FairSync() : new NonfairSync(); readerLock = new ReadLock(this); writerLock = new WriteLock(this);&#125; 由构造方法可知，默认创建非公平锁。 读写锁的内部维护了一个ReadLock和一个WriteLock，它们依赖继承自AQS的Sync实现具体功能。读写锁使用state的高16位表示读状态，也即读锁线程个数；低16位表示写锁的可重入次数。Sync类源码表现如下： 123456789101112131415161718static final int SHARED_SHIFT = 16;//偏移值//低16位为0，第17位为1static final int SHARED_UNIT = (1 &lt;&lt; SHARED_SHIFT);//读锁线程最大个数65535static final int MAX_COUNT = (1 &lt;&lt; SHARED_SHIFT) - 1;//低15位为1static final int EXCLUSIVE_MASK = (1 &lt;&lt; SHARED_SHIFT) - 1;//无符号右移16位，低16位变为原高16位值，原高16位填0static int sharedCount(int c) &#123; return c &gt;&gt;&gt; SHARED_SHIFT; &#125;//按位与运算使高17位为0，低15位不变static int exclusiveCount(int c) &#123; return c &amp; EXCLUSIVE_MASK; &#125; 由源码可知，通过无符号右移获取读锁线程个数，通过与掩码按位与获取写锁可重入次数。 写锁下面只介绍tryAcquire方法 1234567891011121314151617181920212223242526272829protected final boolean tryAcquire(int acquires) &#123; Thread current = Thread.currentThread(); int c = getState();//获取state int w = exclusiveCount(c);//获取写锁可重入次数 if (c != 0) &#123;//说明读锁或写锁已被某线程获取 //w=0说明有线程获取了读锁，w!=0并且当前线程不是写锁拥有者则返回 if (w == 0 || current != getExclusiveOwnerThread()) return false; //说明当前线程获取了写锁，判断可重入次数是否超过最大值 if (w + exclusiveCount(acquires) &gt; MAX_COUNT) throw new Error(\"Maximum lock count exceeded\"); setState(c + acquires);//state+1 return true; &#125; //c=0则根据writerShouldBlock的返回值判断是否执行CAS获取写锁 if (writerShouldBlock() ||!compareAndSetState(c, c + acquires)) return false; setExclusiveOwnerThread(current); return true;&#125;//对于writerShouldBlock，非公平锁实现final boolean writerShouldBlock() &#123; return false; // writers can always barge&#125;//公平锁实现final boolean writerShouldBlock() &#123; return hasQueuedPredecessors();//判断是否有前驱节点&#125; 注意：ReentrantReadWriteLock在采用非公平锁并且在读多写少的情况下，容易导致写线程饥饿。可以使用公平锁或者采用StampedLock。","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC之原子包","slug":"JUC之原子包","date":"2020-09-19T11:56:16.000Z","updated":"2020-11-23T14:23:21.026Z","comments":true,"path":"Java并发/JUC之原子包/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/","excerpt":"","text":"CAS操作 CAS（Compare-And-Swap） CAS使用示例：AtomicInteger CAS的问题 ABA问题 若自旋时间过长则开销大 只能保证单个共享变量的原子操作 Unsafe类 原子包 AtomicInteger 常用方法 源码分析 原子更新基本类型 原子更新数组 原子更新引用类型 原子更新Field JDK8新增的原子操作类LongAdder和DoubleAdder LongAccmulator和DoubleAccumulator 如何实现AtomicByte/AtomicFloat/AtomicDouble? CAS操作CAS（Compare-And-Swap）比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，只有当 V 的值等于旧值A，才将 V 的值更新为 B。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。 CAS使用示例：AtomicIntegerjava.util.concurrent.atomic包中的整数原子类AtomicInteger，其中的修改变量值的方法都采用了Unsafe类的CAS方法。以下代码使用了AtomicInteger执行了自增的操作： 12345private AtomicInteger count = new AtomicInteger();public void add0()&#123;count.incrementAndGet();&#125;public void add1()&#123;count.getAndIncrement();&#125; 以下代码是AtomicInteger中上述两个自增方法的源码： 1234567public final int incrementAndGet() &#123; return unsafe.getAndAddInt(this, valueOffset, 1) + 1;&#125;public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1);&#125; 它们均调用了Unsafe类的getAndAddInt()，其源码如下： 12345678public final int getAndAddInt(Object var1, long var2, int var4) &#123; int var5; do &#123; var5 = this.getIntVolatile(var1, var2); &#125; while(!this.compareAndSwapInt(var1, var2, var5, var5 + var4)); return var5;&#125; 参数的含义分别是：var1指示对象的起始内存地址，var2指示该字段相对对象内存地址的偏移，var1和var2决定了对象在内存中的位置。var4指示需要加的值，此处为1。 通过 getIntVolatile(var1, var2) 得到对象的旧值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5(即没有被改变)，那么就更新内存地址为 var1+var2 的变量为 var5+var4。其中 compareAndSwapInt() 方法在Unsafe类中是native方法。我们注意到该方法在while循环中不断执行，对应的逻辑就是“如果发生冲突则不断尝试执行CAS操作”，这就是基于冲突检测的乐观并发策略。 最后需要注意的是，getAndAddInt()方法返回了var5，该值是旧值。其实add0和add1方法的执行效果是一样的，都是整数原子对象的值+1，由于incrementAndGet()和getAndIncrement()的返回值是整型，而前者的返回值比后者大1，因此容易误会。注意整数原子对象的值+1与它们的返回值无关，它的值是通过CAS操作直接修改的！ CAS的问题ABA问题如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？ 如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类AtomicStampedReference。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。 若自旋时间过长则开销大如果自旋CAS长时间不成功，那么它会一直占用CPU资源。 只能保证单个共享变量的原子操作如果要保证对多个共享变量操作的原子性，可以将多个共享变量放入AtomicReference对象中，来保证原子性。 Unsafe类JDK中的rt.jar中sun.misc包中的Unsafe类提供了硬件级别的原子性操作，Unsafe类中的方法绝大部分都是native方法，它们使用JNI访问本地C++实现库。 Unsafe类主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。因此JDK开发组限制了开发人员通过一般方式使用Unsafe类，比如如下代码会报异常： 1priavte static final Unsafe unsafe = Unsafe.getUnsafe(); J.U.C中原子类获取Unsafe对象就是如此，Unsafe类提供静态方法getUnsafe()返回Unsafe对象，但是如果在用户程序中这样写就会报异常。原因在于getUnsafe()方法源码： 123456789101112public static Unsafe getUnsafe() &#123; //获取调用该方法的类的Class对象 Class var0 = Reflection.getCallerClass(); //判断是不是BootstrapClassLoader加载的该类 if (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123; throw new SecurityException(\"Unsafe\"); &#125; else &#123; return theUnsafe; &#125;&#125;//sun.misc包下的VM类public static boolean isSystemDomainLoader(ClassLoader var0)&#123;return var0 == null;&#125; 显然由于用户类是由AppClassLoader加载的，因此会报异常。 要想使用Unsafe类，可以使用反射来获取unsafe对象： 123456789static final Unsafe unsafe;static &#123; Field field = Unsafe.class.getDeclaredField(\"thUnsafe\"); field.setAccessible(true); unsafe = (Unsafe) field.get(null);&#125; Unsafe类总体功能如下： 其中原子操作只支持如下三个方法： 12345public final native boolean compareAndSwapObject(Object paramObject1, long paramLong, Object paramObject2, Object paramObject3);public final native boolean compareAndSwapInt(Object paramObject, long paramLong, int paramInt1, int paramInt2);public final native boolean compareAndSwapLong(Object paramObject, long paramLong1, long paramLong2, long paramLong3); 其余关于CAS的常用方法有：getAndAddInt, getAndAddLong, getAndSetInt, getAndSetLong, getAndSetObject。 原子包原子包即java.util.concurrent.atomic包，它包含了一系列的原子性操作类，这些类都是使用非阻塞算法CAS实现的。一共有如下类： AtomicInteger依旧以AtomicInteger为例，其余原子类原理类似。 常用方法public final int get()：获取当前值public final int getAndSet(int newValue)：获取当前值，并设置新值public final int getAndIncrement()：获取当前值，并自增public final int getAndDecrement()：获取当前值，并自减public final int getAndAdd(int delta)：获取当前值，并加上预期的值void lazySet(int newValue): 最终会设置成newValue, 使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。 源码分析以下为部分源码： 1234567891011121314151617181920212223public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; //用于获取value字段相对当前对象的“起始地址”的偏移量 valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField(\"value\")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; private volatile int value; //返回当前值 public final int get() &#123; return value; &#125; //递增加detla public final int getAndAdd(int delta) &#123; //三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。 return unsafe.getAndAddInt(this, valueOffset, delta); &#125;&#125; 由源码可知：使用volatile修饰变量，保证了变量的可见性与有序性；使用CAS操作变量，保证了操作的原子性。因此最终效果与使用synchronized一致。 原子更新基本类型 AtomicBoolean AtomicInteger AtomicLong 上述三个原子类类似。 原子更新数组使更新数组的某个元素满足原子性 AtomicIntegerArray: 原子更新整型数组里的元素。 AtomicLongArray: 原子更新长整型数组里的元素。 AtomicReferenceArray: 原子更新引用类型数组里的元素。 原子更新引用类型 AtomicReference: 原子更新引用类型。 AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。 AtomicMarkableReference: 原子更新带有标记位的引用类型。 原子更新Field AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。 AtomicLongFieldUpdater: 原子更新长整型字段的更新器。 AtomicReferenceFieldUpdater: 原子更新引用类型字段的更新器。 这三个类均为抽象类，使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步: 第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。 第二步，更新类的字段必须使用public volatile修饰。 JDK8新增的原子操作类LongAdder和DoubleAdder使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，那么就会由大量线程因为不断自旋而浪费CPU资源。因此JDK8新增了LongAdder用于克服在高并发下使用AtomicLong的缺点，提升性能。 如图所示，使用AtomicLong时，是多个线程同时竞争同一个原子变量： 而使用LongAdder时，则为： LongAdder维护了一个Cell数组，每个Cell里有一个初始值为0L的long型变量，这样在同等并发量的情况下，争夺单个变量更新操作的线程减少。并且如果多个线程争夺同一个Cell原子变量失败了，它并不是在当前Cell变量上一直自旋CAS重试，而是尝试在其他Cell的变量上进行CAS，这个改变增加了当前线程重试CAS成功的可能性。最后，在获取LongAdder当前值时，把所有Cell变量的value累加再加上base返回。 Cell数组默认是null，只有在高并发的情况下才会创建它。在并发量少的时候所有的累加操作都是对base变量进行的，此时与AtomicLong类似。 Cell类使用了@sun.misc.Contended修饰进行字节填充，这是因为数组元素的内存地址连续，为了避免伪共享。 总结：LongAdder在AtomicLong的基础上将单个变量的更新压力分散到各Cell，在低并发的时候通过对base的直接更新可以很好的保障与AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。缺点是LongAdder在求和的时候如果有并发更新，可能导致统计的数据有误差。 DoubleAdder与LongAdder类似。 LongAccmulator和DoubleAccumulatorLongAdder可以看作是LongAccumulator的一个特例。LongAccumulator的构造方法如下： 123456789public LongAccumulator(LongBinaryOperator accumulatorFunction, long identity)&#123; this.function = accumulatorFunction; base = this.identity = identity;&#125;public interface LongBinaryOperator&#123; //根据两个参数计算并返回一个值，具体的运算由用户自定义 long applyAsLong(long left, long right);&#125; 使用LongAdder其实就相当于如下使用LongAccumulator: 123456LongAccumulator accumulator = new LongAccumulator(new LongBinaryOperator()&#123; @Override public long applyAsLong(long left, long right)&#123; return left + right; &#125;&#125;, 0); LongAccumulator可以自定义双目运算规则（applyAsLong()的返回值就是要更新的值。在LongAdder中该值就是base+x，x为其add方法的参数），并且可以指定base的初始值，而LongAdder只能默认base为0。 如何实现AtomicByte/AtomicFloat/AtomicDouble?查看atomic包文档描述，结尾处写道：Additionally, classes are provided only for those types that are commonly useful in intended applications. For example, there is no atomic class for representing byte. In those infrequent cases where you would like to do so, you can use an AtomicInteger to hold byte values, and cast appropriately. You can also hold floats using Float.floatToRawIntBits(float) and Float.intBitsToFloat(int) conversions, and doubles using Double.doubleToRawLongBits(double) and Double.longBitsToDouble(long) conversions. 由文档描述可知，使用Float和Double的方法转换并包装AtomicInteger即可。 参考： 《Java并发编程之美》 《深入理解Java虚拟机》 https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"JUC概述","slug":"JUC概述","date":"2020-09-19T10:05:19.000Z","updated":"2020-11-23T14:23:21.057Z","comments":true,"path":"Java并发/JUC概述/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E6%A6%82%E8%BF%B0/","excerpt":"","text":"OverView 原子包 基础类型 数组 引用 FieldUpdater Adder和Accumulator 锁和工具类 并发集合 线程池 多线程开发的良好习惯 OverView 原子包基础类型AtomicBoolean，AtomicInteger，AtomicLong 数组AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray 引用AtomicReference，AtomicMarkableReference，AtomicStampedReference FieldUpdaterAtomicIntegerFieldUpdater, AtomicLongFieldUpdater，AtomicReferenceFieldUpdate Adder和AccumulatorLongAdder, DoubleAdder, LongAccmulator, DoubleAccumulator 锁和工具类 并发集合 线程池 多线程开发的良好习惯 给线程起个有意义的名字，这样可以方便找 Bug。 缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。 多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。 使用 BlockingQueue 实现生产者消费者问题。 多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。 使用本地变量和不可变类来保证线程安全。 使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。 图片来源均为： https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"ThreadLocal源码剖析","slug":"ThreadLocal源码剖析","date":"2020-09-18T07:16:56.000Z","updated":"2021-01-09T08:54:19.230Z","comments":true,"path":"Java并发/ThreadLocal源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"基本使用 源码剖析 ThreadLocal造成内存泄漏 ThreadLocal使用场景 数据库链接管理 Session管理 InheritableThreadLocal 源码剖析 使用场景 基本使用ThreadLocal提供了线程本地变量，也即如果在类中创建了一个ThreadLocal变量，那么每个访问该变量的线程都会在线程中创建该变量的副本。ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联。从JMM的角度来看，主内存中并不会存储实值（无法在类中通过set方法或构造器赋初值），而线程中所有通过threadLocal引用的操作实际上都是操作线程自身工作内存中的副本，而非主内存中的ThreadLocal对象。 123456789101112131415161718192021222324252627282930313233public class Test &#123; //以下三个变量均存于主内存中 static ThreadLocal&lt;String&gt; threadLocal = new ThreadLocal&lt;&gt;(); static String stringA = new String(\"stringA\"); String stringB = new String(\"stringB\"); public static void main(String[] args) throws InterruptedException &#123; //主线程threadLocal值设置为threadLocalString, 实际上设置主线程工作内存中副本的值 threadLocal.set(\"threadLocalString\"); Test test = new Test(); //子线程修改三个值 new Thread(()-&gt;&#123; threadLocal.set(\"1\"); stringA = \"2\"; test.stringB = \"3\"; //子线程工作内存读取的值 System.out.println(threadLocal.get()); System.out.println(stringA); System.out.println(test.stringB); &#125;).start(); Thread.sleep(1000); //主线程工作内存中读取的值 System.out.println(threadLocal.get()); System.out.println(stringA); System.out.println(test.stringB); &#125;&#125; 输出结果为： 123threadLocalString23 由结果可知，类ThreadLocal变量不会像普通类实例变量和类静态变量那样，将线程中修改的值同步回主内存。 源码剖析首先来看ThreadLocal中的set()方法： 12345678public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125; Thread t = Thread.currentThread();：获取当前线程对象； ThreadLocalMap map = getMap(t); ：获取当前线程对象的ThreadLocalMap。 查看源码发现这是一个定制化的哈希表，其key为ThreadLocal对象引用，value就是我们设置的值。getMap()方法与Thread类的threadLocals变量如下： 123456//ThreadLocal成员方法ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;//Thread类成员变量ThreadLocal.ThreadLocalMap threadLocals = null; Thread中threadLocals被设计成map结构，那么显然一个线程可以关联多个ThreadLocal变量。 if-else：如果当前线程的threadLocals不为空，则以当前ThreadLocal对象为key设置键值对。否则调用createMap()方法创建哈希表。 1234void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue); &#125; 再来看get()和remove()方法： 1234567891011121314151617181920212223242526272829303132333435public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) &#123; T result = (T)e.value; return result; &#125; &#125; return setInitialValue();//若map为空则初始化并返回&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;//一般创建ThreadLocal时会重写该方法protected T initialValue() &#123; return null;&#125;public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) //由于Entry继承自WeakReference,该方法最终调用Reference的clear()方法清除对象引用 m.remove(this); &#125; 总结：每个线程内部都有一个threadLocals成员变量，该变量类型为定制化的哈希表结构，其key为ThreadLocal的this引用，value为我们设置的值。每个线程的本地变量存放在自己工作内存中的threadLocals中。ThreadLocal就是一个工具类，它提供的方法就是为了Thread中的threadLocals而服务。 ——————————————待补充———————————————————————- ThreadLocal造成内存泄漏由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除Entry对象的引用就会导致内存泄漏。 ThreadLocal使用场景数据库链接管理使用ThreadLocal对象把Connection绑定到线程，使得线程中只有一个能控制事务的对象。如果不使用ThreadLocal，那么线程每次获取的是一个新的Connection。 1234567891011121314151617181920212223242526272829303132333435363738394041package com.itheima.utils;import javax.sql.DataSource;import java.sql.Connection;import java.sql.SQLException;/** * 连接的工具类，从数据源中获取一个连接，并实现和线程的绑定 */public class ConnectionUtils &#123; private DataSource dataSource; public void setDataSource(DataSource dataSource) &#123; this.dataSource = dataSource; &#125; private ThreadLocal&lt;Connection&gt; threadLocal = new ThreadLocal&lt;Connection&gt;()&#123; //若初次调用threadLocal.get()时线程的ThreadLocalMap为空，则初始化 @Override protected Connection initialValue() &#123; try &#123; return dataSource.getConnection(); &#125; catch (SQLException throwables) &#123; throwables.printStackTrace(); &#125; return null; &#125; &#125;; /** * 获取当前线程上的连接 */ public Connection getThreadConnection()&#123; return threadLocal.get(); &#125; public void remove()&#123; threadLocal.remove(); &#125;&#125; Session管理https://www.zhihu.com/search?type=content&amp;q=ThreadLocal InheritableThreadLocalInheritableThreadLocal继承自ThreadLocal，它可以让子线程访问在父线程中设置的本地变量。 源码剖析使用场景","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"Java并发基础总结","slug":"Java并发基础总结","date":"2020-09-13T09:07:19.000Z","updated":"2020-11-23T14:23:21.017Z","comments":true,"path":"Java并发/Java并发基础总结/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/","excerpt":"","text":"线程的实现 Java线程优先级 状态转换 使用线程 继承Thread 实现Runnable接口 实现Callable接口 实现接口与继承Thread选择？ 线程之间的协作 wait()/notify()/notifyAll()/notify()/notifyAll()) await()/signal()/signalAll()/signal()/signalAll()) join()) interrupt()) 线程中断 interrupt()) interrupted()/isInterrupted()/isInterrupted()) Thread其他常见方法 join()) sleep()) yield()) setDaemon(Boolean boolean)) 面试：wait()与sleep()区别？与sleep()区别？) 线程死锁 死锁产生必备四条件 避免死锁 synchronized关键字 volatile关键字 volatile的使用场景 线程的实现Thread类的所有关键方法都是声明为native的，也即Java线程的实现本质是使用平台的实现手段。 JDK1.2后，线程模型替换为基于操作系统原生线程模型来实现。 Java线程优先级Java一共设置了10个级别的线程优先级，在两个线程同时处于Ready状态时，优先级高的线程更容易被系统选择执行。 Java的线程优先级是通过映射到系统的原生线程上实现的，因此线程调度最终取决于操作系统，并且操作系统的优先级并不能与Java的优先级一一对应。例如Solaris中有2^32种优先级，Windows只有7种。Windows平台的JDK中使用了除THREAD_PRIORITY_IDLE之外的其余6种线程优先级，对应关系如下表： Java线程优先级 Window线程优先级 1（Thread.MIN_PRIORITY） THREAD_PRIORITY_LOWEST 2 THREAD_PRIORITY_LOWEST 3 THREAD_PRIORITY_BELOW_NORMAL 4 THREAD_PRIORITY_BELOW_NORMAL 5（Thread.NORM_PRIORITY） THREAD_PRIORITY_NORMAL 6 THREAD_PRIORITY_ABOVE_NORMAL 7 THREAD_PRIORITY_ABOVE_NORMAL 8 THREAD_PRIORITY_HIGHEST 9 THREAD_PRIORITY_HIGHEST 10（Thread.MAX_PRIORITY） THREAD_PRIORITY_CRITICAL 状态转换Java线程状态转换图如下： New：创建后尚未启动。 Runnable：包括了操作系统线程状态中的Ready和Runnning。 Waiting（无限期等待）：处于该状态的线程要等待被其他线程显式地唤醒。 Timed Waiting（限期等待）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。 Blocked：等待获取一个排它锁。阻塞和等待的区别在于，阻塞是被动的，而等待线程是主动进入的。 使用线程有以下三种使用线程的方法，其中实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。 继承Thread1234567891011121314public class ThreadTest&#123; public static class MyThread extends Thread&#123; public void run() &#123; // ... &#125; &#125; public static void main(String[] args) &#123; MyThread mt = new MyThread(); mt.start(); &#125;&#125; 调用start()后该线程进入就绪态。 实现Runnable接口1234567891011public class MyRunnable implements Runnable &#123; @Override public void run() &#123; // ... &#125;&#125;public static void main(String[] args) &#123; MyRunnable instance = new MyRunnable(); Thread thread = new Thread(instance); thread.start();&#125; 实现Callable接口12345678910public class MyCallable implements Callable&lt;Integer&gt; &#123; public Integer call() &#123; return 123; &#125;&#125;public static void main(String[] args) throws ExecutionException, InterruptedException &#123; FutureTask&lt;Integer&gt; ft = new FutureTask&lt;&gt;(new MyCallable()); new Thread(ft).start(); System.out.println(ft.get());&#125; 使用FutureTask任务有返回值。 实现接口与继承Thread选择？最好选择接口。 Java类不支持多继承，如果继承了Thread类就不能再继承其他类。而接口则可以多继承与多实现。 继承Thread，任务与线程代码没有分离，耦合度高，不符合软件工程“高内聚低耦合”的原则。 继承Thread整个类开销过大。 线程之间的协作wait()/notify()/notifyAll()以上三个方法均属于Object类而非Thread。 当一个线程调用一个共享变量的wait()方法时，该线程必须事先获取该共享变量的监视器锁，否则调用时会抛出IllegalMonitorStateException异常。调用wait()方法后，该线程会释放共享变量的监视器锁，然后挂起。以下事情可以唤醒该线程： 其他线程获取锁后执行任务完毕后，调用该共享变量的notify()或notifyAll()方法并且释放锁。如果有多个线程在等待，notify()会随机唤醒一个，而notifyAll()则唤醒所有，然后由这些线程来竞争监视器锁，这些线程会依次得到锁并释放锁。 其他线程调用该线程的interrupt()方法，该线程抛出InterruptedException异常返回。 一个线程获取共享变量的监视器锁有两种方式： 执行同步块代码，使用该共享变量作为参数： 1synchronized(/*共享变量*/)&#123;&#125; 调用该共享变量的同步方法： 1synchronized void method()&#123;&#125; 注意，一个线程可以从挂起态变为运行态，即使其他线程没有唤醒或中断该线程或这该线程等待超时，即所谓虚假唤醒。可以通过循环来防止虚假唤醒： 12345synchronized(obj)&#123; while(/*条件不满足则一直等待*/)&#123; obj.wait(); &#125;&#125; 以生产者消费者为例： 123456789//生产线程部分代码，异常在方法外处理synchronized(queue)&#123; //队列满则不需要再生产 while(queue.size() == MAX_SIZE)&#123; queue.wait();//挂起并释放queue的锁 &#125; queue.add(e); queue.notifyAll();&#125; 123456789//消费线程部分代码，异常在方法外处理synchronized(queue)&#123; //队列空则不能消费 while(queue.size() == 0)&#123; queue.wait();//挂起并释放queue的锁 &#125; queue.take(); queue.notifyAll();&#125; 关于调用wait()后释放锁，如果该线程持有多个对象的锁，那么调用了谁的wait，就只释放它的锁，并不会释放其他共享对象的锁。 await()/signal()/signalAll()J.U.C包中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。 join()在线程A中调用线程B的join() 方法，线程A阻塞，直到线程B执行完毕。 interrupt()通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。 线程中断interrupt()线程A运行时，线程B可以调用A的interrupt()方法来设置A的中断标志为true并立即返回。此时线程A实际并没有被中断，它会继续往下执行。但是如果A因为调用了wait()系列方法、join()方法、或者sleep()方法而被挂起，此时B若调用A的interrupt()方法，A会在调用这些方法的地方抛出InterruptedException异常而返回。 interrupted()/isInterrupted()如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。 但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。 123456789101112131415161718public class InterruptExample &#123; private static class MyThread extends Thread &#123; @Override public void run() &#123; while (!Thread.interrupted()) &#123; // .. &#125; System.out.println(\"Thread end\"); &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Thread thread = new MyThread(); thread.start(); thread.interrupt(); &#125;&#125; 查看interrupted源码，发现其返回的是当前线程的中断标志，并且返回后将中断标志重置为false。这里需要注意的是假如在main方法中有这样一句: threadA.interrupted()，此时返回的不是threadA的中断标志而是主线程（main方法所在线程）的。而上述代码while循环中则返回的是MyThread的中断标志。 12345public static boolean interrupted() &#123; return currentThread().isInterrupted(true); &#125;private native boolean isInterrupted(boolean ClearInterrupted); 而要获取某个具体线程对象的中断标志，则应该用isInterrupted()方法。 Thread其他常见方法join()项目中经常会遇到“等待其他几个线程执行完毕后才能继续往下执行”的场景，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。Thread的join()则可以满足该场景的需求。 join()的作用：在线程A中调用线程B的join() 方法，线程A进入waiting状态，直到线程B执行完毕。 sleep()sleep(long millis)是Thread类的static native方法，单位是毫秒。调用Thread.sleep(1000)并不会释放锁，进入timed waiting状态，1000毫秒过后该线程自动唤醒进入就绪态等待CPU调度。 yield()Thread类的静态方法。当一个线程调用yield方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU使用，但是线程调度器可以无条件忽略该暗示。 如果当前线程成功让出CPU使用权，会进入就绪态，甚至可能发生刚让出CPU使用权就又被调度到运行态的情况。 该方法可用于调试或测试时复现并发竞争条件导致的问题。 setDaemon(Boolean boolean)Java中线程分为daemon（守护）线程和user线程两类，其中守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，比如垃圾回收线程就是守护线程，而main方法所在的线程则是主线程。 当所有用户线程结束时，程序也就终止，同时会杀死所有守护线程。 通过在线程调用start()之前myThread.setDaemon(true);来设置该线程为守护线程。 总结：如果希望主线程结束后JVM进程马上结束，就将子线程设置为守护线程。 面试：wait()与sleep()区别？ wait()是Object的方法，sleep()是Thread的方法。 wait()会释放锁，sleep()不会。 线程死锁死锁产生必备四条件 互斥： 线程获取到的资源只能自己使用，其他请求该资源的线程只能等待。 请求并持有：线程请求被其他线程占有资源的同时，并不释放已经持有的资源。 不可剥夺：线程获取到的资源只能由线程使用完后自己释放。 环路：线程-资源形成闭环。 避免死锁只要破坏死锁产生必备的四个条件之一就可以避免死锁，但是目前只能通过避免形成环路来完成，也即可以使用资源申请的有序性原则。 synchronized关键字 同步代码块： 123456789101112131415public class A&#123; static Object obj = new Object(); public void func()&#123; synchronized(obj)&#123;&#125;//锁对象是obj &#125; public void func()&#123; synchronized(this)&#123;&#125;//锁对象是A的实例对象 &#125; public void func()&#123; synchronized(A.class)&#123;&#125;//锁对象是类Class对象 &#125;&#125; 同步方法：锁对象是实例对象。 1public synchronized void func()&#123;&#125; 静态同步方法：锁对象是类Class对象 1public static synchronized void func()&#123;&#125; volatile关键字volatile虽然保证了可见性和有序性，但是并不保证原子性，通过Java内存模型与Java规范的内存间交互操作我们知道，volatile关键字不满足原子性的原因就是，虽然其通过{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}满足了可见性，但是只要{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不是原子的，那么一个线程对一个变量的操作就不是原子的。比如多线程计时器程序： 12345678910public class Test &#123; static volatile int count = 0; public static void main(String[] args) throws InterruptedException &#123; for(int i = 0; i &lt; 6; i++)&#123; new Thread(() -&gt; &#123;for(int j = 0; j &lt; 10000; j++) count++;&#125;).start(); &#125; Thread.sleep(1000); System.out.println(count); &#125;&#125; 使用volatile修饰count，显然在一个线程对一个变量进行{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}操作的时候，其他线程也可以进行这两个操作，这就导致了count的值最终一定会小于60000。而如果对内部for循环加synchronized块，那么它可以通过lock和unlock操作保证同步块中变量的修改一定满足{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不被其他线程打断。 volatile的使用场景使用条件：写入变量值不依赖当前值时。因为如果依赖当前值，则必须保证{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}满足原子性。 常见场景： 状态标志 一次性安全发布(one-time safe publication) 独立观察(independent observation) volatile bean 开销较低的读-写锁策略 双重检查(double-checked) 参考列表： 《Java并发编程之美》 https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"线程安全与锁优化","slug":"线程安全与锁优化","date":"2020-09-12T12:39:28.000Z","updated":"2020-11-23T14:23:21.133Z","comments":true,"path":"Java并发/线程安全与锁优化/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/","excerpt":"","text":"线程安全 Java中的线程安全 不可变 绝对线程安全* 相对线程安全 线程兼容 线程对立* 线程安全 互斥同步 非阻塞同步 CAS（Compare-And-Swap） ABA问题 无同步方案 可重入代码 线程本地存储 锁优化 自旋锁与自适应自旋 锁消除 锁粗化 轻量级锁 偏向锁 线程安全Java中的线程安全线程安全不是一个非真即假的命题，可以将共享数据按照安全程度的强弱顺序分成以下五类: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。 不可变不可变的对象一定是线程安全的，因此不需要再采取任何的线程安全保障措施。 不可变的类型： final修饰的基本数据类型 String 枚举类型 java.lang.Number的部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。 绝对线程安全*不管运行环境如何，调用者都不需要任何额外的同步措施。Java API中标注自己是线程安全的类，大多都不是绝对的线程安全，经常需要其他的同步措施。 相对线程安全相对的线程安全才是我们通常意义上所讲的线程安全，它需要保证对这个对象是线程安全的，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段。Java中大部分都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。 线程兼容线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。 线程对立*线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。 线程安全互斥同步 同步：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。 互斥：互斥是实现同步的手段，主要有临界区、互斥量、信号量等方式。互斥是方法，同步是目的。 Java中实现同步的方式有synchronized关键字和J.U.C包的ReentrantLock。前者表现为原生语法层面的互斥锁，后者表现为API层面的互斥锁（lock()、unlock()配合try/finally语句来完成）。ReentrantLock增加了一些高级功能，主要有： 等待可中断：当持有锁的线程长期不释放锁的时候，等待的线程可选择放弃等待改为处理其他事情。 公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。ReentrantLock默认非公平，但可在构造方法中指定为true。 锁可以绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象。 非阻塞同步互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。 互斥同步属于一种悲观的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。 随着硬件指令集的发展，我们可以使用基于冲突检测的乐观并发策略：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。这种乐观的并发策略的许多实现都不需要将线程阻塞，因此这种同步操作称为非阻塞同步。 CAS（Compare-And-Swap）比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，只有当 V 的值等于旧值A，才将 V 的值更新为 B。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。 ABA问题如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？ 如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类AtomicStampedReference。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。 无同步方案如果一个方法本就不涉及共享数据，那么它天生就是线程安全的。 可重入代码可重入代码一定是线程安全的。 这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。 可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。 线程本地存储可以使用 java.lang.ThreadLocal 类来实现线程本地存储功能。详解参照“ThreadLocal源码剖析”。 锁优化此处指JVM对synchronized的优化。 自旋锁与自适应自旋互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是让一个线程在请求一个共享数据的锁时执行忙循环（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。 自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作占用 CPU 时间，它只适用于共享数据的锁定状态很短的场景。 在 JDK 1.6 中引入了自适应的自旋锁。自适应意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。 锁消除虚拟机在JIT编译器运行时，对一些代码上要求同步，但是被检测出不可能存在共享数据竞争的锁进行消除。 锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去而被其他线程访问到，那就可以把它们当作栈上数据对待。 锁粗化如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。 轻量级锁JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。 轻量级锁是相对于传统的重量级锁（synchronized）而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。 偏向锁偏向锁也是JDK1.6引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，甚至CAS也不需要。 偏向锁偏向于第一个获得它的线程，在接下来的执行过程中，如果该锁没有被其他线程获取，那么第一个线程访问同步块时则永远不需要同步。当其他线程获取该锁后，则结束偏向状态。 参考： 《深入理解Java虚拟机》 周志明 《Java并发编程之美》","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"Java内存模型","slug":"Java内存模型","date":"2020-09-12T12:39:07.000Z","updated":"2020-11-23T14:23:21.013Z","comments":true,"path":"Java并发/Java内存模型/","link":"","permalink":"http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/","excerpt":"","text":"Java指令重排序 主内存与工作内存 内存间交互操作 内存模型三大特征 原子性 可见性 有序性 先行发生原则（Happens-Before规则） 程序次序规则（Program Order Rule） 管程锁定规则（Monitor Lock Rule） volatile变量规则（Volatile Variable Rule） 线程启动规则（Thread Start Rule） 线程加入规则（Thread Join Rule） 线程中断规则（Thread Interruption Rule） 对象终结规则（Finalizer Rule） 传递性（Transitivity） 伪共享 缓存一致性（Cache Coherence） 局部性原理 伪共享 避免伪共享 Java指令重排序Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。但是指令重排在多线程程序中可能会出问题。 主内存与工作内存Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。（C/C++直接使用物理硬件和操作系统的内存模型，因此可能会由于平台差异导致同一份代码无法正常运行。） JMM规定了所有的变量都存储在主内存中。注意： 此处的变量不包括局部变量与方法参数，因为它们是线程私有的。 此处的主内存与硬件的主内存不同，此处仅是JVM内存的一部分。 每条线程还有自己的工作内存，线程的工作内存中保存了被该线程使用到的变量的主内存拷贝副本（如果是对象，不会拷贝整个对象，只会拷贝某些字段值）。 线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也无法访问对方的工作内存。JMM示意图如下： 这与硬件的缓存访问操作很相似： 内存间交互操作JMM定义了8种操作来完成主内存和工作内存之间的交互，这些操作是原子的、不可再分的。 lock: 作用于主内存，把一个变量标识为一条线程独占。 unlock: 作用于主内存，把一个锁定状态的变量释放。 read: 把一个变量的值从主内存传输到工作内存。 load: 把read操作得到的值放入工作内存的变量副本中。 use: 把工作内存变量的值传递给执行引擎。每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行此操作。 assign: 把执行引擎接收到的值赋给工作内存的变量。 store: 把工作内存的一个变量值传输到主内存。 write: 把store传的值放入主内存的变量中。 内存模型三大特征Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。 原子性原子性的含义理解：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。 由JMM直接保证的原子性变量操作包括read/load/use/assign/store/write。 如果应用场景需要一个更大范围的原子性保证，JMM还提供了lock和unlock来满足这种需求，对应的更高层次的字节码指令为monitorenter和monitorexit隐式使用这两个操作，反应到代码中就是synchronized关键字的使用，也即synchronized块的操作也具有原子性。也即lock-&gt;{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}-&gt;unlock保证了{}中一连串操作具有原子性。而volatile关键字不满足原子性的原因就是，虽然其通过{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}满足了可见性，但是只要{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不是原子的，那么一个线程对一个变量的操作就不是原子的。 synchronized关键字经过编译后，会在同步块前后分别形成monitorenter和moniterexit两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明锁对象（monitorenter含义：获得对象的锁；monitorexit含义：释放对象的锁），比如同步块的this/某个对象，或者synchronized方法对应的实例对象，以及静态synchronized方法对应的类Class对象。 Tip: 通过javap反编译发现，临界区代码后有两个monitorexit字节码指令，是因为如果出现异常退出也需要释放锁。 可见性可见性是指：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。 JMM如何实现可见性？ 答：volatile，在变量修改后将新值同步回主内存{assign-&gt;store-&gt;write}，变量使用前从主内存刷新到工作内存{read-&gt;load-&gt;use}。 Java哪些关键字可以保证可见性？ volatile synchronized: 对一个变量执行lock操作后，从主内存刷新到工作内存{lock-&gt;read-&gt;load-&gt;use}；对一个变量执行unlock操作之前，必须先把变量值同步回主内存{assign-&gt;store-&gt;write-&gt;unlock}。 final: 被 final 修饰的字段在构造器中一旦初始化完成，那么其它线程就能看见 final 字段的值。 有序性有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了指令重排序以及工作内存与主内存同步有延迟。在 Java 内存模型中，允许编译器和处理器对指令进行重排序，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。 volatile 关键字通过添加内存屏障的方式来禁止指令重排，即重排序时不能把后面的指令放到内存屏障之前。 也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码（也即锁的作用），相当于是让线程顺序执行同步代码。 先行发生原则（Happens-Before规则）先行发生是JMM中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其含义是：B发生之前，A产生的影响能被B观察到。“影响”包括修改了内存中共享变量的、发送了消息、调用了方法等。 JMM中一些天然的先行发生关系如下： 程序次序规则（Program Order Rule）在一个线程内，在程序前面的操作先行发生于后面的操作。 管程锁定规则（Monitor Lock Rule）一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。 volatile变量规则（Volatile Variable Rule）对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。 线程启动规则（Thread Start Rule）Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。 线程加入规则（Thread Join Rule）Thread 对象的结束先行发生于 join() 方法返回。 线程中断规则（Thread Interruption Rule）对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。 对象终结规则（Finalizer Rule）一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。 传递性（Transitivity）如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。 伪共享缓存一致性（Cache Coherence）在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，如图所示： 当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那么在同步数据回主内存时该以谁的缓存数据为准呢？为了解决一致性问题，需要处理器访问缓存时都遵循一些协议，也即缓存一致性协议，在读写时根据协议来操作，这类协议有MSI，MESI，MOSI等等。 局部性原理局部性原理: CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。 时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。 空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。 伪共享伪共享：多线程下访问同一个Cache行中的多个不同变量时产生。 在Cache内部是按行存储的，其中每一行称为一个Cache行。Cache行是与主内存进行数据交换的单位，其大小一般为2的幂次数字节。 当CPU访问某个变量时，首先会检查CPUCache内是否有该变量，如果有则直接读取，否则就向下级缓存找，直到主内存。然后将找到的变量所在内存区域的一个Cache行大小的内存复制到Cache中。由于存放到Cache行的是内存块而不是单个变量，所以可能会把多个变量存放到一个Cache行中。 由程序运行的局部性原理可知，程序会把变量所在内存中大小为Cache行的内存（地址连续的内存）放入CPUCache中。当多个线程同时写入Cache行中不同的变量时，由于缓存一致性协议，此时只能有一个线程操作Cache行，所以相比将每个变量放到一个Cache行，性能会有所下降，这就是伪共享。以下图为例： 上图中变量x,y所在的内存区域同时被复制到了CPU1和CPU2的Cache行以及二级缓存中，当线程1使用CPU1对x进行更新时，首先修改CPU1Cache1变量x所在的缓存行，此时由于缓存一致性协议，CPU2中变量x对应的缓存行失效，那么线程2在写入变量y时就只能从二级缓存查找了。 在创建数组时，数组里的多个元素就会被放入同一个缓存行，对于单线程程序而言，如果顺序访问数组中的元素，就会充分利用程序运行的局部性原则，从而加速了程序的运行。 避免伪共享jdk1.8之前一般通过字节填充的方式来避免伪共享，也就是创建一个变量时使用无关字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同一个缓存行中。例如如下代码： 1234public final static class FilledLong&#123; public volatile long value = 0L; public long p1, p2, p3, p4, p5, p6;&#125; 使用CPU-Z查看发现我的电脑CPU一级缓存行大小为64Byte，由于一个长整型变量占8Byte，那么以上代码变量总共占了56个Byte，其中6个变量48Byte为填充字节，而类对象的字节码的对象头占用8Byte，所以一个FilledLong对象实际会占用64Byte。 jdk1.8提供了一个sun.misc.Contended注解来解决伪共享问题。将上面的代码修改如下： 1234@sun.misc.Contendedpublic final static class FilledLong&#123; public volatile long value = 0L;&#125; 需要注意的是，默认情况下，@Contended注解只用于Java核心类，比如rt包下的类。如果用户类路径下的类需要使用该注解，则需要添加JVM参数：-XX:-RestrictContended，填充的宽度默认为128，自定义宽度则可以设置-XX:ContendedPaddingWidth。 参考：《深入理解Java虚拟机》 周志明","categories":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"}],"tags":[{"name":"Java并发","slug":"Java并发","permalink":"http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"}]},{"title":"数据结构与算法概述","slug":"数据结构与算法概述","date":"2020-09-10T03:05:44.000Z","updated":"2020-11-23T14:23:21.125Z","comments":true,"path":"数据结构与算法/数据结构与算法概述/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E6%A6%82%E8%BF%B0/","excerpt":"","text":"OverView 数组 链表 哈希表 栈和队列 树 基础 二叉树 满二叉树 完全二叉树 二叉查找树（BST） 平衡二叉树（AVL） 2-3查找树 红黑树（R-B Tree） B树 B+树 B*树 R树 哈夫曼树 堆 图 基础 存储结构 BFS和DFS 最小生成树 最短路径算法 拓扑排序 AOE网与关键路径 高级数据结构与算法 布隆过滤器(Bloom Filter)) BitMap 并查集(Union Find)) 符号表 KMP算法(Knuth Morris Pratt)) 跳跃表(SkipList)) Blog推荐 OverView 数组 优点：存取速度快。 缺点：a.事先必须知道数组的长度。b.需要大块连续的内存块。c.插入删除元素的效率低 Java中主要类似的实现为ArrayList，其他一些容器底层也几乎都会用数组存储数据。 链表 优点：插入删除元素快；无空间限制。 缺点：查找存取慢。 分类：单向链表；双向链表；循环链表 Java中主要类似的实现为LinkedList，其他一些容器底层也会用到链表。 哈希表 详情见HashMap源码剖析。 栈和队列 栈：LIFO 队列：FIFO Java中推荐使用ArrayDeque。 树基础二叉树最多有两棵子树的树。 满二叉树二叉树中所有非叶子节点的度都是2，且叶子节点都在同一层次上。 完全二叉树如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。 二叉查找树（BST）二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树: 若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值； 任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值； 任意节点的左、右子树也分别为二叉查找树。 没有键值相等的节点。 平衡二叉树（AVL）平衡二叉树是指一棵空树或者它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。并且它满足二叉查找树的性质。 2-3查找树红黑树（R-B Tree）B树B树是一种平衡多路查找树。 B+树B*树R树哈夫曼树堆图基础 定义 相关概念 类型 无向图 有向图 完全图 存储结构 邻接矩阵表示法 邻接表表示法 BFS和DFS最小生成树 相关概念 Kruskal算法 Prim算法 最短路径算法 Dijkstra算法 Floyd算法 拓扑排序AOE网与关键路径高级数据结构与算法布隆过滤器(Bloom Filter)BitMap并查集(Union Find)符号表KMP算法(Knuth Morris Pratt)跳跃表(SkipList)Blog推荐 基础：https://www.cnblogs.com/skywang12345/p/3603935.html 进阶：https://blog.csdn.net/v_JULY_v/article/list/3 参考：https://www.pdai.tech/md/algorithm/alg-basic-overview.html","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"LinkedHashMap源码剖析","slug":"LinkedHashMap源码剖析","date":"2020-09-09T07:13:05.000Z","updated":"2020-11-23T14:34:01.014Z","comments":true,"path":"Java/LinkedHashMap源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述 LinkedHashMap的实现 底层数据结构 构造方法 常用方法分析 get() put() removeEldestEntry() afterNodeInsertion() 小结 概述LinkedHashMap是HashMap的一个子类，保存了键值对的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的键值对肯定是先插入的，也可以在构造时带参数，按照访问次序排序。 LinkedHashMap的实现底层数据结构 123456static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125; &#125; 节点Entry继承自HashMap.Node，包含前置指针和后置指针。 123456//双向链表的头指针transient LinkedHashMap.Entry&lt;K,V&gt; head;//双向链表的尾指针transient LinkedHashMap.Entry&lt;K,V&gt; tail;//为false维护的是插入顺序；为true则是维护访问顺序。final boolean accessOrder; 由此可见LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了一个变量用于维护插入顺序或者访问顺序。 构造方法12345678910111213141516171819public LinkedHashMap(int initialCapacity, float loadFactor)&#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity,float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; 由构造方法知LinkedHashMap默认维护的是插入顺序。 常用方法分析get12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount;//get也会导致结构性更改 &#125; &#125; 由get方法可知，accessOrder为true，也即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get方法都会将当前节点移动至链表尾部。保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。 put查看源码发现LinkedHashMap并没有重写put方法，但是重写了newNode方法，因此put会调用重写的newNode方法。并且发现put方法最后调用了afterNodeAccess方法。 123456789101112131415161718Node&lt;K,V&gt; newNode(int hash, K key, V value, Node&lt;K,V&gt; e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = new LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e); linkNodeLast(p);//新建节点连接于链表尾部 return p;&#125;// link at the end of listprivate void linkNodeLast(LinkedHashMap.Entry&lt;K,V&gt; p) &#123; LinkedHashMap.Entry&lt;K,V&gt; last = tail; tail = p; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125;&#125; removeEldestEntry重写该方法可以删除最久未被使用的元素。 afterNodeInsertion新增时判断是否需要删除最久未被使用的元素。 开启accessOrder的情况和最后这两个方法主要用于实现LRU缓存。 小结 LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了变量accessOrder用于维护插入顺序或者访问顺序。 accessOrder为true，即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get/put都会将当前节点移动至链表尾部。注意这意味着get也会导致modCount变化，迭代器会快速失败。","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"HashMap源码剖析","slug":"HashMap源码剖析","date":"2020-09-09T05:10:49.000Z","updated":"2020-11-23T14:33:18.366Z","comments":true,"path":"Java/HashMap源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述 HashMap的实现 底层数据结构 HashMap成员变量的含义 哈希方法 构造方法 扩容机制 常用方法分析 put() 其他常用方法： 小结 概述Map接口主要实现类有四个：HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图： 其中HashMap根据key的hashCode计算得到的哈希值存储数据，因此在访问数据时直接根据hash函数计算就可以得到数据在数组中的位置，访问速度很快，但是遍历顺序却是不确定的。 HashMap最多只允许一个节点的key为null，允许多个节点的value为null。 HashMap非线程安全。若要满足线程安全，可以使用Collections.synchronizedMap方法使HashMap具有线程安全的能力，或者直接使用ConcurrentHashMap。 HashMap的实现底层数据结构 如上图所示，HashMap使用链地址法来解决冲突问题。jdk8后HashMap使用数组+链表/红黑树实现。 1234567891011121314151617181920212223242526272829303132333435363738394041transient Node&lt;K,V&gt;[] table;static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash;//用来定位数组索引位置 final K key;//final修饰，key不可变，否则根据hash函数计算所得的索引位置就变了 V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; public final K getKey() &#123; return key; &#125; public final V getValue() &#123; return value; &#125; public final String toString() &#123; return key + \"=\" + value; &#125; public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value); &#125; public final V setValue(V newValue) &#123; V oldValue = value; value = newValue; return oldValue; &#125; public final boolean equals(Object o) &#123; if (o == this) return true; if (o instanceof Map.Entry) &#123; Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o; if (Objects.equals(key, e.getKey()) &amp;&amp; Objects.equals(value, e.getValue())) return true; &#125; return false; &#125; &#125; HashMap成员变量的含义12345678910111213141516171819202122232425262728293031323334353637383940//数组默认初始容量16.数组容量必须是2的幂，定位索引时采用&amp;运算效率高。static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4;//数组最大容量static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30;//默认负载因子static final float DEFAULT_LOAD_FACTOR = 0.75f;//当链表节点个数 &gt;= 8时，转换为红黑树，访问的时间复杂度由O(N)降为O(logN)static final int TREEIFY_THRESHOLD = 8;//当红黑树节点个数 &lt; 6时，退化为链表static final int UNTREEIFY_THRESHOLD = 6;/** * The smallest table capacity for which bins may be treeified. * (Otherwise the table is resized if too many nodes in a bin.) * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts * between resizing and treeification thresholds. * 只有当数组容量&gt;=64时，bin中的链表才会转换为红黑树； * 否则就算链表节点个数&gt;=8，也不会树化，而是对数组进行扩容。 */static final int MIN_TREEIFY_CAPACITY = 64;//等于capacity * load factor, 当哈希表中有threshold个bin有节点时，进行扩容int threshold; //记录HashMap发生结构性更改的次数，用于实现迭代器fail-fast机制transient int modCount;//负载因子,如果内存空间充足，可以在构造HashMap时适当减小负载因子和增大初 始容量，以此来提高HashMap效率；//相反，如果内存空间紧张而对时间效率要求不高，则可以适当调大负载因子final float loadFactor;//总节点个数transient int size;//用于entrySet()方法返回所有键值对transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; 哈希方法哈希函数用于确定节点在数组中的索引位置，其数学形式为index = hash(key)。jdk1.8实现源码如下： 1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16); &#125; 由源码可知，hash函数的返回值并不是数组索引，因为数组长度并没有参与运算。实际上，获取索引的最后一步操作在获取节点的方法中实现，比如getNode()方法中的代码片段tab[(n - 1) &amp; hash]，tab就是哈希数组，n为数组长度。 以上代码可分为三步： h = key.hashCode() 取key的hashCode值。 hash = h ^ (h &gt;&gt;&gt; 16) 无符号右移16bit(左边补0), 高位运算。高16位异或运算结果为hashCode原来的值，低16位运算结果则是hashCode值的高16位和低16位异或所得。这么做可以在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中，同时不会有太大的开销，并且减小了冲突的可能。 index = (n - 1) &amp; hash 相当于求模运算，但是效率比%更高。因为数组的大小永远是2的幂，所以n - 1是011..11（32位）的形式，任何非负整数（且 &lt;= n-1）和它按位&amp;都会等于其本身。 举个例子： 构造方法123456789101112131415161718192021222324252627//创建指定初始容量和负载因子的HashMappublic HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(\"Illegal initial capacity: \" + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException(\"Illegal load factor: \" + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity); &#125;//创建指定初始容量和默认负载因子的HashMap public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125;public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted &#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false); &#125; 注意，构造方法中并没有创建哈希数组，初始化数组操作是通过resize()方法完成，而resize()方法是在放入键值对的时候才进行调用（初始化或者扩容2倍），比如putVal()方法。 构造方法中调用了tableSizeFor()来获取大于指定容量的最小的2的幂（在ArrayDeque中已分析），其源代码如下： 123456789static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;//从左往右依次运算 &#125; 扩容机制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798/** * Initializes or doubles table size. If null, allocates in * accord with initial capacity target held in field threshold. * Otherwise, because we are using power-of-two expansion, the * elements from each bin must either stay at same index, or move * with a power of two offset in the new table. * @return the table */ final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length;//旧数组容量 int oldThr = threshold;//旧扩容阈值 int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123;//扩容前数组大小如果已经达到最大(2^30)了 threshold = Integer.MAX_VALUE;//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了 return oldTab;//直接返回旧数组不再扩容 &#125;//扩容两倍并检验是否超过最大容量 else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // 阈值同样翻倍 &#125; else if (oldThr &gt; 0) //oldCap为0但是oldThr&gt;0，这是因为构造方法中并没有创建哈希数组，但是却通过tableSizeFor()为threshold赋了值 newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; //对应上面代码的第二种情形，计算新的threshold if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;\"rawtypes\",\"unchecked\"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab;//创建新hash数组并赋值 if (oldTab != null) &#123; //以下代码块将每个bin都复制到新的数组中 for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null;//释放引用，避免内存泄漏 if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode)//转为红黑树操作 ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; //将该链表的冲突节点重新计算索引分配‘原索引’和‘原索引+oldCap’处 Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; //原索引 if ((e.hash &amp; oldCap) == 0) &#123; //e.hash与oldCap按位与只有两种结果，要么为0，要么为oldCap，因为oldCap的二进制形式为0...01000..0 if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123;//原索引+oldCap if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); //原索引放到bin if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; //原索引+oldCap放到bin if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab; &#125; 由注释知，resize()方法用于初始化哈希数组或者扩容2倍。注意，扩容后元素的位置要么是在原位置，要么是在原位置再移动单倍容量位移的位置。 常用方法分析put该方法的流程图如下： 判断table是否为空，空则调用resize()创建数组 计算index，并判断该处是否为null，为null则直接创建节点，并转向6。 不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value 不一致则判断该链为红黑树。 该链为链表则遍历，遍历过程判断链表长度&gt;=8转红黑树处理；不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value 添加节点后判断是否超过阈值threshold，是则扩容 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true); &#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; //1.判断table是否为空，空则调用resize()创建数组 if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //2.计算index，并判断该处是否为null if ((p = tab[i = (n - 1) &amp; hash]) == null) //为null则直接创建节点，并转向6 tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //3.不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; //4.判断该链为红黑树 else if (p instanceof TreeNode) e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); //5.该链为链表则遍历 else &#123; for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //5.1 判断，链表长度&gt;=8转红黑树处理 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash); break; &#125; //5.2 不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break; p = e; &#125; &#125; if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value;//覆盖value afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; //6.添加节点后判断是否超过阈值threshold，是则扩容 if (++size &gt; threshold) resize(); afterNodeInsertion(evict); return null; &#125; 其他常用方法： size()：获取总节点个数 isEmpty()：判断是否为空 containsKey()：判断是否包含指定key get()：获取指定key节点的value remove()：移除指定key的节点 keySet()：获取包含所有key的Set entrySet()：获取包含所有节点的Set 小结 扩容特别耗性能，所以在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。 负载因子可以修改，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。 HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。 JDK1.8引入红黑树大程度优化了HashMap的性能。 参考：https://zhuanlan.zhihu.com/p/21673805 ​ http://irfen.me/java1-8-hashmap/","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"PriorityQueue源码剖析","slug":"PriorityQueue源码剖析","date":"2020-09-08T10:40:43.000Z","updated":"2020-11-23T14:23:21.073Z","comments":true,"path":"Java/PriorityQueue源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述 PriorityQueue的实现 底层数据结构 构造函数 概述Java中优先级队列通过二叉小根堆（任意一个非叶子节点的权值都不大于其孩子节点的权值）实现，可以用一棵完全二叉树表示，这意味着数组可以作为PriorityQueue的底层实现。优先队列的作用是能保证每次取出的元素都是队列中权值最小的，元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器。注意，PriorityQueue不允许放入null元素。 在完全二叉树中，假设某个节点的下标为Node，其左孩子下标为LNode、右孩子下标为RNode，那么有如下关系： Node == (LNode - 1)/2 == (RNode - 1)/2 LNode == 2*Node + 1 RNode == 2*Node + 2 通过上述三个公式，可以很容易计算出某个节点的父节点和孩子节点的下标。 PriorityQueue的实现底层数据结构1234567891011121314/** * Priority queue represented as a balanced binary heap: the two * children of queue[n] are queue[2*n+1] and queue[2*(n+1)]. The * priority queue is ordered by comparator, or by the elements' * natural ordering, if comparator is null: For each node n in the * heap and each descendant d of n, n &lt;= d. The element with the * lowest value is in queue[0], assuming the queue is nonempty. */ transient Object[] queue; // non-private to simplify nested class access /** * The number of elements in the priority queue. */ private int size = 0; 构造函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102private static final int DEFAULT_INITIAL_CAPACITY = 11;/** * The comparator, or null if priority queue uses elements' * natural ordering. */private final Comparator&lt;? super E&gt; comparator;public PriorityQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null); &#125;//默认构造，默认容量，不使用比较器public PriorityQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125;//指定初始容量，不使用比较器public PriorityQueue(Comparator&lt;? super E&gt; comparator) &#123; this(DEFAULT_INITIAL_CAPACITY, comparator); &#125;//指定比较器，使用默认容量public PriorityQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; // Note: This restriction of at least one is not actually needed, // but continues for 1.5 compatibility if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.queue = new Object[initialCapacity]; this.comparator = comparator; &#125;//以上构造都使用this()调用了本构造方法/** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified collection. If the specified collection is an instance of * a &#123;@link SortedSet&#125; or is another &#123;@code PriorityQueue&#125;, this * priority queue will be ordered according to the same ordering. * Otherwise, this priority queue will be ordered according to the * &#123;@linkplain Comparable natural ordering&#125; of its elements. * * @param c the collection whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of the specified collection * cannot be compared to one another according to the priority * queue's ordering * @throws NullPointerException if the specified collection or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(Collection&lt;? extends E&gt; c) &#123; if (c instanceof SortedSet&lt;?&gt;) &#123; SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) ss.comparator(); initElementsFromCollection(ss); &#125; else if (c instanceof PriorityQueue&lt;?&gt;) &#123; PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c; this.comparator = (Comparator&lt;? super E&gt;) pq.comparator(); initFromPriorityQueue(pq); &#125; else &#123; this.comparator = null; initFromCollection(c); &#125; &#125; /** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified priority queue. This priority queue will be * ordered according to the same ordering as the given priority * queue. * * @param c the priority queue whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of &#123;@code c&#125; cannot be * compared to one another according to &#123;@code c&#125;'s * ordering * @throws NullPointerException if the specified priority queue or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(PriorityQueue&lt;? extends E&gt; c) &#123; this.comparator = (Comparator&lt;? super E&gt;) c.comparator(); initFromPriorityQueue(c); &#125; /** * Creates a &#123;@code PriorityQueue&#125; containing the elements in the * specified sorted set. This priority queue will be ordered * according to the same ordering as the given sorted set. * * @param c the sorted set whose elements are to be placed * into this priority queue * @throws ClassCastException if elements of the specified sorted * set cannot be compared to one another according to the * sorted set's ordering * @throws NullPointerException if the specified sorted set or any * of its elements are null */ @SuppressWarnings(\"unchecked\") public PriorityQueue(SortedSet&lt;? extends E&gt; c) &#123; this.comparator = (Comparator&lt;? super E&gt;) c.comparator(); initElementsFromCollection(c); &#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"ArrayDeque源码剖析","slug":"ArrayDeque源码剖析","date":"2020-09-08T07:05:08.000Z","updated":"2020-11-23T14:31:44.064Z","comments":true,"path":"Java/ArrayDeque源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java/ArrayDeque%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述 ArrayDeque实现 底层数据机构 构造函数 扩容：doubleCapacity方法 addFirst() addLast() pollFirst() pollLast() peekFirst() peekLast() 概述Deque, 即“double ended queue”，表示双向队列，它既可以当作队列使用，也可以当作栈使用。ArrayDeque和LinkedList是Deque的两个通用实现，但是官方更推荐使用AarryDeque用作栈和队列。 ArrayDeque底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，需要设置head指针和tail指针，head指向首端第一个有效元素，tail指向尾端第一个可以插入元素的空位。也就是说ArrayDeque底层实现是一个循环数组（circular array），并且数组的任何一点都可能被看作起点或终点。 ArrayDeque是非线程安全的，另外该容器不允许放入null元素。 ArrayDeque实现底层数据机构123456789101112131415161718192021222324252627282930/** * The array in which the elements of the deque are stored. * The capacity of the deque is the length of this array, which is * always a power of two. The array is never allowed to become * full, except transiently within an addX method where it is * resized (see doubleCapacity) immediately upon becoming full, * thus avoiding head and tail wrapping around to equal each * other. We also guarantee that all array cells not holding * deque elements are always null. */ transient Object[] elements; // non-private to simplify nested class access /** * The index of the element at the head of the deque (which is the * element that would be removed by remove() or pop()); or an * arbitrary number equal to tail if the deque is empty. */ transient int head; /** * The index at which the next element would be added to the tail * of the deque (via addLast(E), add(E), or push(E)). */ transient int tail; /** * The minimum capacity that we'll use for a newly created deque. * Must be a power of 2. */ private static final int MIN_INITIAL_CAPACITY = 8; 由注释总结得出以下几点重要信息： 最小初始容量为8，并且自动扩容后数组的大小永远是2的幂。 数组永远不能满，以避免head和tail指针相等。 数组元素不能为null。 构造函数1234567891011121314151617181920212223242526272829303132333435 public ArrayDeque() &#123; elements = new Object[16]; &#125; public ArrayDeque(int numElements) &#123; allocateElements(numElements); &#125; public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); addAll(c); &#125;private void allocateElements(int numElements) &#123; elements = new Object[calculateSize(numElements)]; &#125;private static int calculateSize(int numElements) &#123; int initialCapacity = MIN_INITIAL_CAPACITY; // Find the best power of two to hold elements. // Tests \"&lt;=\" because arrays aren't kept full. if (numElements &gt;= initialCapacity) &#123; initialCapacity = numElements; initialCapacity |= (initialCapacity &gt;&gt;&gt; 1); initialCapacity |= (initialCapacity &gt;&gt;&gt; 2); initialCapacity |= (initialCapacity &gt;&gt;&gt; 4); initialCapacity |= (initialCapacity &gt;&gt;&gt; 8); initialCapacity |= (initialCapacity &gt;&gt;&gt; 16); initialCapacity++; if (initialCapacity &lt; 0) // Too many elements, must back off initialCapacity &gt;&gt;&gt;= 1;// Good luck allocating 2 ^ 30 elements &#125; return initialCapacity; &#125; 由源码可知： 如果不指定容量创建ArrayDeque，默认数组大小为16。 如果指定容量大小，构造方法会调用static int calculateSize(int numElements)计算最合适的2的幂来创建数组。若指定容量小于MIN_INITIAL_CAPACITY8，则直接创建大小为8的数组；若指定容量大于等于8，则会通过以下代码块来获得大于指定容量的最小2的次幂数。 1234567initialCapacity = numElements;initialCapacity |= (initialCapacity &gt;&gt;&gt; 1);initialCapacity |= (initialCapacity &gt;&gt;&gt; 2);initialCapacity |= (initialCapacity &gt;&gt;&gt; 4);initialCapacity |= (initialCapacity &gt;&gt;&gt; 8);initialCapacity |= (initialCapacity &gt;&gt;&gt; 16);initialCapacity++; &gt;&gt;&gt;为无符号右移运算，以8为例，其二进制数为000…01000共32位，后面简写为1000。8 &gt;&gt;&gt; 1后则为0100，相当于除以2的1次幂；8 &gt;&gt;&gt; 2后则为0010，相当于除以2的2次幂… |为按位或，两数按位或，对应位只要有一个1该为结果即为1。 那么以initialCapacity等于8为例： 12345ini &gt;&gt;&gt; 1, 得0100；1000 | 0100 得 ini &#x3D;1100ini &gt;&gt;&gt; 2, 得0011；1100 | 0011 得 ini &#x3D;1111ini &gt;&gt;&gt; 4, 得0000；1111 | 0000 得 ini &#x3D;1111ini &gt;&gt;&gt; 8, 得0000；1111 | 0000 得 ini &#x3D;1111ini &gt;&gt;&gt; 16, 得0000；1111 | 0000 得 ini &#x3D;1111 最后结果为16。 12345initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 1);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 2);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 4);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 8);initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 16); 实际上，以上代码块的作用是将initialCapacity 的最高位1的所有低位全部变为1，如下图所示： 5次操作后再进行自加，就会得到大于initialCapacity的最小2的次幂数。 有一个特殊情况需要处理，即initialCapacity的最高位1是在第31位上： 01XXXXXX XXXXXXXX XXXXXXXX XXXXXXXX 这样在进行所有操作后initialCapacity会变为： 10000000 00000000 00000000 00000000 最高位为1，实际上就上溢为一个负数(-2^31)(32位整型范围为-2^31 ~ 2^31 - 1)。为了处理这种情况，会将initialCapacity右移一位，这样它就变为了一个很大的整数（2的30次幂）。 参考：https://blog.csdn.net/liubin119712/article/details/51075861 使用集合元素创建ArrayDeque调用的addAll()方法实际上继承自父抽象类AbstractCollection的，因为ArrayDeque没有重写该方法。 1234567public boolean addAll(Collection&lt;? extends E&gt; c) &#123; boolean modified = false; for (E e : c) if (add(e)) modified = true; return modified; &#125; 然后addAll中的add方法为ArrayDeque重写的add方法。 扩容：doubleCapacity方法ArrayDeque的自动扩容发生在head == tail的情况下，此时直接扩容为原来的两倍。int newCapacity = n &lt;&lt; 1;。 12345678910111213141516171819/** * Doubles the capacity of this deque. Call only when full, i.e., * when head and tail have wrapped around to become equal. */ private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // head右边元素个数 int newCapacity = n &lt;&lt; 1;//扩容为原空间2倍 if (newCapacity &lt; 0) throw new IllegalStateException(\"Sorry, deque too big\"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r);//复制head右半部分 System.arraycopy(elements, 0, a, r, p);//复制head左半部分 elements = a; head = 0; tail = n; &#125; addFirst 1234567public void addFirst(E e) &#123; if (e == null) throw new NullPointerException(); elements[head = (head - 1) &amp; (elements.length - 1)] = e; if (head == tail) doubleCapacity(); &#125; 因为tail指针总是指向下一个可插入的空位，也即在进行任何添加元素的操作时，总会有空位，所以不需要考虑空间问题。 head = (head - 1) &amp; (elements.length - 1)：这段代码在head不为0时，相当于求模运算，但是效率比使用%高。因为数组的大小永远是2的幂，所以elements.length - 1是011..11（32位）的形式，任何非负整数（且 &lt;= len-1）和它按位与都会等于其本身；而在head为0时，head-1则为-1，其二进制源码为1000...01（32位），由于计算机运算使用补码，-1的补码则为除符号位外全部取反后+1，为1111...11（32位），那么它和elements.length - 1按位与的结果就是elements.length - 1本身，也就是在数组末尾插入。 addLast1234567public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity(); &#125; (tail = (tail + 1) &amp; (elements.length - 1)相当于求模运算。 pollFirst1234567891011public E pollFirst() &#123; int h = head; @SuppressWarnings(\"unchecked\") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // 让GC回收 head = (h + 1) &amp; (elements.length - 1);//求模 return result; &#125; pollLast12345678910public E pollLast() &#123; int t = (tail - 1) &amp; (elements.length - 1); @SuppressWarnings(\"unchecked\") E result = (E) elements[t]; if (result == null) return null; elements[t] = null; tail = t; return result; &#125; peekFirst1234public E peekFirst() &#123; // elements[head] is null if deque empty return (E) elements[head]; &#125; peekLast123public E peekLast() &#123; return (E) elements[(tail - 1) &amp; (elements.length - 1)]; &#125; 参考：https://www.pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"LinkedList源码剖析","slug":"LinkedList源码剖析","date":"2020-09-07T12:11:21.000Z","updated":"2020-11-23T14:36:17.663Z","comments":true,"path":"Java/LinkedList源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述 LinkedList实现 底层数据结构 构造方法 getFirst(), getLast() removeFirst(), removeLast(), remove(e), remove(index) add(), addAll() clear() set(), get() indexOf(), lastIndexOf() Queue接口的方法 概述LinkedList同时实现了List, Queue和Deque三个接口，因此它既可以看作一个顺序容器，又可以看作一个队列，也可以看作一个栈。由于Java官方已经不建议使用Vector和Stack，因此LinkedList是一个选择。关于栈和队列，现在的首选是ArrayDeque，它 没有容量限制，可根据需求自动进行扩容。由于ArrayDeque的底层实现为数组，其作为队列或数组时效率相较于基于双向链表的 LinkedList也要更好一些。注意，ArrayDeque 不支持为 null 的元素，LinkedList支持null。 LinkedList实现底层数据结构LinkedList底层通过双向链表实现，这决定了它所有与下标有关的操作都是线性时间，而在首尾插入删除元素只需要常数时间。为了追求效率LinkedList没有实现同步，如果需要并发访问，可以采用Collections.synchronizedList()方法进行包装。 123456789101112131415161718transient int size = 0;transient Node&lt;E&gt; first;transient Node&lt;E&gt; last;//节点内部类private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125;&#125; 构造方法1234567891011121314public LinkedList() &#123;&#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; getFirst, getLast获取list的第一个元素和最后一个元素 12345678910111213public E getFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return f.item;&#125;public E getLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return l.item;&#125; removeFirst, removeLast, remove删除第一个节点 123456789101112131415161718192021public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f); &#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++;//fast-fail return element; &#125; 删除最后一个节点 12345678910111213141516171819202122public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l); &#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element; &#125; 删除第一次出现的指定元素，若没有则返回false。注意LinkedList允许null元素，因此分为两种情况遍历。 1234567891011121314151617181920212223242526272829303132333435363738394041424344public boolean remove(Object o) &#123; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) &#123; unlink(x); return true; &#125; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) &#123; unlink(x); return true; &#125; &#125; &#125; return false; &#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element; &#125; 删除指定index的节点，使用index &lt; (size &gt;&gt; 1判断index在前半段还是后半段，以此来决定从头部还是尾部开始遍历，可以一定程度提高效率。 1234567891011121314151617181920public E remove(int index) &#123; checkElementIndex(index);//检查是否越界 return unlink(node(index)); &#125;//返回指定index的节点Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125; &#125; add, addAll末尾添加节点 12345678910111213141516public boolean add(E e) &#123; linkLast(e); return true; &#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null) first = newNode; else l.next = newNode; size++; modCount++; &#125; 指定index添加元素。通过node(index)找到index处的节点，将element插入到该节点之前。 123456789101112131415161718192021public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index)); &#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++; &#125; 末尾添加集合里所有元素 123public boolean addAll(Collection&lt;? extends E&gt; c) &#123; return addAll(size, c); &#125; 指定index添加集合元素。添加到指定元素之前。 1234567891011121314151617181920212223242526272829303132333435363738public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; checkPositionIndex(index); Object[] a = c.toArray(); int numNew = a.length; if (numNew == 0) return false; Node&lt;E&gt; pred, succ; if (index == size) &#123; succ = null; pred = last; &#125; else &#123; succ = node(index); pred = succ.prev; &#125; for (Object o : a) &#123; @SuppressWarnings(\"unchecked\") E e = (E) o; Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, null); if (pred == null) first = newNode; else pred.next = newNode; pred = newNode; &#125; if (succ == null) &#123; last = pred; &#125; else &#123; pred.next = succ; succ.prev = pred; &#125; size += numNew; modCount++; return true; &#125; clear清空链表 12345678910111213141516public void clear() &#123; // Clearing all of the links between nodes is \"unnecessary\", but: // - helps a generational GC if the discarded nodes inhabit // more than one generation // - is sure to free memory even if there is a reachable Iterator for (Node&lt;E&gt; x = first; x != null; ) &#123; Node&lt;E&gt; next = x.next; x.item = null; x.next = null; x.prev = null; x = next; &#125; first = last = null; size = 0; modCount++; &#125; set, get123456789101112public E set(int index, E element) &#123; checkElementIndex(index); Node&lt;E&gt; x = node(index); E oldVal = x.item; x.item = element; return oldVal; &#125;public E get(int index) &#123; checkElementIndex(index); return node(index).item; &#125; indexOf, lastIndexOf查找第一次出现指定元素的下标和最后一次出现指定元素的下标，找不到则返回-1。 1234567891011121314151617181920212223242526272829303132333435public int indexOf(Object o) &#123; int index = 0; if (o == null) &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (x.item == null) return index; index++; &#125; &#125; else &#123; for (Node&lt;E&gt; x = first; x != null; x = x.next) &#123; if (o.equals(x.item)) return index; index++; &#125; &#125; return -1; &#125;public int lastIndexOf(Object o) &#123; int index = size; if (o == null) &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (x.item == null) return index; &#125; &#125; else &#123; for (Node&lt;E&gt; x = last; x != null; x = x.prev) &#123; index--; if (o.equals(x.item)) return index; &#125; &#125; return -1; &#125; Queue接口的方法peek(): 获取第一个元素。null不会抛异常。 element(): 获取第一个元素，如果为null会抛异常。 poll(): 获取并删除第一个元素。 offer(): 末尾添加元素。 参考：https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"ArrayList源码剖析","slug":"ArrayList源码剖析","date":"2020-09-07T09:18:35.000Z","updated":"2020-11-23T14:32:57.736Z","comments":true,"path":"Java/ArrayList源码剖析/","link":"","permalink":"http://thmasterplan.cn/Java/ArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/","excerpt":"","text":"概述 ArrayList的实现 ArrayList中的常量 底层数据结构 三种构造函数 扩容机制 add(), addAll() set(), get() remove() trimToSize() indexOf(), lastIndexOf() 快速失败机制 Arrays.copyof()和System.arraycopy() 概述​ ArrayList实现了List接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入null元素，底层通过数组实现。 ​ 每个ArrayList都有一个容量(capacity)，表示底层数组的实际大小。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。 ​ size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。 ​ 为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，可使用Vector替代。ArrayList除未实现同步外，其余跟Vector大致相同。 ArrayList的实现ArrayList中的常量12345678910111213141516/** * Default initial capacity. */ private static final int DEFAULT_CAPACITY = 10; /** * Shared empty array instance used for empty instances. */ private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; /** * Shared empty array instance used for default sized empty instances. We * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when * first element is added. */ private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; 底层数据结构1234567891011121314/** * The array buffer into which the elements of the ArrayList are stored. * The capacity of the ArrayList is the length of this array buffer. Any * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA * will be expanded to DEFAULT_CAPACITY when the first element is added. */ transient Object[] elementData; // non-private to simplify nested class access /** * The size of the ArrayList (the number of elements it contains). * * @serial */ private int size; 三种构造函数1234567891011121314151617181920212223242526272829303132333435363738394041424344/** * Constructs an empty list with the specified initial capacity. * * @param initialCapacity the initial capacity of the list * @throws IllegalArgumentException if the specified initial capacity * is negative */ public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123; this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123; this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123; throw new IllegalArgumentException(\"Illegal Capacity: \"+ initialCapacity); &#125; &#125; /** * Constructs an empty list with an initial capacity of ten. */ public ArrayList() &#123; this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA; &#125; /** * Constructs a list containing the elements of the specified * collection, in the order they are returned by the collection's * iterator. * * @param c the collection whose elements are to be placed into this list * @throws NullPointerException if the specified collection is null */ public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125; &#125; 扩容机制​ 每当向数组中添加元素时，都要检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行自动扩容。 ​ 数组扩容通过公开方法ensureCapacity(int minCapacity)实现。当需要使用ArrayList存储较多数据时，我们最好手动使用该方法进行扩容，以减少每次1.5倍自动扩容产生的复制数组元素的开销。因为ArrayList的初始容量只有10。 ​ 注意以下源码中，grow()方法中的int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);，可见每次扩容是在现有容量的基础上增加0.5倍容量。由于每次扩容老数组的元素会复制到新数组中，可见自动扩容机制的开销非常大。我们在实际使用ArrayList的时候，在可预知要保存多少个元素的情况下，应该在new ArrayList时指定容量大小。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172/** * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if * necessary, to ensure that it can hold at least the number of elements * specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ public void ensureCapacity(int minCapacity) &#123; int minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA) // any size if not default element table ? 0 // larger than default for default empty table. It's already // supposed to be at default size. : DEFAULT_CAPACITY; if (minCapacity &gt; minExpand) &#123; ensureExplicitCapacity(minCapacity); &#125; &#125;private static int calculateCapacity(Object[] elementData, int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; return Math.max(DEFAULT_CAPACITY, minCapacity); &#125; return minCapacity; &#125;private void ensureCapacityInternal(int minCapacity) &#123; ensureExplicitCapacity(calculateCapacity(elementData, minCapacity)); &#125; private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity); &#125; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Increases the capacity to ensure that it can hold at least the * number of elements specified by the minimum capacity argument. * * @param minCapacity the desired minimum capacity */ private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity); &#125; private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE; &#125; add, addAll​ 添加元素之前，调用ensureCapacityInternal(size + 1);检查当前数组元素个数是否已达容量上限，是则进行grow操作。 1234567891011121314151617181920212223242526272829303132333435/** * Appends the specified element to the end of this list. * * @param e element to be appended to this list * @return &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;@link Collection#add&#125;) */ public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true; &#125; /** * Inserts the specified element at the specified position in this * list. Shifts the element currently at that position (if any) and * any subsequent elements to the right (adds one to their indices). * * @param index index at which the specified element is to be inserted * @param element element to be inserted * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; */ public void add(int index, E element) &#123; rangeCheckForAdd(index); ensureCapacityInternal(size + 1); // Increments modCount!! System.arraycopy(elementData, index, elementData, index + 1, size - index); elementData[index] = element; size++; &#125; private void rangeCheckForAdd(int index) &#123; if (index &gt; size || index &lt; 0) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; add(int index, E element)操作的时间复杂度与插入元素的位置相关。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253/** * Appends all of the elements in the specified collection to the end of * this list, in the order that they are returned by the * specified collection's Iterator. The behavior of this operation is * undefined if the specified collection is modified while the operation * is in progress. (This implies that the behavior of this call is * undefined if the specified collection is this list, and this * list is nonempty.) * * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws NullPointerException if the specified collection is null */ public boolean addAll(Collection&lt;? extends E&gt; c) &#123; Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount System.arraycopy(a, 0, elementData, size, numNew); size += numNew; return numNew != 0; &#125; /** * Inserts all of the elements in the specified collection into this * list, starting at the specified position. Shifts the element * currently at that position (if any) and any subsequent elements to * the right (increases their indices). The new elements will appear * in the list in the order that they are returned by the * specified collection's iterator. * * @param index index at which to insert the first element from the * specified collection * @param c collection containing elements to be added to this list * @return &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call * @throws IndexOutOfBoundsException &#123;@inheritDoc&#125; * @throws NullPointerException if the specified collection is null */ public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123; rangeCheckForAdd(index); Object[] a = c.toArray(); int numNew = a.length; ensureCapacityInternal(size + numNew); // Increments modCount int numMoved = size - index; if (numMoved &gt; 0) System.arraycopy(elementData, index, elementData, index + numNew, numMoved); System.arraycopy(a, 0, elementData, index, numNew); size += numNew; return numNew != 0; &#125; 与add()方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 addAll()的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。 set, get12345678910111213141516171819202122public E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index]; &#125;public E set(int index, E element) &#123; rangeCheck(index); E oldValue = elementData(index); elementData[index] = element; return oldValue; &#125;private void rangeCheck(int index) &#123; if (index &gt;= size) throw new IndexOutOfBoundsException(outOfBoundsMsg(index)); &#125; removeremove()方法也有两个版本，一个是remove(int index)删除指定位置的元素，另一个是remove(Object o)删除第一个满足o.equals(elementData[index])的元素。删除操作是add()操作的逆过程，需要将删除点之后的元素向前移动一个位置。注意，根据可达性分析算法，必须将数组中最后一个位置的引用清除掉，堆中的对象才会被回收，也就是显式的为最后一个位置赋null值。 123456789101112131415161718192021222324252627282930313233343536373839public E remove(int index) &#123; rangeCheck(index); modCount++; E oldValue = elementData(index); int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work return oldValue; &#125;public boolean remove(Object o) &#123; if (o == null) &#123; for (int index = 0; index &lt; size; index++) if (elementData[index] == null) &#123; fastRemove(index); return true; &#125; &#125; else &#123; for (int index = 0; index &lt; size; index++) if (o.equals(elementData[index])) &#123; fastRemove(index); return true; &#125; &#125; return false; &#125;private void fastRemove(int index) &#123; modCount++; int numMoved = size - index - 1; if (numMoved &gt; 0) System.arraycopy(elementData, index+1, elementData, index, numMoved); elementData[--size] = null; // clear to let GC do its work &#125; trimToSize将底层数组的容量调整为当前列表保存的实际元素的大小。 12345678910111213/** * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the * list's current size. An application can use this operation to minimize * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance. */ public void trimToSize() &#123; modCount++; if (size &lt; elementData.length) &#123; elementData = (size == 0) ? EMPTY_ELEMENTDATA : Arrays.copyOf(elementData, size); &#125; &#125; indexOf, lastIndexOf获取元素第一次出现的index: 12345678910111213141516171819/** * Returns the index of the first occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int indexOf(Object o) &#123; if (o == null) &#123; for (int i = 0; i &lt; size; i++) if (elementData[i]==null) return i; &#125; else &#123; for (int i = 0; i &lt; size; i++) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 获取元素最后一次出现的index: （倒序遍历数组） 12345678910111213141516171819/** * Returns the index of the last occurrence of the specified element * in this list, or -1 if this list does not contain the element. * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;, * or -1 if there is no such index. */ public int lastIndexOf(Object o) &#123; if (o == null) &#123; for (int i = size-1; i &gt;= 0; i--) if (elementData[i]==null) return i; &#125; else &#123; for (int i = size-1; i &gt;= 0; i--) if (o.equals(elementData[i])) return i; &#125; return -1; &#125; 快速失败机制ArrayList的Fail-Fast机制通过记录modCount的值来实现。该变量在ArrayList的父抽象类AbastractList定义，其含义是容器发生结构性修改的次数。详细介绍在迭代器篇。 Arrays.copyof和System.arraycopyArrays的copyof()方法有很多重载方法，以下为ArrayList中使用的重载版本。 12345678910111213public static &lt;T&gt; T[] copyOf(T[] original, int newLength) &#123; return (T[]) copyOf(original, newLength, original.getClass()); &#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123; @SuppressWarnings(\"unchecked\") T[] copy = ((Object)newType == (Object)Object[].class) ? (T[]) new Object[newLength] : (T[]) Array.newInstance(newType.getComponentType(), newLength); System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 第二个方法最后一个参数表示最后返回的数组元素数据类型，也就是新数组的数据元素类型。该方法在内部创建了了一个长度为newLength的新数组，又调用了System.arraycopy()方法将老数组的元素复制到新数组。 查看java.lang.System发现，System.arraycopy()为本地方法，最终调用了C语言的函数来实现复制。 1public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 参考：https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html ​ https://blog.csdn.net/ns_code/article/details/35568011","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"集合知识体系结构","slug":"集合知识体系结构","date":"2020-09-07T09:17:52.000Z","updated":"2020-11-23T14:23:21.146Z","comments":true,"path":"Java/集合知识体系结构/","link":"","permalink":"http://thmasterplan.cn/Java/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/","excerpt":"","text":"集合知识体系结构 Collection List ArrayList Vector Stack LinkedList Queue LinkedList PriorityQueue Deque&lt;&gt; ArrayDeque Set HashSet LinkedHashSet TreeSet Map HashMap LinkedHashMap HashTable TreeMap Collections工具类 集合知识体系结构 CollectionListArrayList 基于动态数组实现，支持随机访问。 Vector 和 ArrayList 类似，但它是线程安全的。 StackLinkedList 基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。 QueueLinkedList 同上 PriorityQueue 基于小根堆实现，可以用它来实现优先队列。 Deque&lt;&gt;ArrayDeque 基于循环数组实现的队列，比LinkedList性能更好。 SetHashSet 基于HashMap实现（适配器模式），支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。 LinkedHashSet 继承自HashSet，具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。 TreeSet 基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。 MapHashMap 基于哈希表实现。 LinkedHashMap 使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。 HashTable 和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。 TreeMap 基于红黑树实现。 Collections工具类","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"比较器与迭代器","slug":"比较器与迭代器","date":"2020-09-07T09:17:29.000Z","updated":"2020-11-23T14:23:21.130Z","comments":true,"path":"Java/比较器与迭代器/","link":"","permalink":"http://thmasterplan.cn/Java/%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/","excerpt":"","text":"比较器 Comparable Comparator 二者的选择 迭代器 概述 Iterable Iterator 比较器Comparable java.lang.Comparable源码： 123public interface Comparable&lt;T&gt; &#123; public int compareTo(T o);&#125; Comparable的实现类，其实例化对象和同类型对象比较。 其compareTo方法只有一个参数，一个和自己比较的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。 对于容器来说，在容器内部实现compareTo方法。 Comparator java.util.Comparator源码主要部分： 1234public interface Comparator&lt;T&gt;&#123; int compare(T o1, T o2); boolean equals(Object obj);&#125; Comparator的实现类，其实例化对象作为裁判。 其compare方法是两个参数，裁判来比较传入的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。 对于容器来说，在容器外部实现compare方法。 二者的选择 排序规则固定，Comparable接口。排序规则经常变化，Comparator接口。 迭代器概述​ 由于各种容器的底层实现结构（数组，链表，哈希表等）不同，把容器元素的访问逻辑从不同类型容器中抽取出来，从而避免暴露容器的内部结构，使用户对容器元素的操作更简单，即迭代器模式。 Iterable java.lang.Iteable源码： 123456789101112131415public interface Iterable&lt;T&gt; &#123; Iterator&lt;T&gt; iterator(); default void forEach(Consumer&lt;? super T&gt; action)&#123; Objects.requireNonNull(action); for (T t : this) &#123; action.accept(t); &#125; &#125; default Spliterator&lt;T&gt; spliterator() &#123; return Spliterators.spliteratorUnknownSize(iterator(), 0); &#125;&#125; Collection接口继承自Iterable接口，Iterable的作用是： 使得其所有实现成为foreach语句的目标 其iterator()方法返回一个标准的Iterator实现 Iterator java.util.Iterator源码： 12345678910111213141516public interface Iterator&lt;E&gt; &#123; boolean hasNext();//判断是否存在下一个元素 E next();//获取下一个元素 default void remove() &#123; throw new UnsupportedOperationException(\"remove\"); &#125;//移除元素 default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123; Objects.requireNonNull(action); while (hasNext()) action.accept(next()); &#125;&#125; Iterator遍历时禁止对容器进行增删的问题 ​ 使用Iterator或者foreach（foreach底层实现为Iterator）时，禁止对所遍历的容器进行改变其大小结构的操作，也即不能使用容器的add/remove方法，否则会报ConcurrentModificationException。 ​ ArrayList中Iterator实现源码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//ArrayList的内部类private class Itr implements Iterator&lt;E&gt; &#123; int cursor; // index of next element to return int lastRet = -1; // index of last element returned; -1 if no such int expectedModCount = modCount; Itr() &#123;&#125; public boolean hasNext() &#123; return cursor != size; &#125; @SuppressWarnings(\"unchecked\") public E next() &#123; checkForComodification(); int i = cursor; if (i &gt;= size) throw new NoSuchElementException(); Object[] elementData = ArrayList.this.elementData; if (i &gt;= elementData.length) throw new ConcurrentModificationException(); cursor = i + 1; return (E) elementData[lastRet = i]; &#125; public void remove() &#123; if (lastRet &lt; 0) throw new IllegalStateException(); checkForComodification(); try &#123; ArrayList.this.remove(lastRet); cursor = lastRet; lastRet = -1; expectedModCount = modCount; &#125; catch (IndexOutOfBoundsException ex) &#123; throw new ConcurrentModificationException(); &#125; &#125; @Override @SuppressWarnings(\"unchecked\") public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;//省略 &#125; final void checkForComodification() &#123; if (modCount != expectedModCount) throw new ConcurrentModificationException(); &#125; &#125; 123public Iterator&lt;E&gt; iterator() &#123; return new Itr(); &#125; ​ 由源码可知，检查并抛出异常的是checkForComodification方法，其判断条件为modCount != expectedModCount。expectedModCount是迭代器类Itr的成员变量，在迭代器对象创建时赋初值为modCount。那么modCount是什么呢？ ​ 找遍ArrayList类也没有发现modCount，那么向上找，发现其是ArrayList的父抽象类AbstractList的成员变量，其注释如下图 ​ 由注释可知，modCount的含义是list被结构性修改的次数。 ​ 由此可知，当ArrayList调用其add/remove方法时，modCount会自加，而此时迭代器中的expectedModCount未同步，因此才会导致再次调用next方法时抛出异常。如若使用ArrayList迭代器自带的remove方法，迭代器会同步更新expectedModCount的值，因此再次调用next不会报异常。 ​ 使用该机制的主要目的是为了实现ArrayList中的快速失败机制（fail-fast），在Java集合中较大一部分集合是存在快速失败机制的。 ​ 快速失败机制产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。 所以要保证在使用Iterator遍历集合的时候不出错误，就应该保证在遍历集合的过程中不会对集合产生结构上的修改。 总结：在使用迭代器时，ArrayList不能调用自身的add/remove方法。 ​ 但可以使用ArrayList的迭代器的remove方法，该方法移除迭代器返回的最后一个元素，且每调用一次next方法才能调用一次该remove方法（一对一）。 ​ 还可以使用ListIterator，它是一个更加强大的Iterator的子类型，可以使用add/remove方法。 ​ 参考：https://www.cnblogs.com/zyuze/p/7726582.html","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"Java泛型","slug":"Java泛型","date":"2020-09-04T11:06:21.000Z","updated":"2020-11-23T14:23:21.019Z","comments":true,"path":"Java/Java泛型/","link":"","permalink":"http://thmasterplan.cn/Java/Java%E6%B3%9B%E5%9E%8B/","excerpt":"","text":"概述 为什么引入泛型 泛型的基本使用 泛型类 泛型接口 泛型方法 泛型的上下限 概述 在创建接口、类、方法时，为了代码复用和类型安全，使用泛型来作为类型。泛型可以看作形式参数，用于接受数据类型，当创建对象、实现接口、调用方法时才指定具体的类型。例如 123class List&lt;T&gt;&#123; private T element; &#125; 12345678class TestList&#123; public static void main(String[] args)&#123; List&lt;String&gt; list = new List&lt;&gt;(); List&lt;Integer&gt; list = new List&lt;&gt;(); List&lt;Double&gt; list = new List&lt;&gt;(); //使用类时才指定List中元素具体的类型 &#125;&#125; Java泛型从JDK1.5引入，为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但在编译阶段会进行“类型擦除（Type Erasure）”，将所有的泛型表示都替换为具体的类型。 为什么引入泛型 为了代码复用：适用于多种数据类型执行相同的代码，例如 123private static &lt;T extends Number&gt; double add(T a, T b) &#123; return a.doubleValue() + b.doubleValue();&#125; 如果没有泛型，则对于int、float、double等类型都需要重载一个add方法。 为了类型安全：泛型类型在使用时指定，同时也就限定了集合中只能存储某一种具体类型的数据。以ArrayList为例： 12345678910111213public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123;transient Object[] elementData;//ArrayList源码中定义的元素类型为Objectpublic E get(int index) &#123; rangeCheck(index); return elementData(index); &#125;E elementData(int index) &#123; return (E) elementData[index];//强制类型转换，由Object向下转型 &#125;&#125; 由源码可知，当调用get方法获取ArrayList元素时，get方法调用elementData方法，其return时由ArrayList完成强制类型转换（向下转型）。 如若ArrayList没有泛型机制会怎么样呢？ 那么，get方法只能返回Object类型的数据，好处是程序员可以使用ArrayList存储多种类型的数据。但是坏处也显而易见，当程序员使用ArrayList存储”String”、”Integer”、”Double”等各种类型的数据时，调用get方法得到的是Object类型，此时若程序员对这些数据向下转型为某种类型（比如String，String s = (String) obj），编译期不会报错，运行期才会报ClassCastException（因为Integer、Double不能强制转换为String），也就是类型不安全。 泛型的基本使用泛型类 使用泛型类 1234567891011121314151617class A&lt;T&gt;&#123; private T element; public T getElement()&#123; retruen element; &#125; public void setElement(T elem)&#123; this.element = elem; &#125;&#125;public class TestA&#123; public static void main(String[] args)&#123; A&lt;String&gt; a = new A&lt;&gt;(); a.setElement(\"test string...\"); System.out.println(a.getElement().length()); &#125;&#125; 多元泛型 123456789101112131415class B&lt;K, V&gt;&#123; private K key; private V value; //set,get方法。。。&#125;public class TestB&#123; public static void main(String[] args)&#123; B&lt;String, Integer&gt; b = new B&lt;&gt;(); b.setKey(\"小明\"); b.setValue(\"18\"); System.out.println(\"姓名：\"+b.getKey()); System.out.println(\"年龄：\"+b.getValue()); &#125;&#125; 泛型接口1234567891011121314interface C&lt;T&gt;&#123; public T getElem();&#125;class CImpl&lt;T&gt; implements C&lt;T&gt;&#123; //....&#125;//也可在接口的实现类这一步指定具体的类型public class TestC&#123; public static void main(String[] args)&#123; C&lt;String&gt; c = new CImpl&lt;&gt;(); //... &#125;&#125; 泛型方法 格式：修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){ //方法体 }。泛型方法在调用方法时确定数据类型。 1234567891011121314class GenericMethod&#123; public &lt;T&gt; void method&lt;T t&gt;&#123; System.out.println(t); &#125;&#125;public class TestGenericMethod&#123; public static void main(String[] args)&#123; GenericMethod gm = new GenericMethod(); gm.method(\"123\"); gm.method(123); //传递什么类型的参数，泛型就是什么类型 &#125;&#125; 泛型的上下限 有时候我们希望泛型只接收某些类型，而不是所有类型，那么我们就需要限定泛型的接收范围。 &lt;?&gt;：无限制通配符，表示任意类型。 &lt;? extends E&gt;： 表示只接收E类型，或者E类型的子类。 &lt;? super E&gt;： 表示只接收E类型，或者E类型的父类。 例如：以下代码表示T类型只能是Number类或者其子类，在限定了接收类型的同时，还可以使用Number类的方法和成员变量。 123private static &lt;T extends Number&gt; double add(T a, T b) &#123; return a.doubleValue() + b.doubleValue();&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"虚拟机类加载机制","slug":"虚拟机类加载机制","date":"2020-09-03T09:22:40.000Z","updated":"2020-11-23T14:23:21.136Z","comments":true,"path":"JVM/虚拟机类加载机制/","link":"","permalink":"http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/","excerpt":"","text":"类加载过程 类加载器 类加载过程 一个Java类从编写完成到被卸载的过程：X.java -&gt; X.class（编译为磁盘中的二进制文件）-&gt; 加载（ClassLoader将X.class加载到虚拟机内存）-&gt; 连接 （确定类与类之间的关系，包含验证、准备、解析三步） -&gt; 初始化 -&gt; 使用 -&gt; 卸载。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。类加载过程如下图： 注意：类加载时不会同时加载其内部类，这点特性可以用于设计单例模式。 加载：加载是类加载的一个阶段，注意不要混淆。 加载阶段完成以下三件事： 通过一个类的全限定名来获取定义此类的二进制字节流。 将该字节流表示的静态存储结构转换为方法区的运行时数据结构。 在内存中生成一个代表该类的java.lang.Class对象，作为方法区该类的各种数据的访问入口。 二进制字节流的获取方式有： 从ZIP包读取，成为 JAR、EAR、WAR 格式的基础。 从网络获取，典型应用为Applet 运行时计算生成，比如动态代理技术，在java.lang.reflect.Proxy中使用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。 由其他文件生成，比如由JSP文件生成对应的Class类。 从数据库读取。 连接 验证：这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。 准备：在方法区中，为类的静态变量分配内存，并将其初始化为默认值（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型为null…），但是对于final修饰的常量则直接赋指定值。注意：实例变量（即未被static修饰的变量）不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，也就是类加载完成之后了。 解析：将class文件常量池的符号引用替换为直接引用的过程。 符号引用：与虚拟机的内存布局无关。可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。 直接引用：与虚拟机实现的内存布局相关。可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。 初始化：为类的静态变量赋予正确的初始值（此时才赋予程序员设定的值），并执行静态代码块。 Java程序对类的使用方式可分为两种：主动引用与被动引用。每个类（接口）只有被Java程序“首次主动引用”时才初始化。包括： 使用new实例化该类对象。 读取或设置一个类（接口）的静态字段，以及调用一个类（接口）的静态方法。注：被final修饰的静态字段除外。 使用java.lang.reflect包的方法对类进行反射调用。 初始化某类的子类（先初始化父类）。 带main方法的类。 JDK1.7开始提供的动态语言支持 *。 被动引用例子： 通过子类引用父类的静态字段，不会导致子类初始化。 1System.out.println(SubClass.value);&#x2F;&#x2F;value字段在SuperClass中为静态字段 通过数组定义来引用类，不会触发被引用类的初始化。但是该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。 1SuperClass[] array &#x3D; new SuperClass[10]; 常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。 1System.out.println(ConstClass.HELLOWORLD); 类加载器 类与类加载器：加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作在虚拟机外部实现，由类加载器实现。我们可以通过自定义类加载器去控制字节流的获取方式。注意：数组类不通过类加载器创建，它由JVM直接创建。 HotSpot VM内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自java.lang.ClassLoader： BootstrapClassLoader(启动类加载器) ：最顶层的加载类，由C++实现，负责加载 %JAVA_HOME%/lib目录下的jar包和类或者或被 -Xbootclasspath参数指定的路径中的所有类。 ExtensionClassLoader(扩展类加载器) ：主要负责加载目录 %JRE_HOME%/lib/ext 目录下的jar包和类，或被 java.ext.dirs 系统变量所指定的路径下的jar包。 AppClassLoader(应用程序类加载器) :面向用户的加载器，负责加载当前应用classpath下的所有jar包和类。 双亲委派模型：每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 双亲委派模型 。即在类加载的时候： 系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。 加载的时候，首先会把该请求委派该父类加载器的 loadClass() 处理，因此所有的请求最终都应该传送到顶层的启动类加载器 BootstrapClassLoader 中。 当父类加载器无法处理时，才由自己来处理。当父类加载器为null(null代表启动类加载器)时，会使用启动类加载器 BootstrapClassLoader 作为父类加载器。 以上的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。 使用如下代码来验证双亲委派模型： 1234567public class ClassLoaderDemo &#123; public static void main(String[] args) &#123; System.out.println(\"ClassLodarDemo's ClassLoader is \" + ClassLoaderDemo.class.getClassLoader()); System.out.println(\"The Parent of ClassLodarDemo's ClassLoader is \" + ClassLoaderDemo.class.getClassLoader().getParent()); System.out.println(\"The GrandParent of ClassLodarDemo's ClassLoader is \" + ClassLoaderDemo.class.getClassLoader().getParent().getParent()); &#125;&#125; 控制台输出为： 123ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2The Parent of ClassLodarDemo&#39;s ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586The GrandParent of ClassLodarDemo&#39;s ClassLoader is null 双亲委派模型的好处：双亲委派模型保证了Java程序的稳定运行，可以避免类的重复加载（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也保证了 Java 的核心 API 不被篡改。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 java.lang.Object 类的话，那么程序运行的时候，系统就会出现多个不同的 Object 类。 破坏双亲委派模型：自定义类加载器，需要继承ClassLoader。如果不想打破双亲委派模型，就重写 ClassLoader 类中的 findClass() 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载；如果想打破双亲委派模型则需要重写 loadClass() 方法。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"GC与内存分配策略","slug":"GC与内存分配策略","date":"2020-09-02T07:17:43.000Z","updated":"2020-11-23T14:23:21.000Z","comments":true,"path":"JVM/GC与内存分配策略/","link":"","permalink":"http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/","excerpt":"","text":"对象已死吗（GC回收的前提是判断对象已死） 垃圾收集算法 垃圾收集器 内存分配与回收策略 GC的触发条件 对象已死吗（GC回收的前提是判断对象已死） 概述：对于程序计数器、虚拟机栈、本地方法栈，其内存区域和回收都具备确定性，方法结束或线程结束时，其内存自然就回收了。GC主要关注堆和方法区的分配与回收。 引用计数算法（不常用）：给对象添加一个引用计数器，每当被引用时，计数器值+1；引用失效（引用不再指向该对象）时，计数器值-1。任何时刻计数器为0的对象就是不可能再被使用的。缺点：难以解决对象之间相互循环使用的问题。（比如对象A中的引用指向B，对象B中的引用指向A，对象A、B计数器永远为1） 可达性分析算法（主流实现）：通过一系列的称为“GC Roots”的对象作为起始点向下搜索，搜索走过的路径称为“引用链”，当一个对象到“GC Roots”没有任何引用链相连，即证明对象不可达。 可作为GC Roots的对象包括： 虚拟机栈：栈帧中局部变量表中引用的对象 方法区： 类静态变量引用的对象 常量引用的对象 本地方法栈：JNI引用的对象 再谈引用：JDK1.2之后，引用概念分为以下4种，强度依次减弱 强引用：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。 软引用：描述有用但非必须的对象，当系统将要发生OOM异常时，软引用指向的对象才被真正回收。通过SoftReference类实现。 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。 虚引用：为一个对象设置虚引用关联的唯一目的时能在对象被回收时收到一个系统通知。通过PhantomReference类实现。 生存还是死亡：即使在可达性分析算法中不可达的对象，在该对象的finalize()方法中也有一次自救的方法，即重新与引用链上的任何一个对象建立关联即可，譬如把this赋值给某个类变量或者对象的成员变量。但是，建议使用try-finally语法而尽量不使用finally()方法。 回收方法区：主要回收废弃常量和无用的类。废弃常量的回收与堆中的对象类似，而无用类的判定则要复杂的多，需要满足： 堆中不存在该类的实例 ClassLoader已被回收 Class对象没有被引用，且无法在任何地方通过反射访问该类的方法。 是否对类进行回收，HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose:class以及-XX:+TraceClassLoading、-XX:+TraceClassUnLoading查看类加载和卸载信息。 注：对于大量使用反射、动态代理、CGLib等ByteCode框架的场景，要注意方法区的类卸载。 垃圾收集算法 标记-清除算法：标记回收对象，标记完成后统一回收。 缺点：标记和清除效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。 标记-整理算法：标记回收对象，让所有存活的对象向一端移动，然后直接清理掉对象所在的连续内存后的所有内存。 特点：适用于老年代的算法，不会产生内存碎片。 复制算法：对于现在的商业虚拟机，堆内存被划分为三块，一块较大的Eden空间、两块较小的Survivor空间。 当Eden空间满时，第一次Minor-GC（针对新生代的GC）将Eden还存活的对象全部复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden； 当Eden满时，第二次Minor-GC将Eden和Survivor-0中还存活的对象复制到Survivor-1中，存活对象“寿命计数器”+1，清理Eden和Survivor-0； 当Eden满时，第三次Minor-GC将Eden和Survivor-1中还存活的对象复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden和Survivor-1； ……. 如此往复，当某个Survivor满或者对象“寿命计数器”值达到阈值，则将对象复制到老年代中。 当老年代和新生代都满时，会进行一次Full-GC。 HotSpot虚拟机的Eden和Survivor大小默认比例为8:1，保证了内存利用率达到90%。 分代收集算法：现在的商业虚拟机采用分代收集算法。 新生代：由于每次GC时都有绝大部分对象死去，只有少量对象存活，故采用复制算法，因为只需要付出少量存活对象的复制成本。 老年代：由于老年代对象存活率高且没有额外空间对它分配担保，故采用标记-整理算法或标记-清除算法。 垃圾收集器 以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器之间可以搭配使用。 Serial收集器：单线程；简单高效，拥有最高的单线程收集效率；Client场景下的默认新生代收集器。 ParNew收集器：Serial的多线程版本；Server场景下默认的新生代收集器；唯一能与CMS收集器配合使用的收集器。 Parallel Scavenge收集器：多线程，吞吐量（CPU运行用户代码的时间除以CPU总消耗时间）优先的收集器。 Serial Old收集器：Serial的老年代版本，Client场景使用。 Parallel Old收集器：Parallel Scavenge的老年代版本 CMS(Concurrent Mark Sweep)收集器：以获取最短回收停顿时间为目标，基于标记-清除算法。分为四个阶段： 初始标记：只标记与GC Roots直接关联的对象，需要Stop The World。 并发标记：进行 GC Roots Tracing，耗时最长，不需要停顿。 重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要Stop The World。 并发清除：不需要停顿。 缺点明显： CPU资源敏感：CMS默认启动的回收线程数是（CPU数+3）/4，当CPU数较少时，吞吐量很低。 无法处理浮动垃圾：浮动垃圾是指并发清除阶段由于用户线程继续运行而产生的垃圾，这部分垃圾只能下一次GC清除。 标记-清除算法会产生大量空间碎片。 总体上来说，CMS的垃圾回收过程是与用户线程一起并发执行的。 G1(Garbage First)收集器：面向服务端应用。 使用G1时，Java堆内存布局与以往不同，它将整个Java堆划分为多个大小相等的独立Region，新生代与老年代是一部分不连续Region的集合，如图： G1通过记录每个Region垃圾回收时间和回收所得空间（这两个值通过过去回收的经验计算），并维护一个优先列表，每次根据用户允许的收集时间，优先回收价值最大的Region。使用Region划分内存空间，有优先级的区域回收方式，保证了G1在有限的时间内获取尽可能高的收集效率。 每个Region都维护一个Remembered Set，用于记录Region之间的对象引用，来避免GC时的全堆扫描。（其他收集器新生代与老年代之间的对象引用也是使用Remembered Set，避免Minor-GC时全堆扫描）。 如不计算维护Remembered Set的操作，G1的运作可划分如下： 初始标记：停顿。 并发标记 最终标记：停顿。为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。 筛选回收：根据用户允许的收集时间和优先列表来回收。 总结G1的特点如下： 并行与并发：G1在多CPU和大内存的硬件优势下能有效缩短Stop-The-World的时间。 分代收集：新生代和老年代可以一起回收。 空间整合：整体上看基于“标记-整理”算法，局部上看基于“复制”算法。不会产生内存碎片。 可预测的停顿：能让用户自定义在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。 垃圾收集器参数总结 内存分配与回收策略 对象优先在Eden分配 大对象直接进入老年代：大对象是指需要连续内存空间的对象，最典型的大对象是那种很长的字符串以及数组。 经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。 通过参数-XX:PretenureSizeThreshold，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。 长期存活的对象将进入老年代：通过参数-XX:MaxTenuringThreshold用来定义年龄的阈值。 动态对象年龄判定：虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。 空间分配担保：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。 GC的触发条件 对于Minor GC，其触发条件为Eden区满时。而对于Full GC: 调用System.gc()。 老年代空间不足。 空间分配担保失败。 Concurrent Mode Failure。 减少Full GC的方法： 尽量不要创建大对象和数组。 通过-Xmn调大新生代大小。 通过-XX:MaxTenuringThreshold调大进入老年代的阈值。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"Java内存区域与内存溢出异常","slug":"Java内存区域与内存溢出异常","date":"2020-08-23T03:24:45.000Z","updated":"2021-01-06T10:22:31.384Z","comments":true,"path":"JVM/Java内存区域与内存溢出异常/","link":"","permalink":"http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/","excerpt":"","text":"运行时数据区域 直接内存 HotSpot对象 对象创建流程 对象的内存布局 常见的VM堆栈参数 常见的OOM原因 堆 方法区 运行时数据区域​ 线程私有：与线程生命周期相同 程序计数器（Program Counter Register）：记住下一条JVM字节码指令的地址。每条线程都有一个独立的PCR。此内存区域是唯一一个在JVM规范中没有任何OOM情况的区域。 Java虚拟机栈：描述Java方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈等。每个方法从调用到执行完毕，对应一个栈帧从入栈到出栈的过程。 局部变量表存放编译期可知的各种基本数据类型和引用。 JVM规范定义了该区域两种异常情况： 线程请求的栈深度大于VM允许的深度，将抛出StackOverflowError异常。 若虚拟机栈可动态扩展，且扩展时无法申请到足够的内存，将抛出OOM异常。 本地方法栈：与虚拟机栈的区别在于，虚拟机栈为VM执行Java方法服务，而本地方法栈为VM使用到的本地方法服务。 异常情况同虚拟机栈。 线程共享：VM启动时创建 堆：用于存放对象实例和数组。 Java堆是GC管理的主要区域。 扩：随着JIT（Just in Time）技术与逃逸分析技术逐渐成熟，所有对象都分配在堆上并不绝对了。 ​ 热代码：频繁调用的字节码。 ​ [https://developer.ibm.com/zh/articles/j-lo-just-in-time/#] 方法区：存储已被VM加载的类信息（变量和方法数据，方法和构造器的字节码等）、运行时常量池、JIT编译后的机器码等。 许多主流框架都会用到CGLib或者JDK动态代理，动态生成大量Class容易导致方法区OOM异常。 三种常量池区分 class文件常量池：编译阶段，存放编译期生成的字面量（常量值）和符号引用，其中符号引用包括类名、方法名、参数类型等信息。javap -v Main.class反编译如下代码： 12345678public class Main &#123; final String stest &#x3D; &quot;String Test ...&quot;; public static void main(String[] args) &#123; System.out.println(&quot;helloworld&quot;); &#125; &#125; 结果如下： 字符串常量池-StringTable: 在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（可理解为内存地址，而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。注意：对于new的String对象，若在类中new，则其引用变量存于方法区；若在方法中new，则其引用在虚拟机栈的栈帧的局部变量表中。 运行时常量池：类加载完成之后，编译期生成的非字符串类型常量和符号引用进入运行时常量池，由符号引用翻译而来的直接引用也会存入运行时常量池。 直接内存 直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也会频繁使用，可能导致OOM异常。 JDK1.4中加入了NIO类（New Input/Output），引入了一种基于Channel与Buffer的I/O方式，它可以使用本地函数库直接分配堆外内存，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。 HotSpot对象对象创建流程 类加载检查：虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 分配内存：分配方式有 “指针碰撞” 和 “空闲列表” 两种，选择那种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。采用指针碰撞时的GC有Serial、ParNew等，采用空闲列表时的GC有CMS。 初始化零值：内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。 设置对象头信息：初始化零值完成之后，虚拟机要对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 这些信息存放在对象头中。 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。 执行init方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。 对象的内存布局 对象头：Hotspot 虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的自身运行时数据（哈希码、GC 分代年龄、锁状态标志等等），另一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。 实例数据：实例数据部分是对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。 对齐填充：对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。 常见的VM堆栈参数 -Xms: 设置堆的最小值，如-Xms20m -Xmx: 设置堆的最大值，如-Xmx20m -Xmn: 设置堆新生代值 -Xss: 设置虚拟机栈容量 -Xoss: 设置本地方法栈容量（HotSpot的虚拟机栈和本地方法栈仅由-Xss决定） -XX:Permsize=10M: 设置方法区大小为10M -XX:MaxDirectMemorySize=10M: 设置本机直接内存大小为10M 常见的OOM原因 堆堆内存没有足够空间存放新创建的对象。常见异常：java.lang.OutOfMemoryError:Javaheap space; java.lang.OutOfMemoryError:GC overhead limit exceeded 常见原因： 创建了一个超大对象，比如大数组 超出预期的访问量/数据量，通常是上游系统请求流量飙升，常见于各类促销/秒杀活动，可以结合业务流量指标排查是否有尖状峰值。 过度使用终结器（Finalizer），该对象没有立即被 GC。重写了finalize()方法的对象不会被立即GC。 内存泄漏（Memory Leak），大量对象引用没有释放，JVM 无法对其自动回收，常见于使用了 File 等资源没有回收。 解决方案：针对大部分情况，通常只需要通过 -Xmx 参数调高 JVM 堆内存空间即可。如果仍然没有解决，可以参考以下情况做进一步处理： 如果是超大对象，可以检查其合理性，比如是否一次性查询了数据库全部结果，而没有做结果数限制。 如果是业务峰值压力，可以考虑添加机器资源，或者做限流降级。 如果是内存泄漏，需要找到持有的对象，修改代码设计，比如关闭没有释放的连接。 方法区常见原因：对象数组和类型数组所关联的class太多。 解决方案： 修改 -XX:MaxPermSize 启动参数，调大永久代空间。 设置 -XX:+CMSClassUnloadingEnabled 和 -XX:+UseConcMarkSweepGC这两个参数允许 JVM 卸载 class。 JDK 1.8 使用 Metaspace 替换了永久代（Permanent Generation），调整 Metaspace 空间大小的启动参数为 -XX:MaxMetaspaceSize。 其他OOM原因参考：https://zhuanlan.zhihu.com/p/79355050","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"SpringAOP","slug":"SpringAOP","date":"2020-04-23T08:36:02.000Z","updated":"2020-11-23T14:23:21.084Z","comments":true,"path":"JavaWeb/SpringAOP/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/SpringAOP/","excerpt":"","text":"AOP概述 SpringAOP AOP相关概念 连接点（Joinpoint） 切入点（Pointcut） 通知/增强（Advice） 引介（Introduction） 目标对象（Target） 织入（Weaving） 代理（Proxy） 切面（Aspect） SpringAOP编程流程 基于XML的AOP配置 一个简单案例 配置通知 前置通知 后置通知 异常通知 最终通知 环绕通知 切入点表达式 基于注解的AOP配置 AOP实现事务控制 SpringAOP Doc AOP概述AOP为Aspect Oriented Programming的缩写，意为：面向切面编程，通过预编译方式和运行期间动态代理实现程序功能的统一维护的一种技术。利用AOP可以对业务逻辑的各个部分进行隔离，从而使得业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高了开发的效率。 SpringAOPSpring中的AOP是通过配置的方式实现的。 AOP相关概念连接点（Joinpoint）指被拦截到的点。在Spring中，这些点指的是方法，因为Spring只支持方法类型的连接点。 例如：业务层接口中的所有方法都是连接点，JDK动态代理中InvocationHandler的invoke方法具有拦截的功能，能拦截被代理对象中的所有方法，使得代理对象中实现的事务控制与被代理对象（业务层实现类对象）中的业务成为一个完整的业务逻辑，参见该例。 切入点（Pointcut）Joinpoint只是一定会被拦截到的点，不一定会运行增强代码，而Pointcut一定属于Joinpoint，并且一定会运行增强代码。 例如，业务层接口中有些方法是Pointcut，在InvocationHandler的invoke方法中，在增强代码之前加入如下代码： 12345678910public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; if(\"接口中的某个方法名\".equals(method.getName))&#123;//接口中的该方法是Joinpoint，不是Pointcut return method.invoke(被代理对象, args); &#125; Object returnValue = null; 增强代码 returnValue = method.invoke(被代理对象,args);//切入点 增强代码 return returnValue;&#125; 通知/增强（Advice）拦截到Joinpoint后要进行的操作（增强代码）。通知的类型有前置通知、后置通知、异常通知、最终通知、环绕通知。 1234567891011121314151617环绕通知指以下整个invoke方法的执行public Object invoke(Object proxy, Method method, Object[] args) throws Throwable&#123; if(\"接口中的某个方法名\".equals(method.getName))&#123; return method.invoke(被代理对象, args); &#125; Object returnValue = null; try&#123; 增强代码(前置通知) returnValue = method.invoke(被代理对象,args);//明确的切入点方法调用 增强代码(后置通知) return returnValue; &#125;catch(Exception e)&#123; 增强代码(异常通知) &#125;finally&#123; 增强代码(最终通知) &#125;&#125; 引介（Introduction）一种特殊的通知，在不修改类代码的前提下，引介可以在运行期为类动态地添加一些方法或Field。 目标对象（Target）被代理对象。 织入（Weaving）指把增强应用到目标对象来创建代理对象的过程。Spring采用动态代理织入，AspectJ采用编译期织入和类加载阶段织入。 代理（Proxy）一个类被AOP织入增强后，得到一个结果代理类。 切面（Aspect）切入点和通知（引介）的结合。 SpringAOP编程流程 编写核心业务代码。 将公用代码抽取出来制作成通知。 在配置文件中声明切入点与通知间的关系，即切面。 在代码运行阶段，Spring框架监控切入点方法的执行。一旦监控到切入点方法将被运行，则使用代理机制动态创建目标对象的代理对象，根据通知类别在代理对象的对应位置，将通知对应的功能织入，完成完整的代码逻辑后运行。 基于XML的AOP配置一个简单案例1234567891011121314151617181920212223package com.itheima.service;/** * 模拟账户操作 */public interface IAccountService &#123; /** * 无返回值，无参数 */ void saveAccount(); /** * 无返回值，有参数 * @param i */ void updateAccount(int i); /** * 有返回值，无参数 * @return */ int deleteAccount();&#125; 123456789101112131415161718192021package com.itheima.service.impl;import com.itheima.service.IAccountService;public class AccountServiceImpl implements IAccountService &#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存!\"); &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i+\"!\"); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除！\"); return 0; &#125;&#125; 12345678910111213package com.itheima.utils;/** * 用于记录日志的工具类，提供了公共的代码，也就是通知类 */public class Logger &#123; /** * 通知方法：用于打印日志，计划让其在切入点方法执行之前执行，切入点方法就是业务层方法 */ public void printLog()&#123; System.out.println(\"printLog方法开始记录日志！\"); &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd\"&gt; &lt;!--创建accountService对象并存入IOC容器--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt; &lt;!--基于xml的AOP配置步骤 1.创建通知bean对象并存入IOC容器 2.使用aop:config标签表明开始AOP配置 proxy-target-class属性：\"true\"则表明使用CGLib，默认使用JDK动态代理 3.使用aop:aspect标签表明开始配置切面 id属性：切面的唯一标识 ref属性：指定通知类bean的id 4.aop:aspect标签的内部使用对应子标签来配置通知的类型 aop:before：表示前置通知 method属性：指定通知类中哪个方法是前置通知 pointcut属性：指定切入点表达式，也即指定切入点方法是哪一个，切入点表达式的写法： 关键字：execution(表达式) 表达式：访问修饰符 返回值类型 全类名.方法名(参数列表) --&gt; &lt;!--配置Logger通知类--&gt; &lt;bean id=\"logger\" class=\"com.itheima.utils.Logger\"&gt;&lt;/bean&gt; &lt;!--配置AOP--&gt; &lt;aop:config&gt; &lt;!--配置切面--&gt; &lt;aop:aspect id=\"logAdvice\" ref=\"logger\"&gt; &lt;!--配置通知的类型，并建立通知方法与切入点方法的关联--&gt; &lt;aop:before method=\"printLog\" pointcut=\"execution(* com.itheima.service.impl.*.*(..))\"&gt;&lt;/aop:before&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt;&lt;/beans&gt; 123456&lt;!--该依赖负责解析切入点表达式--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; 12345678910111213package com.itheima.test;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean.xml\"); IAccountService accountService = (IAccountService)applicationContext.getBean(\"accountService\"); accountService.saveAccount(); &#125;&#125; 配置通知前置通知在切入点方法之前执行。 1&lt;aop:before method=\"前置通知方法\" pointcut=\"execution(切入点表达式)\"&gt;&lt;/aop:before&gt; 后置通知切入点方法正常执行之后执行。 1&lt;aop:after-returning method=\"后置通知方法\" pointcut=\"execution(切入点表达式)\"&gt;&lt;/aop:after-returning&gt; 异常通知切入点方法产生异常之后执行。 1&lt;aop:after-throwing method=\"异常通知方法\" pointcut=\"execution(切入点表达式)\"&gt;&lt;/aop:after-throwing&gt; 最终通知最后执行且一定会执行。 1&lt;aop:after method=\"最终通知方法\" pointcut=\"execution(切入点表达式)\"&gt;&lt;/aop:after&gt; 环绕通知若只配置以下代码，我们会发现切入点方法并没有执行，而环绕通知方法执行了。 1&lt;aop:around method=\"环绕通知方法\" pointcut=\"execution(切入点表达式)\"&gt;&lt;/aop:around&gt; 通过对比JDK动态代理中的环绕通知代码，发现其有明确的切入点方法调用，因此环绕通知方法中应按照如下配置： 12345678910111213141516171819/** * Spring提供了接口ProceedingJoinPoint，它提供了方法proceed()，相当于明确调用切入点方法 * 该接口可作为环绕通知方法的参数，在程序执行时，Spring会自动提供该接口的实现类对象 */public Object aroundAdvice(ProceedingJoinPoint pjp)&#123; Object returnValue; try&#123; Object[] args = pjp.getArgs(); //前置通知代码 returnValue = pjp.proceed(args);//调用切入点方法 //后置通知代码t return returnValue; &#125;catch(Throwable t)&#123; //异常通知代码 throw new RuntimeException(t); &#125;finally&#123; //最终通知代码 &#125;&#125; 环绕通知实际上就是将通知代码和切入点方法耦合在一起，而不是使用配置的方式。 切入点表达式表达式形式：访问修饰符 返回值类型 全类名.方法名(参数列表) 1234567891011121314151.标准的表达式写法：public void com.itheima.service.impl.AccountServiceImpl.saveAccount()2.访问修饰符可省略3.返回值类型可使用通配符‘*’，表示任意返回值4.包名可以使用通配符‘*’，表示任意包，有几个包就写几个‘*.’ 例：* *.*.*.*.AccountServiceImpl.saveAccount() 包名可以使用&#39;..&#39;表示当前包及其子包 例：* *..AccountServiceImpl.saveAccount()5.类名与方法名也可以使用通配符&#39;*&#39; 例：* *..*.*()6.参数列表：写数据类型 例：* *..*.*(int) 可以使用通配符&#39;*&#39;表示任意类型，前提是切入点方法必须有参数 可以使用&#39;..&#39;作为表达式参数列表，不管切入点方法有无参数都可匹配7.实际开发中切入点表达式的通常写法：业务层下的所有方法都作为切入点 * com.itheima.service.impl.*.*(..) 也可使用在标签aop:pointcut中配置切入点表达式： 1&lt;aop:pointcut id=\"pt\" expression=\"execution(切入点表达式)\"&gt;&lt;/aop:pointcut&gt; 同时通知写法改为： 1&lt;aop:before method=\"前置通知方法\" pointcut-ref=\"pt\"&gt;&lt;/aop:before&gt; aop:pointcut标签在aop:aspect标签之前，则所有切面都适用该切入点； aop:pointcut标签在aop:aspect标签之内，则只有当前切面适用该切入点。 基于注解的AOP配置1234567891011121314151617181920212223package com.itheima.service;/** * 模拟账户操作 */public interface IAccountService &#123; /** * 无返回值，无参数 */ void saveAccount(); /** * 无返回值，有参数 * @param i */ void updateAccount(int i); /** * 有返回值，无参数 * @return */ int deleteAccount();&#125; 1234567891011121314151617181920212223package com.itheima.service.impl;import com.itheima.service.IAccountService;import org.springframework.stereotype.Service;@Service(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Override public void saveAccount() &#123; System.out.println(\"执行了保存!\"); &#125; @Override public void updateAccount(int i) &#123; System.out.println(\"执行了更新\"+i+\"!\"); &#125; @Override public int deleteAccount() &#123; System.out.println(\"执行了删除！\"); return 0; &#125;&#125; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253package com.itheima.utils;import org.aspectj.lang.ProceedingJoinPoint;import org.aspectj.lang.annotation.*;import org.springframework.stereotype.Component;/** * 用于记录日志的工具类，提供了公共的代码，也就是通知 */@Component(\"logger\")@Aspect//表示当前类是一个切面类public class Logger &#123; @Pointcut(\"execution(* com.itheima.service.impl.*.*(..))\") private void pt()&#123;&#125; /** * 通知方法：用于打印日志，计划让其在切入点方法执行之前执行，切入点方法就是业务层方法 */ @Before(\"pt()\") public void beforePrintLog()&#123; System.out.println(\"前置通知-记录日志\"); &#125; @AfterReturning(\"pt()\") public void afterReturningPrintLog()&#123; System.out.println(\"后置通知-记录日志\"); &#125; @AfterThrowing(\"pt()\") public void afterThrowingPrintLog()&#123; System.out.println(\"异常通知-记录日志\"); &#125; @After(\"pt()\") public void afterPrintLog()&#123; System.out.println(\"最终通知-记录日志\"); &#125; //@Around(\"pt()\") public Object aroundAdvice(ProceedingJoinPoint pjp)&#123; Object returnValue; try&#123; Object[] args = pjp.getArgs(); //前置通知代码 returnValue = pjp.proceed(args);//调用切入点方法 //后置通知代码 return returnValue; &#125;catch(Throwable t)&#123; //异常通知代码 throw new RuntimeException(t); &#125;finally&#123; //最终通知代码 &#125; &#125;&#125; 123456789101112131415package com.itheima.test;import com.itheima.service.IAccountService;import org.springframework.context.ApplicationContext;import org.springframework.context.support.ClassPathXmlApplicationContext;public class AOPTest &#123; public static void main(String[] args) &#123; ApplicationContext applicationContext = new ClassPathXmlApplicationContext(\"bean.xml\"); IAccountService accountService = (IAccountService)applicationContext.getBean(\"accountService\"); accountService.saveAccount(); accountService.updateAccount(1); accountService.deleteAccount(); &#125;&#125; 123456789101112131415161718&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:aop=\"http://www.springframework.org/schema/aop\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/aop https://www.springframework.org/schema/aop/spring-aop.xsd http://www.springframework.org/schema/context http://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--配置Spring创建容器时要扫描的包--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt; &lt;!--配置Spring开启注解AOP的支持--&gt; &lt;aop:aspectj-autoproxy&gt;&lt;/aop:aspectj-autoproxy&gt;&lt;/beans&gt; 123456789101112131415161718192021222324252627&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;aopAnnotationDemo&lt;/artifactId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-context&lt;/artifactId&gt; &lt;version&gt;5.2.7.RELEASE&lt;/version&gt; &lt;/dependency&gt; &lt;!--该依赖负责解析切入点表达式--&gt; &lt;dependency&gt; &lt;groupId&gt;org.aspectj&lt;/groupId&gt; &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt; &lt;version&gt;1.8.7&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt;&lt;/project&gt; 完全使用注解，不使用bean.xml： 1234@Configuration@ComponentScan(basePackages=\"com.itheima\")@EnableAspectJAutoProxypublic class SpringConfiguration&#123;&#125; AOP实现事务控制在该案例的基础上，删除其生产事务控制代理对象的工厂类，转而在bean.xml文件中使用AOP配置实现事务。添加如下代码即可： 123456789&lt;aop:config&gt; &lt;aop:pointcut id=\"pt\" expression=\"execution(* *..*.*(..))\"/&gt; &lt;aop:aspect id=\"transactionAdvice\" ref=\"transactionManager\"&gt; &lt;aop:before method=\"beginTransaction\" pointcut-ref=\"pt\"&gt;&lt;/aop:before&gt; &lt;aop:after-returning method=\"commit\" pointcut-ref=\"pt\"&gt;&lt;/aop:after-returning&gt; &lt;aop:after-throwing method=\"rollBack\" pointcut-ref=\"pt\"&gt;&lt;/aop:after-throwing&gt; &lt;aop:after method=\"release\" pointcut-ref=\"pt\"&gt;&lt;/aop:after&gt; &lt;/aop:aspect&gt; &lt;/aop:config&gt; SpringAOP Doc 原理：https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop APIs：https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#aop-api","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"SpringIOC","slug":"SpringIOC","date":"2020-04-14T13:36:18.000Z","updated":"2021-01-22T11:58:21.641Z","comments":true,"path":"JavaWeb/SpringIOC/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/SpringIOC/","excerpt":"","text":"Spring概述 耦合度 概念 从高到低耦合可分为 需要低耦合的原因 降低耦合度的方法 工厂模式解耦例子 持久层 业务层 表现层 bean.properties配置文件 BeanFactory 控制反转Inversion of Control(IOC)) 概念与作用 基于XML的IoC配置 基于注解的IoC配置 IoC案例 SpringIoC Doc Spring概述Spring以IOC(Inversion of Control)和AOP(Aspect Oriented Programming)为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。 耦合度概念模块（类）之间的关联、依赖的程度，是衡量代码独立性的一个指标，也是软件工程设计及编码质量评价的一个标准。耦合的程度依赖于以下几个因素： 模块间的调用 模块间传递的数据量 一个模块施加到另一个模块的控制的多少 模块间接口的复杂程度 从高到低耦合可分为 内容耦合：一个模块直接修改或操作另一个模块的数据，或者直接传入另一个模块时，就发生了内容耦合。例如，类与类之间直接调用或继承关系都属于这种耦合。 公共耦合：多个模块共同引用一个全局数据项。 控制耦合：一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。 标记耦合：模块间通过参数传递复杂的内部数据结构。 数据耦合：模块间通过参数传递基本类型的数据。 需要低耦合的原因在耦合度很高的情况下，维护代码时修改一个地方会牵连到很多地方，难以厘清，可谓是牵一发而动全身。 降低耦合度的方法 少用继承，多用接口。 模块的功能划分尽可能的单一（高内聚）。 遵循一个定义只在一个地方出现。 少使用全局变量。 类成员变量和方法少用public，多用private。 多使用设计模式，比如使用MVC设计模式就可以降低界面与业务逻辑的耦合度。 如果模块间必须存在耦合，尽量使用数据耦合。例如使用配置文件或注解传递参数，使用反射创建对象等都属于数据耦合。 工厂模式解耦例子持久层123456/** * 账户的持久层接口 */public interface IAccountDao &#123; void saveAccount();&#125; 12345678/** * 持久层实现类 */public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(\"账户已经保存！\"); &#125;&#125; 业务层123456789/** * 账户业务层的接口 */public interface IAccountService &#123; /** * 模拟保存账户 */ void saveAccount();&#125; 1234567891011/** * 业务层实现类 */public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao = (IAccountDao) BeanFactory.getBean(\"accountDao\"); public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 表现层123456789/** * 模拟表现层调用业务层，实际开发中类似Servlet */public class Client &#123; public static void main(String[] args) &#123; IAccountService as = (IAccountService) BeanFactory.getBean(\"accountService\"); as.saveAccount(); &#125;&#125; bean.properties配置文件12accountService&#x3D;com.itheima.service.impl.AccountServiceImplaccountDao&#x3D;com.itheima.dao.impl.AccountDaoImpl BeanFactory123456789101112131415161718192021222324252627282930313233343536373839404142434445464748/** * 一个创建Bean对象的工厂 * Bean: 可重用组件，例如在Java中JavaBean有实体类、service和dao对象等 * POJO: 简单实体类 * 工厂模式解耦：使用配置文件或注解传递参数，使用反射创建对象。 */public class BeanFactory &#123; //定义一个Properties对象 private static Properties props; //定义Map存储bean对象，避免多实例降低效率（即避免每次调用getBean方法都要重新创建对象） private static Map&lt;String, Object&gt; beansMap; //初始化 static&#123; props = new Properties(); try &#123; //获取properties文件的流对象并加载 props.load(BeanFactory.class.getClassLoader().getResourceAsStream(\"bean.properties\")); &#125; catch (Exception e) &#123; e.printStackTrace(); throw new ExceptionInInitializerError(\"初始化properties失败\"); &#125; beansMap = new HashMap&lt;&gt;(); Enumeration keys = props.keys(); //遍历properties中的每个key，创建对应的实例并存入beansMap中 while(keys.hasMoreElements())&#123; String beanName = keys.nextElement().toString(); String beanPath = props.getProperty(beanName); Object bean = null; try &#123; bean = Class.forName(beanPath).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; beansMap.put(beanName, bean); &#125; &#125; /** * 根据bean的名称获取bean对象 * @param beanName * @return bean对象 */ public static Object getBean(String beanName)&#123; return beansMap.get(beanName); &#125;&#125; 控制反转Inversion of Control(IOC)概念与作用控制反转把创建对象的权力交给框架，它包括依赖注入(Dependency Injection)与依赖查找(Dependency Lookup)两部分。其作用在于降低程序的耦合度。 基于XML的IoC配置 bean.xml示例 12345678&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd\"&gt; &lt;!--将对象的创建交给spring管理--&gt; &lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt;&lt;/bean&gt;&lt;/beans&gt; ApplicationContext的三个常用实现类（bean对象核心容器） ClassPathXmlApplicationContext：加载类路径下的配置文件 FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件（必须有目录权限） AnnotationConfigApplicationContext：读取注解 IOC容器是一个map结构，key是bean标签中的id，value是bean标签中的class指定的类的对象。 核心容器的两个接口引发的问题 ApplicationContext（常用）：单例对象适用。创建核心容器时，创建对象的策略为立即加载。只要一读取完配置文件就立马创建bean对象。 BeanFactory（ApplicationContext父接口的父接口）：多例对象适用。创建核心容器时，创建对象的策略为延迟加载。也即，何时调用获取bean对象的方法，那时才创建对象。 Spring对bean对象的管理细节 创建bean对象的三种方式 使用默认构造函数创建：在spring的xml配置文件中使用bean标签，配置id和class属性后，且没有其他属性和标签时，采用的是默认构造函数创建bean对象(反射中的newInstance方法使用默认构造创建对象)，如果类没有默认构造函数则无法创建对象。 使用普通类(工厂)中的方法创建对象并存入spring容器(比如jar包中的类)： 12345678/** * 模拟一个工厂类（该类可能是存在于jar包中的，我们无法通过修改源码的方式来提供默认构造函数） */public class InstanceFactory&#123; public IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 1234&lt;!--创建实例工厂对象--&gt;&lt;bean id=\"instanceFactory\" class=\"com.itheima.factory.InstanceFactory\"&gt;&lt;/bean&gt; &lt;!--通过指定实例工厂对象的方法，创建指定对象--&gt;&lt;bean id=\"accountService\" factory-bean=\"instanceFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; 使用工厂中的静态方法创建对象并存入容器(比如jar包中的类)： 12345public class StaticFactory&#123; public static IAccountService getAccountService()&#123; return new AccountServiceImpl(); &#125;&#125; 12&lt;!--通过指定工厂类的静态方法创建对象--&gt;&lt;bean id=\"accountService\" class=\"com.itheima.factory.StaticFactory\" factory-method=\"getAccountService\"&gt;&lt;/bean&gt; bean对象的作用范围：bean标签scope属性，取值为以下 singleton：单例（默认的，不管new多少次，内存中只有一个实例对象） prototype：多例 request：作用于web应用的请求范围 session：作用于web应用的会话范围 global-session：作用于集群环境的会话范围（全局会话范围），若不是集群环境，则效果与session相同 bean对象的生命周期 生命周期：bean创建 - 初始化 - 销毁的过程。 对象创建 单例：容器启动时创建bean对象。 多例：每次调用getBean时创建bean对象。 初始化 对象创建完成，并赋值完毕，调用初始化方法。 销毁 单例：容器销毁时销毁对象，并执行销毁方法。 多例：容器不会管理bean对象，对象只能通过GC回收，因此容器不会调用销毁方法。 指定初始化和销毁方法 XML配置，bean标签中init-method和destroy-method属性指定。 @Bean的initMethod和destroyMethod属性指定。 Bean类实现InitialzingBean接口（定义初始化逻辑）和DisposableBean接口（定义销毁逻辑）。 @PostConstruct注解与@PreDestroy注解，分别标记与init和destroy方法上。 依赖注入（Dependency Injection）：当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建(new)被调用者的实例，但在IoC中，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。要实现IoC，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过【构造器/方法/注解】注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。 注入的数据类型（适合注入不经常变化的数据） 基本数据类型和String Spring中配置好的bean 复杂类型/集合类型 注入的方式有 构造器：通过bean标签中的constructor-arg标签配置实现 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; //读取xml，通过反射创建bean对象；依赖查找 ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); // IAccountService as = (IAccountService) ac.getBean(\"accountService\"); IAccountService as = ac.getBean(\"accountService\", IAccountService.class);//两种方式获取bean对象 as.saveAccount(); /** 使用BeanFactory * BeanFactory beanFactory = new XmlBeanFactory(new ClassPathResource(\"bean.xml\")); * IAccountService as = (IAccountService) beanFactory.getBean(\"accountService\"); */ &#125;&#125; 1234567891011public class AccountServiceImpl implements IAccountService &#123; private IAccountDao accountDao; public AccountServiceImpl(IAccountDao accountDao) &#123; this.accountDao = accountDao; &#125; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 123456&lt;bean id=\"accountService\" class=\"com.itheima.service.impl.AccountServiceImpl\"&gt; &lt;!--name属性指定构造函数中参数列表变量的名称--&gt; &lt;!--value属性用于注入基本类型和String类型，ref属性指定Spring中配置好的bean类型--&gt; &lt;constructor-arg name=\"accountDao\" ref=\"accountDaoImpl\"&gt;&lt;/constructor-arg&gt; &lt;/bean&gt;&lt;bean id=\"accountDaoImpl\" class=\"com.itheima.dao.impl.AccountDaoImpl\"&gt;&lt;/bean&gt; set方法：在bean类中创建属性的setter方法。在bean.xml的bean标签内部配置如下：property标签，name属性指定方法名，value属性用于注入基本类型和String类型，ref属性则为bean类型。 1234&lt;bean id=\"\" class=\"\" &gt; &lt;property name=\"\" value=\"\"&gt; &lt;/property&gt; &lt;/bean&gt; 集合类型的注入：使用set, list, array, map, props等子标签。 12345678910111213&lt;bean id=\"\" class=\"\" &gt; &lt;property name=\"\"&gt; &lt;array&gt; &lt;value&gt;123&lt;/value&gt; &lt;value&gt;456&lt;/value&gt; &lt;/array&gt; &lt;/property&gt; &lt;property name=\"\"&gt; &lt;map&gt; &lt;entry key=\"\" value=\"\"&gt;&lt;/entry&gt; &lt;/map&gt; &lt;/property&gt;&lt;/bean&gt; 注解：@Autowired 基于注解的IoC配置 首先在xml文件中配置context 12345678910&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;&lt;beans xmlns=\"http://www.springframework.org/schema/beans\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xmlns:context=\"http://www.springframework.org/schema/context\" xsi:schemaLocation=\" http://www.springframework.org/schema/beans https://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd\"&gt; &lt;!--指定spring在创建容器时要扫描的包，以下标签在context名称空间和约束中--&gt; &lt;context:component-scan base-package=\"com.itheima\"&gt;&lt;/context:component-scan&gt;&lt;/beans&gt; 创建bean对象的注解：作用与xml配置文件中编写一个bean标签实现的功能是一样的。在bean类上标记，注解的属性值就是该类的id。 @Component：被注解的类由spring创建并存入IoC容器 @Controller：用于表现层 @Service：用于业务层 @Repository：用于持久层 后三个注解的作用与属性都与@Component相同 依赖注入的注解：作用与xml配置文件的bean标签中的property或constructor-arg标签实现的功能一样。 @Resource：在需要注入依赖的变量上标记，并在其实现类上标记@Component（或其余三种）注解。通过name属性匹配实现类。 123456789@Component(\"accountService\")public class AccountServiceImpl implements IAccountService &#123; @Resource(name=\"accountDao\") private IAccountDao accountDao; public void saveAccount() &#123; accountDao.saveAccount(); &#125;&#125; 123456@Repository(\"accountDao\")public class AccountDaoImpl implements IAccountDao &#123; public void saveAccount() &#123; System.out.println(\"Your Account has been saved!\"); &#125;&#125; 12345678public class Client &#123; public static void main(String[] args) &#123; ApplicationContext ac = new ClassPathXmlApplicationContext(\"bean.xml\"); IAccountService as = (IAccountService) ac.getBean(\"accountService\"); as.saveAccount(); &#125;&#125; @Autowired：置于成员变量上，自动按照成员变量的类型注入。只要IOC容器中有唯一的一个bean对象的类型和要注入的成员变量类型匹配，则注入成功；若有IOC容器中有多个bean对象的类型和要注入的成员变量类型匹配，则再按照变量名称匹配，匹配成功则注入成功。 @Qualifier：需要与@Autowired一起使用。@Qualifier的属性值为bean对象的id。 以上三个注解只能用于bean类型的注入，并且推荐使用@Resource注解。集合类型的注入只能通过xml配置文件实现。 @Value：用于注入基本类型与String类型数据。 改变作用范围的注解：作用与bean标签的scope属性实现的功能一样。 @Scope，value属性常用取值为singleton，prototype @Lazy：@Scope默认取值为Singleton，而该注解使得单例时并不在容器创建时立即创建bean对象，而是在第一次getBean时创建。 与生命周期相关的注解：作用与bean标签中的init-method属性、destroy-method属性实现的功能一样。 @PreDestroy：指定销毁方法。置于destroy方法上。 @PostConstruct：指定初始化方法。置于init方法上。 基于注解的IoC配置（不再需要xml文件） 案例代码。 @Configuration：创建一个代替bean.xml的配置类SpringConfig.java后，使用该注解标记该类为配置类。 @Import：标记主配置类，用于导入其他的从配置类。属性：Class&lt;?&gt;[] value;。使用该注解后可不再使用@Configuration注解。 @ComponentScan：指定spring在创建容器时需要扫描的包。其includeFilters和excludeFilters属性可指定扫描规则。 @Bean：标记一个方法，将该方法的返回值作为bean对象存入IoC容器。其属性name用于指定bean对象的id，默认值为方法名，作为IOC容器的key。 @PropertySource：value属性指定properties配置文件的位置，关键字classpath表示类路径下。用于配置数据库等字符串信息。 使用注解创建IOC容器时，使用new AnnotationConfigApplicationContext(SpringConfig.class);获取容器。 给容器中注册bean的方法 包扫描默认注册@Service/@Controller/@Repository/@Component注解的类，用于用户自定义类。 @Bean，常用于注册第三方组件。 @Import，给容器中快速注册大量组件。id默认为全类名。 直接写类名，@Import(类名.class)。 ImportSelector，该接口的方法selectImports返回需要导入的组件的全类名数组。@Import(ImportSelector.class)。 ImportBeanDefinitionRegistrar：使用registerBeanDefinition方法手动注册bean到容器中。@Import(ImportBeanDefinitionRegistrar.class)。 使用FactoryBean结合@Bean。 123456789101112131415public class ColorFactoryBean implements FactoryBean&lt;Color&gt;&#123; //返回一个Color对象，该对象会注册到容器中 @Override public Color getObject() throws Exception&#123; return new Color(); &#125; @Override public Class&lt;?&gt; getObjectType()&#123; return Color.class; &#125; @Override public boolean isSingleton()&#123; return false; &#125;&#125; 123456@Beanpublic ColorFactoryBean colorFactoryBean()&#123; return new ColorFactoryBean();&#125;//注意：如果调用getBean(\"colorFactoryBean\")，获取到的是调用getObject返回的Color对象。//要想获取ColorFactoryBean对象本身，则调用getBean(\"&amp;colorFactoryBean\")。 IoC的案例 使用xml配置，注解结合xml配置（推荐），纯注解配置三种方式 Use “Sourcegraph” to view the code：https://github.com/Laishiji/SpringLearningDemo Spring整合Junit 导入依赖spring-test 使用Junit提供的@RunWith替换Runner(替换main方法) 使用@ContextConfiguration告知Spring的运行器，spring容器的创建是基于xml还是基于注解，并说明位置 12345678910111213141516171819/** * 单元测试,Spring整合Junit */@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfig.class)//xml方式：@ContextConfiguration(locations=\"classpath:bean.xml\")public class AccountServiceTest &#123; @Autowired IAccountService as; @Test public void testFindAll()&#123; List&lt;Account&gt; accounts = as.findAllAccount(); for (Account a : accounts) &#123; System.out.println(a); &#125; &#125;&#125; SpringIoC Dochttps://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/core.html#beans","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"http://thmasterplan.cn/tags/Spring/"}]},{"title":"检索技巧","slug":"检索技巧","date":"2020-04-09T09:00:06.000Z","updated":"2020-11-23T14:23:21.128Z","comments":true,"path":"杂项/检索技巧/","link":"","permalink":"http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/","excerpt":"","text":"Github搜索 搜索引擎检索 Github搜索 in:name example：项目名中包含”example“ in:readme example：readme.md中包含”example“ in:description example：描述中包含”example“ stars:&gt;1000：项目 star数大于1000 forks:&gt;1000：项目fork数大于1000 pushed:&gt;2020-03-05：项目在该日期后有更新 language:java：项目用Java编写 以上条件可组合使用 搜索引擎检索 &quot;example&quot;：完全匹配 example site:www.xxx.com：站点内搜索 example -csdn.net：排除关键字","categories":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"Java基础","slug":"Java基础","date":"2020-04-08T14:47:15.000Z","updated":"2021-01-22T06:11:34.375Z","comments":true,"path":"Java/Java基础/","link":"","permalink":"http://thmasterplan.cn/Java/Java%E5%9F%BA%E7%A1%80/","excerpt":"","text":"面向对象三大特性 继承 多态 封装 权限修饰符作用范围 关键字 static final instanceof native transient 接口与抽象类 抽象类 接口 内部类 成员内部类 局部内部类 包装类 值传递与引用传递 Deep Copy, Shallow Copy Shallow Copy Deep Copy Java四种引用类型 集合的三种遍历方式 异常 字符串 String StringBuffer与StringBuilder 判断字符串是否相等 Arrays常用方法 面向对象三大特性继承 Java类是单继承的，不允许子类继承多个父类的原因在于，编译器无法确定使用哪个父类方法。 在父子类的继承关系中，创建父或子类对象，访问成员方法的规则：优先使用创建的对象的方法，没有则向上找。 继承关系中，父子构造方法访问的特点 子类构造方法有一个默认隐含的super()调用，因此一定是先调用的父类构造，后执行子类构造。 子类构造可以通过显示使用super()来调用父类重载构造，并且必须是子类构造的第一条语句。 重载与重写 重写：子类重写方法与父类方法名相同，参数列表相同。 重载：一个类中有多个相同的方法名，但参数列表不同。 多态 概念：父类（接口）引用指向子类对象。 多态代码中 成员重写方法的访问规则：先在子类对象中找，没有则向上找。 成员变量访问规则：直接使用父类成员变量。 向上转型即多态：父类引用指向子类对象；引用无法调用原本子类特有的方法。 向下转型，例如Animal a = new Cat();Cat cat = (Cat) a;，这个过程将父类变量还原为子类类型，使其又可以访问子类特有的方法。 多态的作用？ Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations. 封装 封装通过将类属性定义为私有，对外提供类属性的setters/getters方法来修改和获取属性值实现。 封装可以减少耦合，防止类数据被外部类定义的代码随机访问。 权限修饰符作用范围 外部类只有public和default两种权限。 private：只能修饰类方法和类变量，类内部才能访问。 default：无论对于类、类变量还是类方法，只能同一包内才能访问。 protected：修饰类变量和类方法，同一包内的类和该类的子类可访问。 关键字static 修饰成员变量或成员方法：不需要创建对象就可通过类名调用，它们均属于类，而非某个对象 修饰内部类（不允许修饰普通类） 1234567891011121314151617181920212223242526272829public class StaticTest &#123; static&#123; System.out.println(\"====外部类静态代码块====\"); &#125; public static class Inner&#123; static&#123; System.out.println(\"====静态内部类静态代码块====\"); &#125; Inner() &#123; System.out.println(\"====静态内部类构造方法====\"); &#125; public static void innerStaticMethod()&#123; System.out.println(\"====静态内部类静态方法====\"); &#125; public void innerMethod()&#123; System.out.println(\"====静态内部类普通方法====\"); &#125; &#125; public static void main(String[] args) &#123; StaticTest staticTest = new StaticTest(); System.out.println(\"====分割线====\"); Inner inner = new Inner(); StaticTest.Inner.innerStaticMethod(); inner.innerMethod(); &#125;&#125; 123456&#x3D;&#x3D;&#x3D;&#x3D;外部类静态代码块&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;分割线&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类静态代码块&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类构造方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类静态方法&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类普通方法&#x3D;&#x3D;&#x3D;&#x3D; 结论： 想要在普通类中创建内部类实例，可以用static修饰内部类。 外部类加载时不会加载内部类。 静态代码块先于构造方法执行。 静态代码块 第一次使用类时，类的静态代码块执行唯一的一次。（类加载的初始化阶段执行静态代码块） 静态代码块先于构造方法执行。 Tips: 静态不能直接访问非静态 静态方法中不能用this, this代表当前对象。 final 修饰类：当前类不能有子类。 修饰方法：该方法不能被子类重写。（显然对于类、方法来说，abstract和final无法同时使用） 修饰数据：对于基本数据类型，其值不能再改变；对于引用数据类型，不能再改为存储其他对象的地址或引用（对象自身是可以改变的）。对于类变量，必须赋初始值或在构造方法/静态代码块中赋值。 修饰数组：数组的引用不能再指向其他数组，但数组内容可变。 instanceof instanceof 的作用是测试它左边的对象是否是它右边的类的实例，返回 boolean类型。 native 使用native关键字修饰方法，说明这个方法是本地函数，也就是这个方法是用C/C++语言（或者其他语言）实现的，并且被编译成了DLL，由JVM调用。 native修饰的方法没有方法体。 transient 实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中，该属性的将只会存在于内存中。常见的应用有密码、银行卡号等敏感信息。 transient关键字只能修饰变量。 接口与抽象类抽象类 public abstract class Name{}；抽象类可以包含成员变量、成员方法、构造方法等，与普通类不同的点只在于：它可能包含抽象方法；它必须要被非抽象子类继承才能实例化，并且非抽象子类必须实现抽象方法（假如父类有抽象方法的话）。 单继承。 抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；抽象方法没有方法体。 抽象类使用： 创建子类继承抽象父类。 子类重写父类抽象方法，去掉abstract关键字，实现方法体。 接口 public interface IName{}； 接口可以继承多个接口，实现类可以实现多个接口。（多继承，多实现） 接口的成员变量默认都是public static final的：假如两个接口有相同的成员变量，一个类实现了这两个接口，那么实现类只能通过接口名.变量名来调用以避免歧义，因此必须为static。声明为final的原因是实现类不能够修改接口成员变量的值。 Java7：常量，抽象方法 Java8：新增了默认方法(default修饰)，静态方法。 增加默认方法的原因：Java升级后的兼容性问题。如果想在老版本接口中添加某个功能，在添加抽象方法的情况下，所有的老版本实现类都需要修改代码；而通过增加default方法来增加功能就不会有这种问题。 考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法。解决方案：重写方法，并使用接口名.super.方法名()调用指定接口的方法。 12345 public interface Vehicle &#123; default void print()&#123; System.out.println(\"vehicle...\"); &#125;&#125; 12345 public interface FourWheeler &#123; default void print()&#123; System.out.println(\"fourWheeler...\"); &#125;&#125; 12345678910111213public class Car implements Vehicle, FourWheeler &#123; @Override public void print() &#123; FourWheeler.super.print(); Vehicle.super.print(); &#125; public static void main(String[] args) &#123; Vehicle car = new Car(); car.print(); &#125;&#125; ​ 输出：fourWheeler…​ vehicle… Java9：新增了私有方法，私有静态方法 内部类成员内部类 三种方法使用成员内部类 在外部类的方法中创建内部类实例 main方法中：Inner inner = new Outer.new Inner(); main方法中直接new，前提是静态内部类 在内部类中访问重名的外部类变量 1234567891011121314151617181920public class Outer &#123; private int num = 10;//外部类私有变量，内部类也可访问 class Inner&#123; private int num = 20; public void innerMethod()&#123; int num = 30; System.out.println(num); System.out.println(this.num); System.out.println(Outer.this.num); &#125; &#125; public static void main(String[] args) &#123; Inner inner = new Outer().new Inner(); inner.innerMethod(); &#125;&#125; 局部内部类 该类定义在方法内部，只有在该方法内部才能使用。 局部内部类中的匿名内部类 如果接口的实现类（或者父类的子类）只需要使用一次，那么这种情况下可以省略掉该类的定义，而使用匿名内部类。 最常见的使用：通过将Runnable接口的实现类的实例对象作为参数传给Thread，创建线程。不仅省略了类定义，同时完成了向上转型。 123456new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(\"...\"); &#125; &#125;).start(); 包装类 包装类通过将基本数据类型封装起来，在类中提供一些方法，便于操作这些基本数据类型。 Java自jdk5后提供自动装箱与自动拆箱机制。 基本类型与字符串的转换 基本类型 -&gt; String：基本类型值+”” String -&gt; 基本类型：使用包装类的静态方法parseXXX(&quot;str&quot;) Integer：static int parseInt(String s) Double：static double parseDouble(String s) 重写equals为什么要重写hashCode?要搞清楚这个问题，我们首先需要准备以下前置知识： Object类的equals方法实现如下： 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 由此可知，“==”判断的是内存地址是否相等，若子类不重写equals，那么对象调用该方法判断的是是否为同一个对象。而我们重写equals的目的一般是判断两个对象的字段值是否相等。 Object类的hashCode方法如下： 1public native int hashCode(); ​ 若子类不重写hashCode方法，那么子类对象的hash码是调用本地C++方法根据对象的内存地址生成的。 结论：我们重写了一个类的equals和hashCode方法后，a.equals(b) == true是a.hashCode() == b.hashCode()的充分条件。 结论证明：若a.equals(b)，说明两个对象的字段值都相等。重写的hashCode方法中生成hash码的方式是根据对象的字段值采用相同的算法生成，因此两个对象的hashCode一定相等。 HashSet是通过持有一个HashMap实例实现的。 我们都知道HashSet是不允许重复存储元素的，当调用其add方法时会进行自动排重，源代码如下： 123public boolean add(E e) &#123; return map.put(e, PRESENT)==null;&#125; PRESENT常量是在HashSet中定义的： 1private static final Object PRESENT = new Object(); 由源码可知，由于HashMap中key的唯一性（不可能存在两个相同的key），HashSet的自动排重是通过将元素作为HashMap的key实现的。而key的唯一性是由key的hash码的唯一性保证的（参见HashMap源码）。 有了以上前置知识，现在考虑以下场景：假设有一个Student类，若我们重写了其equals而不重写hashCode，那么就会导致两个对象的字段值相等，但是hash码不等的情况出现。现在我们的需求是将一些Student对象放入HashSet，假设有两个Student对象的所有字段值都相等（客观现实是同一个人），需要我们的HashSet去重，问题显而易见，这两个对象的hash码不等，那么这两个对象都会作为key存储在HashSet中，无法完成去重。 值传递与引用传递 实参与形参： 形式参数：定义函数时使用的参数，用来接收实际参数。 实际参数：调用有参函数时，传入的内容。 值类型与引用类型 值类型（基本数据类型）：直接存储值。 引用类型：存储的是对象的地址。对象在堆中。 求值策略（Evaluation Strategy）：值传递与引用传递，属于函数调用时参数的求值策略，是对调用函数时求值和传值的方式的描述，而非传递的内容的类型。（内容的类型是指：值类型还是引用类型。）值类型与引用类型，用于区分两种内存分配方式，值类型在虚拟机栈上分配，引用类型在堆上分配。 值传递概念：调用函数时，将实际参数拷贝一份传递给函数。In call by value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (frequently by copying the value into a new memory region). Java uses call by value evaluate function arguments left-to-right 引用传递概念：调用函数时，将实际参数的地址传递给函数。Call by reference (or pass by reference) is an evaluation strategy where a function receives an implicit reference to a variable used as argument, rather than a copy of its value. 总结-“Java中只有值传递，值传递与引用传递的区别重点在于是否拷贝”：对于基本数据类型，传递的是基本数据类型的值的拷贝；对于引用类型，传递的是对象的地址值的拷贝，形参与实参都保存的是堆内存中同一个对象的地址。 参考：https://en.wikipedia.org/wiki/Evaluation_strategy Deep Copy, Shallow CopyShallow Copy B对A的浅拷贝：创建新对象B，将A的字段值复制到B。 如果该字段值是对对象（例如，存储器地址）的引用，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。 如果该字段值是基本数据类型，则复制值。 Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法， then A B = (A) new A().clone(); 示例： 123456789101112131415161718192021222324252627282930313233class C&#123; int a; int b; C(int a, int b)&#123; this.a = a; this.b = b; &#125;&#125;class A implements Cloneable&#123; int val; C object; A(int val, C obj)&#123; this.val = val; this.object = obj; &#125; @Override public Object clone()&#123; try&#123; return super.clone(); &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); return null; &#125; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; A aObj = new A(1, new C(2,3)); A bObj = (A) aObj.clone(); &#125;&#125; 如上代码中，如果bObj修改了引用类型C object中b的值为10，那么对象aObj中引用类型C object中b的值也是10，因为浅拷贝只是拷贝了aObj中object的引用（地址）给bObj。 Deep Copy B对A的深拷贝：创建新对象B，对于A的引用类型字段，在B中创建该引用类型对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。 要实现深拷贝，不仅A需要实现Cloneable接口并重写clone方法，A中的引用类型C也需要实现Cloneable接口并重写clone方法。 深拷贝也可通过对象序列化的方式实现ByteArrayInputStream、ByteArrayOutputStream、ObjectInputStream、ObjectOutputStream。 示例： 123456789101112131415161718192021222324252627282930313233343536373839class C implements Cloneable&#123; int a; int b; C(int a, int b)&#123; this.a = a; this.b = b; &#125; @Override public Object clone() throws CloneNotSupportedException &#123; return super.clone(); &#125;&#125;class A implements Cloneable&#123; int val; C object; A(int val, C obj)&#123; this.val = val; this.object = obj; &#125; @Override public Object clone()&#123; try&#123; A a = (A) super.clone(); a.object = (C) object.clone(); return a; &#125;catch(CloneNotSupportedException e)&#123; e.printStackTrace(); return null; &#125; &#125;&#125;class Test&#123; public static void main(String[] args)&#123; A aObj = new A(1, new C(2,3)); A bObj = (A) aObj.clone(); &#125;&#125; 参考：https://en.wikipedia.org/wiki/Object_copying#Methods_of_copying Java四种引用类型JDK1.2之后，引用概念分为以下4种，强度依次减弱 强引用：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。 软引用：描述有用但非必须的对象，当系统将要发生OOM异常时，软引用指向的对象才被真正回收。通过SoftReference类实现。 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。 虚引用：为一个对象设置虚引用关联的唯一目的时能在对象被回收时收到一个系统通知。通过PhantomReference类实现。 集合的三种遍历方式 for 形式：for(初始化;结束条件;自增操作等) 需要知道集合的大小和元素类型，使用索引。 foreach 形式：for(T element : colletion) 需要知道集合元素的类型，不需要索引。 iterator 形式：Iterator it = collection.iterator();while(it.hasNext()){ object o =it.next(); ...} 集合的大小和类型都无需知道，也无需索引。 Tips: foreach是iterator的语法糖，底层使用iterator实现。 使用for循环进行remove操作时，每一次操作完成后索引需要自减。 iterator/foreach遍历集合时的add/remove操作见“Java集合框架”。 异常 Java异常图解 Throwable类中定义了一些查看异常的方法： public String getMessage()：获取异常的描述信息。 public String toString()：获取异常的类型和异常描述信息。 void printStackTrace()：打印异常的跟踪栈信息。最常用。 捕获异常 1234567891011121314try&#123; //可能产生异常的代码&#125;catch(异常类型1 e)&#123; //异常的处理逻辑；一般会记录到日志中&#125;... catch(异常类型n e)&#123; &#125;finally&#123; //无论是否出现异常都会执行，常用于资源释放 &#125;//jdk1.8之后支持try with resource写法try(需要释放资源的代码)&#123;&#125;catch(Exception e)&#123;&#125; 自定义异常类 1234567891011public class XXXException extends Exception&#123; //添加一个空参构造 public XXXException()&#123; super(); &#125; //添加一个带异常信息的构造 public XXXException(String message)&#123; super(message);//所有的子类异常都交给父类处理 &#125;&#125; 自定义异常类一般以命名Exception结尾，必须继承Exception类或者RuntimeException类： 继承自Exception：自定义异常为编译期异常，必须处理。 继承自RuntimeException：运行期异常无需处理。 字符串String String类是final的，因此不能被继承。源码是一个final修饰的字符数组，因此一旦创建就是一个不可变的字符串。 1private final char value[]; 字符串的拼接：由于String不可变，两个String类型拼接需要新开辟一块内存空间，效率低下。建议使用StringBuffer或StringBuilder，这两者的区别稍后讲解。 String常用方法 比较 equals(Object obj)：如果比较双方一个常量一个变量，应把常量写在前面，如&quot;abc&quot;.equals(str)。因为如使用str.equals(&quot;abc&quot;)，假如str为空会导致空指针异常。 equalsIgnoreCase(String str)：忽略大小写。 endsWith(String suffix)：比较suffix是否为串的后缀。 获取 length()：获取长度。 concat(String str)：获取拼接后的串。 charAt(int index)：获取指定索引字符。 public int indexOf(String str)：查找参数串在本串中首次出现的索引位置，如无匹配结果返回-1。可用于字符串匹配。 截取 subString(int index)：截取从参数位置开始后的子串。 subString(int begin, int end)：截取[begin, end)子串。 trim()：去除字符串的前后空格。 转换 toCharArray()：串转换为字符数组 getBytes()：串转换为底层的字节数组 toUpperCase()和toLowerCase()：大小写转换。 replaceAll(String regex, String replacement)：使用给定的replacement替换所有符合regex规则的子串。 分割：split(String regex)：按照参数规则分割字符串为若干子串。 StringBuffer与StringBuilder 都由final修饰，不能被继承。 都继承于AbstractStringBuilder，底层使用的字符数组没有final修饰。StringBuffer和StringBuilder的默认构造中，char数组默认大小为16，在调用append方法拼接字符串时，先判断拼接后的长度是否超出当前数组大小，若超出则自动扩容（将当前字符数组复制到新容量的数组中），若不超出则直接将要拼接的字符串复制到数组中。源码如下： 1234567891011121314151617public AbstractStringBuilder append(String str) &#123; if (str == null) return appendNull(); int len = str.length(); ensureCapacityInternal(count + len); str.getChars(0, len, value, count); count += len; return this;&#125;private void ensureCapacityInternal(int minimumCapacity) &#123; // overflow-conscious code if (minimumCapacity - value.length &gt; 0) &#123; value = Arrays.copyOf(value, newCapacity(minimumCapacity)); &#125;&#125; StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是 synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。 StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。 jdk1.9后String/StringBuffer/StringBuilder均不再使用字符数组，而是直接使用字节数组byte[] value。 判断字符串是否相等12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * 驻留字符串(即被\"\"包住的字符串)一旦进入运行期，就会在堆中创建，并且其地址值存入常量池StringTable。 * StringTable是一个哈希表，value是字符串在堆中的地址值。 */public static void main(String[] args) &#123; String s1 = \"a\"; String s2 = \"b\"; final String s3 = \"a\"; final String s4 = \"b\"; String s5 = \"a\"; System.out.println(s1 == s3); //true System.out.println(s1 == s5); //true /** * 编译期优化，创建\"ab\"，该拼接操作直接在编译期完成而不是运行期 */ String s6 = \"a\" + \"b\"; /** * 对于编译期不能确定的字符串【变量】的拼接操作(s1和s2的值可能在运行期变化)， * 编译期会转化为new StringBuilder().append(s1).append(s2).toString()，并在运行期运行 */ String s7 = s1 + s2; System.out.println(s6 == s7); //false /** * 常量的拼接是确定值\"ab\"，s8与s6指向同一个\"ab\" */ String s8 = s3 + s4; System.out.println(s6 == s8); //true /** * \"ab\"已经存在，s9与s8、s6都指向同一个\"ab\" */ String s9 = \"ab\"; System.out.println(s6 == s9); //true /** * s7此时在堆中，调用其intern方法将字符串地址放入StringTable并返回, * 若此时常量池中【没有】\"ab\", 则放入成功, 返回地址赋值给s10，s7之后就是一个驻留字符串了; * 若此时StringTable【已有】\"ab\", s7放入StringTable失败, s7依旧不是驻留字符串， * 返回已有的\"ab\"地址给s10。 * 显然此处StringTable中【已有】\"ab\", 那么s7放入失败, 但是s10成为了驻留字符串。 */ String s10 = s7.intern(); System.out.println(s6 == s10); //true /** * 只要是new的String一定不在StringTable中 */ String s11 = new String(\"a\") + \"b\"; System.out.println(s6 == s11); //false String str1 = new String(\"a\"); String str2 = new String(\"a\"); System.out.println(str1 == str2); //false&#125; Arrays常用方法 static List&lt;T&gt; asList&lt;T... a&gt;：返回参数列表的List，例List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;); binarySearch()：有多个重载的方法，二分查找 static String toString(数组)：将参数数组变成字符串，默认格式为[元素1, 元素2, 元素3….] sort(数组)：按照默认升序对数组元素排序；自定义类型需要实现Comparator接口。","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"JavaIO","slug":"JavaIO","date":"2020-04-08T14:23:56.000Z","updated":"2020-11-23T14:23:21.008Z","comments":true,"path":"Java/JavaIO/","link":"","permalink":"http://thmasterplan.cn/Java/JavaIO/","excerpt":"","text":"Java IO/NIO/AIO - Overview Java IO分类 BIO/NIO/AIO BIO NIO AIO Netty Java IO/NIO/AIO - Overview Java IO分类按传输数据类型分类 按数据操作分类 JavaIO常见类使用 BIO/NIO/AIO简介 BIO传统的BIO NIO基础 多路复用 AIO异步IO NettyNetty是一个高性能、异步事件驱动的NIO框架，提供了对TCP、UDP和文件传输的支持。作为当前最流行的NIO框架，Netty在互联网领域、大数据分布式计算领域、游戏行业、通信行业等获得了广泛的应用，一些业界著名的开源组件也基于Netty构建，比如RPC框架、zookeeper等。","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"JDK动态代理","slug":"JDK动态代理","date":"2020-04-05T08:53:39.000Z","updated":"2020-11-23T14:23:21.022Z","comments":true,"path":"JavaWeb/JDK动态代理/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/","excerpt":"","text":"静态代理 静态代理实现日志打印 JDK动态代理 静态代理 假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？ 12345678910public class Calculator&#123; public int add(int a, int b)&#123; return a+b; &#125; public int subtract(int a, int b)&#123; return a-b; &#125; //其余算数运算方法。。。&#125; 方案：直接在Calculator类每个方法前后插入日志代码。缺点： 直接修改源码，不符合开闭原则。应该对扩展开放，对修改关闭。 如果Calculator类有许多方法，修改量太大。 重复代码太多。 日志代码硬编码在代理类中，不利于后期维护。 静态代理实现日志打印 代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于在目标实现的基础上增加额外的功能操作，以满足自身的业务需求。 静态代理的实现：编写一个代理类，实现与目标对象相同的接口，并在内部维护一个目标对象的引用。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。 静态代理实现日志打印： 将Calculator抽取为接口 1234public interface Calculator &#123; int add(int a, int b); int subtract(int a, int b);&#125; 目标对象实现类 1234567891011public class CalculatorImpl implements Calculator &#123; public int add(int a, int b) &#123; return a + b; &#125; public int subtract(int a, int b) &#123; return a - b; &#125; //其余算数运算方法。。。&#125; 代理对象实现类 1234567891011121314151617181920212223242526272829public class CalculatorProxy implements Calculator &#123; //代理对象内部维护一个目标对象引用 private Calculator target; //构造方法，传入目标对象 public CalculatorProxy(Calculator target) &#123; this.target = target; &#125; //调用目标对象的add，并在前后打印日志 @Override public int add(int a, int b) &#123; System.out.println(\"add方法开始...\"); int result = target.add(a, b); System.out.println(\"add方法结束...\"); return result; &#125; //调用目标对象的subtract，并在前后打印日志 @Override public int subtract(int a, int b) &#123; System.out.println(\"subtract方法开始...\"); int result = target.subtract(a, b); System.out.println(\"subtract方法结束...\"); return result; &#125; //其余算数运算方法。。。&#125; 使用代理对象实现计算器并打印日志 1234567public class Test &#123; public static void main(String[] args) &#123; Calculator calculator = new CalculatorProxy(new CalculatorImpl()); calculator.add(1, 2); calculator.subtract(2, 1); &#125;&#125; 静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。 静态代理的缺点： 代理者与委托者一一对应，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。 如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。 JDK动态代理 我们的目标只是为了实现增强功能，如何才能不编写代理类，只提供接口和目标对象就直接得到代理对象呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。 JDK动态代理是面向接口的代理模式，如果被代理对象没有实现接口则无法使用。 Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了JVM动态生成的代理类的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。 实际开发中采用newProxyInstance方法获取代理对象。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101package reflect;import java.lang.reflect.Constructor;import java.lang.reflect.InvocationHandler;import java.lang.reflect.Method;import java.lang.reflect.Proxy;public class ProxyTest &#123; /** * 测试 * @param args * @throws Exception */ public static void main(String[] args) throws Exception &#123; Calculator calculatorProxy =(Calculator) getProxy(new CalculatorImpl()); calculatorProxy.add(1, 2); calculatorProxy.subtract(3, 2); &#125; /** * 传入目标对象，得到代理对象 * @param targetObj * @throws Exception */ private static Object getProxy(final Object targetObj) throws Exception &#123; //传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口 //proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象 Class&lt;?&gt; proxyClass = Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces()); //得到代理类（com.sun.proxy.$Proxy0）的构造器 Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class); //通过构造器创建代理对象 Object proxyObj = constructor.newInstance(new InvocationHandler()&#123; //在重写invoke方法中编写增强功能代码，执行被代理类的任何接口方法都会经过该方法，该方法参数列表的含义依次是： //1.Object proxy: 代理对象的引用 //2.当前执行的方法 //3.当前执行方法的参数 //返回值：和被代理对象有相同的返回值 @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + \"方法开始执行...\");//增强功能代码 Object result = method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\");//增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; private static Object getProxy1(final Object targetObj) throws Exception &#123; Object proxyObj = Proxy.getProxyClass( targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces() ) .getConstructor(InvocationHandler.class) .newInstance(new InvocationHandler()&#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + \"方法开始执行...\");//增强功能代码 Object result = method.invoke(targetObj,args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\");//增强功能代码 return result; &#125; &#125;); return proxyObj; &#125; /** * 实际使用的方法newProxyInstance * @param target * @return * @throws Exception */ public static Object getProxy2(final Object target) throws Exception &#123; Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(), target.getClass().getInterfaces(), new InvocationHandler() &#123; @Override public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123; System.out.println(method.getName() + \"方法开始执行...\");//增强功能代码 Object result = method.invoke(target,args); System.out.println(result); System.out.println(method.getName() + \"方法执行结束...\");//增强功能代码 return result; &#125; &#125;); return proxy; &#125;&#125; 使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。 mybatis Mapper以及springAOP都是通过动态代理实现。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"MyBatis简单案例","slug":"MyBatis简单案例","date":"2020-04-05T08:39:41.000Z","updated":"2020-11-23T14:23:21.068Z","comments":true,"path":"JavaWeb/MyBatis简单案例/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/MyBatis%E7%AE%80%E5%8D%95%E6%A1%88%E4%BE%8B/","excerpt":"","text":"概述 MybatisHelloWorld 概述mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务），而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。 MybatisHelloWorld 工程文件结构如图 创建Maven工程，配置pom.xml，插入： 1234567891011121314151617181920&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;version&gt;5.1.48&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.mybatis&lt;/groupId&gt; &lt;artifactId&gt;mybatis&lt;/artifactId&gt; &lt;version&gt;3.5.4&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.12&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建实体类和DAO接口 实体类 1234567public class User &#123; private Integer id;//包装类默认为null private String lastName; private String email; private String gender; //getters and setters, toString...&#125; DAO接口 123public interface IUserMapper &#123; public User getUserById(Integer id);&#125; 创建sql映射文件：UserMapper.xml 12345678910111213&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE mapper PUBLIC \"-//mybatis.org//DTD Mapper 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-mapper.dtd\"&gt;&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;&lt;mapper namespace=\"com.laishiji.mybatis.dao.IUserMapper\"&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt; &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt; &lt;select id=\"getUserById\" resultType=\"com.laishiji.mybatis.bean.User\"&gt; select id, last_name lastName, gender,email from user where id = #&#123;id&#125; &lt;/select&gt;&lt;/mapper&gt; 也可通过注解来完成映射： 1234public interface IUserMapper &#123; @select(\"select id, last_name lastName, gender,email from user where id = #&#123;id&#125;\") public User getUserById(Integer id);&#125; 创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：mybatisConfig.xml 12345678910111213141516171819202122232425262728293031&lt;?xml version=\"1.0\" encoding=\"UTF-8\" ?&gt;&lt;!DOCTYPE configuration PUBLIC \"-//mybatis.org//DTD Config 3.0//EN\" \"http://mybatis.org/dtd/mybatis-3-config.dtd\"&gt;&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;&lt;configuration&gt; &lt;environments default=\"development\"&gt; &lt;environment id=\"development\"&gt; &lt;transactionManager type=\"JDBC\"/&gt; &lt;dataSource type=\"POOLED\"&gt; &lt;property name=\"driver\" value=\"com.mysql.jdbc.Driver\"/&gt; &lt;property name=\"url\" value=\"jdbc:mysql://localhost:3306/mybatis\"/&gt; &lt;property name=\"username\" value=\"root\"/&gt; &lt;property name=\"password\" value=\"admin\"/&gt; &lt;/dataSource&gt; &lt;/environment&gt; &lt;/environments&gt; &lt;mappers&gt; &lt;mapper resource=\"UserMapper.xml\"/&gt; &lt;/mappers&gt;&lt;/configuration&gt; mysql中建表 12345678910111213drop database if exists mybatis;create database mybatis default character set utf8;create table user( id int(11) primary key auto_increment, last_name varchar(255), gender char(1), email varchar(255))engine=innodb default charset=utf8;insert into user(id,last_name,gender,email) values (1,'Tom','男','123@qq.com'), (2,'Jim','男','234@qq.com'), (3,'Lisa','女','324@qq.com'); 创建测试类 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.laishiji.mybatis;import com.laishiji.mybatis.bean.User;import com.laishiji.mybatis.dao.IUserMapper;import org.apache.ibatis.io.Resources;import org.apache.ibatis.session.SqlSession;import org.apache.ibatis.session.SqlSessionFactory;import org.apache.ibatis.session.SqlSessionFactoryBuilder;import org.junit.Test;import java.io.IOException;import java.io.InputStream;/** * SqlSession代表和数据库的一次会话，用完必须关闭； * SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量； * dao接口没有实现类，但是mybatis会为这个接口生成一个代理对象。 */public class MybatisTest &#123; @Test public void test() throws IOException &#123; String resource = \"mybatisConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession session = sqlSessionFactory.openSession(); User user = session.selectOne(\"com.laishiji.mybatis.dao.IUserMapper.getUserById\",1); System.out.println(user); session.close(); &#125; /** * 接口式编程： * 原生：IUserDao接口 ---&gt; IUserDaoImpl实现类 * mybatis：IUserMapper接口 ---&gt; IUserMapper.xml * @throws IOException */ @Test public void test2() throws IOException &#123; String resource = \"mybatisConfig.xml\"; InputStream inputStream = Resources.getResourceAsStream(resource); SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream); SqlSession openSession = sqlSessionFactory.openSession(); //通过反射+动态代理获取接口的实现类对象 IUserMapper userMapper = openSession.getMapper(IUserMapper.class); User user = userMapper.getUserById(1); System.out.println(user); openSession.close(); &#125;&#125;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"MyBatis","slug":"MyBatis","permalink":"http://thmasterplan.cn/tags/MyBatis/"}]},{"title":"Maven入门","slug":"Maven入门","date":"2020-04-05T03:18:27.000Z","updated":"2021-01-14T08:35:40.715Z","comments":true,"path":"JavaWeb/Maven入门/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Maven%E5%85%A5%E9%97%A8/","excerpt":"","text":"Maven配置踩坑 Maven项目目录结构 项目对象模型（POM） Maven构建生命周期 依赖管理模型 pom.xml约束中的标签 dependency properties scope modelVersion parent Maven配置踩坑 修改本地仓库路径：找到conf目录下的settings.xml，添加&lt;localRepository&gt;PATH&lt;/localRepository&gt;，PATH即为仓库路径。默认仓库路径为用户路径下的.m2目录。 修改Maven云仓库为国内镜像站：同样在conf目录下的settings.xml下，找到&lt;mirrors&gt;标签，添加 123456789101112131415161718&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/repositories/central/&lt;/url&gt;&lt;/mirror&gt;&lt;mirror&gt; &lt;id&gt;repo2&lt;/id&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;name&gt;Human Readable Name for this Mirror.&lt;/name&gt; &lt;url&gt;http://repo2.maven.org/maven2/&lt;/url&gt;&lt;/mirror&gt; 修改默认jdk版本1.5为期望的版本：同样在conf目录下的settings.xml下，找到&lt;profiles&gt;标签，添加 123456789101112&lt;profile&gt; &lt;id&gt;jdk-1.8&lt;/id&gt; &lt;activation&gt; &lt;activeByDefault&gt;true&lt;/activeByDefault&gt; &lt;jdk&gt;1.8&lt;/jdk&gt; &lt;/activation&gt; &lt;properties&gt; &lt;maven.compiler.source&gt;1.8&lt;/maven.compiler.source&gt; &lt;maven.compiler.target&gt;1.8&lt;/maven.compiler.target&gt; &lt;maven.compiler.compilerVersion&gt;1.8&lt;/maven.compiler.compilerVersion&gt; &lt;/properties&gt; &lt;/profile&gt; idea中Maven项目执行两次的问题：找到maven设置项Runner，取消勾选Delegate IDE build/run actions to Maven。 手动添加在线仓库没有的jar依赖：控制台mvn install:install-file。 Maven项目目录结构 项目对象模型（POM） POM是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。 所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。 groupId：公司或者组织的唯一标志。 artifactId：项目的唯一ID。 Maven构建生命周期 clean -&gt; default(build) {validate -&gt; compile -&gt; test -&gt; package -&gt; verify -&gt; install -&gt; deploy } -&gt; site 依赖管理模型 Maven 通过读取项目文件（pom.xml），找出库文件之间的依赖关系并从仓库自动下载。 引入外部依赖：先在 src 文件夹下添加 lib 文件夹，然后将工程需要的 jar 文件复制到 lib 文件夹下。然后添加以下依赖到pom.xml： 1234567&lt;dependency&gt; &lt;groupId&gt;xxx&lt;&#x2F;groupId&gt; &lt;artifactId&gt;xxx&lt;&#x2F;artifactId&gt; &lt;version&gt;1.0&lt;&#x2F;version&gt; &lt;scope&gt;system&lt;&#x2F;scope&gt; &lt;!--作用域--&gt; &lt;systemPath&gt;$&#123;basedir&#125;\\src\\lib\\yyy.jar&lt;&#x2F;systemPath&gt; &lt;&#x2F;dependency&gt; pom.xml约束中的标签dependency子标签有： groupId：定义隶属的实际项目。 artifactId：定义项目中的模块。 version：版本号。 properties在该标签中自定义变量，然后其他节点中可引用自定义变量，自定义变量通过${}引用。常用于统一版本号。 scope表示依赖的作用阶段。标签体中取值有： compile：默认值，表示被依赖项目需要参与compile ，test ， package和运行阶段。 provided：表示被依赖项目不参与package阶段。 runtime：表示依赖不参与compile，但是参与test和运行。 system：与provided类似，但是系统要以外部jar包的形式提供，Maven不会再repo中查找依赖。 test：表示依赖作用于test，compile阶段，不作用于package和运行阶段。 modelVersionPOM模型版本，必须。 parent定义父项目的坐标，若当前项目没有规定某个元素的值，则父项目的对应值即为项目的默认值。","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"Maven","slug":"Maven","permalink":"http://thmasterplan.cn/tags/Maven/"}]},{"title":"Filter_Listener","slug":"Filter-Listener","date":"2020-04-03T07:52:10.000Z","updated":"2020-11-23T14:23:20.993Z","comments":true,"path":"JavaWeb/Filter-Listener/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Filter-Listener/","excerpt":"","text":"Filter（过滤器） 概念 使用 filter的执行流程 filter的生命周期 拦截方式配置 Listener(监听器)) 概念 常用的监听器”6 + 2” 6个常规监听器 2个感知监听 ServletContextListener接口 Filter（过滤器）概念客户端访问服务器资源时，filter拦截请求，作特殊处理：登录验证、统一编码处理、敏感字符过滤等。 使用 实现javax.servlet.Filter接口 覆写init()/doFilter()/destroy()方法 doFilter()放行代码：filterChain.doFilter(servletRequest, servletResponse); 配置拦截路径 注解配置：@WebFilter(&quot;/path&quot;) web.xml配置 123456789&lt;filter&gt; &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt; &lt;filter-class&gt;filterClassName&lt;&#x2F;filter-class&gt;&lt;&#x2F;filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt; &lt;url-pattern&gt;&#x2F;path&lt;&#x2F;url-pattern&gt; &lt;!-- 拦截路径 --&gt;&lt;&#x2F;filter-mapping&gt; filter的执行流程 客户端请求 -&gt; 经过filter，执行doFilter()：对request对象请求消息处理后放行 -&gt; servlet执行完毕 -&gt; 执行doFilter()：对response对象的响应消息处理。 filter链的执行顺序：filter1 -&gt; filter2… -&gt; 资源执行 -&gt;…filter2 -&gt; filter1。 注解配置：按照类名的字符串比较规则比较，值小的先执行。例如filterA与filterB，则filterA先执行。 web.xml配置：按照&lt;filter-mapping&gt;的定义顺序执行。 filter的生命周期 init()：服务器启动后，创建filter对象，调用init()方法，只执行一次。用于加载资源。 doFilter()：每一次请求被拦截资源时，都会执行。 destroy()：服务器关闭，filter对象被销毁。正常关闭情况下，会执行destroy()方法。用于释放资源。 拦截方式配置设置dispatcherTypes属性。 注解方式 DispatcherType.REQUEST：默认值。浏览器直接请求资源时，才会执行filter。 DispatcherType.FORWARD：转发访问资源。 DispatcherType.INCLUDE：包含访问资源。 DispatcherType.ERROR：错误跳转资源。 DispatcherType.ASYNC：异步访问资源。 web.xml方式 添加&lt;dispatcher&gt; &lt;/dispatcher&gt;标签，标签中文本取上述取值即可。 Listener(监听器)概念监听器就是一个实现了特定接口的普通Java程序，这个程序专门用于监听另一个Java对象的方法调用或者属性改变（事件）。当被监听对象发生上述事件后，监听器某个方法将立即被执行。 常用的监听器”6 + 2”6个常规监听器对应JavaWeb三大域对象。 ServletContext ServletContextListener(生命周期监听)，项目启动时，ServletContext创建后创建该接口的实现类对象。注：Spring框架的ContextLoaderListener类实现了该接口。 ServletContextAttributeListener(属性监听) HttpSession HttpSessionListener(生命周期监听)，只有在servlet中调用了request.getSession()方法且根据JSESSIONID找不到对应的session时才会创建新的session对象，触发监听。 HttpSessionAttributeListener(属性监听) ServletRequest ServletRequestListener(生命周期监听)，每一次请求都会创建request对象并触发监听，每一次请求结束都会销毁request对象并触发监听。 ServletRequestAttributeListener(属性监听) 生命周期监听：每当tomcat创建或销毁三大域对象时，都会被其对应的Listener察觉并调用其特定的方法。 属性监听：每当调用域对象的setAttribute()或getAttribute()，都会被对应的属性监听器察觉并调用其特定的方法。 2个感知监听 HttpSessionBindingListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口，其有两个方法valueBound()/valueUnbound，当该对象被绑定(存储)时，触发该对象的valueBound()方法；当该对象被session解绑时session.removeAttribute(&quot;key&quot;);时触发该对象的valueUnbound()方法。 HttpSessionActivationListener：需要通过session.setAttribute(&quot;key&quot;, new Object())存储的对象Object实现该监听器接口。当该session即将被钝化(序列化)时，触发该监听器的sessionWillPassivate()方法；当该session活化时，触发该监听器的sessionDidActivate方法。 ServletContextListener接口用于监听ServletContext对象的销毁与创建。 void contextDestroyed(ServletContextEvent sce)：ServletContext对象被销毁之前会调用该方法。 void contextInitialized(ServletContextEvent sce)：ServletContext对象创建后会调用该方法，服务器启动后自动调用。 使用：实现接口 -&gt; 覆写方法 -&gt; 配置 web.xml配置 123&lt;listener&gt; &lt;listener-class&gt;监听器类名&lt;&#x2F;listener-class&gt;&lt;&#x2F;listener&gt; 注解配置：@WebListener","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Cookie_Session","slug":"Cookie-Session","date":"2020-04-01T12:55:36.000Z","updated":"2020-11-23T14:23:20.990Z","comments":true,"path":"JavaWeb/Cookie-Session/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Cookie-Session/","excerpt":"","text":"会话 Cookie Session 会话会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一标识一个用户并记录其状态。由于HTTP协议是无状态的，也就是说浏览器的每一次请求都是独立的，服务器并不知道这个浏览器之前是否请求过，这才有了会话机制。 Cookie 概念：客户端会话技术，将数据保存到客户端。javax.servlet.http.Cookie(类)。 主要作用：避免多次登录验证，一次登录后服务器便使用cookie验证身份。cookie的作用就像是身份凭证。 使用 创建Cookie对象，绑定数据：new Cookie(String name, String value) 发送Cookie对象到客户端：response.addCookie(Cookie cookie) 获取Cookie，拿到数据： 12345678Cookie[] cookies &#x3D; request.getCookies();if(cookies !&#x3D; null)&#123; for(Cookie c : cookies)&#123; String name &#x3D; c.getName(); String val &#x3D; c.getValue(); &#x2F;&#x2F;.......... &#125;&#125; 原理 客户端发送请求-&gt; 服务器创建Cookie并发送到客户端 -&gt; http响应头增加Set-Cookie：name=value字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证 Tips 一次可以创建多个Cookie并发送 Cookie在浏览器中存活时间 默认情况下，浏览器关闭后Cookie数据销毁 持久化存储：cookie.setMaxAge(int seconds) 正数：将cookie数据写到硬盘的文件中，seconds时间之后文件被删除。 负数：默认值 0：删除已经存在于客户端的cookie数据 Tomcat8之后Cookie支持中文 Cookie共享问题 假设在一个Tomcat服务器中部署了多个web项目： 默认情况下不同web项目的cookie不能共享 cookie.setPath(String path)：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，可将path设置为”/“。 服务器集群共享Cookie： setDomain(String path)：设置一级域名 例如setDomain(&quot;.baidu.com&quot;)，则tieba.baidu.com和news.baidu.com中cookie可以共享 Session 概念：服务器端会话技术，在一次会话的多次请求间共享数据，将数据保存在服务器端的对象中。javax.servlet.http.HttpSession（接口）。 主要作用 用于存储一次会话的多次请求的数据 可以存储任意类型、任意大小的数据 使用 获取session对象：HttpSession session = request.getSession(); 存储数据：session.setAttribute(&quot;name&quot;, Object); 获取数据：session.getAttribute(&quot;name&quot;); 原理：Session的实现依赖于Cookie，服务器通过Cookie确保多次请求获取的Session对象为同一个。 客户端发送请求-&gt; 服务端创建Session对象，若没有Cookie，则http响应头增加Set-Cookie：JSESSIONID=sessionID字段 -&gt; 客户端存储cookie数据 -&gt; 客户端下一次请求http请求头设置cookie -&gt; 服务器验证sessionID Tips 浏览器关闭，服务器不关闭，浏览器重启，两次获取的session对象是否相同？ 默认情况下不是。 为避免这种情况，可手动设置持久化存储JSESSIONID 123Cookie cookie &#x3D; new Cookie(&quot;JSESSIONID&quot;, session.getId());cookie.setMaxAge(60*60);&#x2F;&#x2F;持久化存储cookieresponse.addCookie(cookie); 浏览器不关闭，服务器关闭，服务器开启，两次获取的session对象是否相同？ 新对象地址与原对象不同 为避免服务器重启数据丢失，采用session的钝化和活化技术。 session钝化：在服务器正常关闭前，将session对象序列化到硬盘上 session活化：服务器启动后，将session文件转化为内存中的session对象，删除文件 Tomcat已经集成了钝化与活化技术，正常关闭tomcat后，会在work工作目录的项目文件夹下生成一个SESSIONS.ser文件 session钝化与活化不仅仅是服务器关闭时发生，当在线用户过多时，大量session对象存在于服务器内存中。为减轻服务器内存负担，当一个session长时间没有被访问，也会被序列号到磁盘上（注意session中存储的对象所在的类必须要实现序列化接口）。可在tomcat的conf/context.xml中配置。 session何时被销毁？ 服务器关闭 session对象调用invalidate()方法 session默认失效时间为30分钟(可在tomcat的conf/web.xml中配置) 123&lt;session-config&gt; &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt; &lt;&#x2F;session-config&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"Servlet","slug":"Servlet","date":"2020-04-01T08:10:10.000Z","updated":"2020-11-23T14:23:21.081Z","comments":true,"path":"JavaWeb/Servlet/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/Servlet/","excerpt":"","text":"概述 作用 调用流程 配置 Servlet生命周期 request与response对象 request对象 response对象 ServletContext对象（域对象） 页面跳转 服务端跳转 客户端跳转 Servlet自启动 Servlet映射器(Mapper)) ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序（对称） 概述作用用于处理请求与业务逻辑。 调用流程 用户访问html页面，表单提交 xml文件url-pattern与url匹配，若符合Tomcat则加载servlet-class对应的class文件进内存（反射） 实例化Servlet（class.newInstance()）得到一个Servlet对象 调用service()方法，根据表单的method，在该方法中调用doGet或doPost方法 request对象获取参数，response对象返回数据 服务器通过http协议返回数据 配置 xml配置 注解配置：Servlet3.0后支持，在Servlet类上使用@WebServlet(&quot;/URI&quot;)。 Servlet生命周期 实例化：无论访问多少次该Servlet，构造方法只执行一次，只存在一个对象（单实例） 注：多个用户同时访问时，可能存在线程安全问题。因此尽量不要在Servlet中定义成员变量。 初始化：在构造方法执行后，执行init()方法，无论访问多少次该Servlet，init()方法只执行一次。init()方法的参数ServletConfig对象实例，通过解析web.xml文件创建。 提供服务：将req和resp对象作为参数传递给service()，执行service()方法，在该方法中判断执行doGet()还是doPost() 销毁：当在server.xml的Context字段中配置了reloadable=”true”时，表示web应用有任何类型的更新都会自动重启，重启就会调用destroy()方法；tomcat服务器关闭时destroy()方法会被调用。 被回收：等待下一次GC回收 request与response对象request对象request对象用于封装请求消息数据。 获取参数： request.getParameter()：用于获取单值的参数request.getParameterValues()：用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。request.getParameterMap()：用于遍历所有的参数，并返回Map类型。 获取头信息： request.getHeader()：获取浏览器传递过来的头信息。request.getHeaderNames()：获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息 服务端传参：request.setAttribute()与request.getAttribute() 设置编码：request.setCharacterEncoding(&quot;UTF-8&quot;); 常见方法： request.getRequestURL()：浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”request.getRequestURI()：浏览器发出请求的资源名部分，去掉了协议和主机名”request.getQueryString()：请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到request.getRemoteAddr()：浏览器所处于的客户机的IP地址request.getRemoteHost()：浏览器所处于的客户机的主机名request.getRemotePort()：浏览器所处于的客户机使用的网络端口request.getLocalAddr()：服务器的IP地址request.getLocalName()：服务器的主机名request.getMethod()：得到客户机请求方式，一般是GET或者POST response对象通过response对象设置响应消息数据。 设置响应内容：response.getWriter()获取PrintWriter对象，使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。 设置响应格式与编码：response.setContentType(&quot;text/html;charset=utf-8&quot;)或response.setCharacterEncoding(&quot;UTF-8&quot;) ServletContext对象（域对象）服务器启动后自动创建，在整个Web应用的动态资源（Servlet/JSP…）之间共享数据，与servlet容器（Tomcat）通信，服务器关闭时销毁。 通过request.getServletContext()或this.getServletContext()获取 获取MIME(text/html, image/jpeg…)类型数据：getMimeType(String file) 作为域对象共享数据：setAttribute() getAttribute() removeAttribute()，共享所有用户请求的数据 获取文件的真实路径：getRealPath(String file) 页面跳转服务端跳转forward转发：request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);，服务器内部访问success.html，并将其发送给浏览器。客户端只请求一次，服务器内部跳转。 客户端跳转redirect重定向：response.sendRedirect(&quot;fail.html&quot;);，发送一条消息给浏览器让其访问fail.html，浏览器访问，服务器获取fail.html发送给浏览器。客户端一共请求了两次。 注意：由于WEB-INF目录下的页面浏览器不能访问到，因此只能通过forward转发的方式返回该页面给用户，而redirect重定向不行。 Servlet自启动假如需要在tomacat一启动就执行一些初始化的代码，比如校验数据库的完整性。但是Servlet的生命周期是在用户访问对应路径开始的，这就需要Servlet自启动，执行init()方法中的业务代码：在web.xml中增加&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;，取值范围是1-99，数字表示启动顺序，数字越小启动的优先级越高。 Servlet映射器(Mapper)每一个请求，对应的URL要交给哪一个Servlet处理，由Tomcat中的映射器Mapper类处理。 ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序（对称）ServletContext -&gt; ServletContextListener -&gt; Filter -&gt; 自启动Servlet -&gt; 浏览器请求访问普通Servlet -&gt; 销毁自启动Servlet -&gt; 销毁Filter-&gt; 销毁ServletContextListener -&gt; 销毁ServletContext","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"JSON","slug":"JSON","date":"2020-04-01T08:09:57.000Z","updated":"2020-11-23T14:23:21.024Z","comments":true,"path":"JavaWeb/JSON/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/JSON/","excerpt":"","text":"JSON简介 语法 JSON在Java中的解析 JSON简介 概念：JavaScript对象表示法(JavaScript Object Notation)。 作用：JSON是存储和交换文本信息的语法，常用于信息传输，比XML更小、更快、更易解析。 语法 基本语法： 数据由键值对构成，值的取值类型有： 整数或浮点数 字符串：&quot;string&quot; 布尔值：true/false 数组：[] 对象：{name:&quot;Tom&quot;,age:23,gender:&quot;male&quot;} null 数据由,分隔 {}保存对象，同时也定义了JSON格式 []保存数组 获取数据方式：JSON对象.键名；JSON对象[“键名”]；数组对象[索引]。 JSON在Java中的解析 Java常用的JSON解析类库：GSON, FastJson, Jackson；以Jackson为例。 Java对象转JSON 123456789101112131415161718192021222324252627public class Person&#123; private String name; private int age; private String gender; &#x2F;&#x2F;getter and setter&#125;public class JacksonTest&#123; &#x2F;&#x2F;创建Java对象 Person p &#x3D; new Person(); p.setName(&quot;Tom&quot;); p.setAge(23); p.setGender(&quot;男&quot;); &#x2F;&#x2F;创建Jackson对象 ObjectMapper mapper &#x3D; new ObjectMapper(); &#x2F;&#x2F;转换方法： &#x2F;* writeValue(args, obj): args: File:将obj对象转换为JSON字符串，并保存到指定文件； Writer:转换，并将json数据填充到字符输出流 OutputStream:转换，并将json数据填充到字节输出流 writeValueAsString(obj):将对象转换为json字符串 *&#x2F; String json &#x3D; mapper.writeValueAsString(p); &#125; 注解： @JsonIgnore：排除属性（该注解置于要忽略的属性上），指定属性不会被转换 @JsonFormat：属性值格式化（该注解置于要格式化的属性上），例@JsonFormat(pattern=&quot;yyyy-MM-dd&quot;) JSON转Java对象 123String json &#x3D; &quot;&#123;name:\\&quot;Tom\\&quot;,age:23&#125;&quot;;ObjectMapper mapper &#x3D; new ObjectMapper();Person p &#x3D; mapper.readValue(json, Person.class);","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"XML","slug":"XML","date":"2020-03-30T14:00:41.000Z","updated":"2020-11-23T14:23:21.103Z","comments":true,"path":"JavaWeb/XML/","link":"","permalink":"http://thmasterplan.cn/JavaWeb/XML/","excerpt":"","text":"概念 功能 语法 约束 概念扩展标记语言（Extensible Markup Language），标签可自定义。 功能 用于存储与传输数据 配置文件 在网络中传输 语法 基本语法： 第一行必须定义为文档声明，例如&lt;? xml version=&#39;1.0&#39; ?&gt;。 xml文档中有且仅有一个根标签 属性值必须用使用引号 标签必须正确关闭 标签名称严格区分大小写 例： 12345678910111213 &lt;?xml version&#x3D;&#39;1.0&#39; ?&gt; &lt;users&gt; &lt;user id&#x3D;&#39;1&#39;&gt; &lt;name&gt;Tom&lt;&#x2F;name&gt; &lt;age&gt;23&lt;&#x2F;age&gt; &lt;br&#x2F;&gt; &lt;&#x2F;user&gt; &lt;user id&#x3D;&#39;2&#39;&gt; &lt;name&gt;Lisa&lt;&#x2F;name&gt; &lt;age&gt;20&lt;&#x2F;age&gt; &lt;&#x2F;user&gt;&lt;&#x2F;users&gt; 组成部分： 文档声明：&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt; 标签：自定义标签 属性：id属性值唯一 文本 XML命名空间（XML Namespaces）：提供避免元素命名冲突的方法，比如不同的两个XML被同时使用，且他们有一个相同的标签时，可通过命名空间避免冲突。 XML命名空间属性被放置于元素的开始标签中，语法为xmlns:namespace-prefix=&#39;namespaceURI&#39; 当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联 约束 约束：规定xml文档的书写规则。一般来说，框架提供约束，框架使用者按照约束来编写xml。 DTD：简单的约束技术，文件后缀为.dtd &lt;!ELEMENT &gt;定义标签，&lt;!ATTLIST &gt;定义属性，()定义子标签 约束内容例： 123456&lt;!ELEMENT students (student*)&gt;&lt;!ELEMENT student (name,age,sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt; 引入dtd文档到xml中 内部dtd：将约束规则定义在xml文档中 &lt;!DOCTYPE 根标签名 [约束内容] &gt; 外部dtd：将约束规则定义在外部的dtd文件中 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的绝对路径&quot;&gt; 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;URL路径&quot;&gt; Schema：复杂的约束技术，本质上就是xml，文件后缀为.xsd 可定义xml中文本的类型，文本取值的范围，标签出现的顺序等 引入.xsd约束文件到xml 引入无命名空间的.xsd 1234567&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xsi:noNamespaceSchemaLocation&#x3D;&quot;无命名空间XSD文件的URI&quot;&gt;&lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，通过xsi命名空间下的属性noNamespaceSchemaLocation指定XSD文件的URI--&gt;&lt;&#x2F;root&gt; 引入有命名空间的.xsd 1234567891011&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; xmlns:ns1&#x3D;&quot;前缀ns1对应命名空间&quot; xmlns:ns2&#x3D;&quot;前缀ns2对应命名空间&quot; xsi:schemaLocation&#x3D;&quot;ns1前缀对应命名空间 前缀ns1对应命名空间XSD文件的URI ns2前缀对应命名空间 前缀ns2对应命名空间XSD文件的URI&quot;&gt; &lt;!-- 1.第一步，添加xmlns:xsi属性，引入xsi命名空间 2.第二步，添加命名空间，可添加多个，但没有前缀的命名空间最多只能有1个 3.第三步，通过xsi命名空间下的属性schemaLocation指定每个命名空间XSD文件的URI，命名空间和相应URI一一对应，多个命名空间用空格分隔 --&gt; &lt;&#x2F;root&gt;","categories":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/categories/JavaWeb/"}],"tags":[{"name":"JavaWeb","slug":"JavaWeb","permalink":"http://thmasterplan.cn/tags/JavaWeb/"}]},{"title":"动态规划入门","slug":"动态规划入门","date":"2020-03-28T13:38:15.000Z","updated":"2020-11-23T14:23:21.106Z","comments":true,"path":"数据结构与算法/动态规划入门/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/","excerpt":"","text":"动态规划题目特点 计数 lintcode114 求最值 lintcode669 求存在性 lintcode116 动态规划组成部分 常见动态规划类型 动态规划题目特点计数 有多少种方式走到右下角 有多少种方法选出k个数使得和为Sum lintcode114123456789101112131415161718192021public class Solution &#123; /** * @param m: positive integer (1 &lt;= m &lt;= 100) * @param n: positive integer (1 &lt;= n &lt;= 100) * @return: An integer */ public int uniquePaths(int m, int n) &#123; // write your code here int[][] dp = new int[m][n];//dp[i][j]表示机器人有多少种方式从左上角走到(i,j) //dp[i][j] = dp[i-1][j]+dp[i][j-1] for(int i = 0; i &lt; m; ++i)&#123; for(int j = 0; j &lt; n; ++j)&#123; if(i == 0 || j == 0) dp[i][j] = 1;//第0行(列)的所有格子都只有一种方式到达 else dp[i][j] = dp[i-1][j] + dp[i][j-1]; &#125; &#125; return dp[m-1][n-1]; &#125;&#125; 求最值 从左上角走到右下角路径的最大数字和 最长上升序列长度 lintcode6691234567891011121314151617181920212223242526public class Solution &#123; /** * @param coins: a list of integer * @param amount: a total amount of money amount * @return: the fewest number of coins that you need to make up */ public int coinChange(int[] coins, int amount) &#123; int[] dp = new int[amount+1];//记录组成从0-amount分别需要的最少的硬币数 dp[0] = 0; for(int i = 1; i &lt;= amount; ++i)&#123; dp[i] = Integer.MAX_VALUE;//表示不存在组成i所需要的最少硬币数,同时看作min变量，储存dp[i-coins[j]]+1,j=1,2...中的最小值 for(int j = 0; j &lt; coins.length; ++j)&#123; if(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != Integer.MAX_VALUE &amp;&amp; dp[i-coins[j]]+1 &lt; dp[i])&#123; dp[i] = dp[i-coins[j]] + 1;//组成总数为i需要的最少的硬币数为：组成总数为i-coins[j],j=1,2...coins.length需要的最少硬币数中最小的一个,再加1 &#125; &#125; &#125; if(dp[amount] == Integer.MAX_VALUE) return -1; else return dp[amount]; &#125; &#125; 求存在性 取石子游戏，先手是否必胜 能不能选出k个数使得和为Sum lintcode1161234567891011121314151617181920212223242526272829303132333435363738394041424344public class Solution &#123; /** * @param A: A list of integers * @return: A boolean */ //动态规划 public boolean canJump(int[] A)&#123; if(A == null || A.length == 0) return false; int len = A.length; boolean[] dp = new boolean[len]; dp[0] = true; //思路:最后一步A[len-1]可达，当且仅当前面某个下标i可达且i+A[i]&gt;=A[len-1]；推广到对任意j = 1,2,...len-1，i &lt; j都必须满足dp[i] &amp;&amp; i + A[i] &gt;= j for(int j = 1; j &lt; len; ++j)&#123; dp[j] = false; for(int i = 0; i &lt; j; ++i)&#123; if(dp[i] &amp;&amp; i + A[i] &gt;= j)&#123;//状态方程：能够到达i，并且i+A[i]&gt;=j即表示从i能到达j dp[j] = true; break; &#125; &#125; &#125; return dp[len-1]; &#125; //贪心算法 public boolean canJumpGreedy(int[] A) &#123; //[3,2,1,0,4] if(A == null || A.length == 0) return false; int farthest = A[0];//farthest变量记录当前能够到达的最远距离 for(int i = 1; i &lt; A.length; ++i)&#123; if(farthest &lt; i) return false;//farthest比i小，表示不能到达i，return false else farthest = i + A[i] &gt; farthest ? i + A[i] : farthest;//更新farthest &#125; return true; &#125;&#125; 动态规划组成部分 确定状态：创建数组，数组的每个元素代表什么？ 两个要点：最后一步；子问题。 递归算法的问题：重复计算，效率低下 转移方程：根据子问题定义得到。将计算结果保存下来，并改变计算顺序，空间换时间 初始条件和边界情况 计算顺序：利用之前的计算结果 常见动态规划类型 坐标型 序列型 划分型 区间型 背包型 最长序列型 博弈型","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"反编译及助记符","slug":"反编译及助记符","date":"2020-03-26T06:11:57.000Z","updated":"2020-11-23T14:23:21.113Z","comments":true,"path":"JVM/反编译及助记符/","link":"","permalink":"http://thmasterplan.cn/JVM/%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6/","excerpt":"","text":"JVM参数，均以-XX:开始，其中-XX:+&lt;option&gt;，表示开启option选项；-XX:-&lt;option&gt;，表示关闭option选项；-XX:&lt;option&gt;=&lt;value&gt;，表示将option选项的值设置为value。 -XX:+TraceClassLoading，用于追踪类的加载信息并打印。 反编译.class文件：javap -c 全类名 反编译代码助记符： getstatic：获取类的静态字段 ldc：表示将int, float或是String类型的常量值从常量池推送至栈顶 bipush：表示将单字节（-128-127）的常量值从常量池推送至栈顶 sipush：表示将一个短整型（-32768—32767）常量值推送至栈顶 iconst_1：表示将int类型的1推送至栈顶（iconst_0 - iconst_5） anewarray：创建一个引用类型数组，并将其引用值压入栈顶 newarray：创建一个基本类型的数组，并将其引用值压入栈顶 数组创建本质：new一个数组，对于数组实例来说，其类型是由JVM在运行期间动态生成的，动态生成的类型其父类为Object。","categories":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/categories/JVM/"}],"tags":[{"name":"JVM","slug":"JVM","permalink":"http://thmasterplan.cn/tags/JVM/"}]},{"title":"贪心","slug":"贪心","date":"2020-03-26T06:11:35.000Z","updated":"2020-11-23T14:23:21.138Z","comments":true,"path":"数据结构与算法/贪心/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E8%B4%AA%E5%BF%83/","excerpt":"","text":"解决贪心问题的步骤 经典例题 leetcode455：分发饼干 leetcode435：无重叠区间 leetcode452：用最少数量的箭引爆气球 leetcode406：根据身高重建队列 leetcode121：买卖股票的最佳时机 leetcode122：买卖股票的最佳时机2 leetcode605：种花问题 leetcode392：判断子序列 leetcode53：最大子数组和 leetcode763：划分字母区间 解决贪心问题的步骤 将原问题分解为子问题 找出贪心策略（寻找局部最优解） 得到每一个子问题的最优解 将所有局部最优解的集合构成称为原问题的一个解 经典例题leetcode455：分发饼干123456789101112131415class Solution &#123; public int findContentChildren(int[] g, int[] s) &#123; int child = 0; int cookie = 0; Arrays.sort(g); //先将饼干 和 孩子所需大小都进行排序 Arrays.sort(s); while (child &lt; g.length &amp;&amp; cookie &lt; s.length )&#123; //当其中一个遍历就结束 if (g[child] &lt;= s[cookie])&#123; //当用当前饼干可以满足当前孩子的需求，可以满足的孩子数量+1 child++; &#125; cookie++; // 饼干只可以用一次，因为饼干如果小的话，就是无法满足被抛弃，满足的话就是被用了 &#125; return child; &#125;&#125; leetcode435：无重叠区间123456789101112131415161718192021222324class Solution &#123; //思路：按区间开始处升序排序后，尽量保留结尾小的 public int eraseOverlapIntervals(int[][] intervals) &#123; if (intervals.length == 0) return 0; Arrays.sort(intervals, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] - o2[0]; &#125; &#125;);//按照区间开始升序排序 int prev = 0, count = 0;//变量prev保存遍历时的前一个区间 for (int i = 1; i &lt; intervals.length; i++) &#123; if (intervals[prev][1] &gt; intervals[i][0]) &#123;//前一个区间的结尾&gt;后一个区间的开始，表明有重叠 if (intervals[prev][1] &gt; intervals[i][1]) prev = i;//前一个区间的结尾&gt;后一个区间的结尾，表明前一个区间覆盖后一个区间，删除结尾大的区间 count++; &#125; else prev = i;//无重叠 &#125; return count; &#125;&#125; leetcode452：用最少数量的箭引爆气球1234567891011121314151617181920212223class Solution &#123; //类似于435，删除k个区间后便无重叠区间，则该题答案为n-k，n为总区间个数 public int findMinArrowShots(int[][] points) &#123; if(points.length == 0) return 0; Arrays.sort(points, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] point1, int[] point2)&#123; return point1[0] - point2[0]; &#125; &#125;);//升序排序 int prev = 0, count = 0; for(int i = 1; i &lt; points.length; i++)&#123; if(points[prev][1] &gt;= points[i][0] )&#123; if(points[prev][1] &gt; points[i][1]) prev = i; count++; &#125;else prev = i; &#125; return points.length - count; &#125;&#125; leetcode406：根据身高重建队列123456789101112131415161718192021222324//将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。//按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。//直到完成为止。class Solution &#123; //1.排序：按高度降序排列；在同一高度的人中，按 k 值的升序排列。 //2.逐个地把它们放在输出队列中，索引等于它们的 k 值。 //3.返回输出队列 public int[][] reconstructQueue(int[][] people) &#123; Arrays.sort(people, new Comparator&lt;int[]&gt;()&#123; @Override public int compare(int[] o1, int[] o2)&#123; return o1[0] == o2[0] ? o1[1] - o2[1]: o2[0] - o1[0]; &#125; &#125;); List&lt;int[]&gt; list = new LinkedList&lt;&gt;(); for(int[] p : people)&#123; list.add(p[1],p); &#125; return list.toArray(new int[people.length][2]); &#125;&#125; leetcode121：买卖股票的最佳时机12345678910111213class Solution &#123; public int maxProfit(int prices[]) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, min = prices[0];//min记录前面的最小价格 for(int i = 1; i &lt; prices.length; i++)&#123; int profit = prices[i] - min;//利润等于当前价格减去最小价格 result = result &gt; profit ? result : profit;//更新最大利润 min = prices[i] &gt; min ? min : prices[i];//每一天更新最小价格 &#125; return result; &#125;&#125; leetcode122：买卖股票的最佳时机2123456789101112131415class Solution &#123; public int maxProfit(int[] prices) &#123; if(prices.length == 0 || prices.length == 1) return 0; int result = 0, buy = prices[0]; for(int i = 1; i &lt; prices.length; i++)&#123; if(prices[i] &lt; prices[i-1]) buy = prices[i];//股票降了，抄底买入 else&#123; result += prices[i] - buy;//股票涨的阶段，卖掉前一天的股票 buy = prices[i];//买入当天的股票，利润最大化 &#125; &#125; return result; &#125;&#125; leetcode605：种花问题1234567891011121314public class Solution &#123; public boolean canPlaceFlowers(int[] flowerbed, int n) &#123; int i = 0; while (i &lt; flowerbed.length) &#123; if (flowerbed[i] == 0 &amp;&amp; (i == 0 || flowerbed[i - 1] == 0) &amp;&amp; (i == flowerbed.length - 1 || flowerbed[i + 1] == 0)) &#123;//数组元素为0，并且其左右两边均为0，或者该数组下标位于首（尾） flowerbed[i++] = 1; n--; &#125; if(n &lt;= 0) return true; i++; &#125; return false; &#125;&#125; leetcode392：判断子序列1234567891011121314class Solution &#123; public boolean isSubsequence(String s, String t) &#123; int sLen = s.length(); if(sLen == 0) return true; int j = 0; for(int i = 0; i &lt; t.length(); i++)&#123; if(j &lt; sLen &amp;&amp; t.charAt(i) == s.charAt(j)) j++; if(j == sLen) return true; &#125; return false; &#125;&#125; leetcode53：最大子数组和1234567891011class Solution &#123; public int maxSubArray(int[] nums) &#123; int currMaxSum = nums[0], maxSum = nums[0]; for(int i = 1; i &lt; nums.length; ++i) &#123; currMaxSum = Math.max(nums[i], currMaxSum + nums[i]);//计算以当前元素nums[i]为终点的所有的子数组的最大和 maxSum = Math.max(maxSum, currMaxSum);//maxSum是所有currMaxSum中的最大值 &#125; return maxSum; &#125;&#125; leetcode763：划分字母区间123456789101112131415161718192021class Solution &#123; public List&lt;Integer&gt; partitionLabels(String S) &#123; int[] last = new int[26];//定义一个大小为26的数组，用于存储每个字母最后一次出现的下标 for(int i = 0; i &lt; S.length(); ++i)&#123; last[S.charAt(i) - 'a'] = i;//遍历字符串，更新每个字符的下标 &#125; int start = 0, end = 0; List&lt;Integer&gt; res = new ArrayList&lt;&gt;(); for(int i = 0; i &lt; S.length(); ++i)&#123; end = Math.max(end, last[S.charAt(i) - 'a']);//遍历字符串时扩展区间末端end if(i == end)&#123;//当前下标等于区间末端end时，为一次划分，更新start=end+1 res.add(end-start+1); start = end+1; &#125; &#125; return res; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"注解","slug":"注解","date":"2020-03-25T09:58:33.000Z","updated":"2020-11-23T14:23:21.131Z","comments":true,"path":"Java/注解/","link":"","permalink":"http://thmasterplan.cn/Java/%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"注解（Annotation），也叫元数据，JDK1.5后引入的特性，与类、接口、枚举在同一层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用于对这些元素进行说明。 定义注解 -&gt; 使用注解 -&gt;读取注解 作用分类 编写文档 ：命令行输入javadoc xxx.java，通过代码里标识的注解自动生成doc文档 代码分析：通过代码里标识的注解对代码进行分析（使用反射机制） 编译检查 ：编译器对代码进行编译检查 JDK预定义的注解 @Override：检测被注解的方法是否继承自父类（接口） @Deprecated：被注解的内容已过时，不建议使用 @SuppressWarnings：压制警告，一般传递参数all 自定义注解 注解通过@interface定义，例如public @interface MyAnnotation{} 本质是接口：public interface MyAnnotation extends java.lang.annotation.Annotation{} 注解的属性：接口中的抽象方法 属性的返回值类型 基本数据类型 String 枚举 注解 以上类型的数组 使用注解时，需要对属性赋值，例@SuppressWarning(&quot;all&quot;)；亦可以在定义注解时使用default设置默认值，使用时就不用赋值；如果只有一个属性需要赋值，且属性名为value，则value可以省略可直接赋值，上述压制警告就是这种情形。 123public @interface MyAnno&#123; int a() default 5; &#125; 元注解：可以注释到注解上的注解，一共有五种。 @Retention：描述注解被保留的阶段 12345public enum RetentionPolicy&#123; SOURCE,//注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视 CLASS,//注解只被保留到编译进行的时候，它并不会被加载到 JVM 中 RUNTIME//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时才能获取到它们（常用）&#125; 使用示例： 123@Retention(RetentionPolicy.RUNTIME)public @interface MyAnno&#123;&#125; @Documented：描述注解是否被抽取到doc文档中 @Target：当一个注解被 @Target 注解时，这个注解就被限定了运用的场景 ElementType.ANNOTATION_TYPE：可以给一个注解进行注解 ElementType.CONSTRUCTOR：可以给构造方法进行注解 ElementType.FIELD：可以给成员变量进行注解 ElementType.LOCAL_VARIABLE：可以给局部变量进行注解 ElementType.METHOD：可以给方法进行注解 ElementType.PACKAGE：可以给一个包进行注解 ElementType.PARAMETER：可以给一个方法内的参数进行注解 ElementType.TYPE：可以给一个类型进行注解，比如类、接口、枚举 @Inherited：描述注解是否被子类继承 @Repeatable 在程序中使用（解析）注解：获取注解中定义的属性值 例如在反射中的自定义框架，使用注解后便不需要使用配置文件传参数，通过更改注解的属性值即可实现创建不同的对象、使用对象的方法。 1234567891011121314151617package annotation;import java.lang.annotation.ElementType;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;/** * 描述需要执行的类名和方法名 * */@Target(ElementType.TYPE)@Retention(RetentionPolicy.RUNTIME)public @interface Pro &#123; String className(); String methodName();&#125; 12345678910111213141516171819202122232425262728293031package annotation;import java.lang.reflect.Constructor;import java.lang.reflect.Method;@Pro(className = \"model.Person\",methodName=\"eat\")public class MyFrame2 &#123; public static void main(String[] args) throws Exception &#123; //1.获取注解对象 Class&lt;MyFrame2&gt; myFrame2Class = MyFrame2.class; Pro anno = myFrame2Class.getAnnotation(Pro.class);//在内存中生成了一个该注解接口的子类的实现对象 //2.调用注解对象中定义的抽象方法，获取返回值 String className = anno.className(); String methodName = anno.methodName(); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance(); Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125; 使用注解方式创建DBUtil工具类（降低耦合度） 1234567891011121314151617181920212223package anno;import static java.lang.annotation.ElementType.METHOD;import static java.lang.annotation.ElementType.TYPE;import java.lang.annotation.Documented;import java.lang.annotation.Inherited;import java.lang.annotation.Retention;import java.lang.annotation.RetentionPolicy;import java.lang.annotation.Target;@Target(&#123;METHOD,TYPE&#125;)@Retention(RetentionPolicy.RUNTIME)@Inherited@Documentedpublic @interface JDBCConfig &#123; String ip(); int port() default 3306; String database(); String encoding(); String loginName(); String password(); &#125; 12345678910111213141516171819202122232425262728293031323334353637package util;import java.sql.Connection;import java.sql.DriverManager;import java.sql.SQLException;import anno.JDBCConfig;@JDBCConfig(ip = \"127.0.0.1\", database = \"test\", encoding = \"UTF-8\", loginName = \"root\", password = \"admin\")public class DBUtil &#123; static &#123; try &#123; Class.forName(\"com.mysql.jdbc.Driver\"); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125; public static Connection getConnection() throws SQLException, NoSuchMethodException, SecurityException &#123; JDBCConfig config = DBUtil.class.getAnnotation(JDBCConfig.class);//通过反射获取DBUtil类上的注解对象 String ip = config.ip(); int port = config.port(); String database = config.database(); String encoding = config.encoding(); String loginName = config.loginName(); String password = config.password(); String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding); return DriverManager.getConnection(url, loginName, password); &#125; public static void main(String[] args) throws NoSuchMethodException, SecurityException, SQLException &#123; Connection c = getConnection(); System.out.println(c); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"反射","slug":"反射","date":"2020-03-24T09:08:10.000Z","updated":"2020-11-23T14:23:21.109Z","comments":true,"path":"Java/反射/","link":"","permalink":"http://thmasterplan.cn/Java/%E5%8F%8D%E5%B0%84/","excerpt":"","text":"概述 反射概念 Class类 反射的使用 获取Class类对象 Constructor Field Method 练习 概述反射概念 反射就是把Java类中的各个成分（成员变量、构造器、成员方法）映射成一个个的Java对象。 在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个属性和方法；这种动态获取的信息以及动态调用对象的方法的功能称为Java语言的反射机制。 反射的好处：解耦，提高程序的可扩展性。（例如Spring框架的依赖注入） Class类 Class类存在于JDK的java.lang包中，手动编写的类被编译后会产生一个Class对象，其表示的是创建的类的信息，这个Class对象保存在同名.class的文件中。Class类的对象作用是运行时提供或获得某个对象的类型信息。 反射的使用获取Class类对象 Class对象中将类的成员变量封装到Field[]中，将类的构造方法封装到Constructor[]中，将类的方法封装到Method[]中。 三种方式 Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。此种方式多用于配置文件，将类名定义在配置文件中，通过读取文件加载类。 类名.class：通过类名的class属性获取。多用于参数的传递。 对象.getClass() ：getClass()方法在Object类中定义。通过对象获取类的字节码。 注：不论使用哪种方式，同一个.class文件在一次程序运行中只会被加载一次，因此在一次运行中即使使用三种方式各获取一次，获取的都是同一个对象。 注：获取类的Class对象是Java程序对类的主动使用，会初始化该类（静态代码块，静态变量）。 注：静态synchronized方法的同步对象是：静态同步方法所在类的Class对象。 Class类的一些方法 getName(): 获取全类名 getSimpleName(): 获取类名 newInstance(): 创建实例化对象 Constructor Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。 通过类的Class对象的方法获取Constructor对象： Constructor&lt;?&gt; [] getConstructors(): 返回所有public修饰的Constructor对象的数组 Constructor&lt;?&gt; [] getDeclaredConstructors(): 返回所有的Constructor对象的数组 Constructor getConstructor(Class&lt;?&gt;… parameterTypes): 返回指定参数类型、public修饰的Constructor对象 Constructor getDeclaredConstructor(Class&lt;?&gt;… parameterTypes): 返回指定参数类型的所有Constructor对象 Constructor对象本身的方法 String getName(): 获取构造方法名称 T newInstance(): 创建实例化对象。Class对象的newInstance()方法也是调用构造器对象的该方法。 Field Field类提供有关类或接口的单个字段的信息，以及对它的动态访问权限。 通过类的Class对象的方法获取Field对象： Field[] getFields(): 只获取public修饰的Field字段, 包括继承自父类的字段 Field[] getDeclaredFields(): 获取类的所有字段，但是不包括继承自父类的 Field getField(String name): 获取指定的public修饰的字段，包括继承字段 Field getDeclaredFields(String name): 获取指定的字段，不包括继承字段 Field对象本身的方法 void set(Object obj, Object value): 设置指定对象上此字段的新值 Object get(Object obj): 返回指定对象上此字段的值 Class&lt;?&gt; getType(): 返回一个Class对象，它标识了此Field表示字段的声明类型 String getName(): 返回此Field对象表示的字段的名称 void setAccessible(boolean flag): 设置该字段是否可被访问。对于getDeclaredFields()和getDeclaredFields(String name)方法来说，若返回的Field中有由private修饰的字段，那么需要field.setAccessible(true)以表示其可以被访问。（暴力反射） Method Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。 通过类的Class对象的方法获取Method对象： Method[] getMethods(): 返回public修饰的方法对应Method的数组，包括继承自父类的 Method[] getDeclaredMethods(): 返回所有的方法对应Method的数组，不包括继承的 Method getMethod(String name, Class&lt;?&gt; …parameterTypes): 返回指定名称和参数列表的public修饰的方法对应Method Method getDeclaredMethod(String name, Class&lt;?&gt;… parameterTypes): 返回指定名称和参数列表的方法对应Method Method对象本身的方法 Object invoke(Object obj, Object… args): 对指定对象调用此Method表示的方法 Class&lt;?&gt; getReturnType(): 返回的Class对象描述了此Method表示方法的返回类型 String getName(): 返回Method 对象表示的方法名称，即返回方法的名称 练习写一个“框架”，可以创建任意类的对象，并能够执行其中任意方法 思路：使用反射，不需要更改框架的代码，只需更改配置文件的参数，就可以体现泛用性。（平时创建不同的对象是需要不同的代码的，比如 new Person(), new Student()） 步骤：1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中 ​ 2.在框架程序中读取配置文件 ​ 3.使用反射技术来加载要创建的对象的类文件进内存 ​ 4.创建对象（使用newInstance()方法） ​ 5.执行方法（使用invoke()方法） 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647package reflect;import java.io.InputStream;import java.lang.reflect.Constructor;import java.lang.reflect.Method;import java.util.Properties;public class MyFrame &#123; public static void main(String[] args) throws Exception &#123; //1.加载配置文件 Properties properties = new Properties(); ClassLoader classLoader = MyFrame.class.getClassLoader(); InputStream iStream = classLoader.getResourceAsStream(\"pro.properties\"); properties.load(iStream); //2.获取配置文件中定义的数据 String className = properties.getProperty(\"className\"); String methodName = properties.getProperty(\"methodName\"); //3.加载类进入内存 Class&lt;?&gt; cls = Class.forName(className); //4.创建对象 //Object object = cls.newInstance();本质仍然是调用Constructor对象的newInstance()方法 Constructor&lt;?&gt; c = cls.getConstructor(); Object object = c.newInstance(); //5.获取Method对象 Method method = cls.getMethod(methodName); //6.执行方法 method.invoke(object); &#125;&#125;//Person类package model;public class Person &#123; public void eat() &#123; System.out.println(\"eating...\"); &#125;&#125;//pro.properties配置文件内容className=model.PersonmethodName=eat","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"JDBC","slug":"JDBC","date":"2020-03-07T08:01:05.000Z","updated":"2020-11-23T14:23:21.020Z","comments":true,"path":"Java/JDBC/","link":"","permalink":"http://thmasterplan.cn/Java/JDBC/","excerpt":"","text":"概念 基础 PreparedStatement execute/executeQuery/executeUpdate 获取自增长ID 使用事务 概念官方定义的一套操作所有关系型数据库的接口，各个数据库厂商实现这套接口，提供数据库驱动jar包。 ORM：Object Relationship Database Mapping，即对象与关系数据库的映射，对象中的各成员变量值与关系数据库里一条记录相对应。 DAO：Database Access Object，数据库访问对象，把对数据库某张表相关的操作都封装在这个类里面 基础初始化驱动类：Class.forName(&quot;com.mysql.jdbc.Driver&quot;); 建立与数据库的连接： 123456789static String ip = \"127.0.0.1\";static int port = 3306;static String database = \"tmall\";static String encoding = \"UTF-8\";static String loginName = \"root\";static String password = \"admin\";//mysql数据库url写法：jdbc:mysql://ip:端口号/数据库名称String url = String.format(\"jdbc:mysql://%s:%d/%s?characterEncoding=%s\", ip, port, database, encoding);Connection connection = DriverManager.getConnection(url, loginName, password); 创建Statement并执行sql语句： 123Statement statement = connection.createStatement();String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\";statement.execute(sql); 使用try-with-resource自动关闭连接： 123456try (Connection connection = DriverManager.getConnection(url, loginName, password);Statement statement = c.createStatement();)&#123; String sql = \"insert into tableName values(null,\" + \"'test'\" + \",\" + 20 + \")\"; statement.execute(sql); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; PreparedStatement12345678910111213String sql = \"insert into hero values(null,?,?,?)\";try (Connection c = DriverManager.getConnection(\"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8\",\"root\", \"admin\"); // 根据sql语句创建PreparedStatement PreparedStatement ps = c.prepareStatement(sql);) &#123; // 设置参数 ps.setString(1, \"提莫\"); ps.setFloat(2, 313.0f); ps.setInt(3, 50); // 执行 ps.execute(); &#125; catch (SQLException e) &#123; e.printStackTrace(); &#125; 使用预编译statement优点： 参数设置，可读性好，不需要进行字符串拼接 预编译机制性能比Statement好 可防止SQL注入攻击 execute/executeQuery/executeUpdate executeQuery: 返回一个结果集，这个方法用来执行select语句. 12345678ResultSet rs = statement.executeQuery(sql);while (rs.next()) &#123; int id = rs.getInt(\"id\");// 可以使用字段名 String name = rs.getString(2);// 也可以使用字段的顺序 float hp = rs.getFloat(\"hp\"); int damage = rs.getInt(4); System.out.printf(\"%d\\t%s\\t%f\\t%d%n\", id, name, hp, damage); &#125; executeUpdate:用于执行insert，delete，update等SQL语句，executeupdate返回的值是一个整数，表示受影响的行数，对于create table等不操作行的语句，executeupdate的返回值为0。 execute: 可执行任何sql语句，其返回值为布尔类型，是true时，表示执行的是查询语句，可以通过getResultSet方法获取结果；返回值为false时，执行的是更新语句或DDL语句，getUpdateCount方法获取更新的记录数量 获取自增长ID在执行完插入语句后，为获取新增记录的id 1234567// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id// JDBC通过getGeneratedKeys获取该idResultSet rs = prepareStatement.getGeneratedKeys();if (rs.next()) &#123; int id = rs.getInt(1); System.out.println(id);&#125; 使用事务在mysql中，只有当表的类型是innodb时才支持事务 12345connection.setAutoCommit(false);//事务代码块connection.commit();//回滚事务:connection.rollback()","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"字符串","slug":"字符串","date":"2020-02-15T11:33:53.000Z","updated":"2020-11-23T14:23:21.115Z","comments":true,"path":"数据结构与算法/字符串/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%AD%97%E7%AC%A6%E4%B8%B2/","excerpt":"","text":"leetcode面试题01.09.字符串轮转 leetcode面试题58 - ll左旋转字符串（类似于189.旋转数组） leetcode151：翻转字符串里的单词 leetcode242：有效的字母异位词 leetcode409：最长回文串 leetcode205：同构字符串 leetcode9：回文数 leetcode696：计数二进制子串 leetcode面试题01.09.字符串轮转给定两个字符串s1和s2，请编写代码检查s2是否为s1旋转而成（比如，waterbottle是erbottlewat旋转后的字符串）。（同leetcode：796） 12345678910111213141516171819202122232425262728class Solution &#123; //只需要判断s2是否是s1s1的子串，并且s2.length == s1.length两个条件即可。 public boolean isFlipedString(String s1, String s2) &#123; if(s1.length() != s2.length()) return false;//长度不相等直接返回false else if(s1.length() == 0) return true;//长度相等但是都为空，返回true String s1s1 = s1+s1; if(isSubString(s1s1, s2)) return true;//判断s2是否为s1+s1的子串，是则为true return false; &#125; private boolean isSubString(String s1, String s2)&#123; int i = 0, j = 0; while(i &lt; s1.length())&#123; int k = i; while(k &lt; s1.length() &amp;&amp; j &lt; s2.length() &amp;&amp; s1.charAt(k) == s2.charAt(j) )&#123; k++; j++; &#125; if(j == s2.length()) return true; else j = 0; i++; &#125; return false; &#125;&#125;//一行代码版：//return s1.length() == s2.length &amp;&amp; (s1+s1).indexOf(s2) != -1; leetcode面试题58 - ll左旋转字符串（类似于189.旋转数组）12输入: s &#x3D; &quot;abcdefg&quot;, k &#x3D; 2输出: &quot;cdefgab&quot; 1234567891011121314151617class Solution &#123; public String reverseLeftWords(String s, int n) &#123; char[] chars = s.toCharArray(); reverseString(chars, 0, n-1); reverseString(chars, n, chars.length-1); reverseString(chars, 0, chars.length-1); return new String(chars); &#125; private void reverseString(char[] s, int start, int end)&#123; while(start &lt; end)&#123; char temp = s[start]; s[start++] = s[end]; s[end--] = temp; &#125; &#125;&#125; leetcode151：翻转字符串里的单词12输入: &quot; a good example &quot;输出: &quot;example good a&quot; 123456789101112131415161718192021222324252627282930//翻转每个单词后再翻转整个字符串class Solution &#123; public String reverseWords(String s) &#123; s = s.trim();//去除首尾空格 s = s.replaceAll(\"\\\\s+\", \" \");//去除多余空格 char[] chars = s.toCharArray(); int i = 0, start = 0; while(i &lt; chars.length)&#123;//遇到空格即翻转每个单词 if(chars[i] == ' ')&#123; reverse(chars, start, i-1); start = i+1; &#125; i++; &#125; reverse(chars, start, --i);//翻转最后一个单词 reverse(chars, 0, i);//翻转整个字符串 return new String(chars); &#125; private void reverse(char[] c, int start, int end)&#123; while(start &lt; end)&#123; char temp = c[start]; c[start++] = c[end]; c[end--] = temp; &#125; &#125;&#125; leetcode242：有效的字母异位词12345678910111213141516171819202122232425262728293031323334353637class Solution &#123; public boolean isAnagram(String s, String t) &#123; if(s.length() != t.length()) return false; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125; for(char c : t.toCharArray())&#123; if(!charFrequency.containsKey(c)) return false; else charFrequency.put(c, charFrequency.get(c)-1); &#125; for( char c : charFrequency.keySet())&#123; if(charFrequency.get(c) != 0) return false; &#125; return true; &#125; /* 用数组实现更快 public boolean isAnagram(String s, String t) &#123; int[] cnts = new int[26]; for (char c : s.toCharArray()) cnts[c - 'a']++; for (char c : t.toCharArray()) cnts[c - 'a']--; for (int cnt : cnts) if (cnt != 0) return false; return true; &#125; */&#125; leetcode409：最长回文串1234567891011121314151617181920212223242526272829303132class Solution &#123; //使用数组 public int longestPalindrome(String s) &#123; int[] charFrequency = new int[256]; for (char c : s.toCharArray()) charFrequency[c]++; int result = 0; for (int freq : charFrequency) result += (freq / 2) * 2; return result == s.length() ? result : result+1; &#125; &#125;/* 使用哈希表 public int longestPalindrome(String s) &#123; Map&lt;Character, Integer&gt; charFrequency = new HashMap&lt;&gt;(); for(char c : s.toCharArray())&#123; if(!charFrequency.containsKey(c)) charFrequency.put(c, 1); else charFrequency.put(c, charFrequency.get(c)+1); &#125;//HashMap记录所有字母的频率 int result = 0; for(char c : charFrequency.keySet())&#123; int freq = charFrequency.get(c); result += (freq/2)*2;//为偶数则直接加，为奇数则-1 &#125; return result == s.length() ? result : result+1; &#125;*/ leetcode205：同构字符串123456789101112131415161718class Solution &#123; public boolean isIsomorphic(String s, String t) &#123; return isIsomorphicSinglePass(s, t) &amp;&amp; isIsomorphicSinglePass(t, s); //必须双向验证 //例如\"bar\" -&gt; \" foo\"满足唯一映射，但是反之则不满足 &#125; //单方向判断s -&gt; t, s中的每个字母是否唯一映射t中的每个字母 private boolean isIsomorphicSinglePass(String s, String t)&#123; Map&lt;Character, Character&gt; map = new HashMap&lt;&gt;(); for(int i = 0; i &lt; s.length(); i++)&#123; char charS = s.charAt(i); char charT = t.charAt(i); if(!map.containsKey(charS)) map.put(charS, charT); else if(map.get(charS) != charT) return false; &#125; return true; &#125;&#125; leetcode9：回文数1234567891011121314151617class Solution &#123; public boolean isPalindrome(int x) &#123; if(x == 0) return true; if(x &lt; 0 || x % 10 == 0) return false; return x == reverse(x); &#125; //反转整数 private int reverse(int x)&#123; int result = 0; while(x &gt; 0)&#123; result = result*10; result += x%10; x = x/10; &#125; return result; &#125;&#125; leetcode696：计数二进制子串123输入: &quot;00110011&quot;输出: 6解释: 有6个子串具有相同数量的连续1和0：“0011”，“01”，“1100”，“10”，“0011” 和 “01”。 123456789101112131415161718class Solution &#123; //先统计连续的0和1分别有多少个，如：111100011000，得到4、3、2、3；在4323中的任意相邻两个数字，取小的一个加起来，就是3+2+2 = 7. public int countBinarySubstrings(String s) &#123; int res = 0; int i = 0, count = 1, precount = 0;//count记录相同数字连续子串的长度，precount记录前一个连续子串的长度 while(i &lt; s.length()-1)&#123; if(s.charAt(i) == s.charAt(i+1)) count++; else &#123; res += precount &gt; count ? count : precount;//取小的一个 precount = count; count = 1; &#125; i++; &#125; res += precount &gt; count ? count : precount; return res; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"栈与队列","slug":"栈与队列","date":"2020-02-14T14:43:29.000Z","updated":"2020-11-23T14:23:21.127Z","comments":true,"path":"数据结构与算法/栈与队列/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/","excerpt":"","text":"leetcode232：用栈实现队列 leetcode225：用队列实现栈 leetcode155：最小栈 leetcode20：有效的括号 leetcode232：用栈实现队列123456789101112131415161718192021222324252627282930313233343536373839404142434445464748class MyQueue &#123; private Stack&lt;Integer&gt; stack; /** Initialize your data structure here. */ public MyQueue() &#123; stack = new Stack&lt;&gt;(); &#125; /** Push element x to the back of queue. */ public void push(int x) &#123; stack.push(x); &#125; /** Removes the element from in front of queue and returns that element. */ public int pop() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.pop(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Get the front element. */ public int peek() &#123; Stack&lt;Integer&gt; tempStack = new Stack&lt;&gt;(); while(!stack.empty())&#123; tempStack.push(stack.pop()); &#125; int result = tempStack.peek(); while(!tempStack.empty())&#123; stack.push(tempStack.pop()); &#125; return result; &#125; /** Returns whether the queue is empty. */ public boolean empty() &#123; return stack.empty(); &#125;&#125; leetcode225：用队列实现栈1234567891011121314151617181920212223242526272829303132class MyStack &#123; private Queue&lt;Integer&gt; queue; /** Initialize your data structure here. */ public MyStack() &#123; queue = new LinkedList&lt;&gt;(); &#125; /** Push element x onto stack. */ public void push(int x) &#123; queue.offer(x); int size = queue.size(); while(size-- &gt; 1)&#123; queue.offer(queue.poll()); &#125; &#125; /** Removes the element on top of the stack and returns that element. */ public int pop() &#123; return queue.poll(); &#125; /** Get the top element. */ public int top() &#123; return queue.peek(); &#125; /** Returns whether the stack is empty. */ public boolean empty() &#123; return queue.isEmpty(); &#125;&#125; leetcode155：最小栈12345678910111213141516171819202122232425262728293031323334class MinStack &#123; private Stack&lt;Integer&gt; stack; private Stack&lt;Integer&gt; minStack;//minStack的栈顶元素即是当前stack的最小值 /** initialize your data structure here. */ public MinStack() &#123; stack = new Stack&lt;&gt;(); minStack = new Stack&lt;&gt;(); &#125; public void push(int x) &#123; stack.push(x); if(minStack.empty())&#123; minStack.push(x); &#125;else&#123; if(x &lt;= minStack.peek())&#123; minStack.push(x); &#125; &#125; &#125; public void pop() &#123; int pop = stack.pop(); if(pop == minStack.peek()) minStack.pop(); &#125; public int top() &#123; return stack.peek(); &#125; public int getMin() &#123; return minStack.peek(); &#125;&#125; leetcode20：有效的括号12345678910111213class Solution &#123; public boolean isValid(String s) &#123; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); //遍历字符串，每遇到一种类型的左括号，则将其对应的右括号入栈；若不是左括号，且栈不为空，则出栈，出栈的有括号应与遍历到的右括号一致。 for(char c: s.toCharArray())&#123; if(c == '(') stack.push(')'); else if(c == '[') stack.push(']'); else if((c== '&#123;')) stack.push('&#125;'); else if(stack.empty() || c != stack.pop()) return false; &#125; return stack.empty(); &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"链表","slug":"链表","date":"2020-02-13T12:45:27.000Z","updated":"2020-11-23T14:23:21.140Z","comments":true,"path":"数据结构与算法/链表/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E9%93%BE%E8%A1%A8/","excerpt":"","text":"leetcode160：找出两个链表的交点 leetcode206：反转链表 leetcode21：合并两个有序链表 leetcode83：删除排序链表中的重复元素 leetcode19：删除链表的倒数第N个节点 leetcode24：两两交换链表中的节点 leetcode445：两数相加 leetcode234：判断一个链表是否为回文链表 leetcode328：将链表奇数节点和偶数节点分别放在一起 leetcode160：找出两个链表的交点1234567891011121314151617181920public class Solution &#123; /*设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。*/ public ListNode getIntersectionNode(ListNode headA, ListNode headB) &#123; if(headA == null || headB == null) return null; ListNode pA = headA, pB = headB; while(pA != pB)&#123; pA = pA == null ? headB : pA.next; pB = pB == null ? headA : pB.next; &#125; return pA; &#125;&#125; leetcode206：反转链表123456789101112131415//原地翻转三个主要变量，当前节点cur，前一个节点pre,后一个节点nextTempclass Solution &#123; public ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125;&#125; leetcode21：合并两个有序链表1234567891011121314151617181920212223class Solution &#123; //类似于归并排序中的merge过程 public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode newList = new ListNode(0); ListNode cur = newList; while(l1 != null &amp;&amp; l2 != null)&#123; if(l1.val &lt;= l2.val)&#123; cur.next = l1; cur = cur.next; l1 = l1.next; &#125;else&#123; cur.next = l2; cur = cur.next; l2 = l2.next; &#125; &#125; if(l1 == null) cur.next = l2;//任一链表为空，直接连接另一条链表 else cur.next = l1; return newList.next; &#125;&#125; leetcode83：删除排序链表中的重复元素123456789101112class Solution &#123; public ListNode deleteDuplicates(ListNode head) &#123; ListNode cur = head; while(cur != null &amp;&amp; cur.next != null)&#123; if(cur.val == cur.next.val)&#123; cur.next = cur.next.next; &#125;else cur = cur.next; &#125; return head; &#125;&#125; leetcode19：删除链表的倒数第N个节点1234567891011121314151617class Solution &#123; //先使快指针移动n个节点，然后快慢指针同时移动直到快指针达到链表尾部，此时慢指针即指向要删除的节点的前一个节点 public ListNode removeNthFromEnd(ListNode head, int n) &#123; ListNode first = head, second = head; for(int i = 0; i &lt; n; i++) second = second.next; if(second == null) return head.next;//若n等于链表节点数，直接返回head.next while(second.next != null)&#123; first = first.next; second = second.next; &#125; first.next = first.next.next; return head; &#125;&#125; leetcode24：两两交换链表中的节点123456789101112class Solution &#123; public ListNode swapPairs(ListNode head) &#123; if(head == null || head.next == null) return head; ListNode firstNode = head, secondNode = head.next; firstNode.next = swapPairs(secondNode.next);//swapParis交换一对节点，并返回第二个节点 secondNode.next = firstNode; return secondNode; &#125;&#125; leetcode445：两数相加1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859class Solution &#123; //两栈用于存储两个数，另一个栈存储和 public ListNode addTwoNumbers(ListNode l1, ListNode l2) &#123; Stack&lt;Integer&gt; first = new Stack&lt;&gt;(); Stack&lt;Integer&gt; second = new Stack&lt;&gt;(); while(l1 != null)&#123; first.push(l1.val); l1 = l1.next; &#125; while(l2 != null)&#123; second.push(l2.val); l2 = l2.next; &#125; Stack&lt;Integer&gt; sumStack = new Stack&lt;&gt;(); int carry = 0;//进位 while(!first.empty() &amp;&amp; !second.empty())&#123; int sum = first.pop() + second.pop() + carry; carry = 0;//进位用完归0 if(sum &gt;= 10)&#123; carry = 1; sum = sum % 10; &#125; sumStack.push(sum); &#125; while(!first.empty())&#123; if(carry == 1)&#123; int sum = first.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(first.pop()); &#125; while(!second.empty())&#123; if(carry == 1)&#123; int sum = second.pop() + carry; carry = 0; if(sum == 10)&#123; carry = 1; sum = 0; &#125; sumStack.push(sum); &#125;else sumStack.push(second.pop()); &#125; if(carry == 1) sumStack.push(1);//和的第二位有进位的情况 ListNode sumList = new ListNode(sumStack.pop()); ListNode cur = sumList; while(!sumStack.empty())&#123; cur.next = new ListNode(sumStack.pop()); cur = cur.next; &#125; return sumList; &#125;&#125; leetcode234：判断一个链表是否为回文链表123456789101112131415161718192021222324252627282930313233343536373839404142434445//O(n)和O(1)class Solution &#123; //该算法使用快慢指针找到链表中间节点，然后将链表切分，将后半部分翻转，再进行比较 public boolean isPalindrome(ListNode head) &#123; if(head == null || head.next == null) return true; ListNode slow = head, fast = head; while(fast != null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; &#125;//使用快慢指针使slow指针到达链表中间 if(fast != null) slow = slow.next;//链表节点个数为奇数，slow指针右移离开中间节点 ListNode cur = head; while(cur.next != slow)&#123; cur = cur.next; &#125; cur.next = null;//切分链表为两部分，后半部分第一个节点为slow return isEqual(head, reverseList(slow)); &#125; private ListNode reverseList(ListNode head) &#123; ListNode pre = null; ListNode cur = head; while(cur != null)&#123; ListNode nextTemp = cur.next; cur.next = pre; pre = cur; cur = nextTemp; &#125; return pre; &#125; private boolean isEqual(ListNode l1, ListNode l2) &#123; while (l1 != null &amp;&amp; l2 != null) &#123; if (l1.val != l2.val) return false; l1 = l1.next; l2 = l2.next; &#125; return true; &#125;&#125; leetcode328：将链表奇数节点和偶数节点分别放在一起123456789101112131415161718//O(n)和O(1)class Solution &#123; public ListNode oddEvenList(ListNode head) &#123; if(head == null) return head; ListNode odd = head, even = head.next; ListNode evenHead = even; while(even != null &amp;&amp; even.next != null)&#123; odd.next = even.next; odd = odd.next; even.next = odd.next; even = even.next; &#125; odd.next = evenHead; return head; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"二分查找","slug":"二分查找","date":"2020-02-12T07:23:45.000Z","updated":"2020-11-23T14:23:21.105Z","comments":true,"path":"数据结构与算法/二分查找/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/","excerpt":"","text":"leetcode69：求开方 leetcode744：寻找比目标字母大的最小字母 leetcode540：有序数组中的单一元素 leetcode278：寻找第一个错误的版本 leetcode153：寻找旋转排序数组中的最小值 leetcode34：在排序数组中查找元素的第一个和最后一个位置 leetcode69：求开方1234567891011121314151617class Solution &#123; public int mySqrt(int x) &#123; if(x &lt;= 1) return x; int start = 1, end = x; while(start &lt;= end)&#123; int mid = start + (end - start)/2; int sqrt = x/mid;//不使用square与mid*mid判断是因为可能整型溢出 if(sqrt == mid) return mid; else if(sqrt &lt; mid) end = mid - 1; else start = mid + 1; &#125; return end; &#125;&#125; leetcode744：寻找比目标字母大的最小字母123456789101112131415161718class Solution &#123; public char nextGreatestLetter(char[] letters, char target) &#123; if(target &lt; letters[0] || target &gt;= letters[letters.length-1]) return letters[0]; int start = 0, end = letters.length - 2; while(start &lt;= end)&#123; int mid = start + (end - start)/2; if(letters[mid] == target)&#123; int i = mid+1; while(letters[i] == target) i++; return letters[i]; &#125; else if(letters[mid] &lt; target) start = mid + 1; else end = mid - 1; &#125; return letters[end+1]; &#125;&#125; leetcode540：有序数组中的单一元素1234567891011121314//时空复杂度要求为O(logn)和O(1)class Solution &#123; public int singleNonDuplicate(int[] nums) &#123; int start = 0, end = nums.length - 1; while(start &lt; end)&#123; int mid = start + (end - start)/2; if(mid%2 == 1) mid--;//只对偶数索引进行二分查找 //以[3,3,7,7,10,11,11]为例，只有当单一元素出现后，其后的数组部分，偶数索引mid处才不满足nums[mid] == nums[mid+1] if(nums[mid] == nums[mid+1]) start = mid + 2;//单一元素一定在mid后 else end = mid;//单一元素为mid或者在mid之前 &#125; return nums[start]; &#125;&#125; leetcode278：寻找第一个错误的版本1234567891011public class Solution extends VersionControl &#123; public int firstBadVersion(int n) &#123; int low = 1, high = n; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(isBadVersion(mid)) high = mid;//第mid个版本错误，之后全是错的，向前继续找第一个错误的版本 else low = mid + 1;//第mid个版本正确，向后找 &#125; return low; &#125;&#125; leetcode153：寻找旋转排序数组中的最小值12345678910111213141516171819class Solution &#123; public int findMin(int[] nums) &#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= nums[high]) high = mid; else low = mid+1; &#125; return nums[low]; &#125; /*时间复杂度O(n) public int findMin(int[] nums) &#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; if(nums[i] &gt; nums[i+1]) return nums[i+1]; &#125; return nums[0]; &#125; */&#125; leetcode34：在排序数组中查找元素的第一个和最后一个位置1234567891011121314151617181920212223242526272829303132333435363738class Solution &#123; public int[] searchRange(int[] nums, int target) &#123; if(nums.length == 0) return new int[]&#123;-1,-1&#125;; int firstIndex = findFirst(nums, target); if(nums[firstIndex] != target) return new int[]&#123;-1,-1&#125;; int lastIndex = findLast(nums,target); if(nums[nums.length-1] == target) return new int[]&#123;firstIndex,nums.length-1&#125;; return new int[]&#123;firstIndex, firstIndex &lt; lastIndex ? lastIndex : firstIndex&#125;; &#125; private static int findFirst(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &gt;= target) high = mid;//向左逼近，找左边界 else low = mid + 1; &#125; return low; &#125; private static int findLast(int[] nums, int target)&#123; int low = 0, high = nums.length - 1; while(low &lt; high)&#123; int mid = low + (high - low)/2; if(nums[mid] &lt;= target) low = mid + 1;//向右逼近，找右边界，注意若最后一个数为target，则low不用-1 else high = mid; &#125; return low-1; &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"排序","slug":"排序","date":"2020-02-11T08:07:19.000Z","updated":"2020-11-23T14:23:21.123Z","comments":true,"path":"数据结构与算法/排序/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%8E%92%E5%BA%8F/","excerpt":"","text":"常见排序算法比较 选择排序 冒泡排序 插入排序 堆排序 归并排序 快速排序 常见排序算法比较 排序的稳定性：排序过程中，具有相同关键字的记录经过排序后，这些记录相对的顺序保持不变，则是稳定的。 要求排序稳定的意义在于，在对象排序中，对对象按照某个属性进行排序后，希望保持其他属性的相对顺序不发生改变，则需要稳定的排序算法。比如对一群人按照年龄排序，对于都是69岁的人群来说，我们不希望它们之间原来的顺序改变，因为我们需要维持这群人其他的属性顺序不变。 选择排序从数组开始处遍历，找到剩余未遍历数组中的最小值，与本次遍历第一个数交换，重复此过程，每一次内层循环找到未遍历数组的最小值，外层循环中将一个最小值排好序。 1234567891011public static void sort(int[] nums)&#123; for(int i = 0; i &lt; nums.length - 1; i++)&#123; int minPostion = i; for(int j = i+1; j &lt; nums.length; j++)&#123; minPostion = nums[minPostion] &gt; nums[j] ? j :minPostion; &#125; swap(nums, minPostion, i); &#125;&#125; 冒泡排序内层循环两两比较，将大的数放在后面，最终结果是一次内层循环将一个最大的数排好顺序，与选择排序恰好相反。 1234567public static void sort(int[] nums)&#123; for(int i = nums.length-1; i &gt; 0; i--)&#123;//外层循环决定最大的数的位置 for(int j = 0; j &lt; i; j++)&#123; if(nums[j] &gt; nums[j+1]) swap(nums, j, j+1); &#125; &#125;&#125; 插入排序外层循环遍历数组（选择某张牌），内层循环将外层循环选择的牌插入到前面已经排好序的牌中。 1234567public static void sort(int[] nums)&#123; for(int i = 1; i &lt; nums.length; i++)&#123; for(int j = i; j &gt; 0; j--)&#123; if(nums[j] &lt; nums[j-1]) swap(nums, j, j-1); &#125; &#125;&#125; 插入排序在样本较小且基本有序时效率较高。 堆排序1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class HeapSort &#123; //堆：满足“任一非叶子节点均大于（小于）等于其孩子节点”条件的完全二叉树，分为大根堆和小根堆 public static void main(String[] args) &#123; int[] test = &#123;3,2,5,6,4,7,0,1,10,9,8&#125;; sort(test); for(int num:test)&#123; System.out.print(\" \"+num); &#125; &#125; public static void sort(int[] tree)&#123; buildHeap(tree); for(int j = tree.length - 1; j &gt; 0; j--)&#123; swap(tree,0,j);//将堆顶元素与末尾元素进行交换 adjustHeap(tree,0,j);//重新对堆进行调整 &#125; &#125; /** * 创建大根堆 * @param tree */ public static void buildHeap(int[] tree) &#123; for(int i = tree.length/2 - 1; i &gt;= 0; i--)//从第一个非叶子结点（完全二叉树中必为n/2-1）从下至上，从右至左调整结构 adjustHeap(tree, i, tree.length); &#125; /** * 堆化操作，将第i个节点与其孩子节点进行比较，将最大值放在位置i上； * 递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 * @param tree * @param i * @param length */ public static void adjustHeap(int[] tree,int i,int length)&#123; if(i &gt;= length) return;//递归出口，孩子的下标大于等于数组长度返回 int leftChildIndex = 2*i + 1;//左孩子下标 int rightChildIndex = 2*i + 2;//右孩子下标 int maxIndex = i;//用一个变量来记录i, 2*i+1, 2*i+2三者中的最大值的下标 if(leftChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[leftChildIndex]) maxIndex = leftChildIndex; if(rightChildIndex &lt; length &amp;&amp; tree[maxIndex] &lt; tree[rightChildIndex]) maxIndex = rightChildIndex; if(maxIndex != i)&#123; swap(tree, i, maxIndex); adjustHeap(tree, maxIndex, length);//递归进行堆化，以第i个节点为根的子树从上往下全部进行堆化 &#125; &#125; private static void swap(int[] nums, int i, int j) &#123; int temp = nums[i]; nums[i] = nums[j]; nums[j] = temp; &#125;&#125; 归并排序 Arrays工具类对对象使用归并排序，对象排序要求稳定性。 123456public static void sort(Object[] a) &#123; if (LegacyMergeSort.userRequested) legacyMergeSort(a); else ComparableTimSort.sort(a, 0, a.length, null, 0, 0);&#125; 默认使用TimSort，它是一种对归并排序使用了大量优化的排序算法，属于归并与插入的混合排序算法。 12345678910111213141516171819202122232425262728293031323334353637383940414243 /** * 对数组的left至right这部分进行排序 * @param nums * @param left * @param right */public static void sort(int[] nums, int left, int right)&#123; if(left == right) return; int mid = left + (right - left)/2;//防止整型溢出 sort(nums, left, mid);//对数组的左半部分排序 sort(nums, mid+1, right);//对数组的右半部分排序 merge(nums, left, mid+1, right);//合并数组的两半部分&#125;/** * 合并数组的任意两半部分（均有序的情况下） * @param nums */private static void merge(int[] nums, int left, int mid, int right)&#123; int[] result = new int[right - left + 1]; int i = left, j = mid; int k = 0; while(i &lt; mid &amp;&amp; j &lt;= right)&#123; if(nums[i] &lt;= nums[j])&#123; result[k++] = nums[i++]; &#125;else result[k++] = nums[j++]; &#125; while(i &lt; mid)&#123; result[k++] = nums[i++]; &#125; while(j &lt;= right)&#123; result[k++] = nums[j++]; &#125; k = 0; for(i = left; i &lt;= right; i++)&#123; nums[i] = result[k++]; &#125;&#125; 快速排序Arrays工具类对基础类型数据排序使用双轴快排。 123public static void sort(int[] a) &#123; DualPivotQuicksort.sort(a, 0, a.length - 1, null, 0, 0);&#125; 123456789101112131415161718192021222324252627282930//单轴快排实现public static void sort(int[] nums, int leftBound, int rightBound)&#123; if(leftBound &gt;= rightBound) return; int pivotIndex = partition(nums, leftBound, rightBound);//得到每一次划分后轴的位置 sort(nums, leftBound, pivotIndex-1);//对轴左边的部分继续进行划分 sort(nums, pivotIndex+1, rightBound);//对轴右边的部分进行划分 &#125; /** * 一次划分将小于轴的数放在其左边，大于轴的数放在其右边 * @param nums * @param leftBound * @param rightBound * @return pivotIndex(轴的位置) */ private static int partition(int[] nums, int leftBound, int rightBound)&#123; int pivot = nums[rightBound];//将右边界的数定义为轴 int left = leftBound, right = rightBound - 1; while(left &lt;= right)&#123; while(left &lt;= right &amp;&amp; nums[left] &lt;= pivot) left++;//从左往右找到第一个比轴大的数 while(left &lt;= right &amp;&amp; nums[right] &gt; pivot) right--;//从右往左找到第一个比轴小的数 if(left &lt; right) swap(nums, left, right);//交换 &#125; swap(nums, left, rightBound);//交换nums[left]与轴则完成一次划分 return left; &#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"双指针","slug":"双指针","date":"2020-02-09T11:05:21.000Z","updated":"2020-11-23T14:23:21.108Z","comments":true,"path":"数据结构与算法/双指针/","link":"","permalink":"http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E5%8F%8C%E6%8C%87%E9%92%88/","excerpt":"","text":"leetcode167：升序数组的TwoSum leetcode633：判断某个数是否为平方数之和 leetcode345：反转字符串中的元音字母 leetcode680：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串 leetcode88：合并两个有序数组 leetcode141：判断链表中是否有环 leetcode524：通过删除字母匹配到字典里最长单词 leetcode167：升序数组的TwoSum1234567891011121314class Solution &#123; public int[] twoSum(int[] numbers, int target) &#123; if(numbers == null) return null; int start = 0, end = numbers.length - 1; while(start &lt; end)&#123; if(numbers[start] + numbers[end] == target)&#123; return new int[]&#123;start+1, end+1&#125;; &#125; else if(numbers[start] + numbers[end] &lt; target)&#123; start++; &#125; else end--; &#125; return null; &#125;&#125; leetcode633：判断某个数是否为平方数之和12345678910111213class Solution &#123; public boolean judgeSquareSum(int c) &#123; if(c &lt; 0) return false; int start = 0, end = (int)Math.sqrt(c); while(start &lt;= end)&#123; int squareSum = start*start + end*end; if(squareSum == c) return true; else if(squareSum &lt; c) start++; else end--; &#125; return false; &#125;&#125; leetcode345：反转字符串中的元音字母123456789101112131415161718192021222324class Solution &#123; public String reverseVowels(String s) &#123; HashSet&lt;Character&gt; vowels = new HashSet&lt;&gt;( Arrays.asList('a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U')); int start = 0, end = s.length() - 1; char[] result = new char[s.length()]; while(start &lt;= end)&#123; char startC = s.charAt(start); char endC = s.charAt(end); if(!vowels.contains(startC))&#123; result[start++] = startC; &#125; else if(!vowels.contains(endC))&#123; result[end--] = endC; &#125; else &#123; result[start++] = endC; result[end--] = startC; &#125; &#125; return new String(result); &#125;&#125; leetcode680：给定一个非空字符串 s，最多删除一个字符。判断是否能成为回文字符串1234567891011121314151617181920212223class Solution &#123; public boolean validPalindrome(String s) &#123; int left = 0, right = s.length() - 1; while(left &lt;= right)&#123; if(s.charAt(left) == s.charAt(right))&#123; left++; right--; &#125;else return isPalindrome(s, left+1, right) || isPalindrome(s, left, right-1);//如果左右不对称，则判断删除s.charAt(left)或者s.charAt(right)后的子字符串是否为回文串 &#125; return true; &#125; private boolean isPalindrome(String s, int left, int right)&#123; while(left &lt;= right)&#123; if(s.charAt(left) != s.charAt(right)) return false; else &#123; left++; right--; &#125; &#125; return true; &#125;&#125; leetcode88：合并两个有序数组12345678910111213141516class Solution &#123; public void merge(int[] nums1, int m, int[] nums2, int n) &#123; int i = m - 1, j = n - 1; int k = m+n-1; while(i &gt;= 0 &amp;&amp; j &gt;= 0)&#123; if(nums2[j] &gt; nums1[i]) nums1[k--] = nums2[j--]; else nums1[k--] = nums1[i--]; &#125;//从两个数组尾部开始比较大小 //将剩余的某个数组中未比较的元素写入nums1 while(i &gt;= 0) nums1[k--] = nums1[i--]; while(j &gt;= 0) nums1[k--] = nums2[j--]; &#125;&#125; leetcode141：判断链表中是否有环1234567891011121314//快慢指针public class Solution &#123; public boolean hasCycle(ListNode head) &#123; ListNode fast = head; ListNode slow = head; while(slow != null &amp;&amp; fast!= null &amp;&amp; fast.next != null)&#123; slow = slow.next; fast = fast.next.next; if(fast == slow) return true; &#125; return false; &#125;&#125; leetcode524：通过删除字母匹配到字典里最长单词1234567891011121314151617181920212223242526272829class Solution &#123; public String findLongestWord(String s, List&lt;String&gt; d) &#123; String result = \"\"; int maxLength = 0; for(String target : d)&#123; int targetLen = target.length(); if(isSubStr(s, target))&#123; if(maxLength &lt; targetLen)&#123; maxLength = targetLen; result = target; &#125;else if(maxLength == targetLen)&#123; if(result.compareTo(target) &lt; 0) continue;//比较字符串之间的字典顺序使用compareTo方法 else result = target; &#125; &#125; &#125; return result; &#125; private boolean isSubStr(String s, String target)&#123; int i = 0, j = 0; //遍历字符串s,每匹配一个target的字符j加1 while(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123; if(s.charAt(i) == target.charAt(j)) j++; i++; &#125; return j == target.length();//若j等于target.length(),说明target是s的一部分 &#125;&#125;","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"Linux之进程与网络管理","slug":"(9)Linux之进程与网络管理","date":"2019-12-09T05:54:57.000Z","updated":"2021-01-14T10:14:09.438Z","comments":true,"path":"Linux/(9)Linux之进程与网络管理/","link":"","permalink":"http://thmasterplan.cn/Linux/(9)Linux%E4%B9%8B%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BD%91%E7%BB%9C%E7%AE%A1%E7%90%86/","excerpt":"","text":"进程管理 ps pgrep kill top 服务管理 内存 free vmstat 系统监控工具 任务调度 网络配置 防火墙配置 firewall-cmd 开启一个端口 对某IP开放多个端口 进程管理 lscpu：显示cpu信息 pstree -p：打印进程树。需要安装yum intsall psmisc。 pstree -p PID：查看某进程的进程树。 ps即process state，例如ps -axu，该命令用于查看进程相关信息。Linux系统各进程的相关信息均保存在/proc/PID下。选项： a：常用。打印所有终端中的进程。 x：常用。与终端无关的进程，例如守护进程。 u：常用。额外显示进程的USER，CPU/MEM占比，RSS（常驻内存集，不包括交换分区）与VSZ（分配给进程的虚拟内存，包括交换分区），TT（终端缩写），START（开始运行的时间），STAT（进程状态），TIME（CPU时间），COMMANd（启动进程所用的命令和参数）。 其中STAT的状态有：S，睡眠；s，表示该进程是会话的先导进程；N，表示进程拥有比普通优先级更低的优先级；R，正在运行；D，短期等待；Z，僵死进程；T，被跟踪。 f：显示进程父子关系。 k -%cpu：倒序排序显示cpu占比，-表示倒序。 o：只显示某些选项，后面跟要显示的选项；例如ps axo psr：显示命令使用哪个CPU核。 pgrep搜索进程，显示符合条件的进程的PID，按预定义的模式pgrep [options] pattern： -u uid：有效用户 -U uid：运行命令者 -t terminal：与指定终端相关的进程 -l：显示进程名，例如pgrep -l &#39;^ba.*&#39; -a：显示完整格式的进程名 -P pid：显示指定进程的子进程 按程序名称: pidof 程序名 kill杀死进程。基本写法：kill [选项] PID。常用选项：-9，表示强迫进程立即停止。 killall 进程名：通过进程名杀死匹配的所有进程，支持通配符，多用于因系统负载过大而变慢时。 top与ps命令不同的是，top命令可以使我们动态地监控进程信息，内置命令： 排序：P：按%CPU；M：按%MEM；T：按累积占据CPU时长(TIME+) 首部信息显示： uptime信息：l tasks及cpu信息：t cpu内核分别显示：1 内存信息：m 退出：q 修改刷新时间间隔：s 终止进程：k 保存当前进程信息：W 栏位信息： us：用户空间的cpu使用情况 sy：内核空间的cpu使用情况 ni：调整nice时间 id：空闲 wa：等待IO时间 hi：硬中断 si：软中断 st：虚拟机偷走的时间 load average：1，5，15分钟load平均值，以2核cpu为例，load average小于2表示还可以增大负载，为2则表示cpu使用率打满，大于2则代表等待阻塞。 选项： -b：显示所有进程（默认只显示前一部分） -p：指定显示某些进程 -H：线程模式；示例：top -H -p PID，指定显示某个进程的所有线程 注：EPEL源的htop是功能更丰富的进程管理工具。 服务管理比如MySQL服务，Ningx服务等，通常在后台运行并监听某个端口，等待其他程序的请求。语法：systemctl [start | stop | restart | reload | status] 服务名。 systemctl只是临时生效，重启后则变回以前的设置，如果希望某个服务启动或关闭永久生效，需要使用systemctl enable/disable 服务名。 关于该命令详细说明参考：阮一峰的博客 内存free该命令用于查看内存空间使用状态，常用选项有： -h：易读格式。 -s n：指定刷新间隔为n秒。 vmstat查看虚拟内存使用状态。 系统监控工具 netstat：查看网络情况。 iostat：统计CPU和设备IO信息。 iftop：显示带宽使用情况，EPEL源。 nload：查看网络实时吞吐量。 dstat：替代iostat, vmstat, ifstat。 iotop：I/O监视器。 任务调度待补充。 网络配置防火墙配置firewall-cmd 查看版本： firewall-cmd --version 查看帮助：firewall-cmd --help 显示状态： firewall-cmd --state 查看所有打开的端口：firewall-cmd --zone=public --list-ports 更新防火墙规则： firewall-cmd --reload 查看区域信息: firewall-cmd --get-active-zones 查看指定接口所属区域： firewall-cmd --get-zone-of-interface=eth0 拒绝所有包：firewall-cmd --panic-on 取消拒绝状态：firewall-cmd --panic-off 查看是否拒绝：firewall-cmd --query-panic 开启一个端口 添加：firewall-cmd --zone=public --add-port=80/tcp --permanent （—permanent永久生效，没有此参数重启后失效） 重新载入：firewall-cmd --reload 查看：firewall-cmd --zone=public --query-port=80/tcp 删除：firewall-cmd --zone= public --remove-port=80/tcp --permanent 对某IP开放多个端口 firewall-cmd --permanent --add-rich-rule=&quot;rule family=&quot;ipv4&quot; source address=&quot;10.159.60.29&quot; port protocol=&quot;tcp&quot; port=&quot;1:65535&quot; accept&quot; firewall-cmd --reload 静态IP配置 切入etc/sysconfig/network-scripts/目录，修改ifcfg-enp0s3或ifcfg-ens33文件。 插入如下配置信息： 1234567BOOTPROTO&#x3D;&quot;static&quot; &#x2F;&#x2F;启动协议：系统初始默认为dhcp协议，修改为静态IPADDR&#x3D;&quot;192.168.1.5&quot;&#x2F;&#x2F;打算指定的静态IP地址NETMASK&#x3D;&quot;255.255.255.0&quot;&#x2F;&#x2F;子网掩码GATEWAY&#x3D;&quot;192.168.1.1&quot;&#x2F;&#x2F;本地网关地址DNS1&#x3D;&quot;114.114.114.114&quot;&#x2F;&#x2F;DNS服务器....ONBOOT&#x3D;&quot;yes&quot;&#x2F;&#x2F;设置自启动 重启网络服务。 待补充。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux之磁盘与文件系统","slug":"(8)Linux之磁盘与文件系统","date":"2019-11-29T07:26:51.000Z","updated":"2020-11-23T14:23:20.955Z","comments":true,"path":"Linux/(8)Linux之磁盘与文件系统/","link":"","permalink":"http://thmasterplan.cn/Linux/(8)Linux%E4%B9%8B%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/","excerpt":"","text":"文件系统简介 磁盘简介 分区管理 分区原因 MBR分区 GPT分区 分区管理命令 常用 创建分区 创建MBR分区 创建GPT分区 高级分区操作 文件系统管理 创建文件系统 管理文件系统 文件系统检测和修复 常用工具 挂载设备 分区挂载 swap的挂载 示例 外围设备 光盘 USB 虚拟内存 RAID RAID级别 LVM 概述 LVM示意图 使用逻辑卷步骤 LVM常用命令 LVM快照管理 使用快照 文件系统简介Linux使用的是索引式文件系统（B+树实现）：文件的属性放置到Inode中，文件的实际数据放在Data Block中。 下面以EXT2文件系统为例，其结构如图所示： SuperBlock：记录此文件系统的整体信息，包括Inode/Block的总量、使用量、剩余量，以及文件系统的格式与相关信息等。SuperBlock一般为1024字节。 Inode Table：Inode表，每个Inode记录文件的属性，包括文件的权限、拥有者与群组、容量、atime/mtime/ctime和此文件的数据所在的Block地址。 每个Inode大小均为固定128字节（ext4和xfs可设定到256字节）。 每个文件仅占用一个Inode。 系统读取文件时需要先找到Inode，并分析Inode所记录的权限与用户是否符合，符合则再根据Inode记录的Block地址访问数据。 Data Block：实际记录文件的内容，若文件过大一般会占用多个Block。EXT2文件系统所支持的Block大小有1K，2K和4K三种。 除非重新格式化，Block的大小与数量在格式化完成后就不能再改变。 每个Block内最多只能放置一个文件的数据。 若文件大于Block，则一个文件占用多个block；若文件小于Block，则该Blcok的剩余容量就不能再被使用。 dumpe2fs：查询EXT系列SuperBlock信息的指令。 Block大小 1KB 2KB 4KB 最大单一文件限制 16GB 256GB 2TB 最大文件系统总容量 2TB 8TB 16TB 文件系统与目录树的关系 目录：当在Linux下的文件系统建立一个目录时，文件系统会分配一个Inode与至少一块Block给该目录，其中Inode记录该目录的相关权限和属性，并记录分配的那块Block地址，而该Block用于记录该目录下的文件名与该文件名占用的Inode号；ls -i查询当前目录下文件的Inode号码。 文件：在EXT2建立一个文件时，EXT2会分配一个Inode和对应该文件大小的一个或多个Block。 注：CentOS7之后使用XFS，它是一种日志式文件系统，具备故障恢复能力。其Block大小可从512Bytes - 64KB调整变化，其最大单一文件限制为9EB（1EB = 1024PB = 1024*1024 TB），最大文件系统总容量为18EB。 磁盘简介 硬盘标识：/dev目录下以sd开头的设备文件，例如/dev/sda，/dev/sdb。 同一磁盘的不同分区：以数字区分，例如/dev/sda1，/dev/sda2。 磁盘使用步骤： 磁盘分区 分区上创建文件系统 将分区挂载到目录 分区管理分区原因 隔离系统和程序，可安装多个操作系统。 不同分区可以采用不同文件系统。 优化I/O性能。 实现磁盘空间配额限制 提高修复速度 MBR分区MBR分区不超过2T，一块硬盘最多有4个主分区，也可以3主分区+1扩展分区（扩展分区可包含N个逻辑分区）。MBR分区结构如下图： GPT分区GPT支持128个分区，分区可达ZB级别。GPT分区结构如下图： 分区管理命令常用 列出块设备：lsblk 查看块设备的UUID（通用唯一识别码）：blkid 创建分区创建MBR分区fdisk命令： fdisk -l：查看当前分区情况 fdisk [device]，管理分区，常用子命令： p：分区列表 t：更改分区ID（输入L查询，不同的ID标识分区的类型） n：创建新分区 d：删除分区 v：校验分区 u：转换单位 w：保存退出 q：不保存退出 fdisk实时更改硬盘的分区，分区完成后注意与内存分区表同步（partprobe），查看内核是否已经识别新的分区cat /proc/partitions。 创建GPT分区gdisk命令，用法与fdisk相似。 高级分区操作parted命令。该命令操作都是实时生效，需谨慎操作。 parted /dev/sdb mklabel gpt：设置/dev/sdb这块磁盘为GPT类型。 parted /dev/sdb print：打印/dev/sdb的分区信息。 parted /dev/sdb mkpart primary 1 200：设置一个分区，从1MB到200MB，大小为199MB（注意分区需是连续空间）。 parted /dev/sdb rm 1：删除第一个分区。 parted -l：列出所有硬盘的分区信息。 重新设置内存中的内核分区表版本：partprobe. 文件系统管理查看当前OS支持的文件系统：cat /proc/filesystems 创建文件系统 mkfs -t [type] [device]，例如mkfs -t xfs /dev/sdb2，若要创建swap类型，使用mkswap /dev/xxx命令。 管理文件系统 tune2fs：重新设定ext系列文件系统参数的值 -l：查看指定文件系统superblock信息 -L &#39;LABEL&#39;：修改卷标 -O：文件系统属性的启用或禁用 dumpe2fs：显示ext文件系统信息，将磁盘块分组管理 xfs_info 挂载点：显示已挂载的xfs文件系统信息 文件系统检测和修复文件系统故障常发生于死机或非正常关机后，注意一定要取消挂载后再执行修复命令。不同文件系统修复命令如下：fsck 、e2fsck、xfs_repair。 常用工具 df：查看文件系统和磁盘空间使用情况，常用选项-T,-h。 du -h /xxx/yyy：查看某目录总体空间占用状态，--max-depth=3指定最大目录层级为3 dd：用于转换与复制文件。用法：dd if=/x/y of=/a/b bs=# count=#。说明： if=/x/y：从指定文件读取 of=/a/b：写入到指定文件 ibs=size：一次读size个字节 obs=size：一次写size个字节 bs=size：block size，指定块大小(既是ibs也是obs) cbs=size：一次转换size个字节 skip=blocks：从开头忽略blocks个ibs大小的块，只复制之后的内容 seek=blocks：从开头忽略blocks个obs大小的块，用if中复制的内容替换blocks个obs大小的块之后的内容。 count=n：复制n个bs 备份： dd if=/dev/sdx of=/dev/sdy：整盘备份到另一磁盘 dd if=/dev/sdx of=/xxx/image：整盘备份到文件 dd if=/dev/sdx | gzip &gt; /xxx/image.gz：整盘备份并压缩 恢复： dd if=/xxx/image of=/dev/sdx gzip -dc /xxx/image.gz | dd of=/dev/sdx 挂载设备挂载点：挂载点一定是目录，该目录为进入该文件系统的入口。 分区挂载将分区挂载到目录，则该目录下的文件都存储于该分区中；若有其他分区挂载在该目录的子目录下，则子目录下的文件存储于另一分区中。 挂载点下原有文件在分区挂载完成后会被临时隐藏，因此挂载点目录一般为空。 一个分区可以同时挂载在多个目录下，一个目录只能与一个分区关联。 分区实现永久挂载需要写入配置文件/etc/fstab，使用blkid查看分区的UUID（也可使用设备分区名例如/dev/sda2）并按格式写入配置文件；若需要更改挂载点所属文件系统属性（是否启用acl，suid，exec等），亦可在该配置文件中更改，默认为defaults，然后mount -o remount /dev/xxx重新挂载使更改生效。 swap的挂载写入/etc/fstab，挂载点和文件系统均为swap，保存退出后键入swapon -a；swapoff命令取消交换分区。 示例 mount /dev/sda2 /mnt：将分区sda2挂载在/mnt目录下。 -r：只读挂载 -w：读写挂载，默认 mount -B 目录1 目录2：类似与软连接的效果，两个目录的文件共享。 -o options：挂载文件系统的选项如下图 umount /mnt：取消挂载 cat /etc/mtab：查看目前的挂载情况 查看挂载情况：findmnt 挂载点/设备分区 查看正在访问指定挂载点的进程：lsof 挂载点、fuser -v 挂载点 终止所有正在访问指定挂载点的进程：fuser -km 挂载点 外围设备光盘 手动挂载：mount /dev/cdrom /mnt 操作光盘：eject弹出光盘；eject -t弹入光盘 创建ISO文件：cp /dev/cdrom /root/xxx.iso；mkisofs -r -o ./xxx.iso /etc… USB 查看USB设备是否识别：lsusb 被内核探测为SCSI设备：/dev/sdaX、/dev/sdbX或类似的设备文件 手动挂载：mount /dev/sdbX /mnt 虚拟内存swap交换分区是系统内存的补充，支持虚拟内存，当没有足够的内存保存系统处理的数据时会将数据写入swap分区。可使用free命令查看内存使用情况。 RAIDRAID：Redundant Arrays of Independent Disks（独立冗余磁盘阵列），其作用有： 提高IO能力：磁盘并行读写。 提高容错性。 多块磁盘组织在一起工作。 RAID的实现方式有： 外接式：通过扩展卡提供适配能力。 内接式：主板集成RAID控制器，安装OS前在BIOS里配置。 软件RAID：软件实现。 RAID级别 RAID-0：同一文件分块存储在多块硬盘上，读写性能提升，无容错能力。 RAID-1：同一文件完全一样地存储于两块磁盘（镜像），读性能提升，写性能略有下降，有容错能力，磁盘利用率只有一半。 RAID-5：读写性能提升，至少3块磁盘，有容错能力（允许最多1块磁盘损坏），每一块磁盘都划分一部分空间充当校验位。 RAID-6：读写性能提升，至少4块磁盘，两个校验位，允许最多2块磁盘损坏，容错性较RAID-5高 RAID-10与RAID-01（实际使用RAID-10，RAID-10容错性较RAID-01好） RAID-50 RAID-7：自身带操作系统和管理工具，理论上性能最高的RAID模式。 LVM概述Logical Volume Manager（逻辑卷管理），允许对卷进行方便操作的抽象层。 将物理块设备指定为物理卷； 用多个物理卷来创建一个卷组（物理卷是用固定大小的物理区域[PE，Physical Extent]来定义的）； 从卷组中划分逻辑卷，可在逻辑卷上创建文件系统，逻辑卷大小可扩展。 LVM示意图 使用逻辑卷步骤 将设备指定为物理卷，例如pvcreate /dev/sdb1 /dev/sdd或pvcreate /dev/sd{b1,d}，同时将分区和磁盘指定为物理卷。（如果是分区，需要将分区ID改为8e，表示Linux LVM类型） 用多个物理卷创建卷组，vgcreate [选项] vgName pv1 pv2 ...，例如vgcreate -s 16M vg0 /dev/sdb1 /dev/sdd，选项-s指定PE大小。 从卷组中划分逻辑卷，lvcreate -n mysql -L 8G vg0，-n指定逻辑卷名，-L指定大小，-l也是指定大小但是单位是PE个数。 ll /dev/vg0/mysql发现/dev/vg0/mysql为软链接，指向/dev/dm-0，其另一软链接为/dev/mapper/vg0-mysql，若继续创建逻辑卷，其真实设备名依次为/dev/dm-1、/dev/dm-2… 在逻辑卷上创建文件系统，mkfs.xfs /dev/vg0/mysql。 挂载，mount /dev/vg0/mysql /mnt/mysql；将挂载写入配置文件/etc/fstab，在vim扩展命令模式下键入r!blkid /dev/vg0/mysql进行修改。 LVM常用命令 列出现有的物理卷：pvs、pvdisplay 列出现有卷组：vgs、vgdisplay 列出现有逻辑卷：lvs、lvdisplay 扩展现有逻辑卷：lvextend -l +48%free /dev/vg0/mysql：剩余卷组的48%分配给逻辑卷，亦可使用PE数进行分配lvextend -l +200 /dev/vg0/mysql；此时使用lsblk或者fdisk -l查看已分配成功，但是df查看并未改变，还需要为新扩展的逻辑卷创建相同的文件系统 xfs：xfs_growfs 挂载点 ext：resize2fs 逻辑卷名（注意xfs与ext的区别） 亦可一次搞定（加上-r选项）：lvextend -r -l +xxx /dev/vg0/mysql 扩展现有的卷组：vgextend vg0 PV名 删除逻辑卷、卷组、物理卷：迁移数据 -&gt; umount /mnt/mysql -&gt; lvremove /dev/vg0/mysql -&gt; vgremove vg0 -&gt; pvremove /dev/sdb1 /dev/sdd LVM快照管理逻辑卷的快照需要与该逻辑卷在同一个卷组，且快照的容量小于等于逻辑卷； 逻辑卷中每一个发生修改的文件都会备份到快照中； 使用快照 lvcreate -n mysql_snapshot -s -L 1G /dev/vg0/mysql：创建逻辑卷mysql的快照，选项-s用于创建快照，快照上的文件系统与原逻辑卷相同。 挂载快照到目录：mount -o nouuid /dev/vg0/mysql_snapshot /mnt/snap，由于快照的UUID与原逻辑卷一样，所以挂载时需要指定nouuid选项，不然挂载不上（xfs是这样，ext4不用）。 还原快照到逻辑卷（逻辑卷恢复为快照）： umount /mnt/snap,umount /mnt/mysql：卸载快照和逻辑卷。 lvconvert --merge /dev/vg0/mysql_snapshot：还原，此时快照已经删除。 mount /dev/vg0/mysql /mnt/mysql：重新挂载。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux之软件安装和包管理","slug":"(7)Linux之软件安装和包管理","date":"2019-11-25T04:47:01.000Z","updated":"2020-11-23T14:23:20.944Z","comments":true,"path":"Linux/(7)Linux之软件安装和包管理/","link":"","permalink":"http://thmasterplan.cn/Linux/(7)Linux%E4%B9%8B%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/","excerpt":"","text":"软件运行环境 程序包的来源 rpm包管理 yum管理 源码编译安装 压缩、解压缩工具 打包(存档)和解包工具和解包工具) 软件运行环境 静态链接：libxxx.a，程序对应的依赖库复制到程序包，占用空间多,迁移容易，升级难，需重新编译。 动态链接：libxxx.so，只把依赖做一个动态链接，占用空间少。 ldd 命令：查看二进制程序所依赖的共享库文件。 ldconfig -p：查看本机已经缓存的所有可用库文件名及文件路径映射关系。 程序包的来源获取程序包的途径：官方服务器，镜像站点，epel源（Extra Packages for Enterprise Linux）。 管理程序包： 使用包管理器：rpm 使用前端工具：yum, dnf rpm包管理rpm(redhat package manager)，rpm包中是已经编译好的程序文件。 /var/lib/rpm/：数据库，其中包含了所有rpm包的名称及版本，依赖关系，功能说明，包安装后生成的各文件路径及校验码信息。 rpm -ivh [install-options] PACKAGE_FILES： -i：安装 -v：显示安装过程 -h：显示程序包管理执行进度 -q：查询包是否安装，与-l一起使用，列出包中的文件；与-f使用，查询文件的所属包；-a，查询所有安装的包 -e：卸载 -U：升级 -V：包校验 …其余查询man帮助 yum管理YUM：Yellowdog Update Modifier，rpm的前端程序，基于C/S架构，可解决软件包相关依赖性，可在多个库之间定位软件包。 配置yum源：/etc/yum.repos.d/路径下xxx.repo中配置源服务器路径，yum命令安装时，查询本地repo源 -&gt; 查询服务器端元数据 -&gt; 下载元数据到缓冲区 -&gt; 下载rpm包到缓冲区 -&gt; 按依赖顺序安装包。 使用本地光盘配置yum源 检查是否安装autofs(自动挂载服务) systemctl start autofs：启动 systemctl enable autofs：设置开机自启动 systemctl status autofs：查看服务状态 ls /misc/cd -&gt; df：光盘/dev/sr0已自动挂载到/misc/cd目录下 cd /etc/yum.repos.d/，将原有的国外源删除（备份），创建一个新的以.repo结尾的配置文件，例如创建base.repo,配置如下 1234[base]name&#x3D;cdrom basebaseurl&#x3D;file:&#x2F;&#x2F;&#x2F;misc&#x2F;cdgpgcheck&#x3D;0 yum repolist：查看可用的repo列表 网络源配置 可单独创建一个xxx.repo，也可在现有的repo中追加，例如在base.repo中追加 1234[epel]name&#x3D;aliyun epelbaseurl&#x3D;https:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;epel&#x2F;$releasever&#x2F;$basearch&#x2F;gpgcheck&#x3D;0 其中releasever变量代表当前OS发行版本，basearch代表cpu架构 其他常用指令： yum clean all：清空yum源缓存 yum list：列出repo源所有包 yum install xxx：安装 yum remove xxx：删除 yum update pkgxxx：更新 yum info xxx：查看详细信息 源码编译安装首先使用wget URL下载好源码包，再根据语言选择编译安装方式： C/C++：make项目管理器 安装gcc 解压，进入到源码包目录中，运行./configure，通过选项传递参数指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile（安装前查看源码包中的说明帮助文档README、INSTALL等，亦可通过./configure --help查看可选项） make -j n根据Makefile文件，构建应用程序，j选项表示多线程并行编译。 make install 更改PATH Java：maven 压缩、解压缩工具 .Z后缀 compress：压缩后会删除原文件，可读取STDOUT内容进行压缩，支持管道 -c：结果输出至标准输出，不删除原文件。常见用法：compress -c file &gt; file.Z -v：显示详情 uncompress file.Z zcat file.Z：不显示解压缩的前提下查看文本文件内容 .gz后缀 gzip： -c：同compress -c -#：#取1-9，指定压缩比，值越大压缩比越大 gunzip file.gz zcat file.Z .bz2后缀 bzip2： -k： -#：默认为9 bunzip2 file.bz2 bzcat file.bz2 .xz xz： -k： -#：默认为6 unxz xzcat 一般来说压缩比：xz &gt; bzip2 &gt; gz &gt; compress，均不能压缩目录 .zip zip：支持压缩目录 unzip 打包(存档)和解包工具 tar常见用法：具体选项见man帮助 打包，保留权限：tar -cpvf xxx.tar file1 file2 file3... 追加文件至xxx.tar：tar -rf xxx.tar file1 file2..注：不支持对压缩文件追加 查看包中的文件列表：tar -tf xxx.tar 解包tar -xf xxx.tar [可选：-C /PATH] 结合压缩工具，打包并压缩： tar zcvf xxx.tar.gz [可选：/PATH]；.tar.gz也可写成.tgz tar jcvf xxx.tar.bz2 [可选：/PATH] tar Jcvf xxx.tar.xz [可选：/PATH] --eclude=/PATH/文件名：打包时排除某文件：tar -zcvf xxx.tgz --exclude=/a/b/abc.txt -T：指定打包列表；-X：指定排除列表 tar -zcvf xxx.tgz -T /a/list -X /a/excludeList split：分割一个文件为多份小文件 split -b SIZE xxx.tgz yyy：yyy为切割后的文件前缀，SIZE为每份大小 合并：cat yyy* &gt; xxx.tgz cpio：一种老的存档格式。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux之文件查找","slug":"(6)Linux之文件查找","date":"2019-11-22T07:44:54.000Z","updated":"2020-11-23T14:23:20.941Z","comments":true,"path":"Linux/(6)Linux之文件查找/","link":"","permalink":"http://thmasterplan.cn/Linux/(6)Linux%E4%B9%8B%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE/","excerpt":"","text":"非实时查找（数据库查找） 实时查找 选项 查找路径 查找条件 根据文件名和inode 根据owner, group 根据文件类型 根据文件大小 根据时间 根据权限 处理动作 非实时查找（数据库查找）locate是一个外部命令，需要安装：yum install mlocate。初次使用该命令需要执行updatedb构件索引。 locate命令查询系统上预建的文件索引数据库/var/lib/mlocate/mlocate.db，索引构建过程需要遍历整个根文件系统，极消耗资源。特点是查找速度快，模糊查找，非实时，搜索的是文件的全路径，可手动更新updatedb。常用选项： -i：不区分大小写 -n N：只列举前N个匹配项目 -r：使用基本正则表达式 实时查找find命令通过遍历指定路径完成文件查找，特点是查找速度略慢，精确，实时。 语法：find [选项] [查找路径] [查找条件] [处理动作] 选项 -maxdepth level：最大搜索目录深度，指定路径为第1级。 -mindepth level：最小搜索目录深度。 -depth：先搜索文件，再搜索目录；不加该选项时默认为先搜目录再搜文件。 查找路径默认为当前目录。 查找条件可以查找文件名，大小，类型，权限等，默认为找出指定路径的所有文件。 根据文件名和inode -name 文件名：支持文件通配符 -iname 文件名：不区分字母大小写 -inum n：按inode号查找 -samefile 文件名：相同inode号的文件 -links n：链接数为n的文件 -regex &#39;PATTERN&#39;：匹配整个文件路径而非文件名 根据owner, group -user 用户名 -group 组名 -uid UID -gid GID -nouser：比如某个用户被删除，但其文件还存在 -nogroup 根据文件类型 -type TYPE：TYPE包括f,d,l,s,b,c,p 空文件或目录：-empty，例如find /usr -type d -empty 根据文件大小 -size SIZE，常用单位k, M, G 对于SIZE的写法，-6k代表[0,5k]，6k代表(5k,6k]，+6k代表(6k,+∞) 根据时间 -atime/-mtime/-ctime -amin/-mmin/-cmin find ./ -mtime -3，代表[0,3）天内被修改，find ./ -mtime 3代表第3天被修改，find ./ -mtime +3代表被修改3天以上。 根据权限 -perm (/|-) MODE0配 MODE：精确权限匹配 /MODE：u,g,o中只要匹配到一个即可 -MODE：u,g,o必须同时满足指定权限 例如find ./ -perm -222指u,g,o均要有写权限才满足条件 不想搜索某目录时：使用-path &#39;目录&#39; -a -prune，例如find / -path &#39;/etc&#39; -a -prune -o -name passwd在根目录下除/etc外搜索文件名为passwd的文件。 组合条件：与：-a；或：-o；非：-not/!。即将以上各种条件组合使用查找。当需要使用括号时要转义。例如find /usr \\(-name &quot;f*&quot; -o -type f\\) -ls。 处理动作对符合条件的文件做操作，默认输出至屏幕。 -print：默认的处理动作，显示至屏幕。 -ls：类似于对查找到的文件执行ls -l命令。 -delete：删除查找到的文件。 -fls file：查找到的所有文件的长格式信息保存至指定文件中。等价于-ls &gt; file。 -ok cmd {} \\;：对查找到的每个文件执行由cmd指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认。 -exec cmd {} \\;：对查找到的每个文件执行由cmd指定的命令。 {}用于引用查找到的文件名称自身，包含路径名。。 xargs：cmd1 | xargs [选项] cmd2 xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。 xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。 xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。 xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。 xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。 之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令 具体选项见man帮助 举例：find linux-5.1.4/ -name &quot;*.c&quot; | xargs -n1 cat | wc -l统计出linux内核一共有多少行c代码；cat `find linux-5.1.4/ -name &quot;*.c&quot;`|wc -l实际运行更快。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux之文本处理","slug":"(5)Linux之文本处理","date":"2019-11-19T11:49:20.000Z","updated":"2020-11-23T14:23:20.935Z","comments":true,"path":"Linux/(5)Linux之文本处理/","link":"","permalink":"http://thmasterplan.cn/Linux/(5)Linux%E4%B9%8B%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86/","excerpt":"","text":"查看文本 文本替换 查看并截取 排序和统计 文本内容查找 正则表达式 查看文本 cat：适合查看小文本 -E：显示行结束符$ -n：对显示的每一行编号 -A：显示所有控制符 tac：从最后一行向前反向显示 rev：每一行都是反向显示 more/less：分页查看，按空格一屏一屏地显示，按回车一行一行地显示。同时在文档下方输入/字符串即可查找文档中的字符串。 od：查看非文本文档，比如二进制文件。 文本替换tr [选项] set1 set2 ：将输入的文本中所有的s1替换为s2。 -d：删除所有属于set1的字符。 -s：去重。把连续重复的字符以单独一个字符表示。 -t：把set1对应字符转换为set2对应字符。 查看并截取 head -c#：获取前#字节。 -#：获取前#行。 tail -c#：获取后#字节。 -#：获取后#行。 -f：可用于日志监控，例如tail -f /var/log/messages，即时打印日志追加文本的变化。 按列抽取：cut：cut -d# -f1,3：以#作为分隔符，截取第1列和第3列 -d：指明分隔符 -f：指明字段 练习：获取网卡ip地址：ifconfig ens33 | head -2 | tail -1 | tr -s &quot; &quot; | cut -d&quot; &quot; -f3 排序和统计 文本排序sort：把排序后的文本显示在STDOUT，不改变原始文件 -n：按照数字大小排序 -r：反向排序 -u：删除重复行 -t#：#作为字段界定符 -kX：选项按照使用#分隔的第X列来排序 uniq：删除连续重复的行 -c：显示重复出现的行的次数，常与sort命令一起使用；sort a.txt| uniq -c。 文本数据统计wc： wc test.txt：依次输出行数，单词数，字节数 -l：只计数行数 -w：只计数单词数 -c：只计数字节数 -m：只计数字符总数 -L：显示文件中最长行的长度 文本内容查找按关键字抽取：grep [选项] 模式 file文本搜索工具，根据指定模式（由正则表达式字符及文本字符所编写的过滤条件）对目标文本逐行进行匹配检查，打印匹配到的行。 正则表达式正则表达式(Regular Expression)是一种文本模式，包括普通字符（例如，a 到 z 之间的字母）和特殊字符（称为”元字符”）。 正则表达式使用单个字符串来描述、查找一系列匹配某个句法规则的字符串。 正则表达式元字符表.","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Java位运算","slug":"Java位运算","date":"2019-11-19T10:25:55.000Z","updated":"2020-11-23T14:23:21.009Z","comments":true,"path":"Java/Java位运算/","link":"","permalink":"http://thmasterplan.cn/Java/Java%E4%BD%8D%E8%BF%90%E7%AE%97/","excerpt":"","text":"&amp; ：按位与。同时为1才为1，否则为0。 | ：按位或。有一个为1则为1。 ~ ：按位取反。例如3：补码：0b00000000000000000000000000000011。~3—&gt;得:0b11111111111111111111111111111100。(依旧为补码)。减一后取反得原码(原码-&gt;补码的逆运算)：0b1000000000000000000000000000100。故3取反后为-4。 ^ ：按位异或。不同为1，相同为0。 0与任何数字异或都等于它本身 一个数据对相同的数据异或两次，值不变,常应用于加密。即a^b^b == a。 使用异或实现两个变量值交换。a = a^b; b = a^b; a = a^b。 &lt;&lt; ：左移。左操作数乘以2的n次幂。n是右操作数，即左移的位数。右边空出两位补0，左边两位被挤掉。 &gt;&gt; ：右移。左操作数除以2的n次幂。n是右操作数，即右移的位数。左边空出两位用符号位填充，右边两位被挤掉。 例如：-32 &gt;&gt; 2 ：原码：10000000000000000000000000100000，反码：11111111111111111111111111011111，补码：11111111111111111111111111100000。右移后为：11111111111111111111111111111000。求得原码为：10000000000000000000000000001000。得-8。 &gt;&gt;&gt; ：无符号右移。左边空出的位置用0补全。例如-32 &gt;&gt;&gt; 2变成一个很大的正数。 位运算均针对补码进行。正数的符号位为0，原、反、补码均为其本身；负数的符号位为1，其反码为对原码除符号位其余所有位求反，补码为对反码+1。 对于有符号数，计算机中存储的是补码。","categories":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"http://thmasterplan.cn/tags/Java/"}]},{"title":"网络安全总结","slug":"网络安全总结","date":"2019-11-19T10:21:36.000Z","updated":"2020-11-23T14:23:21.135Z","comments":true,"path":"杂项/网络安全总结/","link":"","permalink":"http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"一、 介绍 二、 古典加密技术 三、 对称加密 四、 公钥加密 五、 消息鉴别 六、 密钥建立和管理 七、 用户认证 八、 身份认证协议 九、 互联网安全协议和标准 十、 Hacking 十一、 信息收集（选择题） 十二、 缓冲区溢出 十三、 Web脚本攻击 十四、 DOS攻击 十五、 恶意代码、病毒、蠕虫 十六、 防火墙 十七、 入侵检测IDS 一、 介绍 网络安全五个特征： 保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。 完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。 可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需网络安全解决措施的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击； 可控性：对信息的传播及内容具有控制能力。 不可否认性：出现的安全问题时提供依据与手段。 安全机制: 加密机制 数字签名机制 访问控制机制 数据完整性机制 认证交换机制 通信业务流填充 路由控制 公证机制 普遍性安全机制 网络攻击方法: 被动攻击 主动攻击 物理临近攻击 内部人员攻击 软硬件装配攻击 二、 古典加密技术 代替密码：明文中的每个字符被替换成密文中的另一个字符 凯撒码 将明文转换为数字，使用加密函数E（m）=m+k(mod 26)得密文。解密函数D（c）=c-k(mod 26)。（只是字母简单的偏移） 维吉尼亚密码 密钥：一个字符串，对应一个数表 暴力破解需要26的k次方 代替密码特点： 单字母代换密码 ：明文中字母的出现频度、重复字母的模式和字母相互之间的结合模式等统计特性不变，安全性差。 多字母代替密码 ：字符块被成组加密 ，有利于抗击统计分析。 置换密码：又称换位密码（transposition cipher） ，并没有改变明文字母，只改变了这些字母的出现顺序。在对密文进行统计之后，易于判断该密文是否使用了置换密码加密方案。 Kerckhoffs假设：假定密码分析者知道对方所使用的密码系统，包括明文的统计特性，加密体制（操作方式、处理方法和加/解密算法）、密钥空间及其统计特性。但是，不知道密钥。在设计一个密码系统时，目标是在Kerckhoffs假设的前提下实现安全。 密码分析方法：尝试发现明文或密钥的过程 唯密文攻击：知道部分密文试图恢复明文，并试图推算密钥 已知明文攻击：知道部分消息密文及对应明文，试图推导密钥或算法 选择明文攻击：事先选择部分明文让被攻击者加密，并得到相应密文，试图推导出密钥或算法。 选择密文攻击：密码分析者需要掌握的内容包括：加密算法、截获的部分密文、自己选择的密文消息以及相应的被解密的明文。密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。由此能够计算出加密者的私钥或者分解模数，运用这些信息，攻击者可以恢复所有的明文。 维吉尼亚密码的密码分析 字母频率统计用于猜测 Kasiski测试法确定密钥长度 重合指数法破译密文 三、 对称加密 分组密码的设计原则 混乱原则：密码设计应保证明文与密文之间的依赖关系足够复杂。 扩散原则：密码设计应保证密钥的每位数字能够影响密文中的多位数字（避免对密钥逐段破译），同时应保证明文的每位数字能够影响密文中的多位数字（隐藏明文的统计特性）。 分组密码特点 优点：易于标准化，易于实现同步 缺点：不善于隐藏明文的数据模式，对于重放、插入、删除等攻击方式的抵御能力不强。 对称加密算法：DES/AES 分组密码工作模式 ECB（Electronic Codebook）: 电码本 用相同的密钥分别对明文分组独立加密 对长明文不安全，因为重复的明文块在密文中也是重复的 CBC（Cipher Block Chaining）：密文分组链接 加密算法的输入是上一个密文组和下一个明文组的异或 优点：能够隐蔽明文的数据模式；能够一定程度上防止分组的重放、插入和删除攻击。 缺点：易导致错误传播。任意一个明文或密文组出错会导致其后的密文分组出错。 CFB（Cipher Feedback）:密文反馈 一次处理s位（明文和密文均是），加密算法的输入是上一块密文，加密后产生的伪随机数输出与明文异或作为下一单元的密文。 实质是一种自同步流密码 适用于必须按比特或字符对明文进行加密的情况 OFB（Output Feedback）：输出反馈 与CFB类似，只是加密算法的输入是上一次加密算法的输出，且使用整个分组 优点：能够克服错误传播 缺点：很难发现密文被篡改；不具备自同步能力 CTR计数器 每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增 并行加密效率高 分组密码典型攻击方法 依据攻击者所掌握的信息：唯密文攻击、已知明文攻击、选择明文攻击 根据采用的技术方法 强力攻击（适用于任何分组密码算法）：穷尽密钥搜索、字典、查表、时间-存储权衡 差分密码分析 线性密码分析 差分-线性密码分析 攻击复杂度：数据复杂度（实施攻击所需输入的数据量）和处理复杂度（处理数据所需的计算量）。 对称密钥编码问题：通信密钥太多，管理与分发困难 四、 公钥加密 RSA原理 计算：(a x b) mod n = [(a mod n) x (b mod n)] mod n. RSA实现上的问题在构造n时应选择p和q的长度相差不大 RSA适合低频少量数据交换，如密钥分发；不适合数据量大，实时性强的场合（因为运算量大，慢） 五、 消息鉴别 概念：消息接收者对消息进行验证（真实性：确认并非假冒）（完整性：内容未被篡改）。 网络通信安全威胁：泄露、伪造、篡改、行为抵赖 鉴别与保密：鉴别不能自动提供保密性，保密性不能自动提供鉴别功能。 报文鉴别系统功能：鉴别算法（鉴别函数f产生鉴别码），鉴别协议，鉴别函数f是决定鉴别系统特性的主要因素。 鉴别函数分类： 以整个报文的密文作为鉴别符； 对称密钥加密：加密的同时提供保密和鉴别（强制明文具有某种结构） 附加报文鉴别结构：发送端：校验码C = f（M），密文X = Ek[M || C]; 接收端：Y = Dk(X) = [M’ || C’], 若f(M’) = C’,则报文可信。 公钥加密：提供报文鉴别和签名，不提供加密功能。 报文鉴别码(MAC)：核心是一个类似于加密的算法Ck()（k为密钥）, Ck(M)输出一个较短的定长数据分组也即MAC。发送[MAC || M]。接收端同样计算MAC，比较两个MAC是否相同。PS：MAC与加密函数比较：MAC可以是单向的，而加密函数必须可逆；MAC算法不能提供保密性。 散列函数方式（采用一个公共散列函数，将任意长度的报文映射为一个定长的散列值，并以散列值作为鉴别符）。（常用SHA-3，MD5）散列函数特性： 输入任意大小数据块，输出定长 容易计算 单向性：对任意散列值h要找到一个M使得H(M) = h不可行。 弱抗冲突性：对任意给定M，要找到M’ != M,使得H(M)=H(M’)计算上不可行。该性质可防止伪造。 强抗冲突性：要找到两报文M和N使他们散列值相同不可行。该性质指出散列函数对“生日攻击”的抵抗能力。 生日悖论攻击：伪造消息报文使hash值不变 中间符合攻击概念 六、 密钥建立和管理 密钥建立的模式：点到点（通信双方直接通信，分布式）；密钥分配中心KDC（用户与KDC有共享主密钥，KDC生成并分配会话密钥，集中式）；密钥转换中心KTC（只负责转发，集中式） Diff-Hellman密钥交换 如图，双方都计算出密钥为2 公钥加密体制的密钥分配：公钥的分配；使用公钥体制来分配对称密钥密码体制的密钥。 伪随机数生成器:线性同余算法；基于密码算法的随机数生成器（循环加密方式，DES的OFB模式）；BBS生成器； 密钥控制技术：密钥标签（DES的64位密钥中的8个校验位作为控制使用这一密钥的标签）；控制矢量 七、 用户认证 身份认证：密码，令牌（磁条卡，存储卡，智能卡），生物识别（虹膜，视网膜，指纹，签名，声音，脸） 口令破解：字典攻击，密码猜测，彩虹表攻击（可见密码不能明文存储，要求哈希后加salt，盐：随机字符） 口令的脆弱性：离线字典攻击；特定账户攻击；流行密码的攻击；单个用户的密码猜测；工作站劫持；电子监控；利用用户失误 Bad Passwords:过短的密码；易猜测的密码 Countermeasures：阻止未经授权访问密码文件；入侵检测措施；帐户锁定机制；自动工作站注销；加密的网络链接 八、 身份认证协议 Kerberos身份认证协议：集中式的认证服务器结构，认证服务器的功能是实现用户与其访问的服务器间的相互鉴别；采用对称加密技术 数字签名：直接数字签名仅涉及通信双方 使用公钥算法进行数字签名 假定接收方知道发送方的公钥 发送方用私钥加密整个消息或者消息的散列码 接收方用公钥解密即可确认发送方的身份 公钥基础设施(PKI) 提供三种安全服务： 认证：身份认证，采用数字签名实现 完整性：数据完整性，采用数字签名或消息认证码 机密性：采用对称加密 包括：认证机构CA，证书库，证书撤销，密钥备份和恢复，自动密钥更新，密钥历史档案，交叉认证，时间戳… X.509认证服务： X.509协议实现基于公钥加密算法和数字签名技术 证书由CA创建，CA用其私钥对证书签名，用户可用CA的公钥验证证书有效性并提取被认证的用户的公钥 九、 互联网安全协议和标准 IPSec:提供认证、保密性、密钥管理。优点：在传输层下，因而对应用程序、用户透明；抵抗旁路攻击；保护路由架构… IPSec架构： IPv6强制，IPv4可选 安全关联SA： 发送方和接收方之间的单向的关系，为数据流提供安全保障 由三个参数定义：Security Parameters Index (SPI)；IP Destination Address；Security Protocol Identifier 有一个安全关联数据库（） SA管理： 创建：先协商SA参数，再更新SAD；可人工创建，也可动态创建 删除：有效期过期；密钥遭破坏；另一端要求删除该SA 认证头(AH)： 提供数据整合和IP包认证 有限地抗重播攻击 基于消息认证码（MAC） 重放攻击：攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。 抗重播服务： 序列号字段：创建一个新的SA时，发送者会将序列号计数器初始化为0； 每当在这一SA上发送一个数据包，序列号计数器的值就加1并将序列号字段设置成计数器的值； 当达到其最大值2³²-1时，就应建立一个新的SA。 一种滑动窗口机制：IP是无连接的、不可靠的 ，需设立窗口；窗口的最左端对应于窗口起始位置的数据包序列号N，则最右端对应于可以接收的合法分组的最高序号N+WindowSize-1 ESP:提供保密性和抗重播服务 密钥管理:密钥生成和分发；AH和ESP各一对密钥； 安全套接层SSL： SSL的两个重要概念： SSL连接： 一个连接是一个提供一种合适类型服务的传输 SSL连接是端对端的 连接是暂时的 SSL会话： 一个SSL会话是在客户端和服务器之间的一个关联 会话由Handshake Protocal创建。会话定义了一组可供多个连接共享的加密安全参数 会话用以：避免为每一个连接提供新的安全参数所需的昂贵的谈判代价 十、 Hacking 攻击思路：信息收集，获取权限，安装后门（木马），扩大影响（攻击该网络其他主机），清除痕迹 安全评估 TCSEC，CC 十一、 信息收集（选择题） Web与搜索引擎服务 目标：获取目标网络或公司的URL，获取目标网络的拓扑结构 扫描目的：查看目标网络中哪些主机是存活的，查看存活的主机运行了哪些服务，查看主机提供的服务有无漏洞 IP扫描：判断目标网络有多少台主机存活（ping）（ping使用ICMP协议） 端口扫描：判断目标主机有哪些端口是打开的(TCP端口和UDP端口)（端口是入侵的通道） TCP扫描：TCP Connect，SYN，FIN UDP扫描 漏洞扫描 操作系统类型探测 十二、 缓冲区溢出 缓冲区：应用程序保存用户输入数据，程序临时数据的内存空间。缓冲区本质：数组。位置：堆、栈、数据段 溢出：用户输入数据长度超出了程序为其分配的内存空间，这些数据会覆盖其他程序数据的内存空间。 危害：程序异常，系统崩溃，程序跳到恶意代码，控制权被窃 溢出种类：堆溢出、栈溢出、整型溢出、格式化字符串溢出、其他溢出 溢出的共性：大对象向小对象复制数据，容纳不下造成溢出 避免缓冲区溢出漏洞： 人编写正确的代码 编译器进行数组边界检查 使用类型安全语言 RunTime保护 操作系统 硬件 十三、 Web脚本攻击 SQL注入攻击 ：把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令。步骤 绕过认证：conditions：账号密码的查询是同一条查询语句；密码没有加密保护 判断能否进行SQL注入 判断数据库类型及注入方法 猜测表名和字段名 猜测用户名和密码 预防 过滤关键字 限制输入长度 秘密字段使用散列函数保护 XSS跨站脚本攻击：通过在链接中插入恶意代码就能盗取用户信息。 预防 对动态生成页面的字符进行编码 对输入进行过滤限制 对动态内容使用HTML和URL编码 设置浏览器不执行任何脚本下载 十四、 DOS攻击 概念：利用网络协议漏洞或其他系统以及应用软件的漏洞耗尽被攻击目标资源，使得被攻击目标无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式。 原理：攻击者向服务器发送众多的带有虚假地址的请求，服务器发送回复信息后无限等待进而无法释放资源，连接超时后攻击者再度发送虚假请求。 DOS分类：SYN Flood（请求方不发送ACK），ping of death（ping请求数据包声称超过64K，接收方TCP/IP堆栈崩溃），teardrop… 发现僵尸网络：IDS（提取僵尸程序指纹信息），行为监测（僵尸程序行为模式），蜜獾捕获（捕获僵尸程序样本） 十五、 恶意代码、病毒、蠕虫 计算机病毒：是一个指令序列，能够把自身拷贝插入到其他主程序中 病毒模块：引导、传染、表现 病毒按链接方式分类： 操作系统病毒：用自己的运行逻辑取代系统的正常逻辑模块 外壳型：将病毒本身包围在宿主程序周围，对原来程序不作修改 入侵型：将病毒插入攻击目标之中，一旦感染难以发现清除 源码病毒：利用java, VBS等网络语言编写放在e-mail附件或HTML主页中。 按传染对象分类：磁盘引导型（磁盘引导区），文件型（可执行文件），宏病毒（office系列） 检测病毒方法： 特征代码法：采样，提取特征代码，特征代码纳入病毒特征数据库，打开被检测文件检索，若出现新病毒重复1-3步 校验和法：在文件被感染前根据文件内容计算校验和保存在其他文件中。优点：既可发现已知病毒又可发现未知病毒；缺点：只能判断文件是否被修改，而不能识别病毒种类和名称，且对隐蔽性病毒无效。 行为监测法：利用病毒的特有行为来监测病毒的方法。 蠕虫：一种可以通过网络连接进行自身复制的程序，与以往病毒方式不同，文件型病毒、宏病毒需要在计算机的硬盘、软盘或文件系统中繁殖，而典型的蠕虫只会在内存中维持一个活动副本，甚至根本不向硬盘写入任何信息。 十六、 防火墙 概念：防火墙指应用于内部网络和外部网络之间的，用来保护内部网络免受非法访问和破坏的网络安全系统。 主要功能： 过滤进出网络的数据 防止不安全的协议和服务 管理进出网络的访问行为 记录通过防火墙的信息内容与活动 对网络攻击进行检测与告警 防止外部对内部网络信息的获取 提供与外部连接的集中管理 不能防范的攻击：内部威胁、病毒、应用程序漏洞、木马、社会工程、不当配置 防火墙分类：按实现技术（包过滤型（静态，动态），代理型（应用代理，电路代理，NAT））；按体系结构（双宿/多宿主机，屏蔽主机（双重保护安全性更高），屏蔽子网，混合结构）。 静态包过滤（传输层和网络层）：对包头内容进行简单过滤（源和目的IP，IP选项，IP上层协议，TCP和UDP源及目的端口，ICMP报文类型和代码）。 防火墙规则制定策略：a.拒绝任何访问，除非被规则特别允许。b.允许任何访问，除非规则特别禁止 过滤的两种基本方式：按服务过滤（如Telnet，SMTP，FTP等等）；按规则过滤。 静态包过滤的优缺点：速度快，价格低，对用户透明；配置难把握，防范能力低，没有用户身份验证机制。 动态包过滤（网络层）（状态检测防火墙）：不仅以一个数据包的内容作为过滤依据，还根据这个数据包在信息流位置加以判断 动态包过滤优缺点：基于应用程序信息验证一个包状态的能力，记录通过的每个包的详细信息；造成网络连接的迟滞，系统资源要求较高。 应用代理防火墙（应用层）：对所有规则内允许的应用程序作中转转发；牺牲了对应用程序的透明性。 应用代理优缺点：可以隐藏内部网络信息，具有强大的日志审核，实现内容过滤；价格高，速度慢，失效时造成网络瘫痪。 电路级代理（传输层）优缺点：隐藏内部网络信息，配置简单（无需为每个应用程序配置一个代理）；多数电路级网关都是基于TCP端口配置，不对数据包检测可能会有漏洞。 NAT优缺点：管理方便并且节约IP地址资源，隐藏内部IP地址信息；外部应用程序不能方便地与NAT网关后的应用程序联系。- 理解防火墙的四种体系结构 十七、 入侵检测IDS 由于防火墙无法发现和阻止:a.对合法服务的攻击。b.源自其他入口的攻击。c.来自内部网络的攻击。d.来自木马的威胁。入侵检测技术通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现网络或系统中是否有违反安全策略行为和被攻击迹象的一种安全技术。 IDS任务：从系统正常运行产生的和攻击者进行攻击时产生的混合数据中找出入侵痕迹。 通用入侵检测框架CIDF：体系结构；组件通信（事件产生器（数据获取）；事件分析器（数据分析）；事件数据库（数据管理）；响应单元（行为响应））；语言规范；编程接口。 小结：入侵检测技术收集主机日志及网络流量等信息，通过模式匹配、统计分析或完整性分析，能够有效发现入侵行为。入侵检测形成了网络的纵深防御，成为防火墙技术的有益补充。网络技术的发展给入侵检测带来各种新的困难，同时也带来机遇。","categories":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"}],"tags":[{"name":"杂项","slug":"杂项","permalink":"http://thmasterplan.cn/tags/%E6%9D%82%E9%A1%B9/"}]},{"title":"Linux之权限与用户组管理","slug":"(4)Linux之权限与用户组管理","date":"2019-11-17T16:16:20.000Z","updated":"2020-11-23T14:23:20.932Z","comments":true,"path":"Linux/(4)Linux之权限与用户组管理/","link":"","permalink":"http://thmasterplan.cn/Linux/(4)Linux%E4%B9%8B%E6%9D%83%E9%99%90%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","excerpt":"","text":"文件权限 权限概述 r/w/x权限对于目录的意义 更改权限 默认权限 特殊权限 ACL 权限与指令间的关系(在用户模式下)) 文件隐藏属性 用户组管理 chown chgrp 用户和组的配置文件 用户和组的增删改 文件权限权限概述使用命令 ls -l file可列出该文件的权限信息 ，例如-rw-r--r-- 1 root root 4.0K 07-19 01:02 abc.log，其含义如下： 第1位： -：表示普通文件。 d：目录。 b：设备文件（块文件，即可以用来存储的设备文件）。 c：设备文件（字符文件，不能用来存储的设备文件）。 l：软链接（快捷方式）。 p：管道文件pipe。 s：套接字文件socket。 后9位：r表示可读，w表示可写，x表示可执行。 2-4位：用户的权限范围。 5-7位：组的权限范围。 8-10位：其余人的权限范围。 1表示该文件的硬链接数。 第一个root表示该文件的所有者用户。 第二个root表示该文件所属的组。 4.0K表示该文件的大小。 后面为最后一次修改的时间戳和文件名。 r/w/x权限对于目录的意义 r权限：可读取目录结构列表，即可查看目录下的文件名和子目录名。（注意：只有r权限不能查看文件内容） w权限：可创建文件和目录，可删除，可重命名，可转移。 x权限：可进入该目录。 更改权限使用chmod更改权限。 chmod u+x,g+w,o-r abc.log：abc.log权限由-rw-r--r--变为-rwxrw----。 chmod a=r file或者chmod +r file：表示对file的u/g/o同时都赋予可读权限。 Linux中也可通过数字更改权限，r = 4，w = 2， x = 1，即u/g/o的权限分别可用一个整数表示，例如chmod 741 file表示file的u/g/o权限为-rwxr----x。 参数-R：R及recursive（递归）；chmod -R 741 directory，表示改变目录及目录下所有文件的权限为741。 默认权限文件预设权限：在没有umask的情况下，目录默认权限为777，文件的默认权限为666。但是使用umask命令发现Linux默认设置umask值为0022，它表示创建文件和目录，g和o都过滤掉写(w/2)权限，因此创建目录默认权限为755，创建文件默认权限为644。 umask的第一位表示过滤特殊权限。 特殊权限 SUID（最常用）：chmod u+s file，使file文件x权限上显示为S，表示非所属者可以获得所属者的所有权限。注意事项： SUID权限仅对二进制程序有效，不能用在脚本和目录上。 执行者对于该程序有x的可执行权限。 SUID权限仅在执行程序的过程中有效。 让本没有相应权限的用户运行该程序时，可以获得其原本没有权限访问的资源。 SGID：非所属组成员获得所属组的权限。 非组成员对于该程序需要具备x的权限。 SGID主要用于目录, 在该目录下创建的任何文件及子目录属于该目录所拥有的组 。 SBIT: 目前只针对目录有效，且只能分配给其他人（o）;对于目录的作用是：当用户在该目录下建立文件或目录时，仅有自己与 root才有权力删除，例如/tmp。 SUID/SGID/SBIT权限设置 ： 文字法 ：SUID: u+s ，SGID: g+s，SBIT: o+t 数字法：将原来的三位数扩展为四位数即可，SUID为4，SGID为2，SBIT为1，把它们放在权限数字的最开头。例如设置SUID，可以写成4777，设置SGID可以写成，2777 。 ACLACL即Access Control List，当一个用户(组)不是某文件的所有者(所属组)，又需要其对该文件拥有某些权限，可指定用户(u)或组(g)的权限，相当于特殊列表，用于实现灵活权限控制。权限优先级：所有者&gt;ACL权限(用户&gt;组&gt;other)。 setfacl -m u:用户名:权限 file。例如setfacl -m u:Tom:rw abc.txt，即指定Tom对abc.txt具有r和w权限。 setfacl -x g:用户名 file：删除权限。 setfacl -R -b dir/：删除dir下所有的ACL权限。 getfacl file：显示file的ACL权限。 权限与指令间的关系(在用户模式下)用户能进入某目录：需要权限x 进入目录后能利用ls查阅：需要权限r 进入目录后能够创建文件和目录：需要权限w 用户在目录内打开读取文件： 目录需要权限x 文件需要权限r 文件隐藏属性lsattr -a：显示所有隐藏属性。 chattr [-RV][-v][+/-/=&lt;属性&gt;] [文件或目录]: -R：递归处理，将指定目录下的所有文件及子目录一并处理 -v：&lt;版本编号&gt; 设置文件或目录版本 -V： 显示指令执行过程 +&lt;属性&gt;： 开启文件或目录的该项属性 -&lt;属性&gt; ：关闭文件或目录的该项属 =&lt;属性&gt;： 指定文件或目录的该项属性 属性： a：让文件或目录只能加数据。 i：不得任意更动文件或目录。 b：不更新文件或目录的最后存取时间。 c：将文件或目录压缩后存放。 d：将文件或目录排除在倾倒操作之外。 s：保密性删除文件或目录。 S：即时更新文件或目录。 u：预防意外删除。 例如chattr +a /var/log/messages:让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件 用户组管理chown更改文件的所有者。示例： chown user file：将file的所有者改为user。 chown user.group file：将file的所有者改为user，同时更改其组为group。 chown -R user directory：若要更改目录的权限，则需要加-R（表示递归）才能将其里面所有文件的权限更改。 chgrp更改文件的所有组。示例：chgrp root file， 将file的所有组改为root。 Linux组的类别有： 用户的主要组：用户必须属于一个且只有一个主组，组名同用户名，且仅包含用户自己。 用户的附加组：一个用户可属于0或多个附加组。 id 用户名：查看用户的uid、gid（主组）、groups的id。管理员root的uid和gid为0。 用户和组的配置文件 /etc/passwd：用户及其属性信息(名称、UID、主组ID)。 /etc/group：组及其属性信息。 /etc/shadow：用户密码及其相关属性。 /etc/gshadow：组密码及其相关信息。 /etc/default/useradd：创建用户时的默认设置。 用户和组的增删改 useradd，userdel，usermod groupadd，groupdel，groupmod","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux之目录与文件","slug":"(3)Linux之目录与文件管理","date":"2019-11-17T16:14:20.000Z","updated":"2020-11-23T14:23:20.921Z","comments":true,"path":"Linux/(3)Linux之目录与文件管理/","link":"","permalink":"http://thmasterplan.cn/Linux/(3)Linux%E4%B9%8B%E7%9B%AE%E5%BD%95%E4%B8%8E%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86/","excerpt":"","text":"目录结构 文件与目录管理 文件的三个时间属性 文件名规则 文件通配符 常用文件操作命令 文件链接 硬链接 软链接（符号链接） 区别 目录结构在Linux系统中，一切皆文件。根目录下的所有目录及其用处如下表所示： 目录 存放： /bin 二进制文件，常用命令。该目录不能有子目录。 /boot 引导加载程序的静态文件，内核 /dev 设备文件，CPU、硬盘等 /etc 配置文件。该目录下不能有二进制文件。 /home 用户家目录，每个用户在/home下都有一个目录 /lib 必须的共享库和内核模块 /media 媒体自动挂载点，比如U盘，光盘等 /mnt 媒体挂载点，手动挂载 /opt 自定义软件安装处，默认安装处为/usr/local /root 超级用户目录 /sbin 存放系统管理员所能执行的命令 /tmp 临时文件 /usr 二级层次结构， 类似于二层根目录。/usr 是可共享的只读数据。 /var 变量数据。存放缓存，日志，数据库文件；该文件夹需要分配的空间较大，因此在磁盘分区时挂载在/var的分区要大一些。 /proc 内存中的进程信息 /sys 系统相关信息 /srv 本系统所提供服务的数据文件 更详细的信息可参见Filesystem Hierarchy Standard By Linux Standards Base Workgroup. 文件与目录管理文件的三个时间属性 atime：access time。最近一次访问文件的时间，显示一个文件的内容或者运行一个shell脚本会更新文件的atime。可用ls -lu命令查看。 mtime：modify time。最近一次文件内容被修改的时间。可用ls -l命令查看。 ctime：change time。文件状态改变的时间，在写入文件、更改所有者、权限或链接设置时随 Inode 的内容更改而更改，即文件状态最后一次被改变的时间。可用ls -lc命令查看。 stat 文件：该命令可查看文件的详细信息（Inode信息）。 文件名规则 XFS文件系统中，文件名最长255字节。 Linux文件颜色代表含义： 蓝色—&gt;目录； 绿色—&gt;可执行文件； 红色—&gt;压缩文件； 浅蓝色—&gt;链接文件； 黄色—&gt;设备文件； 粉色—&gt;套接字文件； 棕色—&gt;管道文件； 灰色—&gt;其他文件 文件通配符 *：匹配0个或多个字符 ?：匹配任意一个字符 [1-5]：匹配字符1, 2, 3, 4, 5 [a-c]：匹配字符a、A、b、B、c(没有C)。 [A-C]：匹配A，b，B，c，C [^abcd]：匹配除abcd外的所有单个字母 常用文件操作命令 cd ~:切换到home;cd -:切换到上一次所在目录。 pwd：打印当前路径。 basename 和 dirname：分别获取当前路径的文件名和目录名。 touch xx：若xx不存在，则创建一个新文件xx；若xx存在，把xx的修改时间改为当前。 &gt; xx：若文件不存在，则创建一个空文件xx；若文件存在，则清空现有文件xx(可用于清空大文件)。 mkdir 目录名 目录名 目录名 ...：创建目录。 mkdir -p test/{a,b,c}/{d,e}：递归创建目录，分别在a,b,c三个目录下创建d,e两个目录。 rmdir 目录名：只能删除空目录。 rm -rf目录：删除目录下所有文件（慎用rm）。-r选项表示recursively，递归删除；-f选项表示force，强制删除。 cp [选项] /PATH1/xx /PATH2/yy：若yy是一个目录，则把文件xx拷贝到yy下；若yy不是一个目录，则把文件xx拷贝到PATH2目录下并重命名为yy。cp不能直接拷贝目录，需要加选项参数，cp -rfp /目录1 /目录2或cp -a /目录1 /目录2：将目录1及其所有子目录及文件拷贝到目录2。参数：-r即递归，-f即强制, -p同时复制属性信息。 mv [选项] /PATH1/xx /PATH2/yy：若yy是一个目录，则把文件xx剪切到yy下；若yy不是一个目录，则把文件xx剪切到PATH2目录下并重命名为yy。例如mv xx yy：就是把xx重命名为yy。 rename .log .logabc *：重命名，把所有文件名中的.log改为.logabc。 文件链接硬链接一个Inode号对应多个文件名，硬链接也即对文件使用了别名，由命令ln oldfile newfile创建。删除一个硬链接文件并不影响其他有相同Inode号的硬链接和原文件。 软链接（符号链接）软链接的Data Block中存放的内容是另一文件的路径。由命令ln -s oldfile newfile创建。rm -rf a.link/删除的是链接指向的文件，而rm -rf a.link删除的才是软链接。删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接） 区别 区别 硬链接 软链接 链接计数 加1 不变 交叉文件系统创建 不能 能 对目录创建 不能 能 与原文件Inode/DataBlock是否相同 都是 都不是","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux之VIM入门","slug":"(2)Linux之VIM入门","date":"2019-11-17T16:12:02.000Z","updated":"2020-11-23T14:23:20.914Z","comments":true,"path":"Linux/(2)Linux之VIM入门/","link":"","permalink":"http://thmasterplan.cn/Linux/(2)Linux%E4%B9%8BVIM%E5%85%A5%E9%97%A8/","excerpt":"","text":"命令(Normal)模式：模式：) 编辑(Insert)模式模式) 扩展命令(Extended Command)模式模式) 命令(Normal)模式：默认模式，可移动光标，剪切/粘贴文本。Normal模式切换到Insert模式：输入i, a, o, I, A, O任意一个即可；Normal模式切换到Extended Command模式：输入:。 h：左； l：右；j：下；k：上； )：下一句；(：上一句 }：下一段；{：上一段 ctrl d：向下翻半屏 ctrl u：向上翻半屏 /字符串：全文查找字符串 编辑(Insert)模式可修改文本。Insert模式切换到Normal模式：ESC键； 扩展命令(Extended Command)模式保存，执行命令，退出等。Extended Command模式切换到Normal模式：ESC键； wq：存盘退出； q!：不存盘退出； w：临时保存，类似于win下的ctrl+s； r filename：将filename的文件内容读到当前文件中； w filename：将当前文件内容写入filename文件中； !命令：在不退出vim的情况下执行命令； r!命令：在不退出vim的情况下，将执行命令的结果写入当前文件。 set number：显示行号；输入数字再输入+或-则向下或向上跳相应行数。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]},{"title":"Linux入门","slug":"(1)Linux之基础入门","date":"2019-11-17T16:11:48.000Z","updated":"2020-11-23T14:23:20.903Z","comments":true,"path":"Linux/(1)Linux之基础入门/","link":"","permalink":"http://thmasterplan.cn/Linux/(1)Linux%E4%B9%8B%E5%9F%BA%E7%A1%80%E5%85%A5%E9%97%A8/","excerpt":"","text":"命令帮助 简单说明 详细说明 小工具 常用命令 常用 开关机 图形化界面 文件与目录 系统设置 内部命令与外部命令 命令别名 远程连接与文件上传 技巧与快捷键 标准IO和重定向 默认I/O I/O重定向至文件 管道 命令帮助简单说明 whatis 命令：列出命令的作用以及man帮助的章节。 命令 --help：命令用法 help：列出所有的内部命令 详细说明 info 命令 man 章节号 命令：命令更详细的用法 man -k &quot;String&quot;：查找所有包含String的命令 小工具 日期：date。 日历：cal。 计算器：bc。 文本编辑器：nano。 常用命令常用 获取root权限：su -或su root。 sync：将内存中的数据写入磁盘，防止丢失。 清屏：clear。 查看主机名：hostname。 启动程序后台运行：nohup。例如：nohup java -jar xxx.jar。 开关机需要root权限。 重启：reboot/shutdown -r 关机：shutdown/poweroff shutdown -h 1：定时1分钟关机。 shutdown -h 8:20：8:20关机。 图形化界面图形界面与命令行界面的切换：Ctrl + Alt + f1...f7，其中只有f7为图形化界面，启动图形化界面也可以用startx命令。 文件与目录 打印所有文件与目录： ls -l/ll：列出当前目录所有文件。 ls -a：列出所有文件包括隐藏目录。 查看文件类型：file 文件名 查看树状目录结构：tree，需要安装；选项-d只显示目录；选项-L显示指定层级；例如tree -d /boot -L 1，打印/boot下的第一层目录。 系统设置 更改密码：passwd。 更改主机名：hostnamectl set-hostname 名字。 修改提示符颜色：root用户修改PS1变量的值，例如PS1=&quot;\\[\\e[31;1m\\]\\u @ \\[\\e[34;1m\\]\\h \\[\\e[36;1m\\]\\w \\[\\e[33;1m\\]\\t $ \\[\\e[37;1m\\]&quot;，并保存在配置文件/root/.bashrc中，普通用户修改需要保存到对应目录下的.bashrc中，并. .bashrc或source .bashrc执行该脚本。 内部命令与外部命令 查看命令类型：type 命令，内部命令集成在shell中，存放于/bin，外部命令存放于/usr/bin。 查看所有内部命令：enable，我们也可以禁用内部命令：enable -n 命令。 PATH环境变量：外部命令必须在当前目录下执行，亦可使用绝对路径调用，若要直接敲命令就可以执行，则需要设置PATH，把命令所在目录添加在PATH后面。查看PATH：echo $PATH. Hash缓存表：系统初始hash表为空，当外部命令执行时，默认会从PATH路径下寻找该命令，找到后会将该命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先查看hash表，存在则执行命令，不存在则去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率。 hash：显示hash缓存 将外部命令路径写入到/etc/profile文件中：PATH=$PATH:/xxx/yy，执行source /etc/profile后即可在任意路径下使用该外部命令。 相同命令执行优先级：别名 &gt; 内部命令 &gt; 外部命令hash表 &gt; $PATH。 命令别名alias 别名 = &#39;常用命令&#39;：设立别名；在CentOS7中，需在/root/.bashrc中保存。 alias可列出所有别名。 若别名与原命令同名，可通过\\命令名执行原命令。 编辑配置文件不会立即生效，可通过. 配置文件名使bash进程重新读取配置文件使编辑生效。 远程连接与文件上传 远程连接：ssh 用户名@IP，例如ssh root@47.92.168.44 文件上传：scp 文件或目录 用户名@IP:/tmp，例如scp myFile.txt root@47.92.168.44:/tmp 技巧与快捷键 命令补全：Tab。命令、文件名、选项、参数补全，连续两次Tab键可列出所有选项。 终止/退出程序：Ctrl+c, Ctrl+d 。 翻页：Shift+PageUp/PageDown。 命令的嵌套执行：用$()表示，以ls -l $(which passwd)为例，which passwd echo：回显字符串；显示变量。 单引号：单引号中的内容就是字符串 反向单引号：其中的内容命令和变量均能识别。例如：touch `date +%F`.log：创建以当前时间命名的文件。反向单引号等价于$()。 双引号：能识别变量不能识别命令 {}：打印重复字符串；例如touch file{1..10}：创建了10个文件分别为file1,file2,,,file10。 标准IO和重定向默认I/O 标准输入(STDIN)：（文件描述符0） 默认接收来自键盘的输入。 标准输出（STDOUT）：（文件描述符1） 默认输出到终端窗口。 标准错误（STDERR）：（文件描述符2） 默认输出到终端窗口。 I/O重定向至文件 标准输出重定向：&gt;；例如hostname &gt; /dev/pts/2将输出重定向至另一设备；若为文件，则清空文件再写入。&gt;&gt;则是追加，而不清空原文件；例如hostname &gt;&gt; /data/abc.log。 标准错误重定向：2&gt;；&gt;&gt;则是追加。 标准输出和标准错误一起重定向：&amp;&gt;。 标准输入重定向：&lt;；例如bc &lt; bc.txt，将bc.txt文件作为输入用bc计算。 示例：cat &gt; abc.log：标准输入单行重定向到文件；cat &lt;&lt;EOF &gt;abc.log标准输入多行重定向至文件，输入EOF才写入文件。 管道 管道命令1 | 命令2 | 命令3 | ...：将命令1的STDOUT发送给命令2的STDIN，再将命令2的STDOUT发送给命令3的STDIN。。。 STDERR默认不能通过管道转发，可利用|&amp;实现。 管道线后面的命令在一个subbash中执行，执行完就退出该subbash。 例子：echo {1..100} | tr &#39; &#39; + | bc：计算1到100的和。","categories":[{"name":"Linux","slug":"Linux","permalink":"http://thmasterplan.cn/categories/Linux/"}],"tags":[{"name":"CentOS7","slug":"CentOS7","permalink":"http://thmasterplan.cn/tags/CentOS7/"}]}]}