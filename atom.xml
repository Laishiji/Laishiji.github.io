<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2020-09-03T09:23:14.793Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-03T09:22:40.000Z</published>
    <updated>2020-09-03T09:23:14.793Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li>一个Java类从编写完成到被卸载的过程：X.java -&gt; X.class（编译为磁盘中的二进制文件）-&gt; 加载（ClassLoader将X.class加载到虚拟机内存）-&gt; 连接 （确定类与类之间的关系，包含验证、准备、解析三步） -&gt; 初始化  -&gt; 使用 -&gt; 卸载。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。类加载过程如下图：</li></ul><p><img src="ClassLoading_Procedure.png" alt=""></p><ul><li><p><strong>加载</strong>：加载是类加载的一个阶段，注意不要混淆。</p><p>加载阶段完成以下三件事：</p><ul><li>通过一个类的全限定名来<strong>获取</strong>定义此类的<strong>二进制字节流</strong>。</li><li>将该字节流表示的静态存储结构<strong>转换</strong>为<strong>方法区的运行时数据结构</strong>。</li><li>在内存中<strong>生成</strong>一个代表该类的java.lang.<strong>Class对象</strong>，<strong>作为</strong>方法区该类的各种<strong>数据的访问入口</strong>。</li></ul><p>二进制字节流的获取方式有：</p><ul><li>从<strong>ZIP包</strong>读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从<strong>网络</strong>获取，典型应用为Applet</li><li><strong>运行时计算生成</strong>，比如动态代理技术，在java.lang.reflect.Proxy中使用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。</li><li>由<strong>其他文件</strong>生成，比如由JSP文件生成对应的Class类。</li><li>从<strong>数据库</strong>读取。</li></ul></li><li><p><strong>连接</strong></p><ul><li><strong>验证</strong>：这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li><li><strong>准备</strong>：在方法区中，为类的<strong>静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong>（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型为null…），但是对于<strong>final修饰</strong>的常量则直接赋<strong>指定值</strong>。注意：实例变量（即未被static修饰的变量）不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，也就是类加载完成之后了。</li><li><strong>解析</strong>：将class文件常量池的<strong>符号引用替换为直接引用</strong>的过程。<ul><li>符号引用：与虚拟机的内存布局无关。可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li>直接引用：与虚拟机实现的内存布局相关。可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。</li></ul></li></ul></li><li><p><strong>初始化</strong>：<strong>为类的静态变量赋予正确的初始值</strong>（此时才赋予程序员设定的值），<strong>并执行静态代码块</strong>。</p><p>Java程序对类的使用方式可分为两种：主动引用与被动引用。每个类（接口）只有被Java程序“<strong>首次主动引用</strong>”时才<strong>初始化</strong>。包括：</p><ol><li>使用<strong>new</strong>实例化该类对象。</li><li><strong>读取或设置</strong>一个类（接口）的<strong>静态字段，</strong>以及<strong>调用</strong>一个类（接口）的<strong>静态方法</strong>。注：被final修饰的静态字段除外。</li><li>使用java.lang.reflect包的方法对类进行<strong>反射</strong>调用。</li><li><strong>初始化某类的子类</strong>（先初始化父类）。</li><li>带<strong>main</strong>方法的类。</li><li>JDK1.7开始提供的动态语言支持 *。</li></ol><p>被动引用例子：</p><ul><li><p>通过子类引用父类的静态字段，不会导致子类初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);&#x2F;&#x2F;value字段在SuperClass中为静态字段</span><br></pre></td></tr></table></figure></li><li><p>通过数组定义来引用类，不会触发被引用类的初始化。但是该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] array &#x3D; new SuperClass[10];</span><br></pre></td></tr></table></figure></li><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p><strong>类与类加载器</strong>：加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作在虚拟机外部实现，由类加载器实现。我们可以通过自定义类加载器去控制字节流的获取方式。注意：数组类不通过类加载器创建，它由JVM直接创建。</p><p>HotSpot VM内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol></li><li><p><strong>双亲委派模型</strong>：每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候：</p><ol><li>系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。</li><li>加载的时候，首先会<strong>把该请求委派该父类加载器的 <code>loadClass()</code> 处理</strong>，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</li></ol><p><img src="classloader_PDM.png" alt=""></p><p>以上的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p><ul><li><strong>双亲委派模型的好处</strong>：双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</li></ul></li><li><p><strong>破坏双亲委派模型</strong>：自定义类加载器，需要继承ClassLoader。如果不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载；如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个Java类从编写完成到被卸载的过程：X.java -&amp;gt; X.class（编译为磁盘中的二进制文
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC与内存分配策略</title>
    <link href="http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</id>
    <published>2020-09-02T07:17:43.000Z</published>
    <updated>2020-09-02T12:53:38.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象已死吗（GC回收的前提是判断对象已死）"><a href="#对象已死吗（GC回收的前提是判断对象已死）" class="headerlink" title="对象已死吗（GC回收的前提是判断对象已死）"></a>对象已死吗（GC回收的前提是判断对象已死）</h3><ul><li><p><strong>概述</strong>：对于程序计数器、虚拟机栈、本地方法栈，其内存区域和回收都具备确定性，方法结束或线程结束时，其内存自然就回收了。GC主要关注堆和方法区的分配与回收。</p></li><li><p><strong>引用计数算法（不常用）</strong>：给对象添加一个引用计数器，每当被引用时，计数器值+1；引用失效（引用不再指向该对象）时，计数器值-1。任何时刻计数器为0的对象就是不可能再被使用的。缺点：难以解决对象之间相互循环使用的问题。（比如对象A中的引用指向B，对象B中的引用指向A，对象A、B计数器永远为1）</p></li><li><p><strong>可达性分析算法（主流实现）</strong>：通过一系列的称为“GC Roots”的对象作为起始点向下搜索，搜索走过的路径称为“引用链”，当一个对象到“GC Roots”没有任何引用链相连，即证明对象不可达。</p><p><img src="Reachability_Analysis.png" alt=""></p><p>可作为GC Roots的对象包括：</p><ul><li>虚拟机栈：栈帧中局部变量表中引用的对象</li><li>方法区：<ul><li>类静态变量引用的对象</li><li>常量引用的对象</li></ul></li><li>本地方法栈：JNI引用的对象</li></ul></li><li><p><strong>再谈引用</strong>：JDK1.2之后，引用概念分为以下4种，强度依次减弱</p><ul><li><strong>强引用</strong>：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。</li><li><strong>软引用</strong>：描述有用但非必须的对象，当<strong>系统将要发生OOM异常时</strong>，软引用指向的对象才被真正回收。通过SoftReference类实现。</li><li><strong>弱引用</strong>：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。</li><li><strong>虚引用</strong>：为一个对象设置虚引用关联的唯一目的时能<strong>在对象被回收时收到一个系统通知</strong>。通过PhantomReference类实现。</li></ul></li><li><p><strong>生存还是死亡</strong>：即使在可达性分析算法中不可达的对象，在该对象的finalize()方法中也有一次自救的方法，即重新与引用链上的任何一个对象建立关联即可，譬如把this赋值给某个类变量或者对象的成员变量。但是，建议使用try-finally语法而尽量不使用finally()方法。</p></li><li><p><strong>回收方法区</strong>：主要回收<strong>废弃常量</strong>和<strong>无用的类</strong>。废弃常量的回收与堆中的对象类似，而无用类的判定则要复杂的多，需要满足：</p><ul><li>堆中不存在该类的实例</li><li>ClassLoader已被回收</li><li>Class对象没有被引用，且无法在任何地方通过反射访问该类的方法。</li><li>是否对类进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</li><li>注：对于大量使用反射、动态代理、CGLib等ByteCode框架的场景，要注意方法区的类卸载。</li></ul></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><p><strong>标记-清除算法</strong>：标记回收对象，标记完成后统一回收。</p><p><img src="mark_clean.jpeg" alt=""></p><ul><li>缺点：标记和清除效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul></li><li><p><strong>标记-整理算法</strong>：标记回收对象，让所有存活的对象向一端移动，然后直接清理掉对象所在的连续内存后的所有内存。</p><p><img src="mark_arrange.png" alt=""></p><ul><li>特点：适用于老年代的算法，不会产生内存碎片。</li></ul></li><li><p><strong>复制算法</strong>：对于现在的商业虚拟机，堆内存被划分为三块，一块较大的Eden空间、两块较小的Survivor空间。</p><ol><li><p>当Eden空间满时，第一次Minor-GC（针对新生代的GC）将Eden还存活的对象全部复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden；</p></li><li><p>当Eden满时，第二次Minor-GC将Eden和Survivor-0中还存活的对象复制到Survivor-1中，存活对象“寿命计数器”+1，清理Eden和Survivor-0；</p></li><li><p>当Eden满时，第三次Minor-GC将Eden和Survivor-1中还存活的对象复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden和Survivor-1；</p><p>…….</p></li><li><p>如此往复，当某个Survivor满或者对象“寿命计数器”值达到阈值，则将对象复制到老年代中。</p></li><li><p>当老年代和新生代都满时，会进行一次Full-GC。</p></li></ol><ul><li><p>HotSpot虚拟机的Eden和Survivor大小默认比例为8:1，保证了内存利用率达到90%。</p><p><img src="Copying.png" alt=""></p></li></ul></li><li><p><strong>分代收集算法</strong>：现在的商业虚拟机采用分代收集算法。</p><ul><li><strong>新生代：由于每次GC时都有绝大部分对象死去，只有少量对象存活</strong>，故采用<strong>复制算法</strong>，因为只需要付出少量存活对象的复制成本。</li><li><strong>老年代：由于老年代对象存活率高且没有额外空间对它分配担保</strong>，故采用标记-整理算法或标记-清除算法。</li></ul></li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="GC.jpg" alt=""></p><p>以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器之间可以搭配使用。</p><ul><li><p><strong>Serial收集器</strong>：单线程；简单高效，拥有最高的单线程收集效率；Client场景下的默认新生代收集器。</p><p><img src="Serial.jpg" alt=""></p></li><li><p><strong>ParNew收集器</strong>：Serial的多线程版本；Server场景下默认的新生代收集器；唯一能与CMS收集器配合使用的收集器。</p><p><img src="ParNew.jpg" alt=""></p></li><li><p><strong>Parallel Scavenge收集器</strong>：多线程，<strong>吞吐量</strong>（CPU运行用户代码的时间除以CPU总消耗时间）<strong>优先</strong>的收集器。</p></li><li><p><strong>Serial Old收集器</strong>：Serial的老年代版本，Client场景使用。</p><p><img src="Serial.jpg" alt=""></p></li><li><p><strong>Parallel Old收集器</strong>：Parallel Scavenge的老年代版本</p><p><img src="Parallel.jpg" alt=""></p></li><li><p><strong>CMS(Concurrent Mark Sweep)收集器</strong>：以获取<strong>最短回收停顿时间</strong>为目标，基于<strong>标记-清除</strong>算法。分为四个阶段：</p><ol><li>初始标记：只标记与GC Roots直接关联的对象，需要Stop The World。</li><li>并发标记：进行 GC Roots Tracing，耗时最长，不需要停顿。</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要Stop The World。</li><li>并发清除：不需要停顿。</li></ol><p><img src="CMS.jpg" alt=""></p><ul><li>缺点明显：<ol><li>CPU资源敏感：CMS默认启动的回收线程数是（CPU数+3）/4，当CPU数较少时，吞吐量很低。</li><li>无法处理浮动垃圾：浮动垃圾是指<strong>并发清除阶段</strong>由于用户线程继续运行而产生的垃圾，这部分垃圾只能下一次GC清除。</li><li>标记-清除算法会产生大量空间碎片。</li></ol></li><li>总体上来说，CMS的垃圾回收过程是与用户线程一起并发执行的。</li></ul></li><li><p><strong>G1(Garbage First)收集器</strong>：面向服务端应用。</p><ul><li><p>使用G1时，Java堆内存布局与以往不同，它<strong>将整个Java堆划分为多个大小相等的独立Region</strong>，新生代与老年代是一部分不连续Region的集合，如图：</p><p><img src="G1HeapAllocation.png" alt=""></p></li><li><p>G1通过记录每个Region垃圾回收时间和回收所得空间（这两个值通过过去回收的经验计算），并维护一个优先列表，每次根据用户允许的收集时间，优先回收价值最大的Region。<strong>使用Region划分内存空间</strong>，<strong>有优先级的区域回收方式</strong>，保证了G1在有限的时间内获取尽可能高的收集效率。</p></li><li><p>每个Region都维护一个Remembered Set，用于记录Region之间的对象引用，来避免GC时的全堆扫描。（其他收集器新生代与老年代之间的对象引用也是使用Remembered Set，避免Minor-GC时全堆扫描）。</p></li><li><p>如不计算维护Remembered Set的操作，G1的运作可划分如下：</p><ol><li>初始标记：停顿。</li><li>并发标记</li><li>最终标记：停顿。为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。</li><li>筛选回收：根据用户允许的收集时间和优先列表来回收。</li></ol></li></ul><p><img src="G1.jpg" alt=""></p><ul><li>总结G1的特点如下：<ol><li>并行与并发：G1在多CPU和大内存的硬件优势下能有效缩短Stop-The-World的时间。</li><li>分代收集：新生代和老年代可以一起回收。</li><li>空间整合：整体上看基于“标记-整理”算法，局部上看基于“复制”算法。不会产生内存碎片。</li><li>可预测的停顿：能让用户自定义在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。</li></ol></li></ul></li><li><p><strong>垃圾收集器参数总结</strong></p><p><img src="GC_Args.png" alt=""></p></li></ul><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><ul><li><strong>对象优先在Eden分配</strong></li><li><strong>大对象直接进入老年代</strong>：大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种<strong>很长的字符串以及数组</strong>。<ul><li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</li><li>通过参数<code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</li></ul></li><li><strong>长期存活的对象将进入老年代</strong>：通过参数<code>-XX:MaxTenuringThreshold</code>用来定义年龄的阈值。</li><li><strong>动态对象年龄判定</strong>：虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，<strong>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li><li><strong>空间分配担保</strong>：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</li></ul><h3 id="GC的触发条件"><a href="#GC的触发条件" class="headerlink" title="GC的触发条件"></a>GC的触发条件</h3><ul><li><p>对于Minor GC，其触发条件为Eden区满时。而对于Full GC:</p><ol><li>调用System.gc()。</li><li>老年代空间不足。</li><li>空间分配担保失败。</li><li>Concurrent Mode Failure。</li></ol></li><li><p>减少Full GC的方法：</p><ol><li>尽量不要创建大对象和数组。</li><li>通过<code>-Xmn</code>调大新生代大小。</li><li>通过<code>-XX:MaxTenuringThreshold</code>调大进入老年代的阈值。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象已死吗（GC回收的前提是判断对象已死）&quot;&gt;&lt;a href=&quot;#对象已死吗（GC回收的前提是判断对象已死）&quot; class=&quot;headerlink&quot; title=&quot;对象已死吗（GC回收的前提是判断对象已死）&quot;&gt;&lt;/a&gt;对象已死吗（GC回收的前提是判断对象已死）&lt;/
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</id>
    <published>2020-08-23T03:24:45.000Z</published>
    <updated>2020-09-02T12:19:48.815Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>​            <img src="JVM_Runtime_DataArea.png" alt=""></p><ul><li><p><strong>线程私有：与线程生命周期相同</strong></p><ul><li><strong>程序计数器（Program Counter Register）</strong>：记住下一条JVM字节码指令的地址。每条线程都有一个独立的PCR。此内存区域是唯一一个在JVM规范中没有任何OOM情况的区域。</li><li><strong>Java虚拟机栈</strong>：描述Java方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈等。每个方法从调用到执行完毕，对应一个栈帧从入栈到出栈的过程。<ul><li>局部变量表存放编译期可知的各种基本数据类型和引用。</li><li>JVM规范定义了该区域两种异常情况：<ul><li>线程请求的栈深度大于VM允许的深度，将抛出StackOverflowError异常。</li><li>若虚拟机栈可动态扩展，且扩展时无法申请到足够的内存，将抛出OOM异常。</li></ul></li></ul></li><li><strong>本地方法栈</strong>：与虚拟机栈的区别在于，虚拟机栈为VM执行Java方法服务，而本地方法栈为VM使用到的本地方法服务。<ul><li>异常情况同虚拟机栈。</li></ul></li></ul></li><li><p><strong>线程共享：VM启动时创建</strong></p><ul><li><p><strong>堆</strong>：用于存放对象实例和数组。</p><ul><li><p>Java堆是GC管理的主要区域。</p></li><li><p>扩：随着JIT（Just in Time）技术与逃逸分析技术逐渐成熟，所有对象都分配在堆上并不绝对了。</p><p><img src="JIT_flow.png" alt=""></p></li></ul><p>​                热代码：频繁调用的字节码。</p><p>​                [<a href="https://developer.ibm.com/zh/articles/j-lo-just-in-time/#" target="_blank" rel="noopener">https://developer.ibm.com/zh/articles/j-lo-just-in-time/#</a>]</p></li><li><p><strong>方法区</strong>：存储已被VM加载的类信息、常量、静态变量、JIT编译后的机器码等。</p><ul><li>运行时常量池。</li><li>许多主流框架都会用到CGLib或者JDK动态代理，动态生成大量Class容易导致方法区OOM异常。</li></ul></li><li><p><strong>三种常量池区分</strong></p><ul><li><p><strong>class文件常量池</strong>：编译阶段，存放编译期生成的字面量（常量值）和符号引用。</p></li><li><p><strong>字符串常量池</strong>：</p><p>类加载完后在<strong>堆</strong>中生成字符串对象实例（JDK1.7及以后），然后将该字符串对象实例的<strong>引用</strong>存到字符串常量池中。</p><p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是驻留字符串(也就是我们常说的用双引号括起来的)的引用（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。</p></li><li><p><strong>运行时常量池</strong>：类加载完成之后，编译期生成的非字符串类型常量和符号引用进入运行时常量池，同时一般来说，由符号引用翻译而来的直接引用也会存入运行时常量池。</p></li></ul></li></ul></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul><li>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也会频繁使用，可能导致OOM异常。</li><li>JDK1.4中加入了NIO类（New Input/Output），引入了一种基于Channel与Buffer的I/O方式，<strong>它可以使用本地函数库直接分配堆外内存</strong>，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</li></ul><h3 id="常见的VM堆栈参数"><a href="#常见的VM堆栈参数" class="headerlink" title="常见的VM堆栈参数"></a>常见的VM堆栈参数</h3><ul><li>-Xms: 设置堆的最小值，如<code>-Xms20m</code></li><li>-Xmx: 设置堆的最大值，如<code>-Xmx20m</code></li><li>-Xmn: 设置堆新生代值</li><li>-Xss: 设置虚拟机栈容量</li><li>-Xoss: 设置本地方法栈容量（HotSpot的虚拟机栈和本地方法栈仅由-Xss决定）</li><li><code>-XX:Permsize=10M</code>: 设置方法区大小为10M</li><li><code>-XX:MaxDirectMemorySize=10M</code>: 设置本机直接内存大小为10M</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;​            &lt;img src=&quot;JVM_Runtime_DataArea.png&quot; a
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal</title>
    <link href="http://thmasterplan.cn/uncategorized/ThreadLocal/"/>
    <id>http://thmasterplan.cn/uncategorized/ThreadLocal/</id>
    <published>2020-04-26T02:20:48.000Z</published>
    <updated>2020-04-26T02:20:48.815Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://thmasterplan.cn/uncategorized/SpringAOP/"/>
    <id>http://thmasterplan.cn/uncategorized/SpringAOP/</id>
    <published>2020-04-23T08:36:02.000Z</published>
    <updated>2020-04-23T08:36:02.359Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringIOC</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringIOC/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringIOC/</id>
    <published>2020-04-14T13:36:18.000Z</published>
    <updated>2020-04-23T08:37:43.666Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h3><ul><li>Spring以IOC(Inversion of Control)和AOP(Aspect Oriented Programming)为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。</li></ul><h3 id="控制反转Inversion-of-Control-IOC"><a href="#控制反转Inversion-of-Control-IOC" class="headerlink" title="控制反转Inversion of Control(IOC)"></a>控制反转Inversion of Control(IOC)</h3><h5 id="耦合度"><a href="#耦合度" class="headerlink" title="耦合度"></a>耦合度</h5><ul><li><p>概念：模块（类）之间的<strong>关联、依赖的程度</strong>，是衡量<strong>代码独立性</strong>的一个指标，也是<strong>软件工程设计及编码质量评价</strong>的一个标准。耦合的程度依赖于以下几个因素：</p><ul><li>模块间的调用</li><li>模块间传递的数据量</li><li>一个模块施加到另一个模块的控制的多少</li><li>模块间接口的复杂程度</li></ul></li><li><p>耦合按从高到低的顺序可分为：</p><ul><li>内容耦合：<strong>一个模块直接修改或操作另一个模块的数据</strong>，或者直接转入另一个模块时，就发生了内容耦合。例如，类与类之间直接调用或继承关系都属于这种耦合。</li><li>公共耦合：<strong>多个模块共同引用一个全局数据项</strong>。</li><li>控制耦合：一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。</li><li>标记耦合：模块间通过<strong>参数传递复杂的内部数据结构</strong>。</li><li><strong><em>数据耦合</em></strong>：模块间通过<strong>参数传递基本类型的数据</strong>。</li></ul></li><li><p>需要低耦合的原因：在耦合度很高的情况下，维护代码时修改一个地方会牵连到很多地方，难以厘清，可谓是牵一发而动全身。</p></li><li><p>降低耦合度的方法：</p><ul><li>少用继承，多用接口。</li><li>模块的功能划分尽可能的单一（高内聚）。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类成员变量和方法少用public，多用private。</li><li>多使用设计模式，比如使用MVC设计模式就可以降低界面与业务逻辑的耦合度。</li><li><strong>如果模块间必须存在耦合，尽量使用数据耦合</strong>。例如使用配置文件或注解传递参数，使用反射创建对象等都属于数据耦合。</li></ul></li></ul><h5 id="工厂模式解耦例子"><a href="#工厂模式解耦例子" class="headerlink" title="工厂模式解耦例子"></a>工厂模式解耦例子</h5><ul><li><p>持久层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 账户的持久层接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IAccountDao &#123;</span><br><span class="line">    void saveAccount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 持久层实现类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;账户已经保存！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 账户业务层的接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IAccountService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模拟保存账户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void saveAccount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 业务层实现类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line"></span><br><span class="line">    private IAccountDao accountDao &#x3D; (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;);</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表现层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 模拟表现层调用业务层，实际开发中类似Servlet</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IAccountService as &#x3D; (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bean.properties配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accountService&#x3D;com.itheima.service.impl.AccountServiceImpl</span><br><span class="line">accountDao&#x3D;com.itheima.dao.impl.AccountDaoImpl</span><br></pre></td></tr></table></figure></li><li><p>BeanFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 一个创建Bean对象的工厂</span><br><span class="line"> * Bean: 可重用组件，例如在Java中JavaBean有实体类、service和dao对象等</span><br><span class="line"> *</span><br><span class="line"> * 工厂模式解耦：使用配置文件或注解传递参数，使用反射创建对象。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">    &#x2F;&#x2F;定义一个Properties对象</span><br><span class="line">    private static Properties props;</span><br><span class="line">    &#x2F;&#x2F;定义Map存储bean对象，避免多实例降低效率（即避免每次调用getBean方法都要重新创建对象）</span><br><span class="line">    private static Map&lt;String, Object&gt; beansMap;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    static&#123;</span><br><span class="line">        props &#x3D; new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;获取properties文件的流对象并加载</span><br><span class="line">            props.load(BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beansMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        Enumeration keys &#x3D; props.keys();</span><br><span class="line">        &#x2F;&#x2F;遍历properties中的每个key，创建对应的实例并存入beansMap中</span><br><span class="line">        while(keys.hasMoreElements())&#123;</span><br><span class="line">            String beanName &#x3D; keys.nextElement().toString();</span><br><span class="line">            String beanPath &#x3D; props.getProperty(beanName);</span><br><span class="line">            Object bean &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                bean &#x3D; Class.forName(beanPath).newInstance();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            beansMap.put(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据bean的名称获取bean对象</span><br><span class="line">     * @param beanName</span><br><span class="line">     * @return bean对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Object getBean(String beanName)&#123;</span><br><span class="line">        return beansMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h5><ul><li><p>概念与作用：控制反转把创建对象的权力交给框架，它包括Dependency Injection与Dependency Lookup两部分。其作用在于<strong>降低程序的耦合度</strong>。</p></li><li><p><strong>基于XML的IoC配置</strong></p><ul><li><p>bean.xml示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--将对象的创建交给spring管理--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>ApplicationContext的三个常用实现类</p><ul><li>ClassPathXmlApplicationContext：加载类路径下的配置文件</li><li>FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件</li><li>AnnotationConfigApplicationContext：读取注解</li></ul></li><li><p><strong>核心容器的两个接口</strong>引发的问题</p><ul><li>ApplicationContext（常用）：单例对象适用。创建核心容器时，<strong>创建对象的策略为立即加载</strong>。只要一读取完配置文件就立马创建bean对象。</li><li>BeanFactory（ApplicationContext父接口的父接口）：多例对象适用。创建核心容器时，<strong>创建对象的策略为延迟加载</strong>。也即，何时调用获取bean对象的方法，那时才创建对象。</li></ul></li></ul></li><li><p>Spring对bean对象的管理细节</p><ul><li><p>创建bean对象的三种方式</p><ul><li><p><strong>使用默认构造函数创建</strong>：在spring的xml配置文件中使用bean标签，配置id和class属性后，且没有其他属性和标签时，采用的是默认构造函数创建bean对象(反射中的newInstance方法使用默认构造创建对象)，如果类没有默认构造函数则无法创建对象。</p></li><li><p><strong>使用普通类(工厂)中的方法创建对象并存入spring容器</strong>(比如jar包中的类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory&#123;</span><br><span class="line">    public IAccountService getAccountService()&#123;</span><br><span class="line">        return new AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建实例工厂对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;instanceFactory&quot; class&#x3D;&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;&#x2F;bean&gt; </span><br><span class="line">&lt;!--通过指定实例工厂对象的方法，创建指定对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; factory-bean&#x3D;&quot;instanceFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用工厂中的静态方法创建对象并存入容器</strong>(比如jar包中的类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class StaticFactory&#123;</span><br><span class="line">    public static IAccountService getAccountService()&#123;</span><br><span class="line">        return new AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--通过指定工厂类的静态方法创建对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.factory.StaticFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bean对象的作用范围调整：bean标签scope属性，取值为以下</p><ul><li>singleton：单例（默认的，不管new多少次，内存中只有一个实例对象）</li><li>prototype：多例</li><li>request：作用于web应用的请求范围</li><li>session：作用于web应用的会话范围</li><li>global-session：作用于集群环境的会话范围（全局会话范围），若不是集群环境，则效果与session相同</li></ul></li><li><p>bean对象的生命周期</p><ul><li>单例对象：单例对象的生命周期与容器相同，容器创建则对象创建，容器销毁时对象销毁，可在bean标签中指定init-method与destroy-method属性来执行bean对象中的init方法和destroy方法。</li><li>多例对象：使用对象时才创建对象，spring不能销毁，只能通过GC回收，因此无论如何都不会执行bean对象中的destroy方法。</li></ul></li></ul></li><li><p>依赖注入（Dependency Injection）：当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例，但在IoC中，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。要实现IoC，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过【构造器/方法/注解】注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。</p><ul><li><p>注入的数据类型</p><ul><li>基本数据类型和String</li><li>bean</li><li>复杂类型/集合类型</li></ul></li><li><p>注入的方式有</p><ul><li><p>构造器：通过bean标签中的<code>constructor-arg</code>标签配置实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;读取xml，通过反射创建bean对象；依赖查找</span><br><span class="line">        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;     IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;);</span><br><span class="line">        IAccountService as &#x3D; ac.getBean(&quot;accountService&quot;, IAccountService.class);&#x2F;&#x2F;两种方式获取bean对象</span><br><span class="line">        as.saveAccount();</span><br><span class="line"></span><br><span class="line">        &#x2F;** 使用BeanFactory</span><br><span class="line">         * BeanFactory beanFactory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;bean.xml&quot;));</span><br><span class="line">         * IAccountService as &#x3D; (IAccountService) beanFactory.getBean(&quot;accountService&quot;);</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line"></span><br><span class="line">    private IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public AccountServiceImpl(IAccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao &#x3D; accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">       accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">        &lt;!--value属性用于注入基本类型和String类型，ref属性则为bean类型--&gt;</span><br><span class="line">        &lt;constructor-arg name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDaoImpl&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountDaoImpl&quot; class&#x3D;&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>set方法：<code>property</code>标签，<code>name</code>属性指定方法名，<code>value</code>属性用于注入基本类型和String类型，<code>ref</code>属性则为bean类型。bean类需要设置set方法。</p><ul><li>集合类型的注入：使用<code>set,list,arroCay,map,props</code>等子标签</li></ul></li><li><p>注解：<code>@Autowired</code></p></li></ul></li></ul></li><li><p><strong>基于注解的IoC配置</strong></p><ul><li><p>首先配置context</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">    &lt;!--指定spring在创建容器时要扫描的包--&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建bean对象的注解</p><ul><li><code>@Component</code>：被注解的类由spring创建并存入IoC容器</li><li><code>@Controller</code>：用于表现层</li><li><code>@Service</code>：用于业务层</li><li><code>@Repository</code>：用于持久层</li><li>后三个注解的作用与属性都与<code>@Component</code>相同</li></ul></li><li><p>依赖注入的注解</p><ul><li><p><code>@Resource</code>：在需要注入依赖的变量上标记，并在其实现类上标记<code>@Component</code>（或其余三种）注解。通过name属性匹配实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;accountService&quot;)</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">    @Resource(name&#x3D;&quot;accountDao&quot;)</span><br><span class="line">    private IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">       accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;accountDao&quot;)</span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;Your Account has been saved!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">        IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Autowired</code>：<code>@Qualifier</code>需要与<code>@Autowired</code>一起使用。</p></li><li>以上的注解只能用于bean类型的注入，集合类型的注入只能通过xml配置文件实现。</li><li><code>@Value</code>：用于注入基本类型与String类型数据。</li></ul></li><li><p>改变作用范围的注解：<code>@Scope</code>，value属性常用取值为singleton，prototype</p></li><li><p>与生命周期相关的注解</p><ul><li><code>@PreDestroy</code>：指定销毁方法</li><li><code>@PostConstruct</code>：指定初始化方法</li></ul></li></ul></li><li><p><strong>基于注解的IoC配置（不再需要xml文件）</strong></p><ul><li><code>@Configuration</code>：创建一个代替bean.xml的配置类<code>SpringConfig</code>后，使用该注解标记该类为配置类</li><li><code>@Import</code>：标记<strong>主配置类</strong>，用于导入其他的从配置类。属性：<code>Class&lt;?&gt;[] value;</code>。使用该注解后可不再使用<code>@Configuration</code>注解。</li><li><code>@ComponentScan</code>：指定spring在创建容器时需要扫描的包</li><li><code>@Bean</code>：标记一个方法，将该方法的返回值作为bean对象存入IoC容器。其属性name用于指定bean对象的id，默认值为方法名。</li><li><code>@PropertySource</code>：指定properties配置文件的位置。用于配置数据库等字符串信息。</li><li>使用<code>new AnnotationConfigApplicationContext(SpringConfig.class);</code>获取容器。</li></ul></li></ul><h3 id="IoC案例"><a href="#IoC案例" class="headerlink" title="IoC案例"></a>IoC案例</h3><ul><li><p>使用xml配置，注解结合xml配置，纯注解配置三种方式</p><ul><li>Use “Sourcegraph” to view the code：<a href="https://github.com/Laishiji/SpringLearningDemo" target="_blank" rel="noopener">https://github.com/Laishiji/SpringLearningDemo</a></li></ul></li><li><p>Spring整合Junit</p><ul><li><p>导入依赖spring-test</p></li><li><p>使用Junit提供的<code>@RunWith</code>替换Runner(替换main方法)</p></li><li><p>使用<code>@ContextConfiguration</code>告知Spring的运行器，spring容器的创建是基于xml还是注解，并说明位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单元测试,Spring整合Junit</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes &#x3D; SpringConfig.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    IAccountService as;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindAll()&#123;</span><br><span class="line">        List&lt;Account&gt; accounts &#x3D; as.findAllAccount();</span><br><span class="line">        for (Account a : accounts) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring概述&quot;&gt;&lt;a href=&quot;#Spring概述&quot; class=&quot;headerlink&quot; title=&quot;Spring概述&quot;&gt;&lt;/a&gt;Spring概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Spring以IOC(Inversion of Control)和AOP(Asp
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>检索技巧</title>
    <link href="http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
    <id>http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/</id>
    <published>2020-04-09T09:00:06.000Z</published>
    <updated>2020-04-09T09:10:12.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github搜索"><a href="#Github搜索" class="headerlink" title="Github搜索"></a>Github搜索</h3><ul><li><code>in:name example</code>：项目名中包含”example“</li><li><code>in:readme example</code>：readme.md中包含”example“</li><li><code>in:description example</code>：描述中包含”example“</li><li><code>stars:&gt;1000</code>：项目 star数大于1000</li><li><code>forks:&gt;1000</code>：项目fork数大于1000</li><li><code>pushed:&gt;2020-03-05</code>：项目在该日期后有更新</li><li><code>language:java</code>：项目用Java编写</li><li>以上条件可组合使用</li></ul><h3 id="搜索引擎检索"><a href="#搜索引擎检索" class="headerlink" title="搜索引擎检索"></a>搜索引擎检索</h3><ul><li><code>&quot;example&quot;</code>：完全匹配</li><li><code>example site:www.xxx.com</code>：站点内搜索</li><li><code>example -csdn.net</code>：排除关键字</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Github搜索&quot;&gt;&lt;a href=&quot;#Github搜索&quot; class=&quot;headerlink&quot; title=&quot;Github搜索&quot;&gt;&lt;/a&gt;Github搜索&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in:name example&lt;/code&gt;：项目名中包含”exam
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-08T14:47:15.000Z</published>
    <updated>2020-04-26T02:40:11.005Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>String</p><ul><li><p>String类是final的，因此不能被继承。源码是一个<strong>final修饰的字符数组</strong>，因此一旦创建就是一个不可变的</p></li><li><p>字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否相等？ <strong>[涉及JVM的部分待补充]</strong></p><ol><li><p>值在编译阶段确定（相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">String b &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">String c &#x3D; &quot;hello&quot; + &quot;World&quot;;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：字符串常量在<strong>编译阶段</strong>会存入<strong>常量池</strong>中<strong>共享</strong>，编译阶段完成字符串的拼接（无引用的情况下），因此在运行期a,b,c均指向同一个地址。</p></li><li><p>值在编译器无法确定（不相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">String b &#x3D; new String(&quot;helloWorld&quot;);</span><br><span class="line">String c &#x3D; &quot;hello&quot; + new String(&quot;World&quot;);</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：b,c均在运行期创建，存在于堆内存。</p></li><li><p>涉及引用操作，编译期值无法确定（不相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld2&quot;;</span><br><span class="line">String b &#x3D; a + 2;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：引用a的值在编译阶段无法确定，在运行期才给其分配内存来指向常量池中的字符串，因此a+2是在运行期创建的，两个对象地址并不相同。</p></li><li><p>涉及引用操作，编译期值确定（相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">final String b &#x3D; &quot;hello&quot;;</span><br><span class="line">String c &#x3D; b + &quot;World&quot;;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：变量b被final修饰，在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中，此时b已经确定指向”hello”,可以被引用。</p></li></ol></li><li><p><strong>字符串的拼接</strong>：由于常量池中字符串不可变，一个字符串和另一个字符串拼接需要开辟<strong>三块</strong>内存空间，效率低下。建议使用StringBuffer或StringBuilder，这两者的区别稍后讲解。</p></li><li><p>String常用方法</p><ul><li>比较<ul><li><code>equals(Object obj)</code>：如果比较双方一个常量一个变量，应把常量写在前面，如<code>&quot;abc&quot;.equals(str)</code>。因为如使用<code>str.equals(&quot;abc&quot;)</code>，假如str为空会导致空指针异常。</li><li><code>equalsIgnoreCase(String str)</code>：忽略大小写。</li><li><code>endsWith(String suffix)</code>：比较suffix是否为串的后缀。</li></ul></li><li>获取<ul><li><code>length()</code>：获取长度。</li><li><code>concat(String str)</code>：获取拼接后的串。</li><li><code>charAt(int index)</code>：获取指定索引字符。</li><li><code>public int indexOf(String str)</code>：查找参数串在本串中首次出现的索引位置，如无匹配结果返回-1。可用于<strong>字符串匹配</strong>。</li></ul></li><li>截取<ul><li><code>subString(int index)</code>：截取从参数位置开始后的子串。</li><li><code>subString(int begin, int end)</code>：截取[begin, end)子串。</li><li><code>trim()</code>：去除字符串的前后空格。</li></ul></li><li>转换<ul><li><code>toCharArray()</code>：串转换为字符数组</li><li><code>getBytes()</code>：串转换为底层的字节数组</li><li><code>toUpperCase()和toLowerCase()</code>：大小写转换。</li><li><code>replaceAll(String regex, String replacement)</code>：使用给定的replacement替换所有符合regex规则的子串。</li></ul></li><li>分割：<code>split(String regex)</code>：按照参数规则分割字符串为若干子串。</li></ul></li></ul></li><li><p>StringBuffer与StringBuilder</p><ul><li>都由final修饰，不能被继承。</li><li>都继承于<strong>AbstractStringBuilder</strong>，底层使用的字符数组没有final修饰，因此在做字符串拼接就在原来的内存上拼接（<code>append()方法</code>），不会浪费内存空间。</li><li>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是  synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。</li><li>StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。</li></ul></li><li><p>jdk1.9后String/StringBuffer/StringBuilder均不再使用字符数组，而是直接使用字节数组byte[] value。</p></li></ul><h3 id="七个关键字"><a href="#七个关键字" class="headerlink" title="七个关键字"></a>七个关键字</h3><h4 id="static-涉及JVM的部分待补充"><a href="#static-涉及JVM的部分待补充" class="headerlink" title="static  [涉及JVM的部分待补充]"></a>static  [涉及JVM的部分待补充]</h4><ul><li><p>修饰成员变量或成员方法</p></li><li><p>不需要创建对象就可通过类名调用，它们均属于类，而非某个对象</p></li><li><p>修饰内部类（不允许修饰普通类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line"></span><br><span class="line">public static class Inner&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类静态代码块&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Inner() &#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类构造方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void innerMethod()&#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类普通方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Inner inner &#x3D; new Inner();</span><br><span class="line">inner.innerMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：====静态内部类静态代码块====</p><pre><code>       ====静态内部类构造方法====       ====静态内部类普通方法====</code></pre><p><strong>结论：想要在普通类中创建内部类实例，可以用static修饰内部类</strong>。</p></li><li><p>静态代码块</p><ul><li>第一次使用类时，类的静态代码块执行唯一的一次。</li><li>静态代码块先于构造方法执行。</li></ul></li><li><p>Tips:</p><ul><li>静态不能直接访问非静态</li><li>静态方法中不能用this, this代表当前对象。</li></ul></li></ul><h4 id="final-涉及JVM的部分待补充"><a href="#final-涉及JVM的部分待补充" class="headerlink" title="final   [涉及JVM的部分待补充]"></a>final   [涉及JVM的部分待补充]</h4><ul><li>修饰类：当前类不能有任何子类。</li><li>修饰方法：该方法不能被子类重写。（显然对于类、方法来说，abstract和final无法同时使用）</li><li>修饰变量：对于基本数据类型，其值不能再改变。对于引用数据类型，不能再改为存储其他对象的地址或引用。</li><li>修饰成员变量：对于基本数据类型，其值不能再改变。对于引用数据类型，不能再改为存储其他对象的地址或引用（对象自身是可以改变的）。并且该变量必须直接赋值或在构造方法中赋值。</li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><h4 id="native"><a href="#native" class="headerlink" title="native"></a>native</h4><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h3 id="权限修饰符作用范围"><a href="#权限修饰符作用范围" class="headerlink" title="权限修饰符作用范围"></a>权限修饰符作用范围</h3><p><img src="权限修饰符.png" alt=""></p><ul><li>外部类只有public和default两种权限。</li><li>待补充。</li></ul><h3 id="Arrays常用方法"><a href="#Arrays常用方法" class="headerlink" title="Arrays常用方法"></a>Arrays常用方法</h3><ul><li><code>static List&lt;T&gt; asList&lt;T... a&gt;</code>：返回参数列表的List，例<code>List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</code></li><li><code>binarySearch()</code>：有多个重载的方法，二分查找</li><li><code>static String toString(数组)</code>：将参数数组变成字符串，默认格式为[元素1, 元素2, 元素3….]</li><li><code>sort(数组)</code>：按照默认升序对数组元素排序；自定义类型需要实现Comparator接口。</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>Java类是<strong>单继承</strong>的，不允许子类继承多个父类的原因在于，编译器无法确定使用哪个父类方法。</li><li>在父子类的继承关系中，创建父或子类对象，访问成员方法的规则：优先使用创建的对象的方法，没有则向上找。</li><li><p>继承关系中，父子构造方法访问的特点</p><ul><li>子类构造方法有一个默认隐含的super()调用，因此一定是先调用的父类构造，后执行子类构造。</li><li>子类构造可以通过显示使用super()来调用<strong>父类重载构造</strong>，并且必须是子类构造的第一条语句。</li></ul></li><li><p>重载与重写</p><ul><li>重写：子类重写方法与父类方法名相同，参数列表相同。</li><li>重载：一个类中有多个相同的方法名，但参数列表不同。</li></ul></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>概念：父类（接口）引用指向子类对象。</li><li>多态代码中<ul><li>成员<strong>重写方法</strong>的访问规则：先在子类对象中找，没有则向上找。</li><li><strong>成员变量</strong>访问规则：直接使用父类成员变量。</li></ul></li><li>向上转型即多态：父类引用指向子类对象；引用无法调用原本<strong>子类特有的方法</strong>。</li><li>向下转型，例如<code>Anaimal a = new Cat();Cat cat = (Cat) a;</code>，这个过程将父类变量还原为子类类型，使其又可以访问<strong>子类特有的方法</strong>。</li><li>多态的作用？<ul><li>Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations.</li></ul></li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装通过将类属性定义为私有，对外提供类属性的setters/getters方法来修改和获取属性值实现。</li><li>封装可以减少耦合，防止类数据被外部类定义的代码随机访问。</li></ul><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><ul><li><p>抽象类：<code>public abstract class Name{}</code>；<strong><em>抽象类是描述一个对象是什么</em></strong>，它可以包含成员变量、成员方法、构造方法等，与普通类不同的点只在于：它可能包含抽象方法；它必须要<strong>被非抽象子类继承</strong>才能实例化，并且非抽象子类必须实现抽象方法（假如父类有抽象方法的话）。</p><ul><li>单继承。</li><li><p>抽象类的构造方法与静态方法不能用abstract修饰。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；抽象方法没有方法体。</p></li><li>抽象类使用：<ul><li>创建子类继承抽象父类。</li><li>子类重写父类抽象方法，去掉abstract关键字，实现方法体。</li></ul></li></ul></li><li><p>接口：<code>public interface IName{}</code>；接口是多个类的<strong>公共规范</strong>。<strong><em>接口描述一个接口提供什么功能。</em></strong></p><ul><li><p>接口可以继承多个接口，实现类可以实现多个接口。（<strong>多继承，多实现</strong>）</p></li><li><p>接口的成员变量默认都是<code>public static final</code>的：假如两个接口有相同的成员变量，一个类实现了这两个接口，那么实现类只能通过接口名.变量名来调用以避免歧义，因此必须为static。声明为final的原因是实现类不能够修改接口成员变量的值。</p></li><li><p>Java7：常量，抽象方法</p></li><li><p>Java8：新增了<strong>默认方法</strong>(default修饰)，<strong>静态方法</strong>。</p><ul><li><p>增加默认方法的原因：Java升级后的兼容性问题。如果想在老版本接口中添加某个功能，在添加抽象方法的情况下，所有的老版本实现类都需要修改代码；而通过增加default方法来增加功能就不会有这种问题。</p></li><li><p>考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法。解决方案：<strong>重写方法，并使用<code>接口名.super.方法名()</code>调用指定接口的方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public interface Vehicle &#123;</span><br><span class="line">  default void print()&#123;</span><br><span class="line">  System.out.println(&quot;vehicle...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public interface FourWheeler &#123;</span><br><span class="line">  default void print()&#123;</span><br><span class="line">  System.out.println(&quot;fourWheeler...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void print() &#123;</span><br><span class="line">FourWheeler.super.print();</span><br><span class="line">Vehicle.super.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Vehicle car &#x3D; new Car();</span><br><span class="line">car.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出：fourWheeler...</span><br><span class="line">              vehicle...</span><br></pre></td></tr></table></figure></li><li><p>Java9：新增了<strong>私有方法</strong>，<strong>私有静态方法</strong></p></li></ul></li><li><p><strong>面向接口编程？</strong></p></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li><p>成员内部类</p><ul><li><p>三种方法使用成员内部类</p><ul><li>在外部类的方法中创建内部类实例</li><li>main方法中：<code>Inner inner = new Outer.new Inner();</code></li><li>main方法中直接new，前提是静态内部类</li></ul></li><li><p>在内部类中访问重名的外部类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">private int num &#x3D; 10;&#x2F;&#x2F;外部类私有变量，内部类也可访问</span><br><span class="line"></span><br><span class="line">class Inner&#123;</span><br><span class="line">private int num &#x3D; 20;</span><br><span class="line"></span><br><span class="line">public void innerMethod()&#123;</span><br><span class="line">int num &#x3D; 30;</span><br><span class="line"></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(this.num);</span><br><span class="line">System.out.println(Outer.this.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Inner inner  &#x3D; new Outer().new Inner();</span><br><span class="line">inner.innerMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>局部内部类</p><ul><li>该类定义在方法内部，只有在该方法内部才能使用。</li></ul></li><li><p>局部内部类中的匿名内部类</p><ul><li><p>如果接口的实现类（或者父类的子类）只需要使用一次，那么这种情况下可以省略掉该类的定义，而使用匿名内部类。</p></li><li><p>最常见的使用：通过将Runnable接口的实现类的实例对象作为参数传给Thread，创建线程。不仅省略了类定义，同时完成了向上转型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li><p>包装类通过将基本数据类型封装起来，在类中提供一些方法，便于操作这些基本数据类型。</p></li><li><p>Java自jdk5后提供自动装箱与自动拆箱机制。</p></li><li><p>基本类型与字符串的转换</p><ul><li>基本类型 -&gt; String：基本类型值+””</li><li>String -&gt; 基本类型：使用包装类的静态方法<code>parseXXX(&quot;str&quot;)</code><ul><li>Integer：<code>static int parseInt(String s)</code></li><li>Double：<code>static double parseDouble(String s)</code></li></ul></li></ul></li></ul><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><ul><li>实参与形参：<ul><li>形式参数：<strong>定义函数时使用的参数</strong>，用来接收实际参数。</li><li>实际参数：<strong>调用有参函数时</strong>，传入的内容。</li></ul></li><li>基本数据类型与引用类型<ul><li>基本数据类型：直接存储值。</li><li>引用类型：存储的是对象的地址。对象在堆中。</li></ul></li><li>求值策略（Evaluation Strategy）：值传递与引用传递，属于函数调用时参数的求值策略，是对调用函数时求值和传值的方式的描述，而非传递的内容的类型。（内容的类型是指：值类型还是引用类型。）值类型与引用类型，用于区分两种内存分配方式，值类型在调用栈上分配，引用类型在堆上分配。[<a href="https://www.zhihu.com/question/20628016" target="_blank" rel="noopener">https://www.zhihu.com/question/20628016</a>]  <strong>[JVM部分后面补充修改]</strong></li><li>值传递概念：调用函数时，将<strong>实际参数拷贝</strong>一份传递给函数。因此不管函数如何修改形参，都不会改变实际参数的值。</li><li>引用传递概念：调用函数时，将实际参数的地址传递给函数。因此如果函数对参数修改，实际参数也会改变。</li><li><strong>Java中只有值传递</strong>：对于基本数据类型，传递的是<strong>基本数据类型的值的拷贝</strong>；对于引用类型，传递的是<strong>对象的地址值的拷贝</strong>，形参与实参都保存的是堆内存中同一个对象的地址，因此通过形参更改了对象（此时地址并没有改变），也会影响到实参。</li></ul><h3 id="Java四种引用类型"><a href="#Java四种引用类型" class="headerlink" title="Java四种引用类型"></a>Java四种引用类型</h3><ul><li>强引用</li><li>软引用</li><li>弱引用</li><li>虚引用</li></ul><h3 id="集合的三种遍历方式"><a href="#集合的三种遍历方式" class="headerlink" title="集合的三种遍历方式"></a>集合的三种遍历方式</h3><ul><li>for<ul><li>形式：<code>for(初始化;结束条件;自增操作等)</code></li><li>需要知道集合的<strong>大小</strong>和元素<strong>类型</strong>，使用索引。</li></ul></li><li>foreach<ul><li>形式：<code>for(T element : colletion)</code></li><li>需要知道集合元素的<strong>类型</strong>，不需要索引。</li></ul></li><li><p>iterator</p><ul><li>形式：<code>Iterator it = collection.iterator();while(it.hasNext()){ object o =it.next(); ...}</code></li><li>集合的大小和类型都无需知道，也无需索引。</li></ul></li><li><p>Tips:</p><ul><li>foreach是iterator的语法糖，底层使用iterator实现。</li><li>不能使用foreach语句进行add/remove操作，会报异常。</li><li>使用for循环进行remove操作时，每一次操作完成后索引需要自减。</li></ul></li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>Java异常图解</p><p><img src="Exception.png" alt=""></p></li><li><p>Throwable类中定义了一些查看异常的方法：</p><ul><li><code>public String getMessage()</code>：获取异常的描述信息。</li><li><code>public String toString()</code>：获取异常的类型和异常描述信息。</li><li><code>void printStackTrace()</code>：打印异常的跟踪栈信息。最常用。</li></ul></li><li><p>捕获异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;可能产生异常的代码</span><br><span class="line">&#125;catch(异常类型1 e)&#123;</span><br><span class="line">    &#x2F;&#x2F;异常的处理逻辑；一般会记录到日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> catch(异常类型n e)&#123;</span><br><span class="line">     </span><br><span class="line"> &#125;finally&#123;</span><br><span class="line">     &#x2F;&#x2F;无论是否出现异常都会执行，常用于资源释放</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;jdk1.8之后支持try with resource写法</span><br><span class="line">try(需要释放资源的代码)&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常类</p><ul><li><pre><code>public class XXXException extends Exception{    //添加一个空参构造    public XXXException(){       super();    }    //添加一个带异常信息的构造    public XXXException(String message){       super(message);//所有的子类异常都交给父类处理    }}</code></pre></li><li><p>自定义异常类一般以命名Exception结尾</p></li><li>必须继承Exception类或者RuntimeException类。<ul><li>继承自Exception：自定义异常为编译期异常，必须处理。</li><li>继承自RuntimeException：运行期异常无需处理。</li></ul></li></ul></li></ul><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String类是final的，因此不能被继承。源码是一个&lt;stron
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java并发</title>
    <link href="http://thmasterplan.cn/JUC/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://thmasterplan.cn/JUC/Java%E5%B9%B6%E5%8F%91/</id>
    <published>2020-04-08T14:28:41.000Z</published>
    <updated>2020-04-08T14:42:04.429Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JUC" scheme="http://thmasterplan.cn/categories/JUC/"/>
    
    
      <category term="JUC" scheme="http://thmasterplan.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/</id>
    <published>2020-04-08T14:23:56.000Z</published>
    <updated>2020-04-08T15:15:14.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2020-04-08T14:23:38.000Z</published>
    <updated>2020-04-08T14:41:16.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器关系图"><a href="#容器关系图" class="headerlink" title="容器关系图"></a>容器关系图</h4><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;容器关系图&quot;&gt;&lt;a href=&quot;#容器关系图&quot; class=&quot;headerlink&quot; title=&quot;容器关系图&quot;&gt;&lt;/a&gt;容器关系图&lt;/h4&gt;&lt;h4 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理</title>
    <link href="http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2020-04-05T08:53:39.000Z</published>
    <updated>2020-04-05T17:38:15.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个小需求引入静态代理"><a href="#一个小需求引入静态代理" class="headerlink" title="一个小需求引入静态代理"></a>一个小需求引入静态代理</h3><ul><li><p>假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  public int add(int a, int b)&#123;</span><br><span class="line">     return a+b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int subtract(int a, int b)&#123;</span><br><span class="line">     return a-b;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案：直接在Calculator类每个方法前后插入日志代码。缺点：</p><ol><li>直接修改源码，不符合<strong>开闭原则</strong>。应该<strong>对扩展开放，对修改关闭</strong>。</li><li>如果Calculator类有许多方法，修改量太大。</li><li>重复代码太多。</li><li>日志代码硬编码在代理类中，不利于后期维护。</li></ol></li></ul><h3 id="静态代理实现日志打印"><a href="#静态代理实现日志打印" class="headerlink" title="静态代理实现日志打印"></a>静态代理实现日志打印</h3><ul><li><p>代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于<strong>在目标实现的基础上增加额外的功能操作</strong>，以满足自身的业务需求。</p></li><li><p>静态代理的实现：编写一个代理类，<strong>实现与目标对象相同的接口</strong>，<strong>并在内部维护一个目标对象的引用</strong>。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。</p></li><li><p>静态代理实现日志打印：</p><ul><li><p>将Calculator抽取为接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Calculator &#123;</span><br><span class="line">int add(int a, int b);</span><br><span class="line">int subtract(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorImpl implements Calculator &#123;</span><br><span class="line"></span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int subtract(int a, int b) &#123;</span><br><span class="line">return a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorProxy implements Calculator &#123;</span><br><span class="line">        &#x2F;&#x2F;代理对象内部维护一个目标对象引用</span><br><span class="line">private Calculator target;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;构造方法，传入目标对象</span><br><span class="line">public CalculatorProxy(Calculator target) &#123;</span><br><span class="line">this.target &#x3D; target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用目标对象的add，并在前后打印日志</span><br><span class="line">@Override</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;add方法开始...&quot;);</span><br><span class="line">int result &#x3D; target.add(a, b);</span><br><span class="line">System.out.println(&quot;add方法结束...&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用目标对象的subtract，并在前后打印日志</span><br><span class="line">@Override</span><br><span class="line">public int subtract(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;subtract方法开始...&quot;);</span><br><span class="line">int result &#x3D; target.subtract(a, b);</span><br><span class="line">System.out.println(&quot;subtract方法结束...&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用代理对象实现计算器并打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Calculator calculator &#x3D; new CalculatorProxy(new CalculatorImpl());</span><br><span class="line">calculator.add(1, 2);</span><br><span class="line">calculator.subtract(2, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。</p></li><li><p>静态代理的缺点：</p><ul><li><strong>代理者与委托者一一对应</strong>，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。</li><li>如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。</li></ul></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>我们的目标只是为了实现增强功能，如何才能不编写代理类，只<strong>提供接口和目标对象</strong>就直接<strong>得到代理对象</strong>呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。</p></li><li><p>Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了<strong>JVM动态生成的代理类</strong>的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。实际开发中采用newProxyInstance方法，直接返回代理对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试</span><br><span class="line"> * @param args</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Calculator calculatorProxy &#x3D;(Calculator) getProxy(new CalculatorImpl());</span><br><span class="line">        calculatorProxy.add(1, 2);</span><br><span class="line">        calculatorProxy.subtract(3, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入目标对象，得到代理对象</span><br><span class="line"> * @param targetObj</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Object getProxy(final Object targetObj) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口</span><br><span class="line">&#x2F;&#x2F;proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象</span><br><span class="line">Class&lt;?&gt; proxyClass &#x3D;</span><br><span class="line">Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;得到代理类（com.sun.proxy.$Proxy0）的构造器</span><br><span class="line">Constructor&lt;?&gt; constructor &#x3D; proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过构造器创建代理对象</span><br><span class="line">Object proxyObj &#x3D; constructor.newInstance(new InvocationHandler()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在重写invoke方法中编写增强功能代码</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">Object result &#x3D; method.invoke(targetObj,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object getProxy1(final Object targetObj) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Object proxyObj &#x3D; Proxy.getProxyClass(</span><br><span class="line">targetObj.getClass().getClassLoader(),</span><br><span class="line">targetObj.getClass().getInterfaces()</span><br><span class="line">)</span><br><span class="line">.getConstructor(InvocationHandler.class)</span><br><span class="line">.newInstance(new InvocationHandler()&#123;</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">Object result &#x3D; method.invoke(targetObj,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">     &#125;);</span><br><span class="line">return proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实际使用的方法newProxyInstance</span><br><span class="line"> * @param target</span><br><span class="line"> * @return</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static Object getProxy2(final Object target) throws Exception &#123;</span><br><span class="line">Object proxy &#x3D; Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">target.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">Object result &#x3D; method.invoke(target,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。</p></li><li><p>mybatis Mapper以及springAOP都是通过动态代理实现。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个小需求引入静态代理&quot;&gt;&lt;a href=&quot;#一个小需求引入静态代理&quot; class=&quot;headerlink&quot; title=&quot;一个小需求引入静态代理&quot;&gt;&lt;/a&gt;一个小需求引入静态代理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;假设现有一个类Calculator，代表一个计算器
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>mybatisHelloWorld</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/</id>
    <published>2020-04-05T08:39:41.000Z</published>
    <updated>2020-04-05T08:40:46.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。<strong>开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务）</strong>，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li></ul><h3 id="MybatisHelloWorld"><a href="#MybatisHelloWorld" class="headerlink" title="MybatisHelloWorld"></a>MybatisHelloWorld</h3><ul><li><p>工程文件结构如图</p><p><img src="mybatisHelloWorld.jpg" alt=""></p></li></ul><ol><li><p>创建Maven工程，配置pom.xml，插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.1.48&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.5.4&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建实体类和DAO接口</p><ul><li><p>实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;&#x2F;&#x2F;包装类默认为null</span><br><span class="line">    private String lastName;</span><br><span class="line">    private String email;</span><br><span class="line">    private String gender;</span><br><span class="line">    &#x2F;&#x2F;getters and setters, toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DAO接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    public User getUserById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建sql映射文件：<code>UserMapper.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.laishiji.mybatis.dao.UserMapper&quot;&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt;</span><br><span class="line">    &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;com.laishiji.mybatis.bean.User&quot;&gt;</span><br><span class="line">         select id, last_name lastName, gender,email from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：<code>mybatisConfig.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">              &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;admin&quot;&#x2F;&gt;</span><br><span class="line">              &lt;&#x2F;dataSource&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>mysql中建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists mybatis;</span><br><span class="line">create database mybatis default character set utf8;</span><br><span class="line"></span><br><span class="line">create table user(</span><br><span class="line">  id int(11) primary key auto_increment,</span><br><span class="line">  last_name varchar(255),</span><br><span class="line">  gender char(1),</span><br><span class="line">  email varchar(255)</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">insert into user(id,last_name,gender,email) values (1,&#39;Tom&#39;,&#39;男&#39;,&#39;123@qq.com&#39;),</span><br><span class="line">                                   (2,&#39;Jim&#39;,&#39;男&#39;,&#39;234@qq.com&#39;),</span><br><span class="line">                                    (3,&#39;Lisa&#39;,&#39;女&#39;,&#39;324@qq.com&#39;);</span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.laishiji.mybatis;</span><br><span class="line"></span><br><span class="line">import com.laishiji.mybatis.bean.User;</span><br><span class="line">import com.laishiji.mybatis.dao.UserMapper;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  SqlSession代表和数据库的一次会话，用完必须关闭；</span><br><span class="line"> *  SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量；</span><br><span class="line"> *  mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws IOException &#123;</span><br><span class="line">        String resource &#x3D; &quot;mybatisConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory &#x3D;  new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        User user &#x3D; session.selectOne(&quot;com.laishiji.mybatis.dao.UserMapper.getUserById&quot;,1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *   接口式编程：</span><br><span class="line">     *    原生：DAO类 ---&gt; DAOImpl实现类</span><br><span class="line">     *    mybatis：xxxMapper接口 ---&gt; xxxMapper.xml</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() throws IOException &#123;</span><br><span class="line">        String resource &#x3D; &quot;mybatisConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory &#x3D;  new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession openSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过反射+动态代理获取接口的实现类对象</span><br><span class="line">        UserMapper mapper &#x3D; openSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user &#x3D; mapper.getUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        openSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。&lt;strong&gt;开发者只需要关注sql语句本身（在配置文件
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://thmasterplan.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/</id>
    <published>2020-04-05T03:18:27.000Z</published>
    <updated>2020-04-24T03:58:47.438Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Maven配置踩坑"><a href="#Maven配置踩坑" class="headerlink" title="Maven配置踩坑"></a>Maven配置踩坑</h3><ul><li><p><strong>修改本地仓库路径</strong>：找到conf目录下的settings.xml，添加<code>&lt;localRepository&gt;PATH&lt;/localRepository&gt;</code>，PATH即为仓库路径。</p></li><li><p><strong>修改Maven云仓库为国内镜像站</strong>：同样在conf目录下的settings.xml下，找到<code>&lt;mirrors&gt;</code>标签，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">       &lt;id&gt;alimaven&lt;&#x2F;id&gt;</span><br><span class="line">       &lt;name&gt;aliyun maven&lt;&#x2F;name&gt;</span><br><span class="line">       &lt;url&gt;http:&#x2F;&#x2F;maven.aliyun.com&#x2F;nexus&#x2F;content&#x2F;groups&#x2F;public&#x2F;&lt;&#x2F;url&gt; &lt;!-- 改为阿里云镜像 --&gt;</span><br><span class="line">     &lt;mirrorOf&gt;central&lt;&#x2F;mirrorOf&gt;        </span><br><span class="line">     &lt;&#x2F;mirror&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>修改默认jdk版本1.5为期望的版本</strong>：同样在conf目录下的settings.xml下，找到<code>&lt;profiles&gt;</code>标签，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;profile&gt;</span><br><span class="line">    &lt;id&gt;jdk-1.8&lt;&#x2F;id&gt;</span><br><span class="line">    &lt;activation&gt;</span><br><span class="line">        &lt;activeByDefault&gt;true&lt;&#x2F;activeByDefault&gt;</span><br><span class="line">        &lt;jdk&gt;1.8&lt;&#x2F;jdk&gt;</span><br><span class="line">    &lt;&#x2F;activation&gt;</span><br><span class="line">    &lt;properties&gt;</span><br><span class="line">        &lt;maven.compiler.source&gt;1.8&lt;&#x2F;maven.compiler.source&gt;</span><br><span class="line">&lt;maven.compiler.target&gt;1.8&lt;&#x2F;maven.compiler.target&gt;</span><br><span class="line">&lt;maven.compiler.compilerVersion&gt;1.8&lt;&#x2F;maven.compiler.compilerVersion&gt; </span><br><span class="line">    &lt;&#x2F;properties&gt; </span><br><span class="line">&lt;&#x2F;profile&gt;</span><br></pre></td></tr></table></figure></li><li><p>idea中Maven项目执行两次的问题：找到maven设置项Runner，取消勾选<code>Delegate IDE build/run actions to Maven</code>。</p></li></ul><h3 id="Maven项目目录结构"><a href="#Maven项目目录结构" class="headerlink" title="Maven项目目录结构"></a>Maven项目目录结构</h3><p><img src="MavenDirStruc.jpg" alt=""></p><h3 id="项目对象模型（POM）"><a href="#项目对象模型（POM）" class="headerlink" title="项目对象模型（POM）"></a>项目对象模型（POM）</h3><ul><li><p>POM详解：<a href="https://www.runoob.com/maven/maven-pom.html。" target="_blank" rel="noopener">https://www.runoob.com/maven/maven-pom.html。</a></p></li><li><p>POM是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p></li><li>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。<ul><li>groupId：公司或者组织的唯一标志。</li><li>artifactId：项目的唯一ID。</li></ul></li></ul><h3 id="Maven构建生命周期"><a href="#Maven构建生命周期" class="headerlink" title="Maven构建生命周期"></a>Maven构建生命周期</h3><ul><li><em>clean</em> <strong>-&gt;</strong> <em>default(build)</em> {validate <strong>-&gt;</strong> compile <strong>-&gt;</strong> test <strong>-&gt;</strong> package <strong>-&gt;</strong> verify <strong>-&gt;</strong> install <strong>-&gt;</strong> deploy } <strong>-&gt;</strong> <em>site</em></li></ul><h3 id="依赖管理模型"><a href="#依赖管理模型" class="headerlink" title="依赖管理模型"></a>依赖管理模型</h3><ul><li><p>Maven 通过读取项目文件（pom.xml），找出库文件之间的依赖关系并从仓库自动下载。</p></li><li><p>引入外部依赖：先在 src 文件夹下添加 lib 文件夹，然后将工程需要的 jar 文件复制到 lib 文件夹下。然后添加以下依赖到pom.xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;xxx&lt;&#x2F;groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;xxx&lt;&#x2F;artifactId&gt;    </span><br><span class="line">        &lt;version&gt;1.0&lt;&#x2F;version&gt; </span><br><span class="line">        &lt;scope&gt;system&lt;&#x2F;scope&gt; &lt;!--作用域--&gt;</span><br><span class="line">        &lt;systemPath&gt;$&#123;basedir&#125;\src\lib\yyy.jar&lt;&#x2F;systemPath&gt; </span><br><span class="line">&lt;&#x2F;dependency&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Maven配置踩坑&quot;&gt;&lt;a href=&quot;#Maven配置踩坑&quot; class=&quot;headerlink&quot; title=&quot;Maven配置踩坑&quot;&gt;&lt;/a&gt;Maven配置踩坑&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改本地仓库路径&lt;/strong&gt;：找到conf目
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Maven" scheme="http://thmasterplan.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Filter_Listener</title>
    <link href="http://thmasterplan.cn/JavaWeb/Filter-Listener/"/>
    <id>http://thmasterplan.cn/JavaWeb/Filter-Listener/</id>
    <published>2020-04-03T07:52:10.000Z</published>
    <updated>2020-04-03T14:29:23.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Filter（过滤器）"><a href="#Filter（过滤器）" class="headerlink" title="Filter（过滤器）"></a>Filter（过滤器）</h3><ul><li><p><strong>概念</strong>：客户端访问服务器资源时，filter拦截请求，作特殊处理：<strong>登录验证</strong>、<strong>统一编码处理</strong>、<strong>敏感字符过滤等</strong>。</p></li><li><p><strong>使用</strong></p><ul><li><p>实现<code>javax.servlet.Filter</code>接口</p></li><li><p>覆写<code>init()/doFilter()/destroy()</code>方法</p><ul><li>doFilter()放行代码：<code>filterChain.doFilter(servletRequest, servletResponse);</code></li></ul></li><li><p>配置拦截路径</p><ul><li><p>注解配置：<code>@WebFilter(&quot;/path&quot;)</code></p></li><li><p>web.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;filterClassName&lt;&#x2F;filter-class&gt;</span><br><span class="line">&lt;&#x2F;filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;name&lt;&#x2F;filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;&#x2F;path&lt;&#x2F;url-pattern&gt; &lt;!-- 拦截路径 --&gt;</span><br><span class="line">&lt;&#x2F;filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>filter的执行流程</strong></p><ul><li>客户端请求 -&gt;</li><li>经过filter -&gt;</li><li>执行doFilter()：<ul><li>对request对象请求消息处理 -&gt;</li><li>放行 -&gt;</li><li>(服务器servlet执行后响应) 对response对象的响应消息处理 </li></ul></li></ul></li><li><p><strong>filter的生命周期</strong></p><ul><li><code>init()</code>：服务器启动后，创建filter对象，调用init()方法，只执行一次。用于加载资源。</li><li><code>doFilter()</code>：<strong>每一次请求</strong>被拦截资源时，都会执行。</li><li><code>destroy()</code>：服务器关闭，filter对象被销毁。正常关闭情况下，会执行destroy()方法。用于释放资源。</li></ul></li><li><p><strong>拦截方式配置</strong>，设置dispatcherTypes属性</p><ul><li><p>注解方式</p><ul><li>DispatcherType.REQUEST：默认值。浏览器直接请求资源时，才会执行filter。</li><li>DispatcherType.FORWARD：转发访问资源。</li><li>DispatcherType.INCLUDE：包含访问资源。</li><li>DispatcherType.ERROR：错误跳转资源。</li><li>DispatcherType.ASYNC：异步访问资源。</li></ul></li><li><p>web.xml方式</p><ul><li>添加<code>&lt;dispatcher&gt; &lt;/dispatcher&gt;</code>标签，标签中文本取上述取值即可。</li></ul></li></ul></li><li><p><strong>过滤器链的执行顺序</strong>：filter1 -&gt; filter2… -&gt; 资源执行 -&gt;…filter2 -&gt; filter1。</p><ul><li>注解配置：按照类名的字符串比较规则比较，值小的先执行。例如filterA与filterB，则filterA先执行。</li><li>web.xml配置：按照<code>&lt;filter-mapping&gt;</code>的定义顺序执行。</li></ul></li></ul><h3 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener(监听器)"></a>Listener(监听器)</h3><ul><li><p>概念：监听器就是一个实现了特定<strong>接口</strong>的普通Java程序，这个程序专门用于监听另一个Java对象的方法调用或者属性改变（事件）。当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p></li><li><p>常用的监听器”6 + 2”：</p><ul><li><p><strong>6个常规监听器</strong>，对应JavaWeb<strong>三大域对象</strong></p><ul><li><p><strong>ServletContext</strong></p><ul><li>ServletContextListener(生命周期监听)，<strong>项目启动时</strong>，ServletContext创建后创建该接口的实现类对象。注：Spring框架的ContextLoaderListener类实现了该接口。</li><li>ServletContextAttributeListener(属性监听)</li></ul></li><li><p><strong>HttpSession</strong></p><ul><li>HttpSessionListener(生命周期监听)，只有在servlet中调用了request.getSession()方法且根据JSESSIONID找不到对应的session时才会创建新的session对象，触发监听。</li><li>HttpSessionAttributeListener(属性监听)</li></ul></li><li><p><strong>ServletRequest</strong></p><ul><li>ServletRequestListener(生命周期监听)，每一次请求都会创建request对象并触发监听，每一次请求结束都会销毁request对象并触发监听。</li><li>ServletRequestAttributeListener(属性监听)</li></ul></li><li><p><strong>生命周期监听</strong>：每当tomcat<strong>创建或销毁三大域对象</strong>时，都会被其对应的Listener察觉并调用其特定的方法。</p></li><li><strong>属性监听</strong>：每当调用域对象的setAttribute()或getAttribute()，都会被对应的属性监听器察觉并调用其特定的方法。</li></ul></li><li><p><strong>2个感知监听</strong></p><ul><li>HttpSessionBindingListener：需要通过<code>session.setAttribute(&quot;key&quot;, new Object())</code>存储的对象Object实现该监听器接口，其有两个方法<code>valueBound()/valueUnbound</code>，当该对象被<strong>绑定(存储)</strong>时，触发该对象的<code>valueBound()</code>方法；当该对象被session<strong>解绑</strong>时<code>session.removeAttribute(&quot;key&quot;);</code>时触发该对象的<code>valueUnbound()</code>方法。</li><li>HttpSessionActivationListener：需要通过<code>session.setAttribute(&quot;key&quot;, new Object())</code>存储的对象Object实现该监听器接口。当该session即将被<strong>钝化(序列化)</strong>时，触发该监听器的<code>sessionWillPassivate()</code>方法；当该session<strong>活化</strong>时，触发该监听器的<code>sessionDidActivate</code>方法。</li></ul></li></ul></li><li><p><strong>设计模式：观察者模式</strong>（待补充）</p></li><li><p><code>javax.servlet.ServletContextListener</code>接口：用于监听ServletContext对象的销毁与创建</p><ul><li><code>void contextDestroyed(ServletContextEvent sce)</code>：ServletContext对象<strong>被销毁</strong>之前会调用该方法。</li><li><p><code>void contextInitialized(ServletContextEvent sce)</code>：ServletContext对象<strong>创建</strong>后会调用该方法，服务器启动后自动调用。</p></li><li><p>使用：实现接口 -&gt; 覆写方法 -&gt; 配置</p><ul><li><p>web.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">   &lt;listener-class&gt;监听器类名&lt;&#x2F;listener-class&gt;</span><br><span class="line">&lt;&#x2F;listener&gt;</span><br></pre></td></tr></table></figure></li><li><p>注解配置：<code>@WebListener</code></p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Filter（过滤器）&quot;&gt;&lt;a href=&quot;#Filter（过滤器）&quot; class=&quot;headerlink&quot; title=&quot;Filter（过滤器）&quot;&gt;&lt;/a&gt;Filter（过滤器）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;：客户端访问
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Cookie_Session</title>
    <link href="http://thmasterplan.cn/JavaWeb/Cookie-Session/"/>
    <id>http://thmasterplan.cn/JavaWeb/Cookie-Session/</id>
    <published>2020-04-01T12:55:36.000Z</published>
    <updated>2020-04-03T07:49:07.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li>会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一<strong>标识一个用户并记录其状态</strong>。由于HTTP协议是无状态的，也就是说浏览器的每一次请求都是独立的，服务器并不知道这个浏览器之前是否请求过，这才有了会话机制。</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li><p>概念：客户端会话技术，将数据保存到客户端。<code>javax.servlet.http.Cookie</code>(类)。</p></li><li><p>主要作用：避免多次登录验证，一次登录后服务器便使用cookie验证身份。cookie的作用就像是身份凭证。</p></li><li><p>使用</p><ul><li><p>创建Cookie对象，绑定数据：<code>new Cookie(String name, String value)</code></p></li><li><p>发送Cookie对象到客户端：<code>response.addCookie(Cookie cookie)</code></p></li><li><p>获取Cookie，拿到数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies &#x3D; request.getCookies();</span><br><span class="line">if(cookies !&#x3D; null)&#123;</span><br><span class="line">   for(Cookie c : cookies)&#123;</span><br><span class="line">      String name &#x3D; c.getName();</span><br><span class="line">      String val &#x3D; c.getValue();</span><br><span class="line">      &#x2F;&#x2F;..........</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理</p><ul><li>客户端发送请求-&gt;</li><li>服务器创建Cookie并发送到客户端 -&gt; </li><li>http响应头增加Set-Cookie：name=value字段 -&gt;</li><li>客户端存储cookie数据 -&gt; </li><li>客户端下一次请求http请求头设置cookie -&gt; </li><li>服务器验证</li></ul></li><li><p>Tips</p><ul><li><p>一次可以创建多个Cookie并发送</p></li><li><p>Cookie在浏览器中存活时间</p><ul><li>默认情况下，浏览器关闭后Cookie数据销毁</li><li><strong>持久化存储</strong>：<code>cookie.setMaxAge(int seconds)</code><ul><li>正数：将cookie数据写到硬盘的文件中，seconds时间之后文件被删除。</li><li>负数：默认值</li><li>0：删除已经存在于客户端的cookie数据</li></ul></li></ul></li><li><p>Tomcat8之后Cookie支持中文</p></li><li><p><strong>Cookie共享问题</strong></p><ul><li><p>假设在一个Tomcat服务器中部署了多个web项目：</p><ul><li><p>默认情况下不同web项目的cookie不能共享</p></li><li><p><code>cookie.setPath(String path)</code>：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，可将path设置为”/“。</p></li></ul></li><li><p>服务器集群共享Cookie：</p><ul><li><code>setDomain(String path)</code>：设置一级域名</li><li>例如<code>setDomain(&quot;.baidu.com&quot;)</code>，则tieba.baidu.com和news.baidu.com中cookie可以共享</li></ul></li></ul></li></ul></li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li><p>概念：服务器端会话技术，在<strong>一次会话的多次请求间共享数据</strong>，将数据保存在服务器端的对象中。<code>javax.servlet.http.HttpSession</code>（接口）。</p></li><li><p>主要作用</p><ul><li>用于存储一次会话的多次请求的数据</li><li>可以存储任意类型、任意大小的数据</li></ul></li><li><p>使用</p><ul><li><p>获取session对象：<code>HttpSession session = request.getSession();</code></p></li><li><p>存储数据：<code>session.setAttribute(&quot;name&quot;, Object);</code></p></li><li><p>获取数据：<code>session.getAttribute(&quot;name&quot;);</code></p></li></ul></li><li><p>原理：<strong>Session的实现依赖于Cookie</strong>，服务器通过Cookie确保多次请求获取的Session对象为同一个。</p><ul><li>客户端发送请求-&gt;</li><li>创建Session对象，若没有Cookie，则http响应头增加Set-Cookie：JSESSIONID=sessionID字段 -&gt;</li><li>客户端存储cookie数据 -&gt; </li><li>客户端下一次请求http请求头设置cookie -&gt; </li><li>服务器验证sessionID</li></ul></li><li><p>Tips</p><ul><li><p>浏览器关闭，服务器不关闭，浏览器重启，两次获取的session对象是否相同？</p><ul><li><p>默认情况下不是。</p></li><li><p>为避免这种情况，可手动设置持久化存储JSESSIONID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie &#x3D; new Cookie(&quot;JSESSIONID&quot;, session.getId());</span><br><span class="line">cookie.setMaxAge(60*60);&#x2F;&#x2F;持久化存储cookie</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>浏览器不关闭，服务器关闭，服务器开启，两次获取的session对象是否相同？</p><ul><li>新对象地址与原对象不同</li><li>为避免服务器重启数据丢失，采用<strong>session的钝化和活化技术</strong>。<ul><li>session钝化：在服务器正常关闭前，将session对象序列化到硬盘上</li><li>session活化：服务器启动后，将session文件转化为内存中的session对象，删除文件</li><li>Tomcat已经集成了钝化与活化技术，正常关闭tomcat后，会在work工作目录的项目文件夹下生成一个SESSIONS.ser文件</li><li>session钝化与活化不仅仅是服务器关闭时发生，当在线用户过多时，大量session对象存在于服务器内存中。为减轻服务器内存负担，当一个session长时间没有被访问，也会被序列号到磁盘上（注意session中存储的对象所在的类必须要实现序列化接口）。可在tomcat的<code>conf/context.xml</code>中配置。</li></ul></li></ul></li><li><p>session何时被销毁？</p><ul><li><p>服务器关闭</p></li><li><p>session对象调用invalidate()方法</p></li><li><p>session默认失效时间为30分钟(可在tomcat的conf/web.xml中配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">        &lt;session-timeout&gt;30&lt;&#x2F;session-timeout&gt;</span><br><span class="line">    &lt;&#x2F;session-config&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;会话&quot;&gt;&lt;a href=&quot;#会话&quot; class=&quot;headerlink&quot; title=&quot;会话&quot;&gt;&lt;/a&gt;会话&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一&lt;strong&gt;标识一个用户并记录其状态&lt;/strong&gt;。由于
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://thmasterplan.cn/JavaWeb/Servlet/"/>
    <id>http://thmasterplan.cn/JavaWeb/Servlet/</id>
    <published>2020-04-01T08:10:10.000Z</published>
    <updated>2020-04-03T15:17:16.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet-Server-applet"><a href="#Servlet-Server-applet" class="headerlink" title="Servlet(Server applet)"></a>Servlet(Server applet)</h3><ul><li>用于处理请求与业务逻辑。</li><li><strong>调用流程</strong>：<ul><li>用户访问html页面，表单提交</li><li>xml文件<code>url-pattern</code>与url匹配，若符合Tomcat则加载<code>servlet-class</code>对应的class文件进内存（反射）</li><li>实例化Servlet（class.newInstance()）得到一个Servlet对象</li><li>调用service()方法，根据表单的method，在该方法中调用doGet或doPost方法</li><li>request对象获取参数，response对象返回数据</li><li>服务器通过http协议返回数据</li></ul></li><li><p>Servlet<strong>生命周期</strong>：</p><ul><li>实例化：无论访问多少次该Servlet，构造方法只执行一次，只存在一个对象（单实例）<ul><li>注：多个用户同时访问时，可能存在线程安全问题。因此尽量不要在Servlet中定义成员变量。</li></ul></li><li><strong>初始化</strong>：在构造方法执行后，执行<strong>init()</strong>方法，无论访问多少次该Servlet，init()方法<strong>只执行一次</strong>。init()方法的参数ServletConfig对象实例，通过解析web.xml文件创建。</li><li><strong>提供服务</strong>：tomcat创建req和resp对象，将这两个对象作为参数传递给service()，执行<strong>service()</strong>方法，在该方法中判断执行doGet()还是doPost()</li><li><p><strong>销毁</strong>：当在server.xml的Context字段中配置了reloadable=”true”时，表示web应用有任何类型的更新都会自动重启，重启就会调用<strong>destroy()</strong>方法；tomcat服务器关闭时destroy()方法会被调用。</p></li><li><p>被回收：等待下一次GC回收</p></li></ul></li><li><strong>自启动</strong>：假如需要在tomacat一启动就执行一些初始化的代码，比如校验数据库的完整性。但是Servlet的生命周期是在用户访问对应路径开始的，这就需要Servlet自启动，执行init()方法中的业务代码：在web.xml中增加<code>&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;</code>，取值范围是1-99，数字表示启动顺序，数字越小启动的优先级越高。</li><li><p><strong>注解配置</strong>（Servlet3.0后支持，不再需要web.xml配置文件）</p><ul><li>Servlet类上使用<code>@WebServlet(&quot;/URI&quot;)</code>配置</li></ul></li><li><p><strong>页面跳转</strong>：</p><ul><li>服务端跳转<strong>forward(转发)</strong>：<code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code>,服务器内部访问success.html，并将其发送给浏览器。<strong>客户端只请求一次，服务器内部跳转</strong>。</li><li>客户端跳转<strong>redirect(重定向)</strong>：<code>response.sendRedirect(&quot;fail.html&quot;);</code>，发送一条消息给浏览器让其访问fail.html，浏览器访问，服务器获取fail.html发送给浏览器。<strong>客户端一共请求了两次</strong>。</li></ul></li><li><p><strong>Servlet映射器(Mapper)</strong>：每一个请求，对应的URL要交给哪一个Servlet处理，由Tomcat中的映射器Mapper类处理。</p></li><li><p><strong>request对象</strong>：封装请求消息数据</p><ul><li><p>获取参数：</p><p><code>request.getParameter()</code>：用于获取单值的参数<br><code>request.getParameterValues()</code>：用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。<br><code>request.getParameterMap()</code>：用于遍历所有的参数，并返回Map类型。</p></li><li><p>获取头信息：</p><p><code>request.getHeader()</code>：获取浏览器传递过来的头信息。<br><code>request.getHeaderNames()</code>：获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p></li><li><p>服务端传参：<code>request.setAttribute()</code>与<code>request.getAttribute()</code></p></li><li><p>设置编码：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p></li><li><p>常见方法：</p><p><code>request.getRequestURL()</code>：浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”<br><code>request.getRequestURI()</code>：浏览器发出请求的资源名部分，去掉了协议和主机名”<br><code>request.getQueryString()</code>：请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br><code>request.getRemoteAddr()</code>：浏览器所处于的客户机的IP地址<br><code>request.getRemoteHost()</code>：浏览器所处于的客户机的主机名<br><code>request.getRemotePort()</code>：浏览器所处于的客户机使用的网络端口<br><code>request.getLocalAddr()</code>：服务器的IP地址<br><code>request.getLocalName()</code>：服务器的主机名<br><code>request.getMethod()</code>：得到客户机请求方式，一般是GET或者POST                 </p></li></ul></li><li><p><strong>response对象</strong>：通过response对象设置响应消息数据</p><ul><li><p>设置响应内容：<code>response.getWriter()</code>获取PrintWriter对象，使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。             </p></li><li><p>设置响应格式与编码：<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>或<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code></p></li></ul></li><li><p><strong>ServletContext对象</strong>：服务器启动后自动创建，在整个Web应用的动态资源（Servlet/JSP…）之间共享数据，与servlet容器通信，服务器关闭时销毁。</p><ul><li>通过request.getServletContext()或this.getServletContext()获取</li><li>获取MIME(text/html, image/jpeg…)类型数据：<code>getMimeType(String file)</code></li><li>作为域对象共享数据：<code>setAttribute() getAttribute() removeAttribute()</code>，共享所有用户请求的数据</li><li>获取文件的真实路径：<code>getRealPath(String file)</code></li></ul></li><li><p><strong>ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序</strong>（对称）</p><ul><li>ServletContext -&gt;</li><li>ServletContextListener -&gt;</li><li>Filter -&gt;</li><li>自启动Servlet -&gt;</li><li>浏览器请求访问普通Servlet -&gt;</li><li>销毁自启动Servlet -&gt;</li><li>销毁Filter-&gt;</li><li>销毁ServletContextListener -&gt;</li><li>销毁ServletContext</li></ul></li><li><p>Listener, Filter, Servlet的实现类对象均是<strong>服务器通过反射创建</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Servlet-Server-applet&quot;&gt;&lt;a href=&quot;#Servlet-Server-applet&quot; class=&quot;headerlink&quot; title=&quot;Servlet(Server applet)&quot;&gt;&lt;/a&gt;Servlet(Server applet)
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JSON</title>
    <link href="http://thmasterplan.cn/JavaWeb/JSON/"/>
    <id>http://thmasterplan.cn/JavaWeb/JSON/</id>
    <published>2020-04-01T08:09:57.000Z</published>
    <updated>2020-04-01T08:11:33.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h3><ul><li>概念：JavaScript对象表示法(JavaScript Object Notation)。</li><li>作用：JSON是存储和交换文本信息的语法，常用于信息传输，比XML更小、更快、更易解析。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>基本语法：</p><ul><li>数据由键值对构成，值的取值类型有：<ul><li>整数或浮点数</li><li>字符串：<code>&quot;string&quot;</code></li><li>布尔值：<code>true/false</code></li><li>数组：<code>[]</code></li><li>对象：<code>{name:&quot;Tom&quot;,age:23,gender:&quot;male&quot;}</code></li><li>null</li></ul></li><li>数据由<code>,</code>分隔</li><li><code>{}</code>保存对象，同时也定义了JSON格式</li><li><code>[]</code>保存数组</li></ul></li><li><p>获取数据方式：JSON对象.键名；JSON对象[“键名”]；数组对象[索引]。</p></li></ul><h3 id="JSON在Java中的解析"><a href="#JSON在Java中的解析" class="headerlink" title="JSON在Java中的解析"></a>JSON在Java中的解析</h3><ul><li><p>Java常用的JSON解析类库：GSON, FastJson, Jackson；以Jackson为例。</p></li><li><p>Java对象转JSON</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private int age;</span><br><span class="line">   private String gender;</span><br><span class="line">   &#x2F;&#x2F;getter and setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JacksonTest&#123;</span><br><span class="line">   &#x2F;&#x2F;创建Java对象</span><br><span class="line">    Person p &#x3D; new Person();</span><br><span class="line">    p.setName(&quot;Tom&quot;);</span><br><span class="line">    p.setAge(23);</span><br><span class="line">    p.setGender(&quot;男&quot;);</span><br><span class="line">   &#x2F;&#x2F;创建Jackson对象</span><br><span class="line">   ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">   &#x2F;&#x2F;转换方法：</span><br><span class="line">   &#x2F;*</span><br><span class="line">      writeValue(args, obj):</span><br><span class="line">         args: </span><br><span class="line">            File:将obj对象转换为JSON字符串，并保存到指定文件；</span><br><span class="line">            Writer:转换，并将json数据填充到字符输出流</span><br><span class="line">            OutputStream:转换，并将json数据填充到字节输出流</span><br><span class="line">      writeValueAsString(obj):将对象转换为json字符串</span><br><span class="line">   *&#x2F;</span><br><span class="line">   String json &#x3D; mapper.writeValueAsString(p);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解：<ul><li>@JsonIgnore：排除属性（该注解置于要忽略的属性上），指定属性不会被转换</li><li>@JsonFormat：属性值格式化（该注解置于要格式化的属性上），例<code>@JsonFormat(pattern=&quot;yyyy-MM-dd&quot;)</code></li></ul></li></ul></li><li><p>JSON转Java对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String json &#x3D; &quot;&#123;name:\&quot;Tom\&quot;,age:23&#125;&quot;;</span><br><span class="line">ObjectMapper mapper &#x3D; new ObjectMapper();</span><br><span class="line">Person p &#x3D; mapper.readValue(json, Person.class);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JSON简介&quot;&gt;&lt;a href=&quot;#JSON简介&quot; class=&quot;headerlink&quot; title=&quot;JSON简介&quot;&gt;&lt;/a&gt;JSON简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;概念：JavaScript对象表示法(JavaScript Object Notation)。&lt;
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://thmasterplan.cn/JavaWeb/XML/"/>
    <id>http://thmasterplan.cn/JavaWeb/XML/</id>
    <published>2020-03-30T14:00:41.000Z</published>
    <updated>2020-03-30T14:15:08.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>扩展标记语言（Extensible Markup Language），标签可自定义。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>用于<strong>存储</strong>与<strong>传输</strong>数据<ul><li>配置文件</li><li>在网络中传输</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>基本语法：</p><ul><li>第一行必须定义为文档声明，例如<code>&lt;? xml version=&#39;1.0&#39; ?&gt;</code>。</li><li><p>xml文档中有且仅有一个<strong>根标签</strong></p></li><li><p>属性值必须用使用引号</p></li><li>标签必须正确关闭</li><li>标签名称严格区分大小写</li></ul></li><li><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &lt;?xml version&#x3D;&#39;1.0&#39; ?&gt;</span><br><span class="line">  &lt;users&gt;</span><br><span class="line">      &lt;user id&#x3D;&#39;1&#39;&gt;</span><br><span class="line">          &lt;name&gt;Tom&lt;&#x2F;name&gt;</span><br><span class="line">          &lt;age&gt;23&lt;&#x2F;age&gt;</span><br><span class="line">          &lt;br&#x2F;&gt;</span><br><span class="line">      &lt;&#x2F;user&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;user id&#x3D;&#39;2&#39;&gt;</span><br><span class="line">          &lt;name&gt;Lisa&lt;&#x2F;name&gt;</span><br><span class="line">          &lt;age&gt;20&lt;&#x2F;age&gt;</span><br><span class="line">      &lt;&#x2F;user&gt;</span><br><span class="line">&lt;&#x2F;users&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>组成部分：</p><ul><li>文档声明：<code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</code></li><li>标签：自定义标签</li><li>属性：id属性值唯一</li><li>文本</li></ul></li><li><p>XML<strong>命名空间</strong>（XML Namespaces）：提供避免元素命名冲突的方法，比如不同的两个XML被同时使用，且他们有一个相同的标签时，可通过命名空间避免冲突。</p><ul><li>XML<strong>命名空间属性</strong>被放置于<strong>元素的开始标签</strong>中，语法为<code>xmlns:namespace-prefix=&#39;namespaceURI&#39;</code></li><li>当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联</li></ul></li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li><p>约束：规定xml文档的书写规则。一般来说，框架提供约束，框架使用者按照约束来编写xml。</p></li><li><p>DTD：简单的约束技术，文件后缀为.dtd</p><ul><li><p><code>&lt;!ELEMENT &gt;</code>定义标签，<code>&lt;!ATTLIST &gt;</code>定义属性，<code>()</code>定义子标签</p></li><li><p>约束内容例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT students (student*)&gt;</span><br><span class="line">&lt;!ELEMENT student (name,age,sex)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">&lt;!ATTLIST student number ID #REQUIRED&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入dtd文档到xml中</p><ul><li>内部dtd：将约束规则定义在xml文档中<ul><li><code>&lt;!DOCTYPE 根标签名 [约束内容] &gt;</code></li></ul></li><li>外部dtd：将约束规则定义在外部的dtd文件中<ul><li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的绝对路径&quot;&gt;</code></li><li>网络：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;URL路径&quot;&gt;</code></li></ul></li></ul></li></ul></li><li><p>Schema：复杂的约束技术，本质上就是xml，文件后缀为.xsd</p><ul><li><p>可定义xml中文本的类型，文本取值的范围，标签出现的顺序等</p></li><li><p>引入.xsd约束文件到xml</p><ul><li><p>引入无命名空间的.xsd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; </span><br><span class="line">      xsi:noNamespaceSchemaLocation&#x3D;&quot;无命名空间XSD文件的URI&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">   1.第一步，添加xmlns:xsi属性，引入xsi命名空间</span><br><span class="line">   2.第二步，通过xsi命名空间下的属性noNamespaceSchemaLocation指定XSD文件的URI</span><br><span class="line">--&gt;</span><br><span class="line">&lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入有命名空间的.xsd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;root xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot; </span><br><span class="line">          xmlns:ns1&#x3D;&quot;前缀ns1对应命名空间&quot; </span><br><span class="line">          xmlns:ns2&#x3D;&quot;前缀ns2对应命名空间&quot; </span><br><span class="line">          xsi:schemaLocation&#x3D;&quot;ns1前缀对应命名空间 前缀ns1对应命名空间XSD文件的URI </span><br><span class="line">                       ns2前缀对应命名空间 前缀ns2对应命名空间XSD文件的URI&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">       1.第一步，添加xmlns:xsi属性，引入xsi命名空间</span><br><span class="line">       2.第二步，添加命名空间，可添加多个，但没有前缀的命名空间最多只能有1个</span><br><span class="line">       3.第三步，通过xsi命名空间下的属性schemaLocation指定每个命名空间XSD文件的URI，命名空间和相应URI一一对应，多个命名空间用空格分隔</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;&#x2F;root&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;扩展标记语言（Extensible Markup Language），标签可自定义。&lt;/p&gt;
&lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-28T13:38:15.000Z</published>
    <updated>2020-03-29T02:30:37.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划题目特点"><a href="#动态规划题目特点" class="headerlink" title="动态规划题目特点"></a>动态规划题目特点</h3><ul><li><p><strong>计数</strong></p><ul><li><p>有多少种方式走到右下角</p></li><li><p>有多少种方法选出k个数使得和为Sum</p></li><li><p>例：lintcode114</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: positive integer (1 &lt;= m &lt;= 100)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n: positive integer (1 &lt;= n &lt;= 100)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];<span class="comment">//dp[i][j]表示机器人有多少种方式从左上角走到(i,j)</span></span><br><span class="line">        <span class="comment">//dp[i][j] = dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;<span class="comment">//第0行(列)的所有格子都只有一种方式到达</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>求最值</strong></p><ul><li><p>从左上角走到右下角路径的最大数字和</p></li><li><p>最长上升序列长度</p></li><li><p>例：lintcode669</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coins: a list of integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount: a total amount of money amount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: the fewest number of coins that you need to make up</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];<span class="comment">//记录组成从0-amount分别需要的最少的硬币数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i)&#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;<span class="comment">//表示不存在组成i所需要的最少硬币数,同时看作min变量，储存dp[i-coins[j]]+1,j=1,2...中的最小值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != Integer.MAX_VALUE &amp;&amp; dp[i-coins[j]]+<span class="number">1</span> &lt; dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[i-coins[j]] + <span class="number">1</span>;<span class="comment">//组成总数为i需要的最少的硬币数为：组成总数为i-coins[j],j=1,2...coins.length需要的最少硬币数中最小的一个,再加1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>求存在性</strong></p><ul><li><p>取石子游戏，先手是否必胜</p></li><li><p>能不能选出k个数使得和为Sum</p></li><li><p>例：lintcode116</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: A list of integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: A boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//思路:最后一步A[len-1]可达，当且仅当前面某个下标i可达且i+A[i]&gt;=A[len-1]；推广到对任意j = 1,2,...len-1，i &lt; j都必须满足dp[i] &amp;&amp; i + A[i] &gt;= j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            dp[j] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &amp;&amp; i + A[i] &gt;= j)&#123;<span class="comment">//状态方程：能够到达i，并且i+A[i]&gt;=j即表示从i能到达j</span></span><br><span class="line">                     dp[j] = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//贪心算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpGreedy</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[3,2,1,0,4]</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> farthest = A[<span class="number">0</span>];<span class="comment">//farthest变量记录当前能够到达的最远距离</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(farthest &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//farthest比i小，表示不能到达i，return false</span></span><br><span class="line">            <span class="keyword">else</span> farthest = i + A[i] &gt; farthest ? i + A[i] : farthest;<span class="comment">//更新farthest</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="动态规划组成部分"><a href="#动态规划组成部分" class="headerlink" title="动态规划组成部分"></a>动态规划组成部分</h3><ul><li><p><strong>确定状态</strong>：创建数组，<strong>数组的每个元素代表什么</strong>？</p><ul><li><p>两个要点</p><ul><li>最后一步</li><li>子问题</li></ul></li><li><p>递归算法的问题：重复计算，效率低下</p></li></ul></li><li><p><strong>转移方程</strong>：<strong>根据子问题定义</strong>得到。将计算结果保存下来，并改变计算顺序，空间换时间</p></li><li><strong>初始条件和边界情况</strong></li><li><strong>计算顺序</strong>：利用之前的计算结果</li></ul><h3 id="常见动态规划类型"><a href="#常见动态规划类型" class="headerlink" title="常见动态规划类型"></a>常见动态规划类型</h3><ul><li>坐标型</li><li>序列型</li><li>划分型</li><li>区间型</li><li>背包型</li><li>最长序列型</li><li>博弈型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动态规划题目特点&quot;&gt;&lt;a href=&quot;#动态规划题目特点&quot; class=&quot;headerlink&quot; title=&quot;动态规划题目特点&quot;&gt;&lt;/a&gt;动态规划题目特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;计数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="lintcode" scheme="http://thmasterplan.cn/tags/lintcode/"/>
    
  </entry>
  
</feed>
