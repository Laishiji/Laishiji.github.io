<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2021-02-14T08:31:22.164Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL连接与访问方法</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E8%BF%9E%E6%8E%A5%E4%B8%8E%E8%AE%BF%E9%97%AE%E6%96%B9%E6%B3%95/</id>
    <published>2021-02-13T03:59:31.000Z</published>
    <updated>2021-02-14T08:31:22.164Z</updated>
    
    <content type="html"><![CDATA[<h1 id="访问方法"><a href="#访问方法" class="headerlink" title="访问方法"></a>访问方法</h1><p>访问方法：MySQL执行查询语句的方式。同一个查询语句可能可以使用多种不同的访问方法来执行，但是执行的时间相差甚远，因此查询优化器会根据SQL语句来选择合适的访问方法。访问方法有const、ref、ref_or_null、range、index、all六种。</p><p>首先建表如下：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> single_table (</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">    key1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key2 <span class="built_in">INT</span>,</span><br><span class="line">    key3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part1 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part2 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    key_part3 <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    common_field <span class="built_in">VARCHAR</span>(<span class="number">100</span>),</span><br><span class="line">    <span class="comment">-- id列主键，key1/key3为二级索引，key2为唯一二级索引</span></span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key1 (key1),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key3 (key3),</span><br><span class="line">    <span class="keyword">UNIQUE</span> <span class="keyword">KEY</span> idx_key2 (key2),</span><br><span class="line">    <span class="keyword">KEY</span> idx_key_part(key_part1, key_part2, key_part3)</span><br><span class="line">) <span class="keyword">Engine</span>=<span class="keyword">InnoDB</span> <span class="keyword">CHARSET</span>=utf8;</span><br></pre></td></tr></table></figure><h2 id="const"><a href="#const" class="headerlink" title="const"></a>const</h2><p>使用<strong>主键或唯一二级索引等值查询</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">id</span> = <span class="number">1438</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> key2 = <span class="number">3841</span>;</span><br></pre></td></tr></table></figure><p>通过这两种方式定位一条记录速度非常快，代价可忽略不计，因此称为<code>const</code>，意为常数级别。</p><h2 id="ref"><a href="#ref" class="headerlink" title="ref"></a>ref</h2><p><strong>二级索引：等值查询</strong>；或者<strong>联合索引：左边连续索引列等值查询</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table</span><br><span class="line"><span class="keyword">WHERE</span> key1 = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> key_part1 = <span class="string">'god like'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> key_part1 = <span class="string">'god like'</span> </span><br><span class="line"><span class="keyword">AND</span> key_part2 = <span class="string">'legendary'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> key_part1 = <span class="string">'god like'</span> </span><br><span class="line"><span class="keyword">AND</span> key_part2 = <span class="string">'legendary'</span> </span><br><span class="line"><span class="keyword">AND</span> key_part3 = <span class="string">'penta kill'</span>;</span><br></pre></td></tr></table></figure><p>对于非唯一二级索引的等值查询，如果需要回表的记录非常多，那么它的性能和全表扫描的性能相比是有待商榷的。如果匹配的记录较少，那么ref的速度依然很快。</p><h2 id="ref-or-null"><a href="#ref-or-null" class="headerlink" title="ref_or_null"></a>ref_or_null</h2><p><strong>在ref方法的基础上，允许查询索引列为null值的记录</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> key1 = <span class="string">'abc'</span></span><br><span class="line"><span class="keyword">OR</span> key1 <span class="keyword">IS</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure><h2 id="range"><a href="#range" class="headerlink" title="range"></a>range</h2><p><strong>索引列需要匹配某个或某些范围的值</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> single_table</span><br><span class="line"><span class="keyword">WHERE</span> key2 <span class="keyword">IN</span> (<span class="number">1438</span>, <span class="number">6328</span>) </span><br><span class="line"><span class="keyword">OR</span> (key2 &gt;= <span class="number">38</span> <span class="keyword">AND</span> key2 &lt;= <span class="number">79</span>);</span><br></pre></td></tr></table></figure><h2 id="index"><a href="#index" class="headerlink" title="index"></a>index</h2><p><strong>遍历二级索引全部记录</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> key_part1, key_part2, key_part3 </span><br><span class="line"><span class="keyword">FROM</span> single_table </span><br><span class="line"><span class="keyword">WHERE</span> key_part2 = <span class="string">'abc'</span>;</span><br></pre></td></tr></table></figure><p>以上这个SQL语句虽然查询列表中只有联合索引列，但是查询条件却没有key_part1，因此无法使用到联合索引进行搜索。MySQL考虑到直接遍历二级索引比直接遍历聚簇索引的成本要小很多，因此将<strong>遍历二级索引全部记录</strong>的方法称为<code>index</code>。</p><h2 id="all"><a href="#all" class="headerlink" title="all"></a>all</h2><p><strong>遍历聚簇索引，即全表扫描</strong>。例如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> *</span><br><span class="line"><span class="keyword">FROM</span> single_table</span><br><span class="line"><span class="keyword">WHERE</span> common_field = <span class="string">"test"</span>;</span><br></pre></td></tr></table></figure><h1 id="连接"><a href="#连接" class="headerlink" title="连接"></a>连接</h1><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> t1, t2 </span><br><span class="line"><span class="keyword">WHERE</span> t1.m1 &gt; <span class="number">1</span> </span><br><span class="line"><span class="keyword">AND</span> t1.m1 = t2.m2 </span><br><span class="line"><span class="keyword">AND</span> t2.n2 &lt; <span class="string">'d'</span>;</span><br></pre></td></tr></table></figure><p>以上SQL的执行过程为：先从t1表（驱动表，即第一个查询的表）找到满足t1.m1 &gt; 1的记录，再将所有符合条件的t1.m1的值赋给t2.m2，从t2表（被驱动表）中分别去查询符合条件的记录。也就是说，<strong>驱动表他只需要访问一次，而被驱动表很可能被访问多次</strong>，被驱动表的访问次数取决于驱动表单表查询后返回结果集的记录数。因此对于只有多表过滤条件的SQL语句，如t1.m1 = t2.m2，那么MySQL查询被驱动表的次数就是驱动表中的总记录数，这个代价就太大了。</p><h2 id="内连接与外连接"><a href="#内连接与外连接" class="headerlink" title="内连接与外连接"></a>内连接与外连接</h2><ul><li><p><strong>内连接</strong>：对于内连接的两个表，驱动表中的记录在被驱动表中找不到匹配的记录，该记录不会加入到最后的结果集。</p></li><li><p><strong>外连接</strong>：驱动表中的记录即使在被驱动表中没有匹配的记录，也仍然需要加入到结果集。左外连接的驱动表为<code>LEFT JOIN</code>左边的表，右外连接的驱动表为<code>RIGHT JOIN</code>右边的表。</p></li></ul><h2 id="WHERE与ON"><a href="#WHERE与ON" class="headerlink" title="WHERE与ON"></a>WHERE与ON</h2><p>内连接中的WHERE子句和ON子句是等价的。一般情况下，我们都把只涉及单表的过滤条件放到WHERE子句中，把涉及两表的过滤条件都放到ON子句中，我们也一般把放到ON子句中的过滤条件也称之为<code>连接条件</code>。</p><h2 id="块嵌套循环连接"><a href="#块嵌套循环连接" class="headerlink" title="块嵌套循环连接"></a>块嵌套循环连接</h2><p>普通的连接方式就像双重for循环一样，首先从驱动表中查询获取结果集，然后每一次从结果集中取出一条记录，从磁盘中加载被驱动表到内存进行匹配，我们称之为<strong>嵌套循环连接（Nested-Loop Join）</strong>。在被驱动表特别大的时候，我们的内存甚至可能不足以一次性加载整张表，需要先加载一部分与结果集中的一条记录匹配，接着释放内存，加载另一部分表进行匹配。这个周而复始的加载过程实在是太耗时了，严重影响了MySQL的查询性能，因此MySQL的设计者提出了<strong>基于块的嵌套循环连接（Block Nested-Loop Join）</strong>。</p><p>MySQL的设计者提出了一个<code>join buffer</code>的概念，它是一块执行连接查询前申请的一块固定大小的内存，先把若干条驱动表结果集中的记录装在这个<code>join buffer</code>中，然后开始扫描被驱动表，<strong>每一条被驱动表的记录一次性和<code>join buffer</code>中的多条驱动表结果集记录做匹配</strong>，因为匹配的过程都是在内存中完成的，所以这样可以显著减少被驱动表的<code>I/O</code>代价。</p><p><code>join buffer</code>的大小是可以通过启动参数或者系统变量<code>join_buffer_size</code>进行配置，默认大小为<code>262144字节</code>（也就是<code>256KB</code>），最小可以设置为<code>128字节</code>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;访问方法&quot;&gt;&lt;a href=&quot;#访问方法&quot; class=&quot;headerlink&quot; title=&quot;访问方法&quot;&gt;&lt;/a&gt;访问方法&lt;/h1&gt;&lt;p&gt;访问方法：MySQL执行查询语句的方式。同一个查询语句可能可以使用多种不同的访问方法来执行，但是执行的时间相差甚远，因此查询
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://thmasterplan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL事务</title>
    <link href="http://thmasterplan.cn/uncategorized/MySQL%E4%BA%8B%E5%8A%A1/"/>
    <id>http://thmasterplan.cn/uncategorized/MySQL%E4%BA%8B%E5%8A%A1/</id>
    <published>2021-02-13T03:56:29.000Z</published>
    <updated>2021-02-13T03:56:29.677Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL查询优化</title>
    <link href="http://thmasterplan.cn/uncategorized/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/"/>
    <id>http://thmasterplan.cn/uncategorized/MySQL%E6%9F%A5%E8%AF%A2%E4%BC%98%E5%8C%96/</id>
    <published>2021-02-13T03:56:15.000Z</published>
    <updated>2021-02-13T03:56:15.971Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E7%B4%A2%E5%BC%95/</id>
    <published>2021-01-29T14:48:41.000Z</published>
    <updated>2021-02-13T03:45:54.911Z</updated>
    
    <content type="html"><![CDATA[<h1 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h1><h2 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h2><p>B树是一种多路查找自平衡的树，它的所有叶子节点都位于同一层，即B树是绝对平衡的（就像2-3树一样）。与AVL树不同，B树适用于读写相对大的数据块的存储系统，如磁盘。B树有如下重要特点：</p><ul><li>根结点至少有两个子女。</li><li>所有的叶子结点都位于同一层。</li><li>每个节点中的元素从小到大排列。</li><li>每个节点中都存储有数据。</li></ul><p>B树图解：</p><p><img src="B-tree.png" alt=""></p><p><a href="https://github.com/Laishiji/DataStructureAndAlgorithm/tree/master/DataStructures/src/tree" target="_blank" rel="noopener">AVL树、2-3树、红黑树链接</a></p><h2 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h2><p>在B树的基础上，为叶子结点增加链表指针(B树+叶子有序链表），且非叶子节点不保存数据，只有叶子节点保存数据，非叶子节点中保存的是孩子节点中的临界值（最大值或最小值），因此非叶子节点能存储更多的孩子节点地址信息，B+树相较于B树更加“矮胖”，I/O次数减少。B+树通常用于关系型数据库(如MySQL)和操作系统的文件系统中。</p><p><img src="Bplus-tree.png" alt=""></p><h1 id="InnoDB索引"><a href="#InnoDB索引" class="headerlink" title="InnoDB索引"></a>InnoDB索引</h1><h2 id="聚簇索引"><a href="#聚簇索引" class="headerlink" title="聚簇索引"></a>聚簇索引</h2><p>聚簇索引（Clustered Index）就是按照<strong>主键列</strong>构造一棵B+树，所有完整的用户记录都存放在这个聚簇索引的叶子节点处。聚簇索引并不需要我们在<code>MySQL</code>语句中显式的使用<code>INDEX</code>语句去创建，<code>InnoDB</code>存储引擎会自动的为我们创建。如果用户创建表时没有指定主键，InnoDB会选择表中的<strong>第一个Not NULL Unique Index（非空唯一索引）</strong>作为主键，若这也没有，那么就会添加隐藏列DB_ROW_ID作为主键，这是一个隐式的自增ID。聚簇索引有如下特点：</p><ul><li>页内的记录按照<code>主键列</code>的大小顺序排成一个<strong>单向链表</strong>。</li><li>页之间按照<code>主键列</code>的大小顺序排成一个<strong>双向链表</strong>。</li><li>同一层次的非叶子节点索引页之间根据<code>主键列</code>的大小顺序排成一个<strong>双向链表</strong>。</li><li>叶子节点中存储了所有列的数据。</li></ul><h2 id="二级索引"><a href="#二级索引" class="headerlink" title="二级索引"></a>二级索引</h2><p>以非主键列（下面用<code>c列</code>代替）构建的B+树索引称为二级索引（Secondary Index）。二级索引的特点是：</p><ul><li>页内的记录按照<code>c列</code>的大小顺序排成一个<strong>单向链表</strong>。</li><li>页之间按照<code>c列</code>的大小顺序排成一个<strong>双向链表</strong>。</li><li>同一层次的非叶子节点索引页之间根据<code>c列</code>的大小顺序排成一个<strong>双向链表</strong>。</li><li><strong>叶子节点中存储的并不是完整的记录，而是只存储了<code>c列和主键</code>这两个列的值</strong>。（重要）</li></ul><p>因此where子句的条件中使用二级索引匹配时：先在二级索引中匹配到对应的主键id，再根据主键id<strong>回表</strong>，到聚簇索引中查询其他列的数据，这里也就是用到了2棵B+树；若查询要求返回的列中只有索引列，甚至不需要进行<strong>回表</strong>操作。</p><h2 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h2><p>我们也可以同时以多个列的大小作为排序规则，也就是同时为多个列建立索引，比方说我们想让B+树按照<code>c1</code>和<code>c2</code>列的大小进行排序，这个包含两层含义：</p><ul><li>先把各个记录和页按照<code>c1</code>列进行排序。</li><li>在记录的<code>c1</code>列相同的情况下，采用<code>c2</code>列进行排序。</li></ul><p><code>(c1, c2)</code>就是一个联合索引，其本质上也是一个二级索引，只会建立一棵B+树</p><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ol><li>每当为某个表创建一个<code>B+</code>树索引（聚簇索引不是人为创建的，默认就有）的时候，都会为这个索引创建一个<code>根节点</code>页面。最开始表中没有数据的时候，每个<code>B+</code>树索引对应的<code>根节点</code>中既没有用户记录，也没有目录项记录。随后向表中插入用户记录时，先把用户记录存储到这个<code>根节点</code>中。当<code>根节点</code>中的可用空间用完时继续插入记录，此时会将<code>根节点</code>中的所有记录复制到一个新分配的页，比如<code>页a</code>中，然后对这个新页进行<code>页分裂</code>的操作，得到另一个新页，比如<code>页b</code>。这时新插入的记录根据键值（也就是聚簇索引中的主键值，二级索引中对应的索引列的值）的大小就会被分配到<code>页a</code>或者<code>页b</code>中，而<code>根节点</code>便升级为存储目录项记录的页。</li><li>非叶子节点中目录项记录时唯一的，如果用户创建的二级索引不是唯一索引，那么一个非叶子节点中岂不是可能出现相同的记录？因此对于二级索引，目录项记录是由索引列+主键列构成的，保证了一条记录的唯一性。</li><li>一个页面最少存储2条记录。</li></ol><h1 id="执行SQL时使用到索引的情形"><a href="#执行SQL时使用到索引的情形" class="headerlink" title="执行SQL时使用到索引的情形"></a>执行SQL时使用到索引的情形</h1><p>首先创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> auto_increment,</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone_number <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>),</span><br><span class="line">    <span class="comment">-- 以三个列构建的联合索引</span></span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone_number (<span class="keyword">name</span>, birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>插入数据后简化的B+树如下：</p><p><img src="exampledata.jpg" alt=""></p><p>由图可知，联合索引对应的B+树页面和记录的排序方式为：</p><ul><li>先按照<code>name</code>列的值进行排序。</li><li>如果<code>name</code>列的值相同，则按照<code>birthday</code>列的值进行排序。</li><li>如果<code>birthday</code>列的值也相同，则按照<code>phone_number</code>的值进行排序。</li></ul><p>根据索引以上的性质，可以得出<strong>以下情况MySQL会使用到索引</strong>的结论：</p><h2 id="WHERE子句"><a href="#WHERE子句" class="headerlink" title="WHERE子句"></a>WHERE子句</h2><h3 id="全值匹配"><a href="#全值匹配" class="headerlink" title="全值匹配"></a>全值匹配</h3><p><strong>搜索条件列和索引列一致</strong>，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span></span><br><span class="line"><span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span> </span><br><span class="line"><span class="keyword">AND</span> phone_number = <span class="string">'15123983239'</span>;</span><br></pre></td></tr></table></figure><h3 id="匹配左边的列"><a href="#匹配左边的列" class="headerlink" title="匹配左边的列"></a>匹配左边的列</h3><p><strong>依次匹配定义联合索引时左边的列</strong>，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span>;</span><br></pre></td></tr></table></figure><p>或者：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span></span><br><span class="line"><span class="keyword">AND</span> birthday = <span class="string">'1990-09-27'</span>;</span><br></pre></td></tr></table></figure><p>但是下面这个SQL语句就不会使用到B+树索引：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> birthday = <span class="string">'1990-09-27'</span>;</span><br></pre></td></tr></table></figure><p>以下这个SQL语句只会使用<code>name</code>列的索引，<code>phone_number</code>就只能去遍历了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> </span><br><span class="line"><span class="keyword">AND</span> phone_number = <span class="string">'15123983239'</span>;</span><br></pre></td></tr></table></figure><h3 id="最左匹配"><a href="#最左匹配" class="headerlink" title="最左匹配"></a>最左匹配</h3><p><strong>匹配列的前缀</strong>，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'As%'</span>;</span><br></pre></td></tr></table></figure><p>这是因为默认的字符串匹配规则就是从左开始依次匹配的，下面这个SQL语句就无法使用索引了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> <span class="keyword">LIKE</span> <span class="string">'%As%'</span>;</span><br></pre></td></tr></table></figure><h3 id="匹配索引的范围值"><a href="#匹配索引的范围值" class="headerlink" title="匹配索引的范围值"></a>匹配索引的范围值</h3><p>比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> <span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span>;</span><br></pre></td></tr></table></figure><p>由于B+树中的记录和页都是由链表串连起来的，因此范围匹配实际上就是找到区间的端点，然后取出中间所有的结果，那么上面这个SQL语句执行时就是找到<code>name=&#39;Asa&#39;</code>和<code>name=&#39;Barlow&#39;</code>这两个区间端点了，因此依然会使用到索引。</p><p>以下这个SQL语句会使用到<code>name</code>列和<code>birthday</code>列索引，原理不再赘述：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> </span><br><span class="line"><span class="keyword">AND</span> birthday &gt; <span class="string">'1980-01-01'</span> </span><br><span class="line"><span class="keyword">AND</span> birthday &lt; <span class="string">'2000-12-31'</span> </span><br><span class="line"><span class="keyword">AND</span> phone_number &gt; <span class="string">'15100000000'</span>;</span><br></pre></td></tr></table></figure><h2 id="ORDER-BY子句"><a href="#ORDER-BY子句" class="headerlink" title="ORDER BY子句"></a>ORDER BY子句</h2><p>一般情况下我们使用ORDER BY子句对查询结果排序都是MySQL在内存中使用排序算法完成的，而如果我们的<strong>ORDER BY子句条件和和索引列一致</strong>的话，就不需要进行耗时的排序操作了，因为B+树在构建索引时就为我们排好序了，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>, birthday, phone_number <span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>注意，<strong>ORDER BY子句给出条件的顺序必须与定义索引时的顺序一致</strong>，这一点与WHERE子句的全值匹配是不一样的（查询优化器会对WHERE子句的条件进行优化）。以下这个SQL语句也是不需要在内存中排序的，原理不再赘述：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">'Ashburn'</span> </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> birthday, phone_number </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>以下情况是无法使用索引进行排序的：</p><p><strong>ASC/DES混用</strong></p><p>对于使用联合索引进行排序的场景，我们要求各个排序列的排序顺序是一致的，也就是要么各个列都是<code>ASC</code>规则排序，要么都是<code>DESC</code>规则排序。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>, birthday </span><br><span class="line"><span class="keyword">DESC</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>上面这个SQL语句就无法使用索引排序。</p><p><strong>排序列包含一个非索引列</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span>, country </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p><strong>排序列不是单独的索引列</strong></p><p>要想使用索引进行排序操作，必须保证索引列是以单独列的形式出现，而不是修饰过的形式。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">UPPER</span>(<span class="keyword">name</span>) </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><h2 id="GROUP-BY子句"><a href="#GROUP-BY子句" class="headerlink" title="GROUP BY子句"></a>GROUP BY子句</h2><p>分组使用到索引的情况与排序类似，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone_number, <span class="keyword">COUNT</span>(*) </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> <span class="keyword">name</span>, birthday, phone_number;</span><br></pre></td></tr></table></figure><h1 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h1><p>由于二级索引中只存储了索引列和主键列，那么如果查询列中如果有非索引列，MySQL就需要<code>回表</code>进行查询，即到聚簇索引中查询完整的数据。</p><p>二级索引中的记录是连续的，从中读取记录我们称为<code>顺序I/O</code>。但是从二级索引中读取出的记录的主键值，几乎可以肯定一定是离散的（见上图），那么我们回表就是去聚簇索引中根据离散分布的主键值查询一堆离散分布记录，这个称为<code>随机I/O</code>。</p><p>如果需要回表的记录非常多，这个代价还是很大的，还不如直接全表扫描聚簇索引来的快呢。因此使用二级索引查询时我们应该查询尽量少的数据，或者使用<code>LIMIT</code>限制查询数量。</p><p>那么如果我们的<strong>查询列中只有索引列</strong>，就不需要回表了呗，即所谓的覆盖索引。比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span>, birthday, phone_number </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">WHERE</span> <span class="keyword">name</span> &gt; <span class="string">'Asa'</span> </span><br><span class="line"><span class="keyword">AND</span> <span class="keyword">name</span> &lt; <span class="string">'Barlow'</span>;</span><br></pre></td></tr></table></figure><h1 id="索引注意事项"><a href="#索引注意事项" class="headerlink" title="索引注意事项"></a>索引注意事项</h1><ol><li><p><strong>只为用于搜索、排序或分组的列创建索引</strong>：即只为出现在<code>WHERE</code>子句中的列、连接子句中的连接列，或者出现在<code>ORDER BY</code>或<code>GROUP BY</code>子句中的列创建索引。</p></li><li><p><strong>只为基数大的列创建索引</strong>。列的基数：某一列中不重复数据的个数。比如某一列有大量重复数据，那么二级索引回表的代价就太大了。</p></li><li><p><strong>索引列的数据类型占用的字节数尽量小</strong>：比如我们能使用<code>INT</code>就不要使用<code>BIGINT</code>，能使用<code>MEDIUMINT</code>就不要使用<code>INT</code>。因为：</p><ol><li>数据类型越小，CPU的比较操作越快。</li><li>数据类型越小，在一个数据页内就可以放下更多的记录，从而减少磁盘<code>I/O</code>带来的性能损耗，也就意味着可以把更多的数据页缓存在内存中，从而加快读写效率。</li></ol></li><li><p><strong>只对字符串的前缀建立索引</strong>：如果索引需要把完整的字符串存储起来，那么既会浪费存储空间，查询时匹配也会耗时许多。因此我们可以只对字符串的前几个字符建立索引，比如：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> person_info(</span><br><span class="line">    <span class="keyword">name</span> <span class="built_in">VARCHAR</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    birthday <span class="built_in">DATE</span> <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    phone_number <span class="built_in">CHAR</span>(<span class="number">11</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    country <span class="built_in">varchar</span>(<span class="number">100</span>) <span class="keyword">NOT</span> <span class="literal">NULL</span>,</span><br><span class="line">    <span class="comment">-- 只需要在列后面写上保留的字符个数就行了</span></span><br><span class="line">    <span class="keyword">KEY</span> idx_name_birthday_phone_number (<span class="keyword">name</span>(<span class="number">10</span>), birthday, phone_number)</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>使用这种方式建立索引的缺点是，由于索引存储的不是完整的字符串，就无法使用索引进行排序，比如下面这个SQL语句就需要在内存中利用排序算法排序了：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * </span><br><span class="line"><span class="keyword">FROM</span> person_info </span><br><span class="line"><span class="keyword">ORDER</span> <span class="keyword">BY</span> <span class="keyword">name</span> </span><br><span class="line"><span class="keyword">LIMIT</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用索引时索引列不应被修饰</strong>：比如对索引列使用计算表达式或函数，MySQL都是无法使用索引查询的。</p></li><li><p><strong>使用隐式主键或显式指定自增非空id</strong>：如果使用其他主键，比如手机号身份证号等等，那么会有一个问题——主键的插入顺序是随机的。而我们的B+树构建过程中主键是递增的，若插入主键是随机的，那么就会有大量的<strong>页面分裂</strong>和<strong>记录移位</strong>，这个性能开销是非常大的。</p></li><li><p><strong>尽量使用覆盖索引，避免回表</strong>。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;B树与B-树&quot;&gt;&lt;a href=&quot;#B树与B-树&quot; class=&quot;headerlink&quot; title=&quot;B树与B+树&quot;&gt;&lt;/a&gt;B树与B+树&lt;/h1&gt;&lt;h2 id=&quot;B树&quot;&gt;&lt;a href=&quot;#B树&quot; class=&quot;headerlink&quot; title=&quot;B树&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://thmasterplan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>InnoDB表结构</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL_InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL_InnoDB%E8%A1%A8%E7%BB%93%E6%9E%84/</id>
    <published>2021-01-28T14:31:36.000Z</published>
    <updated>2021-02-13T03:42:02.651Z</updated>
    
    <content type="html"><![CDATA[<h1 id="字符集"><a href="#字符集" class="headerlink" title="字符集"></a>字符集</h1><p>计算机中只能存储二进制数据，因此字符串的存储需要<strong>编码</strong>与<strong>解码</strong>。将一个字符映射成二进制数据的过程叫<strong>编码</strong>，将二进制数据映射到一个字符的过程叫做<strong>解码</strong>。人们抽象出一个<strong>字符集</strong>的概念来描述某个字符范围的编码规则。常用的字符集有：</p><ul><li><strong>ASCII</strong>：共收录128个字符，包括空格、标点符号、数字、大小写字母和一些不可见字符。<strong>1个字符</strong>使用<strong>1Byte</strong>编码。</li><li><strong>ISO 8859-1</strong>：别名<strong>latin1</strong>，共收录256个字符，是在<strong>ASCII</strong>字符集的基础上又扩充了128个西欧常用字符。<strong>1个字符</strong>使用<strong>1Byte</strong>编码。</li><li><strong>GB2312</strong>：收录了汉字以及拉丁字母、希腊字母、日文平假名及片假名字母、俄语西里尔字母。其中收录汉字6763个，其他文字符号682个，兼容<strong>ASCII</strong>字符集。属于<strong>变长编码方式</strong>，<strong>ASCII</strong>字符采用<strong>1Byte</strong>编码，其他则采用<strong>2Byte</strong>编码。</li><li><strong>GBK</strong>：在收录字符范围上对<code>GB2312</code>字符集作了扩充。也是<strong>变长编码方式</strong>。</li><li><strong>utf8</strong>：即万国码，收录地球上所有字符，包括表情符号，且在不断扩充。兼容<strong>ASCII</strong>，采用<strong>变长编码方式</strong>。编码一个字符需要使用<strong>1~4Byte</strong>。</li></ul><p>MySQL中的<strong>utf8</strong>指的是<strong>utf8mb3</strong>，属于阉割过的<strong>utf8</strong>字符集，使用<strong>1~3Byte</strong>编码。若要可编码表情符号，需要使用<strong>utf8mb4</strong>。可使用</p><p><code>SHOW CHARSET</code>查看MySQL支持的字符集，<code>SHOW COLLATION</code>查看字符的比较规则。</p><h1 id="InnoDB表结构"><a href="#InnoDB表结构" class="headerlink" title="InnoDB表结构"></a>InnoDB表结构</h1><h2 id="行记录结构"><a href="#行记录结构" class="headerlink" title="行记录结构"></a>行记录结构</h2><p>数据页就是B+树的一个节点，它是磁盘和内存间交互的基本单位，一页的大小一般为16KB。一个数据页节点中可存储多条行记录，行记录又分为4种格式：<code>Compact</code>、<code>Redundant</code>、<code>Dynamic</code>和<code>Compressed</code>。</p><h3 id="Compact行格式"><a href="#Compact行格式" class="headerlink" title="Compact行格式"></a>Compact行格式</h3><p>这种行格式下，一条记录可分为如下几部分：</p><p><img src="compact.png" alt=""></p><ul><li><p><strong>变长字段长度列表</strong>：逆序存储当前记录中<strong>变长数据类型</strong>实际占用的Byte数，如<code>VARCHAR(M)</code>、<code>VARBINARY(M)</code>、各种<code>TEXT</code>类型和各种<code>BLOB</code>类型，以及采用<strong>变长编码方式</strong>字符集时的<code>CHAR</code>类型。</p></li><li><p><strong>NULL值列表</strong>：使用一个二进制位逆序存储当前记录中某列的NULL值，为NULL则置1，否则为0。</p></li><li><p><strong>记录头信息</strong>：由5个固定Byte组成，这40个bit的详细信息如下表：</p></li></ul><div class="table-container"><table><thead><tr><th>名称</th><th>大小（单位：bit）</th><th>描述</th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td><strong>delete_mask</strong></td><td>1</td><td>标记该记录是否被删除。1表示记录被删除，实际上记录依旧存储在磁盘上，之所以不立即删除该记录是因为删除后需要把其他记录在磁盘上重新排列，可能会涉及B+树的自平衡操作，需要性能消耗。被1标记的记录会组成一个<code>垃圾链表</code>，这些空间属于<code>可重用空间</code>，之后若插入新记录，可直接原地覆盖，若重新插入相同记录，则只需要把该标记位置0即可。</td></tr><tr><td><strong>min_rec_mask</strong></td><td>1</td><td>B+树的每层非叶子节点中的最小记录都会添加该标记。</td></tr><tr><td><strong>n_owned</strong></td><td>4</td><td>表示当前记录拥有的记录数。</td></tr><tr><td><strong>heap_no</strong></td><td>13</td><td>表示当前记录在记录堆的位置信息。</td></tr><tr><td><strong>record_type</strong></td><td>3</td><td>表示当前记录的类型，<code>0</code>表示叶子节点记录（数据页），<code>1</code>表示B+树非叶子节点记录，<code>2</code>表示最小记录，<code>3</code>表示最大记录。</td></tr><tr><td><strong>next_record</strong></td><td>16</td><td>表示下一条记录的相对位置。注意，下一条记录指得并不是按照我们插入顺序的下一条记录，而是按照主键值由小到大的顺序的下一条记录。而且规定 Infimum记录（也就是最小记录） 的下一条记录就是本页中主键值最小的用户记录，而本页中主键值最大的用户记录的下一条记录就是Supremum记录（也就是最大记录）。因此一页中的记录是一个按主键值升序的单链表，where子句使用主键匹配时可使用二分查找定位记录。</td></tr></tbody></table></div><ul><li><strong>记录的真实数据</strong>：除了用户在表中显式定义的列，InnoDB还会添加如下三个隐藏列：</li></ul><div class="table-container"><table><thead><tr><th>列名</th><th>是否必须</th><th>占用空间</th><th>描述</th></tr></thead><tbody><tr><td>DB_ROW_ID</td><td>否</td><td>6Byte</td><td>行ID，唯一标识一条记录</td></tr><tr><td>DB_TRX_ID</td><td>是</td><td>6Byte</td><td>事务ID</td></tr><tr><td>DB_ROLL_PTR</td><td>是</td><td>7Byte</td><td>回滚指针</td></tr></tbody></table></div><p>  InnoDB的表都是根据主键顺序组织存放的，而聚簇索引就是按照主键构造一棵B+树。如果用户创建表时没有指定主键，InnoDB会选择表中的<strong>第一个Not NULL Unique Index（非空唯一索引）</strong>作为主键，若这也没有，那么就会添加隐藏列DB_ROW_ID作为主键，这是一个隐式的自增ID。</p><h3 id="行溢出数据"><a href="#行溢出数据" class="headerlink" title="行溢出数据"></a>行溢出数据</h3><p>一行记录<strong>除去隐藏列和记录头信息</strong>，最多占用的Byte长度加起来不能超过65525。但是一个数据页只有16KB，因此对于占用存储空间非常大的列（VARCHAR/TEXT/BLOB等类型），在<strong>记录的真实数据</strong>处只会存储该列的一部分数据，把剩余的数据分散存储在几个其他的页中，然后<strong>记录的真实数据</strong>处用20个Byte存储指向这些页的地址，如图所示：</p><p><img src="row_overflow.png" alt=""></p><h3 id="其余行格式"><a href="#其余行格式" class="headerlink" title="其余行格式"></a>其余行格式</h3><p>Redundant行格式是MySQL5.0之前使用的一种行格式，而<strong>MySQL8.0默认使用的行格式为Dynamic</strong>。Dynamic和Compressed行格式与Compact行格式相似，但是在行溢出数据处理时不同，它们不会在记录的真实数据处存储字段真实数据的前<code>768</code>个Byte，而是把所有的数据都存储到其他页面中。而Compressed和Dynamic不同的一点是，Compressed行格式会采用压缩算法对页面进行压缩，以节省空间。</p><p><a href="https://dev.mysql.com/doc/refman/8.0/en/innodb-row-format.html#innodb-row-format-compact" target="_blank" rel="noopener">行格式具体区别参考官方文档</a></p><h2 id="数据页结构"><a href="#数据页结构" class="headerlink" title="数据页结构"></a>数据页结构</h2><p>一个16KB的数据页节点可划分为如下几部分：</p><p><img src="index_page.png" alt=""></p><p>用户存入的记录都在<strong>User Records</strong>部分，每插入一条记录<strong>User Records</strong>部分增大，相应的<strong>Free Space</strong>减少 。<strong>Infimum + Supremum</strong>存储当前页InnoDB自动添加的最小记录和最大记录，这里的最大和最小是指的是主键。</p><ul><li><p><strong>Page Directory</strong>：InnoDB会把一页中的记录划分为若干个组，每个组的最后一个记录的地址偏移量作为一个<strong>槽</strong>(Slot)，存放在<strong>Page Directory</strong>中，所以在一个页中根据主键查找记录是非常快的，分为两步：</p><ul><li>通过二分法确定该记录所在的槽。</li><li>通过记录的next_record属性遍历该槽所在的组中的各个记录。</li></ul></li><li><p><strong>Page Header</strong>：存储当前页记录的状态信息。</p></li><li><strong>File Header</strong>：不同类型的页都会以<strong>File Header</strong>作为第一个组成部分，它描述了一些针对各种页都通用的一些信息，如校验和、上一页的页号和下一页的页号（由此可知，B+树每一层的所有节点连接成一个双向链表）、页面类型、当前页页号、LSN值(Log Sequence Number)等。</li><li><strong>File Trailer</strong>：为了避免数据页同步过程中断电导致页没有同步完毕的情况，使用该部分进行校验页是否完整。前4个Byte代表页的校验和，后4个Byte代表页面最后修改时对应的日志序列位置（LSN）。若不匹配File Header中的校验和和LSN值说明数据页同步出错。</li></ul><h2 id="表空间"><a href="#表空间" class="headerlink" title="表空间"></a>表空间</h2><p>InnoDB的表空间由段（segment）、区（extent）、页（page）组成，其逻辑存储结构如下图所示：</p><p><img src="innodb_logic_storage_structure.png" alt=""></p><p>表空间可以看作InnoDB存储引擎结构的最高层，即存储引擎基于表。默认情况下InnoDB存储引擎有一个<strong>共享表空间ibdata1</strong>，这张表中存放了回滚（undo）信息、插入缓冲索引页、系统事务信息和二次写缓冲信息等系统信息，再MySQL8.0之后，用户创建表后则会创建一个<strong>独立表空间</strong>，存放数据、索引和插入缓冲Bitmap页。</p><ul><li><strong>段</strong>：由上图可知，常见的段有数据段（B+树叶子节点段）、索引段（B+树非叶子节点段）和回滚段等。对段的管理是由引擎自身完成的，DBA不能对其控制。</li><li><strong>区</strong>：任何情况下一个区都占用<strong>1MB</strong>，默认一个区由64个连续的页组成，一页占16KB。创建的表默认大小是96KB，那创建的表的大小至少是1MB才对啊？其实这是因为在每个段开始时，先有32个页大小的碎片页（fragment page）来存放数据，当这些页使用完之后才是64个连续页的申请。如果存放一条记录就开辟1MB的空间，岂不是很浪费？</li><li><strong>页</strong>：页是InnoDB磁盘管理的最小单位。默认每个页大小为16KB，可通过参数<code>innodb_page_size</code>修改。注意区的大小依旧是1MB，一个区的页的数量会产生变化。常见的页类型有：<ol><li>数据页（B-tree Node）。</li><li>Undo页（Undo Log Page）。</li><li>系统页（System Page）。</li><li>事务数据页（Transaction system Page）。</li><li>插入缓冲位图页（Insert Buffer Bitmap）。</li><li>插入缓冲空闲列表页（Insert Buffer Free List）。</li><li>未压缩的二进制大对象页（Uncompressed BLOB Page）。</li><li>压缩的二进制大对象页（Compressed BLOB Page）。</li></ol></li></ul><h1 id="MySQL存储目录"><a href="#MySQL存储目录" class="headerlink" title="MySQL存储目录"></a>MySQL存储目录</h1><p>使用<code>SHOW VARIABLES LIKE &#39;datadir&#39;;</code>查看数据库、表文件、视图、触发器等的存储目录。下面依次介绍它们在文件系统中的表示：</p><h2 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h2><p>每当我们使用<code>CREATE DATABASE 数据库名;</code>语句创建一个数据库的时候，文件系统中MySQL存储目录下就会创建一个以数据库名为文件名的子目录，并在该子目录下创建一个名为<code>db.opt</code>的文件，该文件包含了该数据库的各种属性，比如该数据库的字符集和比较规则。</p><h2 id="表"><a href="#表" class="headerlink" title="表"></a>表</h2><p>表的信息可以分为两种：表结构的定义信息；表中的数据。</p><p>对于InnoDB，每创建一个表都会建立一个<strong>独立表空间</strong>，这个表示独立表空间的文件就是<code>表名.ibd</code>，在MySQL8.0之后，表结构定义信息和表中的数据（索引）都存储在该文件中。</p><p>对于MyISAM，其表结构信息存储在<code>表名.frm</code>这个二进制文件中，而且不像InnoDB的索引即数据，MyISAM中的索引全是二级索引（辅助索引），因此MyISAM的索引和数据是分开存放的。其中<code>表名.MYD</code>代表数据文件，<code>表名.MYI</code>代表索引文件</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图其实是虚拟的表，所以在存储视图的时候是不需要存储真实的数据的，只需要把它的结构存储起来就行了。和表一样，描述视图结构的文件也会被存储到所属数据库对应的子目录下边，只会存储一个<code>视图名.frm</code>的文件。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;字符集&quot;&gt;&lt;a href=&quot;#字符集&quot; class=&quot;headerlink&quot; title=&quot;字符集&quot;&gt;&lt;/a&gt;字符集&lt;/h1&gt;&lt;p&gt;计算机中只能存储二进制数据，因此字符串的存储需要&lt;strong&gt;编码&lt;/strong&gt;与&lt;strong&gt;解码&lt;/strong&gt;。将一
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://thmasterplan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Spring原理</title>
    <link href="http://thmasterplan.cn/JavaWeb/Spring%E5%8E%9F%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/Spring%E5%8E%9F%E7%90%86/</id>
    <published>2021-01-21T06:33:27.000Z</published>
    <updated>2021-01-22T13:57:35.012Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring重要模块"><a href="#Spring重要模块" class="headerlink" title="Spring重要模块"></a>Spring重要模块</h1><p><img src="Spring主要模块.png" alt=""></p><ul><li><strong>Spring Test</strong> : 提供了对 JUnit 和 TestNG 测试的支持。</li><li><strong>Spring Beans</strong>：包含访问配置文件，创建和管理Bean（BeanFactory），依赖注入相关的类。</li><li><strong>Spring Core：</strong> 定义并提供资源定位方式，基本核心工具类，其他组件都会使用该模块。</li><li><strong>Spring Context</strong>：IoC容器实现，构建于Beans和Core模块之上。</li><li><strong>Spring AOP</strong> ：提供了面向切面的方法级别的编程实现，最小化的动态代理实现。运行时织入。</li><li><strong>Spring Aspects</strong> ： 该模块为与AspectJ的集成提供支持。编译期织入。</li></ul><h1 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a>Inversion of Control</h1><h2 id="IoC图解"><a href="#IoC图解" class="headerlink" title="IoC图解"></a>IoC图解</h2><p><img src="IoC_Graph.png" alt=""></p><h2 id="Spring核心类和接口"><a href="#Spring核心类和接口" class="headerlink" title="Spring核心类和接口"></a>Spring核心类和接口</h2><h3 id="BeanDefinition接口"><a href="#BeanDefinition接口" class="headerlink" title="BeanDefinition接口"></a>BeanDefinition接口</h3><p>Spring通过定义<code>BeanDefinition</code>接口来管理bean对象以及它们之间的依赖关系。</p><p>根据配置，Spring运行时生成用来描述Bean对象的<code>BeanDefinition</code>实现类对象，在<code>BeanDefinition</code>的抽象实现类<code>AbstractBeanDefinition</code>中定义了许多属性，常用属性配置有：</p><ul><li><strong>作用范围</strong>：XML配置方式scope，注解方式@Scope。</li><li><strong>是否懒加载</strong>：XML配置方式lazy-init，注解方式@Lazy。</li><li><strong>是否优先实现</strong>：XML配置方式primary，注解方式@Primary。设置为true的bean会是优先的实现类。</li><li><strong>工厂Bean</strong>：XML配置方式factory-bean和factory-method，注解方式则需要工厂类实现FactoryBean接口并结合@Bean注解。</li></ul><p>Spring2.5后源码中常用的实现类为<code>GenericBeanDefinition</code>，取代之前的<code>RootBeanDefinition</code>和<code>ChildBeanDefinition</code>。</p><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><p>Spring的IoC容器接口设计图如下：</p><p><img src="container.png" alt=""></p><p>由图可知，Spring主要有以下两个<strong>容器系列</strong>：</p><ol><li>实现<code>BeanFactory</code>接口的简单容器系列，它们只实现了容器的最基本功能。如下：<code>BeanFactory</code> =&gt; <code>HierarchicalBeanFactory</code> =&gt; <code>ConfigurableBeanFactory</code></li><li><code>ApplicationContext</code>应用上下文，它作为容器的高级形态而存在，它通过继承以下接口实现了附加功能：<ol><li><code>MessageSource</code>：信息源。可以支持国际化的实现，为开发多语言版本的应用提供服务。</li><li><code>ResourceLoader</code>（新版本Spring为<code>ResourcePatternResolver</code>）：资源定位加载器，用于加载配置文件。若不继承该接口，用户需要像使用<code>BeanFactory</code>那样手动加载。</li><li><code>ApplicationEventPublisher</code>：应用事件。</li></ol></li></ol><h4 id="BeanFacory与FactoryBean"><a href="#BeanFacory与FactoryBean" class="headerlink" title="BeanFacory与FactoryBean"></a>BeanFacory与FactoryBean</h4><p><code>FactoryBean</code>接口的实现类对象是一个由IoC容器管理的Bean对象，只不过它是一个可以生成对象的工厂Bean。而<code>BeanFactory</code>是Spring中最基本的IoC容器，在该接口中定义了一个静态常量：转义符<code>&amp;</code>，可以使用getBean(“&amp;XXXFactoryBean”)获取<code>XXXFactoryBean</code>本身，而若是调用getBean(“XXXFactoryBean”)其返回的是工厂Bean生产的对象。</p><h4 id="DefaultListableBeanFactory"><a href="#DefaultListableBeanFactory" class="headerlink" title="DefaultListableBeanFactory"></a>DefaultListableBeanFactory</h4><p>该类是一个<strong>简单IoC容器实现类，其他的容器都是通过持有一个该容器的实例并在此基础上扩展功能实现</strong>，如<code>XmlBeanFactory</code>，以及<code>ApplicationContext</code>的诸多<strong>实现类</strong>。</p><p><code>DefaultListableBeanFactory</code>扩展了<code>AbstractAutowireCapableBeanFactory</code>，并实现了<code>ConfigurableListableBeanFactory</code>和<code>BeanDefinitionRegistry</code>接口，它维护了一个<code>ConcurrentHashMap</code>实例beanDefinitionMap，这就是容器的存储结构，另外<code>BeanDefinitionRegistry</code>接口的实现就是用于向容器中注册<code>BeanDefinition</code>的。</p><h4 id="AbstractApplicationContext"><a href="#AbstractApplicationContext" class="headerlink" title="AbstractApplicationContext"></a>AbstractApplicationContext</h4><p>这是一个重要的抽象类，它实现了<code>ConfigurableApplicationContext</code>，实现了一些方法，并定义了许多应用上下文的模板方法，如publishEvent、registerListeners和<strong>refresh</strong>方法等。同时该类继承了<code>DefaultResourceLoader</code>类，实现了资源路径的获取。</p><h3 id="Resource-ResourceLoader"><a href="#Resource-ResourceLoader" class="headerlink" title="Resource/ResourceLoader"></a>Resource/ResourceLoader</h3><p><code>Resource</code>接口是Spring用来封装I/O操作的类，它是一个资源描述器，在容器创建时给出Bean定义信息的路径，如文件，类路径等。而<code>ResourceLoader</code>实现不同的<code>Resource</code>加载策略，接口中定义了一个getResource方法，按需返回特定类型的<code>Resource</code>。</p><h3 id="BeanDefinitionReader"><a href="#BeanDefinitionReader" class="headerlink" title="BeanDefinitionReader"></a>BeanDefinitionReader</h3><p>该接口中定义了一系列用于读取<code>BeanDefinition</code>的重载方法loadBeanDefinitions，Spring就是在该方法中使用<code>ResourceLoader</code>读取bean的定义信息。该接口还定义了一个重要方法getRegistry，其返回一个<code>BeanDefinitionRegistry</code>，该接口中定义了方法<strong>registerBeanDefinition</strong>，用于注册<code>BeanDefinition</code>到IoC容器中。由此可总结，<code>BeanDefinition</code>的注册可分为如下三个过程：</p><ol><li><code>Resource</code>定位：Bean配置信息的资源定位。</li><li><code>BeanDefinition</code>的载入和解析：把用户定义好的Bean信息抽象为<code>BeanDefinition</code>。</li><li><code>BeanDefinition</code>注册到IoC容器。</li></ol><h3 id="PostProcessor"><a href="#PostProcessor" class="headerlink" title="PostProcessor"></a>PostProcessor</h3><p>后置处理器本身也是一种需要注册到容器里的Bean对象：</p><ul><li>其里面的<strong>方法会在特定的时机被容器调用</strong>；</li><li>其作用是在不改变容器或Bean核心逻辑的情况下<strong>对Bean进行增强</strong>。</li></ul><p>Spring中有如下的后置处理器：</p><ul><li>容器级别：<code>BeanDefinitionRegistryPostProcessor</code>和<code>BeanFactoryPostProcessor</code>。</li><li>普通的Bean后置处理器：<code>BeanPostProcessor</code>。<strong>该接口的两个方法分别在每个普通Bean初始化前后被调用</strong>。</li></ul><h3 id="Aware子接口"><a href="#Aware子接口" class="headerlink" title="Aware子接口"></a>Aware子接口</h3><p>所有的 Bean 对 Spring 容器的存在是没有感知的，但是在实际项目中，我们不可避免的要用到 Spring 容器本身提供的资源，这时候要让 Bean 主动意识到 Spring 容器的存在，才能调用 Spring 所提供的资源，这就是<code>Aware</code>的作用。不过<code>Aware</code>只在框架内部使用，若在Bean中使用，那么就紧耦合了。常见的<code>Aware</code>如下：</p><div class="table-container"><table><thead><tr><th>Aware子接口</th><th>描述</th></tr></thead><tbody><tr><td>BeanNameAware</td><td>获取容器中 Bean 的名称</td></tr><tr><td>BeanFactoryAware</td><td>获取当前 BeanFactory ，这样可以调用容器的服务</td></tr><tr><td>ApplicationContextAware</td><td>同上。</td></tr><tr><td>MessageSourceAware</td><td>获取 Message Source 相关文本信息。</td></tr><tr><td>ApplicationEventPublisherAware</td><td>使Bean可以发布事件。</td></tr><tr><td>ResourceLoaderAware</td><td>获取资源加载器，这样获取外部资源文件。</td></tr></tbody></table></div><h3 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h3><p>监听器将监听感兴趣的事件，一旦事件发生便做出响应。Spring的事件驱动模型三大组成部分如下：</p><ul><li>事件：<code>ApplicationEvent</code>抽象类。</li><li>事件监听器：<code>ApplicationListener</code>接口。</li><li>事件发布器：<code>ApplicationEventPublisher</code>和<code>ApplicationEventMulticaster</code>接口。发布与广播。</li></ul><h2 id="容器的初始化"><a href="#容器的初始化" class="headerlink" title="容器的初始化"></a>容器的初始化</h2><h3 id="refresh方法"><a href="#refresh方法" class="headerlink" title="refresh方法"></a>refresh方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">refresh</span><span class="params">()</span> <span class="keyword">throws</span> BeansException, IllegalStateException </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="keyword">this</span>.startupShutdownMonitor) &#123;</span><br><span class="line">StartupStep contextRefresh = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.refresh"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 1.准备工作，记录下容器的启动时间、标记“已启动”状态、处理配置文件中的占位符</span></span><br><span class="line">prepareRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获得ApplicationContext的子类BeanFactory。步骤如下：</span></span><br><span class="line">            <span class="comment">//2.1.如果已经有了BeanFactory就销毁它里面的单例Bean并关闭这个BeanFactory。</span></span><br><span class="line">            <span class="comment">//2.2.创建一个新的BeanFactory。</span></span><br><span class="line">            <span class="comment">//2.3.对这个BeanFactory进行定制（customize),如allowBeanDefinitionOverriding等参数</span></span><br><span class="line">            <span class="comment">//2.4.转载BeanDefinitions(读取配置文件，将xml转换成对应得BeanDefinition)</span></span><br><span class="line">            <span class="comment">//2.5.检查是否同时启动了两个BeanFactory。 </span></span><br><span class="line">ConfigurableListableBeanFactory beanFactory = obtainFreshBeanFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3.为容器注册必要的系统级的Bean</span></span><br><span class="line">prepareBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line"><span class="comment">// 4.允许容器的子类去注册后置处理器</span></span><br><span class="line">postProcessBeanFactory(beanFactory);</span><br><span class="line"></span><br><span class="line">StartupStep beanPostProcess = <span class="keyword">this</span>.applicationStartup.start(<span class="string">"spring.context.beans.post-process"</span>);</span><br><span class="line"><span class="comment">// 5.调用容器级的后置处理器</span></span><br><span class="line">invokeBeanFactoryPostProcessors(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 6.向容器注册bean级别的后置处理器</span></span><br><span class="line">registerBeanPostProcessors(beanFactory);</span><br><span class="line">beanPostProcess.end();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 7.初始化国际化配置</span></span><br><span class="line">initMessageSource();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 8.初始化事件发布器</span></span><br><span class="line">initApplicationEventMulticaster();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 9.单例bean初始化之前预留给子类初始化其他特殊bean的模板方法</span></span><br><span class="line">onRefresh();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 10.向事件发布器注册事件监听器</span></span><br><span class="line">registerListeners();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 11.设置系统级别的服务，初始化所有非懒加载的单例bean</span></span><br><span class="line">finishBeanFactoryInitialization(beanFactory);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 12.触发初始化完成的回调方法，并发布容器刷新完成的事件给监听器</span></span><br><span class="line">finishRefresh();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">catch</span> (BeansException ex) &#123;</span><br><span class="line"><span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">logger.warn(<span class="string">"Exception encountered during context initialization - "</span> +</span><br><span class="line"><span class="string">"cancelling refresh attempt: "</span> + ex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Destroy already created singletons to avoid dangling resources.</span></span><br><span class="line">destroyBeans();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Reset 'active' flag.</span></span><br><span class="line">cancelRefresh(ex);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Propagate exception to caller.</span></span><br><span class="line"><span class="keyword">throw</span> ex;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">finally</span> &#123;</span><br><span class="line"><span class="comment">// 重置Spring内核中的共用缓存</span></span><br><span class="line">resetCommonCaches();</span><br><span class="line">contextRefresh.end();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="容器初始化总结"><a href="#容器初始化总结" class="headerlink" title="容器初始化总结"></a>容器初始化总结</h3><ol><li><strong>刷新容器</strong>，并<strong>注册系统级的Bean</strong>，如系统环境Bean。</li><li>注册并调用<strong>系统级的后置处理器</strong>，注册<strong>普通Bean的后置处理器</strong>。</li><li>初始化国际化配置、事件发布器、注册事件监听器。</li><li><strong>初始化特殊的bean和所有非懒加载的单例bean</strong>。</li><li>清除资源缓存，初始化生命周期处理器，发布最终事件。</li></ol><h2 id="Bean的创建（生命周期）"><a href="#Bean的创建（生命周期）" class="headerlink" title="Bean的创建（生命周期）"></a>Bean的创建（生命周期）</h2><p>如图所示：</p><p><img src="bean_lifecycle.png" alt=""></p><p>单例Bean的生命周期如上图所示。而多例Bean是不会由容器管理的，多例Bean只能由GC回收，因此其定义的销毁方法不会被容器调用。</p><h3 id="如何解决循环依赖？"><a href="#如何解决循环依赖？" class="headerlink" title="如何解决循环依赖？"></a>如何解决循环依赖？</h3><ol><li><p>方法调用栈：refresh -&gt; finishBeanFactoryInitialization -&gt; preInstantiateSingletons -&gt; <strong>getBean</strong> -&gt; <strong>doGetBean</strong>。</p></li><li><p><code>AbstractBeanFactory</code>：<strong>doGetBean</strong>方法中</p><p>a. 第一处<strong>getSingleton</strong>：尝试从三级缓存中获取Bean对象。-&gt; <code>DefaultSingletonRegistry</code>：<strong>getSingleton</strong>方法源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">getSingleton</span><span class="params">(String beanName, <span class="keyword">boolean</span> allowEarlyReference)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 尝试从一级缓存singletonObjects从获取Bean</span></span><br><span class="line">    Object singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">    <span class="comment">// 如果一级缓存中没有并且Bean正在创建中</span></span><br><span class="line">    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; isSingletonCurrentlyInCreation(beanName)) &#123;</span><br><span class="line">        <span class="comment">//尝试从二级缓存earlySingletonObjects获取还未进行属性赋值的Bean</span></span><br><span class="line">        singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">        <span class="comment">//如果二级缓存中也没有，且Bean允许被循环引用</span></span><br><span class="line">        <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span> &amp;&amp; allowEarlyReference) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>.singletonObjects) &#123;</span><br><span class="line">                <span class="comment">//加锁同步后再次重新尝试从一级和二级缓存中获取Bean（double-check）</span></span><br><span class="line">                singletonObject = <span class="keyword">this</span>.singletonObjects.get(beanName);</span><br><span class="line">                <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    singletonObject = <span class="keyword">this</span>.earlySingletonObjects.get(beanName);</span><br><span class="line">                    <span class="keyword">if</span> (singletonObject == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        </span><br><span class="line">                        <span class="comment">//若依然都没有，则尝试从三级缓存singletonFactories中获取Bean</span></span><br><span class="line">                        ObjectFactory&lt;?&gt; singletonFactory = <span class="keyword">this</span>.singletonFactories.get(beanName);</span><br><span class="line">                        <span class="keyword">if</span> (singletonFactory != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            singletonObject = singletonFactory.getObject();</span><br><span class="line">                            <span class="comment">//若从三级缓存中获取到Bean，则将Bean放入二级缓存，并从三级缓存中移除</span></span><br><span class="line">                            <span class="keyword">this</span>.earlySingletonObjects.put(beanName, singletonObject);</span><br><span class="line">                            <span class="keyword">this</span>.singletonFactories.remove(beanName);</span><br><span class="line">                        &#125;</span><br><span class="line">                        </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> singletonObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 三级缓存都是<code>HashMap</code>。其中singletonObjects里存放的是实例化并且已完成属性赋值之后的单例对象，earlySingletonObjects中存放的是已完成实例化未属性赋值的早期单例对象，而singletonFactories中存放的是<code>ObjectFactory</code>对象，此对象的getObject方法返回值即是刚完成实例化还未属性赋值的单例对象。因此，<strong>单例对象先存在于singletonFactories中，后存在于earlySingletonObjects中，最后属性赋值完成后放入singletonObjects中</strong>。</p><p> b. <strong>createBean</strong>：根据不同的作用域创建Bean实例。-&gt; <code>AbstractAutowireCapableBeanFactory</code>：</p><ol><li><p><strong>createBean</strong>，创建bean实例的准备：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">createBean</span><span class="params">(String beanName, RootBeanDefinition mbd, @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object beanInstance = doCreateBean(beanName, mbdToUse, args);</span><br><span class="line">        <span class="keyword">return</span> beanInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>doCreateBean</strong>，创建bean实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> Object <span class="title">doCreateBean</span><span class="params">(<span class="keyword">final</span> String beanName, <span class="keyword">final</span> RootBeanDefinition mbd, <span class="keyword">final</span> @Nullable Object[] args)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> BeanCreationException </span>&#123;</span><br><span class="line">    BeanWrapper instanceWrapper = <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 省略代码</span></span><br><span class="line">    <span class="keyword">if</span> (instanceWrapper == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 重点！实例化bean</span></span><br><span class="line">        instanceWrapper = createBeanInstance(beanName, mbd, args);</span><br><span class="line">    &#125;</span><br><span class="line">    Object bean = instanceWrapper.getWrappedInstance();</span><br><span class="line">    <span class="comment">//省略代码</span></span><br><span class="line">    <span class="keyword">boolean</span> earlySingletonExposure = (mbd.isSingleton() &amp;&amp; <span class="keyword">this</span>.allowCircularReferences &amp;&amp; isSingletonCurrentlyInCreation(beanName));</span><br><span class="line">    <span class="keyword">if</span> (earlySingletonExposure) &#123;</span><br><span class="line">        <span class="comment">//省略代码</span></span><br><span class="line">        <span class="comment">// 重点！将实例化的对象添加到三级缓存singletonFactories中</span></span><br><span class="line">        addSingletonFactory(beanName, () -&gt; getEarlyBeanReference(beanName, mbd, bean));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始化bean</span></span><br><span class="line">    Object exposedObject = bean;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        populateBean(beanName, mbd, instanceWrapper);<span class="comment">//重点!注入属性值（依赖注入）</span></span><br><span class="line">        exposedObject = initializeBean(beanName, exposedObject, mbd);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 省略无关代码</span></span><br><span class="line">    <span class="keyword">return</span> exposedObject;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>populateBean</strong>：给bean实例注入属性值（依赖注入）</p></li></ol></li></ol><p>Java中的循环依赖分两种，一种是构造器的循环依赖，另一种是属性的循环依赖。构造器循环依赖是指：两个类在它们的构造器参数中互相依赖（多个类则是成环）。构造器循环依赖是无法解决的，属于严重的代码设计问题。<strong>Spring只能解决属性的循环依赖</strong>，假设类A与类B存在属性循环依赖，Spring先创建A的对象。在Bean的创建过程中，当执行到doGetBean方法时：</p><ol><li>在第一处getSingleton方法中，一二三级缓存map均为空，获取不到A的实例；</li><li>执行到createBean-&gt;doCreatBean方法中，通过createBeanInstance方法创建对象A；</li><li>addSingletonFactory方法将还未进行属性赋值的对象A放入三级缓存singletonFactories中，完成对象A的早期暴露。</li><li>接着执行populateBean方法对A进行属性注入。此时发现需要对A注入B的实例，触发getBean方法对B进行初始化。</li><li>B的初始化流程首先重复步骤1、2、3，接着执行populateBean对B进行属性注入，发现它有一个属性A，触发getBean方法对A进行初始化。</li><li>再次来到步骤1，此时三级缓存singletonFactories已经存在A的实例了，将A放入二级缓存并从三级缓存中删除，属性注入，完成对B的初始化。</li><li>回溯到对A的初始化流程（步骤4结尾），对A中注入B的实例。</li></ol><p>参考文章：<a href="https://www.cnblogs.com/zzq6032010/p/11406405.html" target="_blank" rel="noopener">https://www.cnblogs.com/zzq6032010/p/11406405.html</a></p><h3 id="Spring有线程安全问题？"><a href="#Spring有线程安全问题？" class="headerlink" title="Spring有线程安全问题？"></a>Spring有线程安全问题？</h3><p>多例：每次使用都是新的对象，无线程安全问题。</p><p>单例：对象中有实例变量，是线程不安全的，可以使用<code>ThreaLocal</code>解决。</p><h2 id="Autowired原理"><a href="#Autowired原理" class="headerlink" title="@Autowired原理"></a>@Autowired原理</h2><ul><li>@Autowired注解的实现是通过后置处理器<code>AutowiredAnnotationBeanPostProcessor</code>类的postProcessPropertyValues方法实现的。</li><li>自动装配时，从容器中如果发现有多个同类型的属性时，@Autowired注解会<strong>先根据类型判断，然后根据@Primary、@Priority注解判断，最后根据名称来判断</strong>，如果还是不能决定注入哪一个bean时，就会抛出<code>NoUniqueBeanDefinitionException</code>异常。</li></ul><h1 id="Aspect-Oriented-Programming"><a href="#Aspect-Oriented-Programming" class="headerlink" title="Aspect Oriented Programming"></a>Aspect Oriented Programming</h1><h2 id="AOP的三种织入方式"><a href="#AOP的三种织入方式" class="headerlink" title="AOP的三种织入方式"></a>AOP的三种织入方式</h2><ul><li>编译期织入：需要特殊的Java编译器，如AspectJ。</li><li>类加载时织入：需要特殊的Java编译器，如AspectJ和AspectWerkz。</li><li>运行时织入：Spring采用的方式，通过动态代理实现。</li></ul><h2 id="Spring-AOP原理"><a href="#Spring-AOP原理" class="headerlink" title="Spring AOP原理"></a>Spring AOP原理</h2><p>待补充。</p><h1 id="Spring事务"><a href="#Spring事务" class="headerlink" title="Spring事务"></a>Spring事务</h1><p>默认采用数据库的隔离级别，InnoDB为可重复读。</p><h2 id="事务的传播机制"><a href="#事务的传播机制" class="headerlink" title="事务的传播机制"></a>事务的传播机制</h2><p>所谓事务传播机制，是指若一个方法存在事务，且在该方法内部调用了其他方法，那么其他方法是否存在事务呢？Spring中的事务传播如下表：</p><div class="table-container"><table><thead><tr><th>事务传播行为类型</th><th>说明</th></tr></thead><tbody><tr><td><strong>PROPAGATION_REQUIRED</strong></td><td>如果当前没有事务，就新建一个事务，如果已经存在一个事务中，加入到这个事务中。（默认）</td></tr><tr><td><strong>PROPAGATION_SUPPORTS</strong></td><td>支持当前事务，如果当前没有事务，就以非事务方式执行。</td></tr><tr><td>PROPAGATION_MANDATORY</td><td>使用当前的事务，如果当前没有事务，就抛出异常。</td></tr><tr><td>PROPAGATION_REQUIRES_NEW</td><td>新建事务，如果当前存在事务，把当前事务挂起。</td></tr><tr><td>PROPAGATION_NOT_SUPPORTED</td><td>以非事务方式执行操作，如果当前存在事务，就把当前事务挂起。</td></tr><tr><td>PROPAGATION_NEVER</td><td>以非事务方式执行，如果当前存在事务，则抛出异常。</td></tr><tr><td>PROPAGATION_NESTED</td><td>如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。</td></tr></tbody></table></div><h2 id="Transactional"><a href="#Transactional" class="headerlink" title="@Transactional"></a>@Transactional</h2><ol><li>@Transactional注解只能应用到public修饰符上，其它修饰符不起作用，但不报错。</li><li>默认情况下此注解会对unchecked异常进行回滚，对checked异常不回滚。如果是checked异常也想回滚的话，注解上需写明rollbackFor属性，即@Transactional(rollbackFor=Exception.class)。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[checked异常]：表示无效，不是程序中可以预测的。比如无效的用户输入，文件不存在，网络或者数据库链接错误。这些都是外在的原因，都不是程序内部可以控制的。</span><br><span class="line">[unchecked异常]：表示错误，程序的逻辑错误。是RuntimeException的子类，比如IllegalArgumentException, NullPointerException和IllegalStateException。</span><br></pre></td></tr></table></figure><h2 id="事务不回滚解决方案"><a href="#事务不回滚解决方案" class="headerlink" title="事务不回滚解决方案"></a>事务不回滚解决方案</h2><ol><li>检查方法是不是public。</li><li>检查异常是不是unchecked异常。</li><li>如果是checked异常，注解@Transactional(rollbackFor=Exception.class)。</li></ol><h1 id="Spring-MVC执行流程"><a href="#Spring-MVC执行流程" class="headerlink" title="Spring MVC执行流程"></a>Spring MVC执行流程</h1><p>如图所示：</p><p><img src="springmvc.png" alt=""></p><p><strong>SpringMVC执行流程:</strong></p><ol><li>用户发送请求至前端控制器<strong>DispatcherServlet</strong>。</li><li>DispatcherServlet收到请求调用处理器映射器<strong>HandlerMapping</strong>。</li><li>HandlerMapping根据请求url找到具体的处理器，生成处理器执行链<strong>HandlerExecutionChain</strong>(包括处理器对象和处理器拦截器)返回给DispatcherServlet。</li><li>DispatcherServlet请求处理器适配器<strong>HandlerAdapter</strong>进行适配，并执行参数封装，数据格式转换，数据验证等操作。</li><li>执行处理器<strong>Handler</strong>(Controller，也叫页面控制器)。</li><li>Handler执行完成返回<strong>ModelAndView</strong>。</li><li>HandlerAdapter将Handler执行结果ModelAndView返回到DispatcherServlet。</li><li>DispatcherServlet将ModelAndView传给<strong>ViewReslover</strong>视图解析器。</li><li>ViewReslover解析后返回具体View。</li><li>DispatcherServlet对View进行渲染视图（即将模型数据model填充至视图中）后响应用户。</li></ol><h1 id="Spring-Boot自动装配"><a href="#Spring-Boot自动装配" class="headerlink" title="Spring Boot自动装配"></a>Spring Boot自动装配</h1><p>注：该部分完全总结自掘金小册”SpringBoot源码解读与原理分析”。</p><p>主启动类上的<code>@SpringBootApplication</code>注解的作用如下图：</p><p><img src="springboot.jpg" alt=""></p><h2 id="ComponentScan"><a href="#ComponentScan" class="headerlink" title="@ComponentScan"></a>@ComponentScan</h2><p>源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScan</span>(excludeFilters = &#123; <span class="meta">@Filter</span>(type = FilterType.CUSTOM, classes = TypeExcludeFilter<span class="class">.<span class="keyword">class</span>),</span></span><br><span class="line"><span class="class">@<span class="title">Filter</span>(<span class="title">type</span> </span>= FilterType.CUSTOM, classes = AutoConfigurationExcludeFilter<span class="class">.<span class="keyword">class</span>) &#125;)</span></span><br></pre></td></tr></table></figure><p>Spring Boot默认扫描主启动类所在包及子包里所有组件，并指定排除逻辑：</p><ul><li><code>TypeExcludeFilter</code>：用户可自定义Filter继承该类，包扫描时Spring就会调用match方法执行我们自定义的过滤逻辑。</li><li><code>AutoConfigurationExcludeFilter</code>：排除自动配置类。</li></ul><h2 id="SpringBootConfiguration"><a href="#SpringBootConfiguration" class="headerlink" title="@SpringBootConfiguration"></a>@SpringBootConfiguration</h2><p>与<code>@Configuration</code>的作用相同，被其标注的类会被 Spring 的IOC容器认定为配置类。</p><h2 id="EnableAutoConfiguration"><a href="#EnableAutoConfiguration" class="headerlink" title="@EnableAutoConfiguration"></a>@EnableAutoConfiguration</h2><p>Spring的手动装配Bean的方式有：</p><ul><li>使用<strong>模式注解</strong> <code>@Component</code> 等（Spring2.5+）</li><li>使用配置类 <code>@Configuration</code> 与 <code>@Bean</code> （Spring3.0+）</li><li>使用<strong>模块装配</strong> <code>@EnableXXX</code> 与 <code>@Import</code> （Spring3.1+）</li></ul><p>模式注解只能在自己编写的代码中标注，无法装配jar包中的组件。为此可以使用 <code>@Configuration</code> 与 <code>@Bean</code>，手动装配组件。但这种方式一旦注册过多，会导致编码成本高，维护不灵活等问题。而模块装配适合批量装配组件。</p><p>模块装配的使用方式为：给配置类标注自定义注解<code>@EnableXXX</code>。自定义注解<code>@EnableXXX</code>的代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Import</span>(普通类/配置类/ImportSelector的实现类/ImportBeanDefinitionRegistrar的实现类)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> EnableTest &#123;   &#125;</span><br></pre></td></tr></table></figure><p><code>@Import</code>注解的使用方式如下：创建几个颜色的实体类，如Red，Yellow，Blue，Green，Black等。</p><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorRegistrarConfiguration</span> </span>&#123; </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Yellow <span class="title">yellow</span><span class="params">()</span> </span>&#123;<span class="keyword">return</span> <span class="keyword">new</span> Yellow();&#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ImportSelector</code>的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回要注册的类的全类名数组</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorImportSelector</span> <span class="keyword">implements</span> <span class="title">ImportSelector</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String[] selectImports(AnnotationMetadata importingClassMetadata) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[] &#123;Blue<span class="class">.<span class="keyword">class</span>.<span class="title">getName</span>(), <span class="title">Green</span>.<span class="title">class</span>.<span class="title">getName</span>()&#125;</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ImportBeanDefinitionRegistrar</code>的实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorImportBeanDefinitionRegistrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span> </span>&#123;</span><br><span class="line">    <span class="comment">//手动注册Bean</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        registry.registerBeanDefinition(<span class="string">"black"</span>, <span class="keyword">new</span> RootBeanDefinition(Black<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>自定义装配类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(&#123;Red<span class="class">.<span class="keyword">class</span>, <span class="title">ColorRegistrarConfiguration</span>.<span class="title">class</span>, <span class="title">ColorImportSelector</span>.<span class="title">class</span>, <span class="title">ColorImportBeanDefinitionRegistrar</span>.<span class="title">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableColor</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>全局配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@EnableColor</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ColorConfiguration</span> </span>&#123;  &#125;</span><br></pre></td></tr></table></figure><p>Spring Boot的自动装配就是模块装配：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@AutoConfigurationPackage</span></span><br><span class="line"><span class="meta">@Import</span>(AutoConfigurationImportSelector<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">EnableAutoConfiguration</span></span>&#123;</span><br><span class="line">    省略...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="AutoConfigurationPackage"><a href="#AutoConfigurationPackage" class="headerlink" title="@AutoConfigurationPackage"></a>@AutoConfigurationPackage</h3><p>该注解的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(AutoConfigurationPackages.Registrar<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">AutoConfigurationPackage</span></span></span><br></pre></td></tr></table></figure><p>而<code>AutoConfigurationPackages.Registrar</code>的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Registrar</span> <span class="keyword">implements</span> <span class="title">ImportBeanDefinitionRegistrar</span>, <span class="title">DeterminableImports</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registerBeanDefinitions</span><span class="params">(AnnotationMetadata metadata, BeanDefinitionRegistry registry)</span> </span>&#123;</span><br><span class="line">        register(registry, <span class="keyword">new</span> PackageImports(metadata).getPackageNames().toArray(<span class="keyword">new</span> String[<span class="number">0</span>]));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Set&lt;Object&gt; <span class="title">determineImports</span><span class="params">(AnnotationMetadata metadata)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Collections.singleton(<span class="keyword">new</span> PackageImports(metadata));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由此可知<code>@AutoConfigurationPackage</code>的作用本质上是通过<code>@Import</code>注解<strong>注册主启动类所在包下的类</strong>。</p><h3 id="AutoConfigurationImportSelector"><a href="#AutoConfigurationImportSelector" class="headerlink" title="AutoConfigurationImportSelector"></a>AutoConfigurationImportSelector</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AutoConfigurationImportSelector</span> <span class="keyword">implements</span> <span class="title">DeferredImportSelector</span>, <span class="title">BeanClassLoaderAware</span>,</span></span><br><span class="line"><span class="class"><span class="title">ResourceLoaderAware</span>, <span class="title">BeanFactoryAware</span>, <span class="title">EnvironmentAware</span>, <span class="title">Ordered</span></span></span><br></pre></td></tr></table></figure><p><code>DeferredImportSelector</code> 处理自动配置，其执行时机是<strong>在 <code>@Configuration</code> 注解中的其他逻辑被处理完毕之后（包括对 <code>@ImportResource</code>、<code>@Bean</code> 这些注解的处理）再执行</strong>。</p><p>现在来看核心方法<strong>selectImports</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> NO_IMPORTS;</span><br><span class="line">    &#125;</span><br><span class="line">    AutoConfigurationEntry autoConfigurationEntry = getAutoConfigurationEntry(annotationMetadata);</span><br><span class="line">    <span class="keyword">return</span> StringUtils.toStringArray(autoConfigurationEntry.getConfigurations());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的核心就是<strong>getAutoConfigurationEntry</strong>，它获取了需要自动装配的所有类的全类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> AutoConfigurationEntry <span class="title">getAutoConfigurationEntry</span><span class="params">(AnnotationMetadata annotationMetadata)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!isEnabled(annotationMetadata)) &#123;</span><br><span class="line">        <span class="keyword">return</span> EMPTY_ENTRY;</span><br><span class="line">    &#125;</span><br><span class="line">    AnnotationAttributes attributes = getAttributes(annotationMetadata);</span><br><span class="line">    <span class="comment">// 【核心】加载候选的自动配置类</span></span><br><span class="line">    List&lt;String&gt; configurations = getCandidateConfigurations(annotationMetadata, attributes);</span><br><span class="line">    configurations = removeDuplicates(configurations);</span><br><span class="line">    Set&lt;String&gt; exclusions = getExclusions(annotationMetadata, attributes);</span><br><span class="line">    checkExcludedClasses(configurations, exclusions);</span><br><span class="line">    configurations.removeAll(exclusions);</span><br><span class="line">    configurations = getConfigurationClassFilter().filter(configurations);</span><br><span class="line">    fireAutoConfigurationImportEvents(configurations, exclusions);</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> AutoConfigurationEntry(configurations, exclusions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>该方法的核心则是通过<strong>getCandidateConfigurations</strong>获取候选的自动配置类的全类名：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> List&lt;String&gt; <span class="title">getCandidateConfigurations</span><span class="params">(AnnotationMetadata metadata, AnnotationAttributes attributes)</span> </span>&#123;</span><br><span class="line">    List&lt;String&gt; configurations = SpringFactoriesLoader.loadFactoryNames(getSpringFactoriesLoaderFactoryClass(), getBeanClassLoader());</span><br><span class="line">    Assert.notEmpty(configurations, <span class="string">"No auto configuration classes found in META-INF/spring.factories. If you "</span> + <span class="string">"are using a custom packaging, make sure that file is correct."</span>);</span><br><span class="line">    <span class="keyword">return</span> configurations;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>SpringFactoriesLoader.loadFactoryNames()</code>加载了指定常量路径<code>META-INF/spirng.factories</code>下的资源，该文件在<code>spring-boot-autoconfiguration</code>包中。spring.factories文件内容节选：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Initializers</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationContextInitializer</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.SharedMetadataReaderFactoryContextInitializer,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.logging.ConditionEvaluationReportLoggingListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Application Listeners</span></span><br><span class="line"><span class="meta">org.springframework.context.ApplicationListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.BackgroundPreinitializer</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Listeners</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportListener</span>=<span class="string">\</span></span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.ConditionEvaluationReportAutoConfigurationImportListener</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configuration Import Filters</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.AutoConfigurationImportFilter</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnBeanCondition,\</span><br><span class="line">org.springframework.boot.autoconfigure.condition.OnClassCondition,\</span><br><span class="line"><span class="attr">org.springframework.boot.autoconfigure.condition.OnWebApplicationCondition</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Auto Configure</span></span><br><span class="line"><span class="meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="string">\</span></span><br><span class="line">org.springframework.boot.autoconfigure.admin.SpringApplicationAdminJmxAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.aop.AopAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.amqp.RabbitAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.batch.BatchAutoConfiguration,\</span><br><span class="line">org.springframework.boot.autoconfigure.cache.CacheAutoConfiguration,\</span><br></pre></td></tr></table></figure><p>到此Spring Boot的自动装配机制已经显而易见了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Spring重要模块&quot;&gt;&lt;a href=&quot;#Spring重要模块&quot; class=&quot;headerlink&quot; title=&quot;Spring重要模块&quot;&gt;&lt;/a&gt;Spring重要模块&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;Spring主要模块.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>MySQL之锁</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E9%94%81/</id>
    <published>2020-11-24T11:05:46.000Z</published>
    <updated>2021-01-22T14:52:38.196Z</updated>
    
    <content type="html"><![CDATA[<h1 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h1><h2 id="读写锁"><a href="#读写锁" class="headerlink" title="读写锁"></a>读写锁</h2><p><strong>读锁</strong>：读锁是<strong>共享锁（S Lock）</strong>。多个用户在同一时刻可同时读取同一资源，互不干扰。</p><p><strong>写锁</strong>：写锁是<strong>排他锁（X Lock）</strong>。一个写锁会阻塞其他的写请求和读请求。写锁的优先级高于读锁，因此一个写请求可能会被插入到读请求队列的前面，反之则不行。</p><h2 id="锁粒度"><a href="#锁粒度" class="headerlink" title="锁粒度"></a>锁粒度</h2><p>应该尽量只锁定需要修改的那部分数据，而不是所有的资源。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。</p><p>但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此封锁粒度越小，系统开销就越大。</p><p>在选择封锁粒度时，需要在锁开销和并发程度之间做一个权衡。</p><p><strong>MySQL的Server层中实现了表锁，而存储引擎层则部分支持行锁（如InnoDB和XtraDB，行锁又分为S锁和X锁），部分支持表锁</strong>。</p><h2 id="意向锁"><a href="#意向锁" class="headerlink" title="意向锁"></a>意向锁</h2><p>InnoDB存储引擎支持多粒度锁定，它允许事务在行级上的锁和在表级上的锁上同时存在，由此引发一个问题：假如现有事务T₁对某表中的一行添加了行级S锁，与此同时事务T₂申请该表的表级X锁，显然T₁持有的S锁与T₂申请的锁冲突，那么T₂如何知道这个冲突呢？如果采用遍历整张表的每一行来查看是否某行有锁存在，显然得不偿失。</p><p>因此，为了支持多粒度加锁操作，InnoDB支持表级别的意向锁（Intention Lock）：</p><ol><li><strong>意向共享锁（IS Lock）</strong>：事务想要获得一张表中某几行的共享锁。</li><li><strong>意向排他锁（IX Lock）</strong>：事务想要获得一张表中某几行的排他锁。</li></ol><p>如果事务需要对行记录X加锁，那么它应先对行所在的表加意向锁IX，如果该表已有锁存在，那么该事务需要等待。</p><p>回到开始的问题，事务T₁对表某行添加了行级S锁，那么必须先添加表级IS锁，事务T₂申请表级X锁，由于不兼容，因此需要等待。</p><p><strong>InnoDB存储引擎中锁的兼容性如下表所示</strong>：</p><div class="table-container"><table><thead><tr><th style="text-align:center">T₁/T₂</th><th style="text-align:center">IS</th><th style="text-align:center">IX</th><th style="text-align:center">S</th><th style="text-align:center">X</th></tr></thead><tbody><tr><td style="text-align:center"><strong>IS</strong></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>IX</strong></td><td style="text-align:center">Y</td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>S</strong></td><td style="text-align:center">Y</td><td style="text-align:center"></td><td style="text-align:center">Y</td><td style="text-align:center"></td></tr><tr><td style="text-align:center"><strong>X</strong></td><td style="text-align:center"></td><td style="text-align:center"></td><td style="text-align:center"></td></tr></tbody></table></div><h2 id="悲观锁和乐观锁"><a href="#悲观锁和乐观锁" class="headerlink" title="悲观锁和乐观锁"></a>悲观锁和乐观锁</h2><h3 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h3><p>悲观锁对数据被外界修改持悲观态度，因此，在整个数据处理过程中，将数据处于锁定状态。读取数据时需要<strong>一致性锁定读</strong>，其它事务无法修改这些数据。修改删除数据时也要加锁，其它事务无法读取这些数据。</p><h3 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h3><p>相对悲观锁而言，乐观锁机制采取了更加宽松的加锁机制。悲观锁大多数情况下依靠数据库的锁机制实现，以保证操作最大程度的独占性。但随之而来的就是数据库性能的大量开销，特别是对长事务而言，这样的开销往往无法承受。</p><p>而乐观锁机制在一定程度上解决了这个问题，InnoDB中<strong>乐观锁</strong>通过<strong>一致性非锁定读</strong>实现。注意，乐观锁机制并不是真的锁。</p><h2 id="查看MySQL中的锁信息"><a href="#查看MySQL中的锁信息" class="headerlink" title="查看MySQL中的锁信息"></a>查看MySQL中的锁信息</h2><p>可通过命令<code>SHOW ENGINE INNODB STATUS;</code>以及information_schema架构下的INNODB_TRX、INNODB_LOCKS、INNODB_LOCK_WAITS来观察锁的信息。</p><h1 id="并发一致性问题"><a href="#并发一致性问题" class="headerlink" title="并发一致性问题"></a>并发一致性问题</h1><h2 id="丢失修改"><a href="#丢失修改" class="headerlink" title="丢失修改"></a>丢失修改</h2><p>事务T₁修改数据后还未提交，事务T₂覆盖数据，两个事务依次提交，则T₁的修改丢失了。<strong>只有串行化执行事务才能避免丢失修改（最高的隔离级别或手动加写锁（即for update））</strong>。</p><p><img src="change-lost.png" alt=""></p><h2 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h2><p><strong>脏读是指一个事务读取了另一个事务未提交的数据</strong>。事务T₁修改一个数据但未提交，事务T₂随后读取这个数据。如果T₁撤销了这次修改，那么T₂读取的数据是脏数据。</p><p><img src="dirty-read.png" alt=""></p><h2 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h2><p><strong>不可重复读是指在一个事务内多次执行相同的查询得到的结果不一致</strong>。事务T₂读取一个数据，事务T₁对该数据做了修改。如果T₂再次读取这个数据，此时读取的结果和第一次读取的数据不一致。</p><p><img src="unrepeatable-read.png" alt=""></p><h1 id="InnoDB存储引擎中的锁"><a href="#InnoDB存储引擎中的锁" class="headerlink" title="InnoDB存储引擎中的锁"></a>InnoDB存储引擎中的锁</h1><h2 id="一致性非锁定读"><a href="#一致性非锁定读" class="headerlink" title="一致性非锁定读"></a>一致性非锁定读</h2><p>一致性非锁定读（consistent nonlocking read）（又叫<strong>快照读</strong>）指InndoDB存储引擎通过多版本并发控制（Multi Version Concurrency Control）的方式来读取行数据。</p><p>举例：如果事务T₁正在对某行执行写操作，该行上有X锁，此时事务T₂要读取该行数据，那么T₂并不会等待T₁释放锁，而是读取该行的一个快照数据。如图所示：</p><p><img src="mvcc.jpg" alt=""></p><p>快照数据是指该行之前版本的数据，通过undo段（undo segment，位于共享表空间内）实现。undo段用于在事务中回滚数据，因此快照数据本身没有额外的开销。此外，读取快照数据是不需要上锁的，因为没有事务需要对历史数据进行修改操作。</p><p><strong>InnoDB存储引擎在READ COMMITTED和REPEATABLE READ隔离级别下都是采用一致性非锁定读实现</strong>。然而它们读取的快照数据版本是不同的：</p><ul><li>READ COMMITTED：若T₁被锁定行提交，T₂<strong>读取被锁定行的最新一份快照数据。</strong></li><li>REPEATABLE READ：若T₁被锁定行提交，T₂<strong>读取当前事务开始时的行数据版本。</strong></li></ul><h2 id="一致性锁定读"><a href="#一致性锁定读" class="headerlink" title="一致性锁定读"></a>一致性锁定读</h2><p><strong>在数据逻辑一致性要求较高时</strong>，用户需要显式地<strong>对数据库读取操作加锁。</strong>InnoDB对于SELECT语句支持两种一致性锁定读（locking read）操作：</p><ul><li><code>SELECT...FOR UPDATE;</code>：对读取的行记录加一个X锁（悲观锁）。</li><li><code>SELECT...LOCK IN SHARE MODE;</code>：对读取的行记录加一个S锁（悲观锁）。</li></ul><p>注意以上两个语句必须要在事务中，因此务必使用<code>BEGIN</code>、<code>START TRANSACTION</code>或<code>SET AUTOCOMMIT=0</code>。</p><h1 id="加行锁的3种算法"><a href="#加行锁的3种算法" class="headerlink" title="加行锁的3种算法"></a>加行锁的3种算法</h1><ol><li>Record Lock：锁定单个行记录，<strong>通过锁定索引（一般为主键）实现</strong>。<strong>在RC隔离级别下，InnoDB采用Record Lock</strong>。</li><li>Gap Lock：间隙锁，锁定一个范围，但不包含记录本身。</li><li>Next-Key Lock：Record Lock+Gap Lock，<strong>锁定一个范围，并且锁定记录本身</strong>。当查询的列是唯一索引时，InnoDB不再采用Next-Key Lock而是Record Lock。</li></ol><p>创建表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> z(a <span class="built_in">INT</span>, b <span class="built_in">INT</span>, PRIMARY <span class="keyword">KEY</span>(a), <span class="keyword">KEY</span>(b)); <span class="comment">-- a是唯一索引，b是非唯一索引</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">1</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">3</span>,<span class="number">1</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">5</span>,<span class="number">3</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">7</span>,<span class="number">6</span>;</span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">10</span>,<span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>在会话A中进行事务T₁：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b=<span class="number">3</span> <span class="keyword">FOR</span> <span class="keyword">UPDATE</span>; <span class="comment">-- 对5,3这一行加一个X锁，采用Next-Key Lock算法，锁定a=5,b=[1,6]</span></span><br></pre></td></tr></table></figure><p><img src="next-key-lock.png" alt=""></p><p>在会话B中：</p> <figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> a=<span class="number">5</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>; <span class="comment">--对5,3这一行加一个S锁</span></span><br></pre></td></tr></table></figure><p>结果为阻塞：</p><p><img src="next-key-lock1.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">1</span>;</span><br></pre></td></tr></table></figure><p>结果为阻塞：</p><p><img src="next-key-lock2.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">6</span>;</span><br></pre></td></tr></table></figure><p>结果为阻塞：</p><p><img src="next-key-lock3.png" alt=""></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> z <span class="keyword">SELECT</span> <span class="number">6</span>,<span class="number">7</span>;</span><br></pre></td></tr></table></figure><p>可正常插入：</p><p><img src="next-key-lock4.png" alt=""></p><p>由此实验可见，对于唯一索引，Next-Key Locking降级为Record Lock，本例中只锁定a=5；对于非唯一索引，则锁定一个范围，本例中锁定b的闭区间为[1,6]。</p><h2 id="幻读问题在InnoDB中是如何解决的？"><a href="#幻读问题在InnoDB中是如何解决的？" class="headerlink" title="幻读问题在InnoDB中是如何解决的？"></a>幻读问题在InnoDB中是如何解决的？</h2><p><strong>所谓幻读，指的是当事务A在读取某个范围的记录时，事务B又在该范围内插入或删除了一条记录，事务A再次读取该范围的记录时出现了幻行</strong>。幻读问题示例：</p><p>对于上述示例而言，在事务T₁中，假如将隔离级别改为RC：<code>SET SESSION tx_isolation=&#39;READ-COMMITTED;&#39;</code>，然后执行：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">BEGIN</span>;</span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> z <span class="keyword">WHERE</span> b&gt;<span class="number">3</span> <span class="keyword">LOCK</span> <span class="keyword">IN</span> <span class="keyword">SHARE</span> <span class="keyword">MODE</span>;<span class="comment">-- RC级别采用Record Lock算法，只锁定5,3一行</span></span><br></pre></td></tr></table></figure><p>在另一会话中执行<code>INSERT INTO z SELECT 11,11;</code>，那么显然可以插入成功，此时再次在事务T₁中执行<code>SELECT * FROM z WHERE b&gt;3 LOCK IN SHARE MODE;</code>，返回的结果比第一次多了一行数据(11,11)，这就是幻读问题（也是不可重复读问题）。而若隔离级别为RR，对于b而言锁定的是[3,+∞]，在另一个事务中根本无法插入数据。</p><p><strong>InnoDB的RC和RR隔离级别都通过一致性非锁定读（乐观锁机制）实现，RR是InnoDB的默认隔离级别。</strong></p><p><strong>在RC级别下，由于事务读的是最新版本的快照版本，有不可重复读和幻读问题。若改用悲观锁，由于RC级别采用Record Lock算法，因此只能解决读取一行情况下的不可重复读问题，若是读取多行依然会前后不一致，即不可重复读问题。至于幻读问题更是无法解决了。</strong></p><p><strong>在RR级别下，事务A读取数据行DATA，其他事务可以修改行DATA，但事务A读的是其自身开始时行DATA的快照版本，不会有不可重复读问题和幻读问题。若改用悲观锁，那么数据的一致性比使用乐观锁时更高，由于采用Next-Key Lock算法锁住了DATA及其周围的数据，其它事务甚至根本不能修改DATA及其范围内的数据而会被阻塞，更不会有不可重复读和幻读问题了。</strong></p><p>总结来说，<strong>InnoDB默认使用乐观锁机制，通过多版本并发控制（MVCC）解决了幻读问题；而人为使用悲观锁时，通过Next-Key Lock算法解决了幻读问题，并且相对乐观锁机制提高了数据一致性。</strong></p><h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>当多个事务在同一资源上相互占用，并请求锁定对方占用的资源时，产生死锁。例如如下两个事务同时处理stock_price表并同时执行完第一条更新语句：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 事务1</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> stock_price <span class="keyword">SET</span> <span class="keyword">close</span>=<span class="number">45</span> <span class="keyword">WHERE</span> stock_id=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> stock_price <span class="keyword">SET</span> <span class="keyword">close</span>=<span class="number">20</span> <span class="keyword">WHERE</span> stock_id=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 事务2</span></span><br><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> stock_price <span class="keyword">SET</span> <span class="keyword">close</span>=<span class="number">100</span> <span class="keyword">WHERE</span> stock_id=<span class="number">3</span>;</span><br><span class="line"><span class="keyword">UPDATE</span> stock_price <span class="keyword">SET</span> <span class="keyword">close</span>=<span class="number">10</span> <span class="keyword">WHERE</span> stock_id=<span class="number">4</span>;</span><br><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><strong>死锁检测</strong>：超时机制，超时则回滚；等待图（wait-for graph）方式，InnoDB就采用这种方式。等待图是指：数据库保存锁的信息链表和事务等待链表，通过上述链表构造一张图，若存在回路就代表存在死锁。</p><p><strong>死锁解决</strong>：死锁发生以后，只有部分或完全回滚其中一个事务才能打破死锁。InnoDB处理死锁的方法是，将持有最少行级排他锁的事务进行回滚。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://www.cyc2018.xyz/" target="_blank" rel="noopener">http://www.cyc2018.xyz/</a></li><li>MySQL技术内幕:InnoDB存储引擎[M].姜承尧著.北京:机械工业出版社,2013.6</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;锁概述&quot;&gt;&lt;a href=&quot;#锁概述&quot; class=&quot;headerlink&quot; title=&quot;锁概述&quot;&gt;&lt;/a&gt;锁概述&lt;/h1&gt;&lt;h2 id=&quot;读写锁&quot;&gt;&lt;a href=&quot;#读写锁&quot; class=&quot;headerlink&quot; title=&quot;读写锁&quot;&gt;&lt;/a&gt;读写锁&lt;/h
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://thmasterplan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL基础</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/MySQL%E5%9F%BA%E7%A1%80/</id>
    <published>2020-11-18T04:30:33.000Z</published>
    <updated>2021-01-29T15:00:41.306Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#一-基础">一.基础</a></p><p><a href="#二-增删改">二.增删改</a></p><p><a href="#三-查询">三.查询</a></p><ul><li><p><a href="#DISTINCT">DISTINCT</a></p></li><li><p><a href="#LIMIT">LIMIT</a></p></li></ul><p><a href="#四-排序">四.排序</a></p><p><a href="#五-过滤">五.过滤</a></p><p><a href="#六-通配符">六.通配符</a></p><p><a href="#七-正则表达式">七.正则表达式</a></p><p><a href="#八-计算字段">八.计算字段</a></p><p><a href="#九-函数">九.函数</a></p><p><a href="#十-分组">十.分组</a></p><p><a href="#十一-子查询">十一.子查询</a></p><p><a href="#十二-JOIN">十二.JOIN</a></p><ul><li><p><a href="#内连接">内连接</a></p></li><li><p><a href="#自连接">自连接</a></p></li><li><p><a href="#外部连接">外部连接</a></p></li></ul><p><a href="#十三-UNION">十三.UNION</a></p><p><a href="#十四-视图">十四.视图</a></p><p><a href="#十五-事务管理">十五.事务管理</a></p><p><a href="#十六-安全管理">十六.安全管理</a></p><p><a href="十七-范式">十七.范式</a></p><p><a href="#参考">参考</a></p><h1 id="一-基础"><a href="#一-基础" class="headerlink" title="一.基础"></a>一.基础</h1><ol><li><p>注释：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 注释</span></span><br><span class="line"><span class="comment">-- 注释</span></span><br><span class="line"><span class="comment">/* 注释</span></span><br><span class="line"><span class="comment">   注释*/</span></span><br></pre></td></tr></table></figure></li><li><p>查看数据库和表信息：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">DATABASES</span>; <span class="comment">-- 查询所有数据库</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">TABLES</span>; <span class="comment">-- 查看所有表</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 以下语句效果相同：查看单表的信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">COLUMNS</span> <span class="keyword">FROM</span> my_table;</span><br><span class="line">DESC my_table;</span><br><span class="line"><span class="keyword">EXPLAIN</span> my_table;</span><br><span class="line"><span class="keyword">DESCRIBE</span> my_table;</span><br></pre></td></tr></table></figure></li><li><p>创建和使用数据库：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">DATABASE</span> <span class="keyword">test</span>;</span><br><span class="line"><span class="keyword">USE</span> <span class="keyword">test</span>;</span><br></pre></td></tr></table></figure></li><li><p>SHOW命令：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">STATUS</span>; <span class="comment">-- 显示服务器状态信息</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span>; <span class="comment">-- 显示授权用户的权限</span></span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">ERRORS</span>;</span><br><span class="line"><span class="keyword">SHOW</span> <span class="keyword">WARNINGS</span>; <span class="comment">-- 显示错误与警告信息</span></span><br><span class="line"><span class="keyword">HELP</span> <span class="keyword">SHOW</span>; <span class="comment">-- 查看所有SHOW的用法</span></span><br></pre></td></tr></table></figure></li><li><p>创建和操纵表：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 实际生产中，所有字段最好都设置为NOT NULL,以避免NPE</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> my_table (</span><br><span class="line">  <span class="comment">-- int 类型，不为空，自增</span></span><br><span class="line">  <span class="keyword">id</span> <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> AUTO_INCREMENT,</span><br><span class="line">  <span class="comment">-- int 类型，不可为空，默认值为 1，不为空</span></span><br><span class="line">  col1 <span class="built_in">INT</span> <span class="keyword">NOT</span> <span class="literal">NULL</span> <span class="keyword">DEFAULT</span> <span class="number">1</span>,</span><br><span class="line">  <span class="comment">-- 变长字符串类型，最长为 45 个字符，可为空</span></span><br><span class="line">  col2 <span class="built_in">VARCHAR</span>(<span class="number">45</span>) <span class="literal">NULL</span>,</span><br><span class="line">  <span class="comment">-- 日期类型，可为空</span></span><br><span class="line">  col3 <span class="built_in">DATE</span> <span class="literal">NULL</span>, </span><br><span class="line">  <span class="comment">-- 设置主键为 id</span></span><br><span class="line">  PRIMARY <span class="keyword">KEY</span> (<span class="keyword">id</span>)</span><br><span class="line">)<span class="keyword">ENGINE</span>=<span class="keyword">InnoDB</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 添加列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">ADD</span> col4 <span class="built_in">CHAR</span>(<span class="number">45</span>);</span><br><span class="line"><span class="comment">-- 删除列</span></span><br><span class="line"><span class="keyword">ALTER</span> <span class="keyword">TABLE</span> my_table <span class="keyword">DROP</span> <span class="keyword">COLUMN</span> col4;</span><br><span class="line"><span class="comment">-- 删除表</span></span><br><span class="line"><span class="keyword">DROP</span> <span class="keyword">TABLE</span> my_table;</span><br><span class="line"><span class="comment">-- 重命名表</span></span><br><span class="line"><span class="keyword">RENAME</span> <span class="keyword">TABLE</span> my_table <span class="keyword">TO</span> my_table2;</span><br></pre></td></tr></table></figure></li></ol><h1 id="二-增删改"><a href="#二-增删改" class="headerlink" title="二.增删改"></a>二.增删改</h1><ol><li><p>插入</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 插入完整一行</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table <span class="keyword">VALUES</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="string">'col2'</span>, <span class="string">'2020-11-11'</span>);</span><br><span class="line"><span class="comment">-- 插入行的部分字段数据</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table(col1,col2) <span class="keyword">VALUES</span>(<span class="number">2</span>, <span class="string">'col2'</span>);</span><br><span class="line"><span class="comment">-- 插入多行, 用逗号分割即可</span></span><br><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> my_table <span class="keyword">VALUES</span>(<span class="literal">null</span>, <span class="number">2</span>, <span class="string">'col2'</span>, <span class="string">'2020-11-11'</span>),(<span class="literal">null</span>, <span class="number">3</span>, <span class="string">'col2'</span>, <span class="string">'2020-12-12'</span>);</span><br><span class="line"><span class="comment">-- 插入查询结果</span></span><br><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> new_table <span class="keyword">AS</span> my_table <span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table;</span><br></pre></td></tr></table></figure></li><li><p>更新</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">UPDATE</span> my_table <span class="keyword">SET</span> col1=<span class="number">10</span>, col2=<span class="string">'hhh'</span> <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br></pre></td></tr></table></figure></li><li><p>删除</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> <span class="keyword">id</span>=<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 删除整张表</span></span><br><span class="line"><span class="keyword">DELETE</span> <span class="keyword">FROM</span> my_table;</span><br><span class="line"><span class="keyword">TRUNCATE</span> <span class="keyword">TABLE</span> my_table;</span><br></pre></td></tr></table></figure><p><strong>两者的区别</strong>：DELETE是删除表的所有行，TRUNCATE是直接删除整张表再新建一张空表，因此后者更快。</p></li></ol><h1 id="三-查询"><a href="#三-查询" class="headerlink" title="三.查询"></a>三.查询</h1><h2 id="DISTINCT"><a href="#DISTINCT" class="headerlink" title="DISTINCT"></a>DISTINCT</h2><p>去重。它作用于列出的所有列，只有所有列的值完全相同才会被去重。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">DISTINCT</span> col1,col2 <span class="keyword">FROM</span> my_table;</span><br></pre></td></tr></table></figure><h2 id="LIMIT"><a href="#LIMIT" class="headerlink" title="LIMIT"></a>LIMIT</h2><p>限制返回结果的函数。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 只有一个参数</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">LIMIT</span> <span class="number">5</span>; <span class="comment">-- 只返回前5行，即1，2，3，4，5行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 有两个参数</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">LIMIT</span> <span class="number">5</span>,<span class="number">5</span>; <span class="comment">-- 返回从第6行开始的5行，即6，7，8，9，10行</span></span><br></pre></td></tr></table></figure><h1 id="四-排序"><a href="#四-排序" class="headerlink" title="四.排序"></a>四.排序</h1><p>使用ORDER BY子句。ASC，升序（默认）；DESC，降序。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">ORDER</span> <span class="keyword">BY</span> col1 <span class="keyword">DESC</span>, COL2 <span class="keyword">ASC</span>;</span><br></pre></td></tr></table></figure><h1 id="五-过滤"><a href="#五-过滤" class="headerlink" title="五.过滤"></a>五.过滤</h1><p>不进行过滤的数据非常大，导致通过网络传输了多余的数据，从而浪费了网络带宽。因此尽量使用 SQL 语句来过滤不必要的数据，而不是传输所有的数据到客户端中然后由客户端进行过滤。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col1 <span class="keyword">BETWEEN</span> <span class="number">2</span> <span class="keyword">AND</span> <span class="number">10</span>;</span><br></pre></td></tr></table></figure><p>WHERE子句操作符如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">操作符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">=</td><td style="text-align:center">等于</td></tr><tr><td style="text-align:center">&lt;&gt;或!=</td><td style="text-align:center">不等于</td></tr><tr><td style="text-align:center">&lt;</td><td style="text-align:center">小于</td></tr><tr><td style="text-align:center">&gt;</td><td style="text-align:center">大于</td></tr><tr><td style="text-align:center">&lt;=</td><td style="text-align:center">小于等于</td></tr><tr><td style="text-align:center">&gt;=</td><td style="text-align:center">大于等于</td></tr><tr><td style="text-align:center">BETWEEN … AND …</td><td style="text-align:center">在两个值之间</td></tr><tr><td style="text-align:center">IS NULL</td><td style="text-align:center">匹配NULL值</td></tr></tbody></table></div><p><strong>AND 和 OR</strong> 用于连接多个过滤条件。默认AND的优先级更高，当一个过滤表达式涉及到多个 AND 和 OR 时，可以使用 () 来决定优先级，使得优先级关系更清晰。</p><p><strong>IN</strong> 用于匹配一组值，其后也可以接一个 SELECT 子句，从而匹配子查询得到的一组值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col1 <span class="keyword">IN</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br></pre></td></tr></table></figure><p><strong>NOT</strong> 用于否定一个条件。MySQL支持使用其对 <strong>IN</strong>、<strong>BETWEEN</strong> 和 <strong>EXISTS</strong>子句取反。</p><h1 id="六-通配符"><a href="#六-通配符" class="headerlink" title="六.通配符"></a>六.通配符</h1><p><strong>LIKE</strong> 操作符指示MySQL其后跟的搜索模式利用通配符匹配而非直接相等匹配。注意根据MySQL的配置方式，匹配可以是区分大小写的。</p><ul><li><code>%</code> 表示任何字符出现任意次数。注意单个<code>%</code> 无法匹配NULL。</li><li><code>_</code> 表示匹配任意单个字符。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 <span class="keyword">LIKE</span> <span class="string">'%abc%'</span>; <span class="comment">-- 匹配列col2所有含有abc片段的列值</span></span><br></pre></td></tr></table></figure><h1 id="七-正则表达式"><a href="#七-正则表达式" class="headerlink" title="七.正则表达式"></a>七.正则表达式</h1><p>MySQL仅支持正则表达式的一个子集，使用 <strong>REGEXP</strong> 操作符。</p><p>MySQL中的正则表达式匹配不区分大小写，若要区分，可在 <strong>REGEXP</strong> 后使用 <strong>BINARY</strong> 关键字。</p><ol><li><p>基本字符匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 REGEXP <span class="built_in">BINARY</span> <span class="string">'.abc'</span>;</span><br></pre></td></tr></table></figure><p><code>.</code>表示匹配任意单个字符。</p></li><li><p>OR匹配</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 REGEXP <span class="built_in">BINARY</span> <span class="string">'.abc | ABC'</span>;</span><br></pre></td></tr></table></figure><p>使用<code>|</code>表示条件或。</p></li><li><p>匹配几个字符之一</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 REGEXP <span class="string">'[abc]'</span>;</span><br></pre></td></tr></table></figure><p>使用<code>[abc]</code>定义一组字符，它的含义是匹配a或匹配b或匹配c。</p><p>可在<code>[]</code>开头使用<code>^</code>表示匹配除了<code>[]</code>中指定字符以外的所有字符。例如<code>[^abc]</code>表示匹配除了这三个字符以外的所有字符。</p></li><li><p>匹配范围</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 REGEXP <span class="string">'[1-3]'</span>; <span class="comment">-- 匹配1或2或3</span></span><br><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 REGEXP <span class="string">'[a-f]'</span>; <span class="comment">-- 匹配a到f</span></span><br></pre></td></tr></table></figure><p>在<code>[]</code>中使用<code>-</code>表示匹配一个范围。</p></li><li><p>匹配特殊字符</p><p>为了匹配特殊字符，需要使用<code>\\</code>作为转义字符。例如<code>\\-</code>匹配<code>-</code>，<code>\\.</code>匹配<code>.</code>。</p></li><li><p>定位符</p><p>使用<code>^</code>锚定文本的开始，使用<code>$</code>锚定文本的结尾。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table <span class="keyword">WHERE</span> col2 REGEXP <span class="string">'^[ab]bug$'</span>; <span class="comment">-- 匹配以a或b开头，以g结尾的值</span></span><br></pre></td></tr></table></figure></li><li><p>匹配多个实例</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">元字符</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">*</td><td style="text-align:center">匹配前面的子表达式零次或多次。例如，zo<em> 能匹配 “z” 以及 “zoo”。</em> 等价于{0,}。</td></tr><tr><td style="text-align:center">+</td><td style="text-align:center">匹配前面的子表达式一次或多次。例如，’zo+’ 能匹配 “zo” 以及 “zoo”，但不能匹配 “z”。+ 等价于 {1,}。</td></tr><tr><td style="text-align:center">{n}</td><td style="text-align:center">n 是一个非负整数。匹配确定的 n 次。例如，’o{2}’ 不能匹配 “Bob” 中的 ‘o’，但是能匹配 “food” 中的两个 o。</td></tr><tr><td style="text-align:center">{n,m}</td><td style="text-align:center">m 和 n 均为非负整数，其中n &lt;= m。最少匹配 n 次且最多匹配 m 次。</td></tr></tbody></table></div><h1 id="八-计算字段"><a href="#八-计算字段" class="headerlink" title="八.计算字段"></a>八.计算字段</h1><p>在数据库服务器上完成数据的转换和格式化的工作往往比客户端上快得多，并且转换和格式化后的数据量更少的话可以减少网络通信量。</p><p>计算字段通常需要使用 <strong>AS</strong> 来取别名，否则输出的时候字段名为计算表达式。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> column1 * column2 <span class="keyword">AS</span> <span class="keyword">alias</span> <span class="keyword">FROM</span> my_table; <span class="comment">-- MySQL支持+, -, *, /</span></span><br></pre></td></tr></table></figure><p><strong>CONCAT()</strong> 用于连接两个字段。许多数据库会使用空格把一个值填充为列宽，因此连接的结果会出现一些不必要的空格，使用 <strong>TRIM()</strong> 可以去除首尾空格。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">CONCAT</span>(<span class="keyword">TRIM</span>(col1), <span class="string">'('</span>, <span class="keyword">TRIM</span>(col2), <span class="string">')'</span>) <span class="keyword">AS</span> concat_col <span class="keyword">FROM</span> mytable;</span><br></pre></td></tr></table></figure><h1 id="九-函数"><a href="#九-函数" class="headerlink" title="九.函数"></a>九.函数</h1><p>MySQL函数可分为文本处理函数，日期和时间处理函数，数值处理函数，聚集函数等。</p><p>其中聚集函数是运行在行组上，计算和返回单个值的函数，如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">函 数</th><th style="text-align:center">说 明</th></tr></thead><tbody><tr><td style="text-align:center">AVG()</td><td style="text-align:center">返回某列的平均值，忽略NULL</td></tr><tr><td style="text-align:center">COUNT()</td><td style="text-align:center">返回某列的行数</td></tr><tr><td style="text-align:center">MAX()</td><td style="text-align:center">返回某列的最大值</td></tr><tr><td style="text-align:center">MIN()</td><td style="text-align:center">返回某列的最小值</td></tr><tr><td style="text-align:center">SUM()</td><td style="text-align:center">返回某列值之和</td></tr></tbody></table></div><p>使用 DISTINCT 可以汇总不同的值。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(<span class="keyword">DISTINCT</span> col1) <span class="keyword">AS</span> avg_col <span class="keyword">FROM</span> my_table;</span><br></pre></td></tr></table></figure><p>其余函数可参考：<a href="https://www.runoob.com/mysql/mysql-functions.html" target="_blank" rel="noopener">MySQL函数|菜鸟教程</a>。</p><h1 id="十-分组"><a href="#十-分组" class="headerlink" title="十.分组"></a>十.分组</h1><p>使用 <strong>GROUP BY</strong>子句指定某列，该列相同的值则划为一组。</p><p>可以对同一分组数据使用聚集函数进行处理，例如求同一分组中某列的平均值等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(col1) <span class="keyword">AS</span> col1_avg <span class="keyword">FROM</span> mytable <span class="keyword">GROUP</span> <span class="keyword">BY</span> col2;</span><br></pre></td></tr></table></figure><p>使用 <strong>HAVING</strong> 子句指定分组的过滤条件。WHERE 过滤行，优先级高于 <strong>HAVING</strong>。</p><p>分组规定：</p><ol><li>GROUP BY子句可以包含任意数目的列，这使得能对分组进行嵌套，进行更细致的分组。</li><li>如果嵌套了分组，数据将在最后规定的分组上进行汇总。</li><li>GROUP BY子句中列出的每个列都必须是检索列或有效的表达式。</li><li>除聚集函数计算语句外，SELECT语句中的每个列都必须在GROUP BY子句中给出。</li><li>如果分组中有NULL值，则NULL将作为一个分组。</li><li>关键字的顺序：WHERE &gt; GROUP BY &gt; HAVING &gt; ORDER BY &gt; LIMIT。</li></ol><h1 id="十一-子查询"><a href="#十一-子查询" class="headerlink" title="十一.子查询"></a>十一.子查询</h1><p><strong>子查询中只能返回一个字段的数据</strong>。</p><p>可以将子查询的结果作为 WHRER 语句的过滤条件：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> * <span class="keyword">FROM</span> my_table1 <span class="keyword">WHERE</span> col1 <span class="keyword">IN</span> </span><br><span class="line">                                  (<span class="keyword">SELECT</span> col2 <span class="keyword">FROM</span> my_table2);</span><br></pre></td></tr></table></figure><p><strong>子查询作为计算字段</strong>：下面的语句可以检索出客户的订单数量，子查询语句会对第一个查询检索出的每个客户执行一次。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> cust_name, (<span class="keyword">SELECT</span> <span class="keyword">COUNT</span>(*)</span><br><span class="line">                   <span class="keyword">FROM</span> Orders</span><br><span class="line">                   <span class="keyword">WHERE</span> Orders.cust_id = Customers.cust_id)</span><br><span class="line">                   <span class="keyword">AS</span> orders_num</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">ORDER</span> <span class="keyword">BY</span> cust_name;</span><br></pre></td></tr></table></figure><p>也可以将子查询的结果作为UPDATE语句的插入值。</p><h1 id="十二-JOIN"><a href="#十二-JOIN" class="headerlink" title="十二.JOIN"></a>十二.JOIN</h1><p>使用 JOIN 关键字连接多张表，并且条件语句使用 ON 而不是 WHERE。</p><p>连接可以替换子查询，并且比子查询的效率一般会更快。</p><p>可以用 AS 给列名、计算字段和表名取别名（AS可省略），给表名取别名是为了简化 SQL 语句以及连接相同表。</p><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><p>内连接又称<strong>等值连接</strong>，使用 INNER JOIN 关键字。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea <span class="keyword">AS</span> A <span class="keyword">INNER</span> <span class="keyword">JOIN</span> tableb <span class="keyword">AS</span> B</span><br><span class="line"><span class="keyword">ON</span> A.key = B.key;</span><br></pre></td></tr></table></figure><p>也可以不明确使用 INNER JOIN，而使用普通查询并在 WHERE 中将两个表中要连接的列用等值方法连接起来。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> A.value, B.value</span><br><span class="line"><span class="keyword">FROM</span> tablea A, tableb B</span><br><span class="line"><span class="keyword">WHERE</span> A.key = B.key;</span><br></pre></td></tr></table></figure><h2 id="自连接"><a href="#自连接" class="headerlink" title="自连接"></a>自连接</h2><p>自连接可以看成内连接的一种，只是连接的表是自身而已。</p><p>一张员工表，包含员工姓名和员工所属部门，要找出与 Jim 处在同一部门的所有员工姓名。</p><p>子查询版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">name</span> <span class="keyword">FROM</span> employee</span><br><span class="line"><span class="keyword">WHERE</span> department = (</span><br><span class="line">      <span class="keyword">SELECT</span> department</span><br><span class="line">      <span class="keyword">FROM</span> employee</span><br><span class="line">      <span class="keyword">WHERE</span> <span class="keyword">name</span> = <span class="string">"Jim"</span>);</span><br></pre></td></tr></table></figure><p>自连接版本</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e1.name </span><br><span class="line"><span class="keyword">FROM</span> employee e1 <span class="keyword">INNER</span> <span class="keyword">JOIN</span> employee e2</span><br><span class="line"><span class="keyword">ON</span> e1.department = e2.department</span><br><span class="line">      <span class="keyword">AND</span> e2.name = <span class="string">"Jim"</span>;</span><br></pre></td></tr></table></figure><p>应使用自连接而非子查询。</p><h2 id="外部连接"><a href="#外部连接" class="headerlink" title="外部连接"></a>外部连接</h2><p>外连接保留了没有关联的那些行。分为左外连接，右外连接以及全外连接。<strong>MySQL不支持全外连接，需要左外连接和右外连接结合UNION实现全外连接的效果。</strong></p><ul><li>左外连接：LEFT OUTER JOIN</li><li>右外连接：RIGHT OUTER JOIN。其中OUTER可省略。</li></ul><p>检索所有顾客的订单信息，包括还没有订单信息的顾客。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><h1 id="十三-UNION"><a href="#十三-UNION" class="headerlink" title="十三.UNION"></a>十三.UNION</h1><p>使用 <strong>UNION</strong> 来组合两个查询，如果第一个查询返回 M 行，第二个查询返回 N 行，那么组合查询的结果一般为 M+N 行。</p><p><strong>每个查询必须包含相同的列、表达式和聚集函数</strong>。</p><p>默认会去除相同行，如果需要保留相同行，使用 UNION ALL。</p><p>只能包含一个 ORDER BY 子句，并且必须位于语句的最后。</p><p>实现全外连接：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 由于不存在有订单信息却没有没有顾客信息的情况，因此该例没有实际意义，仅作全外连接实现的演示</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">LEFT</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id</span><br><span class="line"><span class="keyword">UNION</span></span><br><span class="line"><span class="keyword">SELECT</span> Customers.cust_id, Customer.cust_name, Orders.order_id</span><br><span class="line"><span class="keyword">FROM</span> Customers <span class="keyword">RIGHT</span> <span class="keyword">JOIN</span> Orders</span><br><span class="line"><span class="keyword">ON</span> Customers.cust_id = Orders.cust_id;</span><br></pre></td></tr></table></figure><h1 id="十四-视图"><a href="#十四-视图" class="headerlink" title="十四.视图"></a>十四.视图</h1><p>视图是虚拟的表，它由一个SQL查询来定义，可以当作表使用。与持久表不同的是，视图中的数据没有实际的物理存储，因此不能对其进行索引操作。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">VIEW</span> myview <span class="keyword">AS</span> <span class="keyword">SELECT</span>语句;</span><br></pre></td></tr></table></figure><p>视图的作用：</p><ul><li>可只使用实际表的一部分数据。</li><li>通过只给用户访问视图的权限，保证数据的安全性。</li></ul><h1 id="十五-事务管理"><a href="#十五-事务管理" class="headerlink" title="十五.事务管理"></a>十五.事务管理</h1><p><strong>事务术语</strong>：</p><ul><li><p>事务（transaction）：指一组SQL语句。</p></li><li><p>回退（rollback）：指撤销指定SQL语句的过程。</p></li><li><p>提交（commit）：指将未存储的SQL语句结果写入数据库表。</p></li><li><p>保留点（savepoint）：指事务处理中设置的临时占位符，可以对它发布回退。</p></li></ul><p>标识事务的开始：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">START</span> <span class="keyword">TRANSACTION</span>;</span><br></pre></td></tr></table></figure><p>回退：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">ROLLBACK</span>;</span><br></pre></td></tr></table></figure><p><strong>事务处理用来管理INSERT, UPDATE和DELETE，你不能回退SELECT语句，CREATE语句和DROP操作</strong>。</p><p>在事务块中，需要手动提交：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">COMMIT</span>;</span><br></pre></td></tr></table></figure><p><strong>为了支持回退部分事务处理</strong>，必须在事务处理块中合适的位置放置占位符，这样，如果需要回退，可以回退到某个占位符。创建占位符：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SAVEPOINT</span> delete1;</span><br><span class="line"><span class="comment">-- Some SQL statements;</span></span><br><span class="line"><span class="keyword">ROLLBACK</span> <span class="keyword">TO</span> delete1; <span class="comment">-- 回退到保留点delete1</span></span><br></pre></td></tr></table></figure><p>保留点在事务处理完成后自动释放，也可明确释放保留点：</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RELEASE</span> <span class="keyword">SAVEPOINT</span> delete1;</span><br></pre></td></tr></table></figure><h1 id="十六-安全管理"><a href="#十六-安全管理" class="headerlink" title="十六.安全管理"></a>十六.安全管理</h1><p><strong>MySQL 的账户信息保存在 mysql 这个数据库中</strong>。</p><p><strong>查看用户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">USE</span> mysql;</span><br><span class="line"><span class="keyword">SELECT</span> <span class="keyword">user</span> <span class="keyword">FROM</span> <span class="keyword">user</span>;</span><br></pre></td></tr></table></figure><p><strong>创建账户</strong></p><p>新创建的账户没有任何权限。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> myuser <span class="keyword">IDENTIFIED</span> <span class="keyword">BY</span> <span class="string">'mypassword'</span>;</span><br></pre></td></tr></table></figure><p><strong>修改账户名</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">RENAME</span> <span class="keyword">USER</span> myuser <span class="keyword">TO</span> newuser;</span><br></pre></td></tr></table></figure><p><strong>删除账户</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>查看权限</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> <span class="keyword">GRANTS</span> <span class="keyword">FOR</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>授予权限</strong></p><p>账户用 username@host 的形式定义，username@% 使用的是默认主机名。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 授权myuser对数据库mydatabase的所有表有select和insert权限</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">TO</span> myuser;</span><br></pre></td></tr></table></figure><p><strong>删除权限</strong></p><p>GRANT 和 REVOKE 可在几个层次上控制访问权限：</p><ul><li>整个服务器，使用 GRANT ALL 和 REVOKE ALL；</li><li>整个数据库，使用 ON database.*；</li><li>特定的表，使用 ON database.table；</li><li>特定的列；</li><li>特定的存储过程。</li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">SELECT</span>, <span class="keyword">INSERT</span> <span class="keyword">ON</span> mydatabase.* <span class="keyword">FROM</span> myuser;</span><br></pre></td></tr></table></figure><p>具体有哪些权限可参照MySQL必知必会表28-1。</p><p><strong>更改密码</strong></p><p>必须使用 Password() 函数进行加密。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SET</span> PASSWROD <span class="keyword">FOR</span> myuser = <span class="keyword">Password</span>(<span class="string">'new_password'</span>);</span><br><span class="line"><span class="keyword">SET</span> PASSWROD = <span class="keyword">Password</span>(<span class="string">'new_password'</span>); <span class="comment">--不指定用户名则更新当前登录用户的密码</span></span><br></pre></td></tr></table></figure><h1 id="十七-范式"><a href="#十七-范式" class="headerlink" title="十七.范式"></a>十七.范式</h1><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ul><li><p>减少数据冗余。</p></li><li><p>消除插入、更新和删除异常。</p></li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><strong>1NF</strong></p><p><strong>表的每一个字段都是最小单元，不可再分</strong>。</p><p>实践：数据库设计画ER图时对实体做好分析可满足1NF。</p><p><strong>2NF</strong></p><p><strong>满足1NF，且表中的字段必须完全依赖于全部主键而非部分主键</strong>。</p><p>实践：一张表只设一个主键，若该表满足1NF，则一定满足2NF。</p><p><strong>3NF</strong></p><p><strong>满足2NF，且非主键外的所有字段必须互不依赖，即消除了依赖传递</strong>，例如：主键决定字段A，字段A决定字段B，则主键可决定字段B，这就是依赖传递。</p><p>实践：若存在相互依赖的字段，则它们应单独在一张表中，比如前面例子中字段A, B应单独在一张表中。</p><p><strong>BCNF</strong></p><p><strong>满足3NF，且每张表中只有一个唯一索引（一般为主键）。</strong></p><p>实践：MySQL中一般不用。以user表为例，假设该user表有手机号tel字段，每个人的手机号都是唯一的，显然用手机号做主键是不合适的，此时一般还是需要自定义一个自增id。这里就有两个唯一索引了，不满足BCNF。那么为了满足BCNF，我们需要单独建表存储一个id号和手机号tel字段，这样查询性能会降低。</p><p><strong>4NF</strong></p><p><strong>满足3NF，且消除表中字段的多值依赖。</strong></p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li>MySQL 必知必会 / (英) Forta, B 著；刘晓霞，钟铭译. -北京：人民邮电出版社，2009.1</li><li><a href="www.cyc2018.xyz">CS-Notes</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#一-基础&quot;&gt;一.基础&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#二-增删改&quot;&gt;二.增删改&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#三-查询&quot;&gt;三.查询&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#DISTINCT&quot;&gt;DISTINCT&lt;/
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="MySQL" scheme="http://thmasterplan.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis入门</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%85%A5%E9%97%A8/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E5%BA%93/Redis%E5%85%A5%E9%97%A8/</id>
    <published>2020-11-13T14:04:39.000Z</published>
    <updated>2020-11-24T11:30:49.389Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#简介">简介</a></p><ul><li><p><a href="#启动Redis">启动Redis</a></p></li><li><p><a href="#基础命令">基础命令</a></p></li><li><p><a href="#管理">管理</a></p></li></ul><p><a href="#数据类型">数据类型</a></p><ul><li><p><a href="#字符串">字符串(String)</a></p></li><li><p><a href="#哈希">哈希(Hash)</a></p></li><li><p><a href="#列表">列表(List)</a></p></li><li><p><a href="#集合">集合(Set)</a></p></li><li><p><a href="#有序集合">有序集合(ZSet)</a></p></li></ul><p><a href="#Redis进阶">Redis进阶</a></p><ul><li><p><a href="#事务">事务</a></p><ul><li><p><a href="#命令">命令</a></p></li><li><p><a href="#事务中的错误处理">事务中的错误处理</a></p></li></ul></li><li><p><a href="#过期时间">过期时间</a></p><ul><li><p><a href="#命令">命令</a></p></li><li><p><a href="#实现缓存">实现缓存</a></p></li></ul></li><li><p><a href="#排序">排序</a></p></li><li><p><a href="#管道">管道</a></p></li></ul><p><a href="#持久化">持久化</a></p><ul><li><p><a href="#RDB方式">RDB(Redis DataBase)方式</a></p><ul><li><p><a href="#配置文件">配置文件</a></p></li><li><p><a href="#SAVE/BGSAVE">SAVE/BGSAVE</a></p></li><li><p><a href="#FLUSHALL">FLUSHALL</a></p></li><li><p><a href="#复制">复制</a></p></li><li><p><a href="#快照原理">快照原理</a></p></li></ul></li><li><p><a href="#AOF方式">AOF(Append Only File)方式</a></p><ul><li><a href="#同步硬盘数据">同步硬盘数据</a></li></ul></li></ul><p><a href="#集群">集群</a></p><ul><li><p><a href="#主从复制">主从复制</a></p></li><li><p><a href="#主从复制的原理">主从复制的原理</a></p></li><li><p><a href="#哨兵机制">哨兵机制</a></p><ul><li><a href="#简介">简介</a></li></ul></li></ul><ul><li><p><a href="#使用">使用</a></p></li><li><p><a href="#原理">原理</a></p></li><li><p><a href="#部署">部署</a></p><ul><li><a href="#集群">集群</a></li></ul></li></ul><p><a href="#Spring-Data-Redis">Spring Data Redis</a></p><p><a href="#常见面试问题">常见面试问题</a></p><h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><p>Redis(Remote Dictionary Server)即远程字典服务器，它以字典结构存储数据，并允许其他应用通过TCP协议读写字典中的内容。Redis与传统数据库不同的是其数据库是存在<strong>内存</strong>中，所以<strong>读写速度非常快</strong>，因此Redis被广泛应用于<strong>缓存</strong>方向。另外，redis也可用来做<strong>分布式锁</strong>（推荐使用Zookeeper），redis提供了多种数据类型来支持不同的业务场景。除此之外，<strong>Redis 支持事务</strong> 、<strong>持久化</strong>、<strong>LUA脚本</strong>、<strong>LRU驱动事件</strong>、<strong>多种集群</strong>方案。</p><p>附：<a href="http://doc.redisfans.com/" target="_blank" rel="noopener">Redis命令参考及文档</a>。</p><h2 id="启动Redis"><a href="#启动Redis" class="headerlink" title="启动Redis"></a>启动Redis</h2><p>Redis的可执行文件及其含义如下表：</p><div class="table-container"><table><thead><tr><th style="text-align:center">文件名</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">redis-server</td><td style="text-align:center">启动Redis服务器</td></tr><tr><td style="text-align:center">redis-cli</td><td style="text-align:center">Redis命令行客户端</td></tr><tr><td style="text-align:center">redis-benchmark</td><td style="text-align:center">性能测试工具</td></tr><tr><td style="text-align:center">redis-check-aof</td><td style="text-align:center">AOF文件修复工具</td></tr><tr><td style="text-align:center">redis-check-dump</td><td style="text-align:center">RDB文件检查工具</td></tr><tr><td style="text-align:center">redis-sentinel</td><td style="text-align:center">Sentinel服务器</td></tr></tbody></table></div><p>直接运行<code>redis-server</code>即可以默认配置文件<code>redis.conf</code>启动服务器，可选参数<code>--port 6380</code>指定端口号，默认端口号为6379。</p><p><strong>生产环境中，应以初始化脚本启动Redis</strong>。在utils目录下有一个名为redis_init_script的脚本文件，用于配置Redis的运行方式、持久化/日志文件的存储位置等。步骤：</p><ol><li><p>将redis_init_script复制到/etc/init.d目录下，修改文件名为redis_端口号，修改脚本文件中的REDISPORT变量为相同的端口号。</p></li><li><p>将redis.conf复制到/etc/redis目录下，以端口号.conf命名，按需求修改配置文件参数：</p></li></ol><div class="table-container"><table><thead><tr><th style="text-align:center">参数</th><th style="text-align:center">取值</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">daemonize</td><td style="text-align:center">yes</td><td style="text-align:center">以守护进程模式运行</td></tr><tr><td style="text-align:center">pidfile</td><td style="text-align:center">/var/run/redis_端口号.pid</td><td style="text-align:center">设置PID文件位置</td></tr><tr><td style="text-align:center">port</td><td style="text-align:center">端口号</td><td style="text-align:center">设置监听端口号</td></tr><tr><td style="text-align:center">dir</td><td style="text-align:center">/var/redis/端口号</td><td style="text-align:center">设置持久化文件存放位置</td></tr></tbody></table></div><h2 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h2><ul><li><code>SELECT [n]</code>：Redis默认有16个数据库，可以通过配置参数databases修改。该命令用于选择数据库，n取0到15。</li><li><code>DBSIZE</code>：查看当前数据库键值对数量。</li><li><code>FLUSHDB</code>：清空当前数据库。</li><li><code>FLUSHALL</code>：清空所有数据库。</li><li><code>TYPE key</code>：查询value的数据类型。</li><li><code>KEYS [pattern]</code>：模糊匹配符合条件的key。</li><li><code>EXISTS key</code>：判断key是否存在。</li></ul><h2 id="管理"><a href="#管理" class="headerlink" title="管理"></a>管理</h2><ul><li>配置文件中<code>bind</code>参数指定可以访问Redis服务器的IP。</li><li><code>requirepass</code>参数指定密码，客户端每次连接Redis都需要发送密码；发送密码的命令：<code>AUTH 密码</code>。在主从系统中若master设置了密码，slave的配置文件中需要配置参数<code>masterauth</code>指定主服务器的密码。</li></ul><h1 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h1><p>Redis一共有字符串，哈希，列表，集合和有序集合五种数据类型。</p><p>Redis的数据类型都不支持数据类型嵌套，比如集合类型的每个元素都只能是字符串，不能是另一个集合或哈希表。</p><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>字符串类型能存储任何形式的字符串，包括二进制数据，一个字符串的最大容量为512MB。常用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">SETGET&#x2F;DEL&#x2F;APPEND&#x2F;STRLEN</span><br><span class="line">INCR&#x2F;DECR&#x2F;INCRBY&#x2F;DECRBY：整数的加减。</span><br><span class="line">GETRANGE&#x2F;SETRANGE key 0 5：获取&#x2F;设置字符串下标0到5的片段。</span><br><span class="line">SETEX&#x2F;SETNX：赋值的同时设置过期时间。</span><br><span class="line">MSET&#x2F;MGET&#x2F;MSETNX：同时获取&#x2F;设置多个键值对。</span><br><span class="line">GETSET：先GET再SET。</span><br></pre></td></tr></table></figure><h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>散列类型是字段和字段值的映射，字段值只能是字符串，一个散列类型最多支持2³²-1个字段。</p><p>散列类型适合存储对象。常用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HSET&#x2F;HGET&#x2F;HMSET&#x2F;HMGET&#x2F;HGETALL&#x2F;HDEL</span><br><span class="line">HLEN：获取哈希表键值对个数。</span><br><span class="line">HEXISTS</span><br><span class="line">HKEYS&#x2F;HVALS</span><br><span class="line">HINCRBY&#x2F;HINCYBYFLOAT</span><br><span class="line">HSETNX</span><br></pre></td></tr></table></figure><h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>列表类型内部实现为一个双向链表，常用操作是向两端添加元素或列表的一个片段，也可以把列表当作队列使用，一个列表类型最多支持2³²-1个元素。</p><p>使用列表的代价是通过索引访问元素比较慢。</p><p>另外可以通过<code>LRANGE</code>命令，就是从某个元素开始读取多少个元素，可以基于List实现分页查询，这个很棒的一个功能，基于Redis实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。常用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LPUSH&#x2F;RPUSH&#x2F;LRANGE&#x2F;LPOP&#x2F;RPOP</span><br><span class="line">LINDEX&#x2F;LLEN&#x2F;LREM</span><br><span class="line">LTRIM key startindex endindex</span><br><span class="line">RPOPLPUSH 源列表 目的列表</span><br><span class="line">LSET key index value</span><br><span class="line">LINSERT key before&#x2F;after value</span><br></pre></td></tr></table></figure><h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>集合对外提供的功能与列表类似，特殊之处在于集合是可以<strong>自动排重</strong>的。当你需要存储一个列表数据，又不希望出现重复数据时，集合是一个很好的选择。多个集合之间可以进行并集、交集和差集运算。</p><p>集合在Redis内部是使用值为空的哈希表实现的。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程。常用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SADD&#x2F;SMEMBERS&#x2F;SISMEMBER</span><br><span class="line">SCARD</span><br><span class="line">SREM</span><br><span class="line">SRANDMEMBER</span><br><span class="line">SPOP</span><br><span class="line">SMOVE</span><br><span class="line">SDIFF&#x2F;SINTER&#x2F;SUNION：差集&#x2F;交集&#x2F;并集。</span><br></pre></td></tr></table></figure><h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>和集合相比，有序集合增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p>举例： 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用有序集合存储。常用命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ZADD&#x2F;ZRANGE</span><br><span class="line">ZRANGEBYSCORE</span><br><span class="line">ZREM key e [e...]：删除一个或多个元素。</span><br><span class="line">ZCARD：获得集合中元素的数量</span><br><span class="line">ZCOUNT key min max：获得指定分数范围的元素个数。</span><br><span class="line">ZREVRANK</span><br><span class="line">ZREVRANGE</span><br><span class="line">ZREVRANGEBYSCORE</span><br></pre></td></tr></table></figure><h1 id="Redis进阶"><a href="#Redis进阶" class="headerlink" title="Redis进阶"></a>Redis进阶</h1><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h3><p>如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>MULTI</code></td><td style="text-align:center">标记一个事务块的开始。事务块内的多条命令会按照先后顺序被放进一个<strong>队列</strong>当中，最后由 <code>EXEC</code>命令<strong>原子性</strong>地执行。</td></tr><tr><td style="text-align:center"><code>EXEC</code></td><td style="text-align:center">执行所有事务块内的命令。</td></tr><tr><td style="text-align:center"><code>WATCH</code></td><td style="text-align:center">监视一个(或多个) key ，如果在事务执行(<code>EXEC</code>)之前这个(或这些) key 被其他命令所改动，那么事务将被打断。</td></tr><tr><td style="text-align:center"><code>DISCARD</code></td><td style="text-align:center">取消事务，放弃执行事务块内的所有命令。如果正在使用 <code>WATCH</code>命令监视某个(或某些) key，那么取消所有监视，等同于执行命令 <code>UNWATCH</code>。</td></tr><tr><td style="text-align:center"><code>UNWATCH</code></td><td style="text-align:center">取消 <code>WATCH</code>命令对所有 key 的监视。</td></tr></tbody></table></div><h3 id="事务中的错误处理"><a href="#事务中的错误处理" class="headerlink" title="事务中的错误处理"></a>事务中的错误处理</h3><p>如果事务中的命令有<strong>语法错误</strong>，那么Redis执行<code>EXEC</code>命令后会直接返回错误，<strong>所有命令都不会执行</strong>；</p><p>如果事务中的命令语法没有错误，在执行<code>EXEC</code>命令后<strong>运行中出错</strong>（比如使用使用散列类型的命令操作集合类型的数据），那么其他<strong>正确的命令依旧会被执行</strong>。</p><p>注意，<strong>Redis中的事务不支持回滚</strong>，因此如果发生运行时错误，那么程序员就需要手动操作了，因此一定要注意命名规范避免运行时错误。</p><h2 id="过期时间"><a href="#过期时间" class="headerlink" title="过期时间"></a>过期时间</h2><h3 id="命令-1"><a href="#命令-1" class="headerlink" title="命令"></a>命令</h3><p>如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>EXPIRE</code>/<code>EXPIREAT</code></td><td style="text-align:center">为给定key设置过期时间，单位：秒；后者为接受的时间参数为Unix时间戳</td></tr><tr><td style="text-align:center"><code>PEXPIRE</code>/<code>PEXPIREAT</code></td><td style="text-align:center">为给定key设置过期时间，单位：毫秒；后者为接受的时间参数为Unix时间戳</td></tr><tr><td style="text-align:center"><code>TTL</code></td><td style="text-align:center">返回给定key的剩余生存时间，单位：秒。当 <code>key</code> 不存在时，返回 <code>-2</code> ；当 <code>key</code> 存在但没有设置剩余生存时间时，返回 <code>-1</code> 。</td></tr><tr><td style="text-align:center"><code>PTTL</code></td><td style="text-align:center">除了返回值单位为毫秒以外，其余同<code>TTL</code>。</td></tr><tr><td style="text-align:center"><code>PERSIST</code></td><td style="text-align:center">取消key的过期时间设置。</td></tr></tbody></table></div><h3 id="实现缓存"><a href="#实现缓存" class="headerlink" title="实现缓存"></a>实现缓存</h3><p>为了提高网站的负载能力，常常需要将一些访问频率较高并且对CPU/IO资源消耗较大的操作结果缓存起来，并希望让这些缓存过一段时间自动过期。</p><p>实际开发中会发现很难为缓存键设置合理的过期时间，为此<strong>可以通过限制Redis能够使用的最大内存，并让Redis按照一定的规则淘汰不需要的缓存键，这种方式在只将Redis用作缓存数据库时非常实用。</strong></p><p>具体的设置方法为：修改redis.conf中的<strong>maxmemory</strong>参数(单位为字节)，当超出限制后Redis会根据<strong>maxmemory-policy</strong>参数指定的策略来删除键，直到Redis占用的内存小于指定的值。maxmemory-policy支持的规则如下表所示：</p><div class="table-container"><table><thead><tr><th style="text-align:center">内存淘汰规则</th><th>说明</th></tr></thead><tbody><tr><td style="text-align:center">volatile-lru</td><td>使用LRU算法删除一个设置了过期时间的键。</td></tr><tr><td style="text-align:center">allkeys-lru</td><td>使用LRU算法删除一个键</td></tr><tr><td style="text-align:center">volatile-random</td><td>随机删除一个设置了过期时间的键</td></tr><tr><td style="text-align:center">allkeys-random</td><td>随机删除一个键</td></tr><tr><td style="text-align:center">volatile-ttl</td><td>删除过期时间最近的一个键</td></tr><tr><td style="text-align:center">noeviction</td><td>不删除键，只返回错误</td></tr></tbody></table></div><p>注：对于LRU算法，事实上Redis并不会准确地将整个数据库中最久未使用的键删除，而是每次从数据库中随机选3个键并删除这三个键中最久未使用的键。volatile-ttl规则也是如此。“3”这个数字可以通过参数maxmemory-samples配置。</p><h2 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h2><p>使用<code>SORT</code>命令：<code>SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC | DESC] [ALPHA] [STORE destination]</code>。参考：<a href="http://doc.redisfans.com/key/sort.html" target="_blank" rel="noopener">SORT</a>.</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>由于客户端和Redis服务器使用TCP连接，网络传输是有时延的，在执行多个命令时每条命令都要等待上一条命令执行完才能执行，即使命令不需要上一条命令的执行结果，这样的话总时延是很高的，会对性能产生很大的影响。因此<strong>Redis底层通信协议对管道提供了支持，通过管道可以一次性发送多条命令并在执行完后一次性将结果返回</strong>。</p><p><strong>Spring Data Redis对管道的支持</strong>： If you do not care about the results of the pipelined operations, you can use the standard <code>execute</code> method, passing <code>true</code> for the <code>pipeline</code> argument. The <code>executePipelined</code> methods run the provided <code>RedisCallback</code> or <code>SessionCallback</code> in a pipeline and return the results, as shown in the following example:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//pop a specified number of items from a queue</span></span><br><span class="line">List&lt;Object&gt; results = stringRedisTemplate.executePipelined(</span><br><span class="line">  <span class="keyword">new</span> RedisCallback&lt;Object&gt;() &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">doInRedis</span><span class="params">(RedisConnection connection)</span> <span class="keyword">throws</span> DataAccessException </span>&#123;</span><br><span class="line">      StringRedisConnection stringRedisConn = (StringRedisConnection)connection;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt; batchSize; i++) &#123;</span><br><span class="line">        stringRedisConn.rPop(<span class="string">"myqueue"</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h1 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h1><p>Redis支持RDB和AOF两种持久化方式，实际生产中常一起使用。一起使用时重启Redis会优先采用AOF文件恢复。</p><h2 id="RDB方式"><a href="#RDB方式" class="headerlink" title="RDB方式"></a>RDB方式</h2><p>Redis会在以下几种情况下自动将内存中的<strong>所有数据</strong>生产一份副本并存储在硬盘上，这个过程称为<strong>快照</strong>：</p><ul><li>根据配置文件指定的规则进行自动快照；</li><li>用户执行了<code>SAVE</code>或<code>BGSAVE</code>命令；</li><li>执行<code>FLUSHALL</code>命令；</li><li>执行<strong>复制</strong>(replication)时。</li></ul><p>Redis默认将快照文件存储在Redis当前进程的工作目录中的<strong>dump.rdb</strong>文件中，可以通过配置<code>dir</code>和<code>dbfilename</code>两个参数分别修改。</p><p>RDB文件是经过压缩的二进制格式，可以通过配置<code>rdbcompression</code>参数禁用压缩节省CPU资源。</p><p>Redis启动后会读取RDB快照文件，将数据从硬盘载入到内存。</p><h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3><p>配置文件中自动快照的条件由两个参数构成：时间窗口M和改动的键的个数N，每当M秒内被更改的键个数大于N个时，Redis进行自动快照。redis.conf默认设置了三个条件，它们之间是<strong>或</strong>的关系：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">save 900 1 #900秒内有一个或一个以上的键被更改则进行快照</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure><h3 id="SAVE-BGSAVE"><a href="#SAVE-BGSAVE" class="headerlink" title="SAVE/BGSAVE"></a>SAVE/BGSAVE</h3><p>当进行服务重启、手动迁移以及备份时我们也需要手动执行快照操作。</p><ul><li><code>SAVE</code>：<strong>同步</strong>进行快照操作，快照执行过程中<strong>阻塞</strong>所有来自客户端的请求。尽量避免在生产环境中使用该命令。</li><li><code>BGSAVE</code>：后台<strong>异步</strong>进行快照操作，快照执行过程中可以继续响应来自客户端的请求。可以通过<code>LASTSAVE</code>命令获取最近一次成功执行快照的时间，以此判断后台快照是否执行完成。推荐使用该方式。</li></ul><h3 id="FLUSHALL"><a href="#FLUSHALL" class="headerlink" title="FLUSHALL"></a>FLUSHALL</h3><p>如果配置文件中没有配置自动快照条件，执行<code>FLUSHALL</code>则不会进行快照；否则就算<code>FLUSHALL</code>没有触发配置的条件，依旧会执行一次快照。</p><h3 id="复制"><a href="#复制" class="headerlink" title="复制"></a>复制</h3><p>主从复制过程中的<strong>复制初始化阶段</strong>会进行自动快照。</p><h3 id="快照原理"><a href="#快照原理" class="headerlink" title="快照原理"></a>快照原理</h3><p>快照的流程：</p><ol><li>Redis调用linux的fork函数复制一份当前进程（父进程）的副本（子进程）；</li><li>父进程继续接受并处理客户端发送的命令，子进程开始将内存中的数据写入硬盘中的临时文件；</li><li>当子进程写入完毕后，用临时文件替换旧的RDB文件，至此一次快照操作完成。</li></ol><p>注意：在执行fork函数时Linux会采用<strong>写时复制策略</strong>，即fork函数发生的一刻父子进程共享同一内存数据，快照过程中若父进程要更改某片数据，操作系统会将该片数据复制一份，共享内存中的数据不会被修改，因此<strong>新RDB文件不会受快照过程中的修改的影响</strong>。</p><h2 id="AOF方式"><a href="#AOF方式" class="headerlink" title="AOF方式"></a>AOF方式</h2><p>通过RDB方式实现持久化，一旦Redis异常退出，就会丢失最后一次快照以后更改的所有数据，因此开发者除了需要通过组合配置自动快照的条件以外，最好结合AOF一起使用。</p><p>AOF可以将Redis执行的每一条<strong>写</strong>命令追加到硬盘文件中，默认文件名为<strong>appendonly.aof</strong>，可通过参数<code>appendfilename</code>修改。Redis启动时会逐个执行AOF文件中的命令来将硬盘中的数据载入到内存中，载入速度较RDB文件慢一些。</p><p>默认情况下Redis是没有开启AOF方式的，我们可以通过配置<code>appendonly yes</code>参数来启动。</p><p>考虑以下三条写命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">SET foo 1</span><br><span class="line">SET foo 2</span><br><span class="line">SET foo 3</span><br></pre></td></tr></table></figure><p>最终内存中键foo的值为3，前两条命令是冗余的，为避免AOF文件太大，Redis进行了优化，每当达到一定条件时就<strong>自动重写</strong>AOF文件，配置如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">auto-aof-rewrite-percentage 100 #若当前aof文件超过上次重写的aof文件大小的100%，则再次重写，若之前未重写过则以启动时的aof文件为依据</span><br><span class="line">auto-aof-rewrite-min-size 64mb #只有当aof文件超过64mb时才允许重写</span><br></pre></td></tr></table></figure><p>另外，我们也可通过<code>BGREWRITEAOF</code>命令手动执行重写。</p><h3 id="同步硬盘数据"><a href="#同步硬盘数据" class="headerlink" title="同步硬盘数据"></a>同步硬盘数据</h3><p>由于硬盘缓存的存在，操作系统默认每30秒才执行一次同步操作，将缓存数据真正写入硬盘，这对启用AOF持久化的应用是无法忍受的，因此需要在写入AOF文件后主动要求系统进行同步。在配置文件中设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#appendfsync always #每次写入都同步</span><br><span class="line">appendfsync everysec #每秒</span><br><span class="line">#appendfsync no #不主动进行同步</span><br></pre></td></tr></table></figure><p>Redis默认每秒执行一次同步操作。</p><h1 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h1><h2 id="主从复制"><a href="#主从复制" class="headerlink" title="主从复制"></a>主从复制</h2><p>为避免单点故障，可采用主从复制的部署模式。主（master）服务器可以进行<strong>读写</strong>操作，当写操作导致数据变化时会自动将数据同步给从（slave）服务器。而从服务器一般是<strong>只读</strong>的。一个master可以拥有多个slave，而一个slave只能有一个master。</p><p>主从复制配置方式有以下三种，其中主服务器无需任何配置：</p><ul><li>从服务器配置文件添加：<code>slaveof MASTER_IP MASTER_PORT</code></li><li>从服务器启动时命令行添加：<code>redis-server --port SLAVE_PORT --slaveof MASTER_IP MASTER_PORT</code></li><li>从服务器运行时设置：<code>SLAVEOF MASTER_IP MASTER_PORT</code>，如果执行该命令时该服务器已经是另一个master的slave，则停止和原master的同步，转而和新的master进行同步。另外，还可使用<code>SLAVEOF NO ONE</code>命令终止主从关系，甚至自身成为其他slave的master。</li></ul><h2 id="主从复制的原理"><a href="#主从复制的原理" class="headerlink" title="主从复制的原理"></a>主从复制的原理</h2><p><strong>复制初始化</strong>：当一个slave启动后，会向master发送<code>SYNC</code>内部命令，master接收到命令后在后台进行快照（RDB持久化），并将保存快照期间接受的命令缓存起来。快照完成后，Redis会将快照文件和缓存的命令发送给slave，slave收到后载入快照文件并执行缓存的命令。</p><p><strong>复制同步阶段</strong>：复制初始化结束后，master每当收到写命令时就会将命令同步给slave，从而保证主从服务器数据一致。</p><p><strong>断线重连</strong>：主从服务器之间的连接断开重连后，Redis2.6及之前会重新进行复制初始化，而Redis2.8之后开始支持增量数据传输，即master只将断线期间执行的命令发送给slave。断线期间执行的命令存储在一个<strong>积压队列</strong>中，它是一个固定长度的循环队列，默认大小为1MB，可通过参数<code>repl-backlog-size</code>设置。</p><p><strong>初步配置解决master和slave之间的数据不一致问题</strong>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">min-slaves-to-write 3 #只有当3个或以上的slave连接到master时，master才是可写的</span><br><span class="line">min-slaves-max-lag 10 #允许slave断连的最长时间为10秒，超过10秒则master拒绝写入</span><br></pre></td></tr></table></figure><p>Tips：</p><ol><li>slave不仅可以接收master的同步数据，自身也可以作为其他slave的master。</li><li>通过设置master只写、slave只读实现读写分离，适用于读多写少的场景。</li><li>为了提高性能，可禁用master的持久化功能，只开启slave的持久化功能。注意，这种情况下master一定不能用进程管理工具设置Redis崩溃后自动重启，否则master的数据丢失了，slave的数据也会被覆盖清空。</li><li>无硬盘复制：<code>repl-diskless-sync yes</code>；开启后，复制初始化时不再将数据存储在硬盘上，而是直接通过网络发送给slave。</li></ol><h2 id="哨兵机制"><a href="#哨兵机制" class="headerlink" title="哨兵机制"></a>哨兵机制</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>在一个典型的一主多从的Redis系统中，slave起到了数据冗余备份和读写分离的作用，当master宕机后，需要人工介入才能恢复系统。为此，Redis2.8之后提供了<strong>哨兵机制来实现自动化的系统监控和故障恢复</strong>。</p><p>哨兵是一个独立的进程，功能主要有两个：</p><ol><li>监控master和slave是否正常运行；</li><li><strong>master故障时自动将slave转换为新master</strong>。</li></ol><p>一个主从系统中可以有多个哨兵，一个哨兵也可以监控多个主从系统，哨兵之间可以互相监控，以保证系统足够稳健。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ol><li><p>新建配置文件sentinel.conf：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sentinel monitor MASTER_NAME MASTER_IP MASTER_PORT 最低通过票数（执行故障恢复至少需要几个哨兵节点同意） </span><br><span class="line">例如：sentinel monitor mymaster 127.0.0.1 6379 1</span><br></pre></td></tr></table></figure></li><li><p>启动哨兵进程：<code>redis-sentinel /PATH/sentinel.conf</code></p></li><li><p>其他<a href="http://doc.redisfans.com/topic/sentinel.html#id4" target="_blank" rel="noopener">哨兵配置参数参考</a>。</p></li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p>哨兵和master建立连接后，会定时执行以下三个操作，贯穿哨兵进程的整个生命周期：</p><ol><li>每10秒向master和slave发送 <a href="http://doc.redisfans.com/server/info.html" target="_blank" rel="noopener">INFO</a> 命令来获取信息更新并进行相应的操作，比如与新增的slave建立连接并加入监控列表，对主从服务器角色变化进行信息更新等。</li><li>每2秒向master和slave的<code>_sentinel_:hello</code>频道发送自己的信息，该频道用以获取其他同样监控master/slave的哨兵节点的信息，或向它们分享自己的信息。</li><li>每1秒向master、slave和其他哨兵节点发送<code>PING</code>命令，用于监控数据库和其他哨兵节点有没有停止服务。时间间隔可通过<code>down-after-milliseconds</code>配置，若其值小于1000ms，则按指定的间隔发送<code>PING</code>，若值大于1000ms，则每隔1秒发送。</li></ol><p>若超过<code>down-after-milliseconds</code>指定时间后<code>PING</code>的节点未回复，则哨兵认为其<strong>主观下线（subjectively down）</strong>。如果该节点是主服务器，哨兵会进一步判断是否需要对其进行故障恢复：发送<code>SENTINEL is-master-down-by-addr</code>命令询问其他哨兵是否也认为该服务器<strong>主观下线</strong>。若返回结果计数达到sentinel.conf中配置的<strong>最低通过票数</strong>，则哨兵认为主服务器<strong>客观下线（objectively down）</strong>，接下来使用<em>Raft</em>算法选举领头的哨兵对主从系统发起故障恢复。选举领头哨兵可以保证同一时间内只有一个哨兵节点来执行故障恢复。</p><p>故障恢复就是从多个slave中挑选优先级最高的作为新的master，优先级可通过<code>slave-priority</code>配置。</p><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>相对稳妥的哨兵部署方案是：</p><ul><li>为每个节点部署一个哨兵。</li><li>使每个哨兵与其对应的节点的网络环境相同或相互近。</li><li>设置最低通过投票数为(N/2 + 1)，N为哨兵个数。</li></ul><h2 id="集群-1"><a href="#集群-1" class="headerlink" title="集群"></a>集群</h2><p>集群与哨兵的区别在于，集群着眼于水平扩展容量，哨兵着眼于高可用性，哨兵可以属于集群的子集。</p><p>Redis 集群不支持那些需要同时处理多个键的 Redis 命令（如<code>MGET</code>）， 因为执行这些命令需要在多个 Redis 节点之间移动数据， 并且在高负载的情况下， 这些命令将降低 Redis 集群的性能， 并导致不可预测的行为。</p><p>Redis 集群<strong>通过分区（partition）来提供一定程度的可用性</strong>）： 即使集群中有一部分节点失效或者无法进行通讯， 集群也可以继续处理命令请求。</p><p>Redis 集群使用<strong>数据分片（sharding）</strong>而非一致性哈希（consistency hashing）来实现 。</p><p>详细配置过程与原理见：<a href="http://doc.redisfans.com/topic/cluster-tutorial.html" target="_blank" rel="noopener">Redis集群教程</a>。</p><h1 id="Spring-Data-Redis"><a href="#Spring-Data-Redis" class="headerlink" title="Spring Data Redis"></a>Spring Data Redis</h1><p>参考：<a href="https://docs.spring.io/spring-data/redis/docs/current/reference/html/#redis" target="_blank" rel="noopener">Spring官方文档</a>.</p><h1 id="常见面试问题"><a href="#常见面试问题" class="headerlink" title="常见面试问题"></a>常见面试问题</h1><p>参考：<a href="http://dreamcat.ink/2020/03/31/ge-ren-tu-xie-xi-lie-zong-jie-redis/#Redis%E4%BA%8B%E5%8A%A1" target="_blank" rel="noopener">DreamCats</a>.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#简介&quot;&gt;简介&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#启动Redis&quot;&gt;启动Redis&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#基础命令&quot;&gt;基础命令&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#
      
    
    </summary>
    
    
      <category term="数据库" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    
      <category term="Redis" scheme="http://thmasterplan.cn/tags/Redis/"/>
    
  </entry>
  
  <entry>
    <title>(三)秒杀项目优化之多级缓存</title>
    <link href="http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(3)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/"/>
    <id>http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(3)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%A4%9A%E7%BA%A7%E7%BC%93%E5%AD%98/</id>
    <published>2020-11-12T09:35:07.000Z</published>
    <updated>2020-11-23T14:23:20.925Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#Redis缓存">Redis缓存</a></p><p><a href="#本地热点缓存">本地热点缓存</a></p><p><a href="#Nginx代理服务器缓存">Nginx代理服务器缓存</a></p><h1 id="Redis缓存"><a href="#Redis缓存" class="headerlink" title="Redis缓存"></a>Redis缓存</h1><p>使用Redis缓存可分为单机模式，sentinel哨兵模式，和cluster集群模式，区别仅仅在于吞吐量的提升，由于条件有限本实验仅采用单机模式。</p><p>将商品详情页的数据缓存在Controller层，下次访问相同数据则不再调用Service和Dao访问数据库。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取商品详情页</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line"><span class="meta">@ResponseBody</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//根据商品的id到redis获取ItemModel,记住ItemModel及其成员变量一定要实现Serializable接口</span></span><br><span class="line">    ItemModel itemModel = (ItemModel) redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//若redis内不存在对应的ItemModel，则访问下游service</span></span><br><span class="line">    <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">        itemModel = itemService.getItemById(id);</span><br><span class="line">        <span class="comment">//设置itemModel到Redis内</span></span><br><span class="line">        redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">        <span class="comment">//设置缓存失效时间</span></span><br><span class="line">        redisTemplate.expire(<span class="string">"item_"</span>+id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">    &#125;</span><br><span class="line">    ItemVO itemVO = convertVOFromModel(itemModel);</span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="本地热点缓存"><a href="#本地热点缓存" class="headerlink" title="本地热点缓存"></a>本地热点缓存</h1><p>使用Redis缓存需要通过网络IO访问Redis服务器，因此使用本地热点缓存进一步提升吞吐量。本地热点缓存的特点：</p><ul><li>仅缓存热点数据（指那些频繁被访问，变化频率小，在内存中生命周期短的数据，本项目中主要是秒杀活动中的商品详情页）；</li><li>脏读非常不敏感（即使有脏读问题也不大）；</li><li>内存可控（JVM堆栈的内存）。</li></ul><p>我们<strong>使用Guava cache做本地缓存</strong>，它：</p><ul><li>使用哈希表作为容器；</li><li>线程安全；</li><li>可控制key的数量和超时时间；</li><li>可配置LRU算法。</li></ul><ol><li><p>引入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.google.guava<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>guava<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>18.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>业务层实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 封装本地缓存操作类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line">    <span class="comment">//存方法</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//取方法</span></span><br><span class="line">    <span class="function">Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span>(<span class="string">"cacheService"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheServiceImpl</span> <span class="keyword">implements</span> <span class="title">CacheService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Cache&lt;String,Object&gt; commonCache = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//cacheService生命周期中的初始化方法</span></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        commonCache = CacheBuilder.newBuilder()</span><br><span class="line">                .initialCapacity(<span class="number">10</span>)<span class="comment">//设置缓存容器的初始容量为10</span></span><br><span class="line">                .maximumSize(<span class="number">100</span>)<span class="comment">//设置缓存最多100个key，超过后按照LRU算法移除缓存项</span></span><br><span class="line">                .expireAfterWrite(<span class="number">30</span>, TimeUnit.SECONDS)<span class="comment">//设置写缓存后多少秒过期</span></span><br><span class="line">                .build();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setCommonCache</span><span class="params">(String key, Object value)</span> </span>&#123;</span><br><span class="line">        commonCache.put(key,value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">getFromCommonCache</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonCache.getIfPresent(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>修改获取商品详情页的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取商品详情页，使用本地缓存和Redis缓存</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/get"</span>)</span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> CommonReturnType <span class="title">getItem</span><span class="params">(@RequestParam(name = <span class="string">"id"</span>)</span>Integer id)</span>&#123;</span><br><span class="line"></span><br><span class="line">        ItemModel itemModel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1. 先取本地缓存</span></span><br><span class="line">        itemModel = (ItemModel)cacheService.getFromCommonCache(<span class="string">"item_"</span>+id);</span><br><span class="line">        <span class="comment">//2. 若本地缓存内不存在对应的ItemModel，则访问Redis缓存</span></span><br><span class="line">        <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//2.1. 根据商品的id到redis获取ItemModel,记住ItemModel及其成员变量一定要实现Serializable接口</span></span><br><span class="line">            itemModel = (ItemModel) redisTemplate.opsForValue().get(<span class="string">"item_"</span>+id);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//2.2. 若redis内不存在对应的ItemModel，则访问下游service</span></span><br><span class="line">            <span class="keyword">if</span>(itemModel == <span class="keyword">null</span>) &#123;</span><br><span class="line">                itemModel = itemService.getItemById(id);</span><br><span class="line">                <span class="comment">//设置itemModel到Redis内</span></span><br><span class="line">                redisTemplate.opsForValue().set(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">                <span class="comment">//设置缓存失效时间</span></span><br><span class="line">                redisTemplate.expire(<span class="string">"item_"</span>+id, <span class="number">10</span>, TimeUnit.MINUTES);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//2.3. 设置itemModel到本地缓存</span></span><br><span class="line">            cacheService.setCommonCache(<span class="string">"item_"</span>+id,itemModel);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ItemVO itemVO = convertVOFromModel(itemModel);</span><br><span class="line">        <span class="keyword">return</span> CommonReturnType.create(itemVO);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><h1 id="Nginx代理服务器缓存"><a href="#Nginx代理服务器缓存" class="headerlink" title="Nginx代理服务器缓存"></a>Nginx代理服务器缓存</h1><p>Nginx作为反向代理服务器配置缓存时，缓存内容以文件的形式存储在磁盘中，文件的地址则存储在内存中。在配置文件nginx.conf中配置proxy_cache：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置缓存数据的路径以及和缓存索引相关的内容</span></span><br><span class="line"><span class="comment">#levels:设置在相对于path指定目录的第2级目录中缓存数据，目录名称根据请求URL通过哈希算法得到。</span></span><br><span class="line"><span class="comment">#keys_zone:设置存放缓存索引的内存区域的名称与大小（100MB）。</span></span><br><span class="line"><span class="comment">#inactive:缓存数据失效时间，过期则删除，再次请求时重新从后端服务器获取。</span></span><br><span class="line"><span class="comment">#max_size:缓存数据最大容量，超过则根据LRU算法删除部分缓存。</span></span><br><span class="line">proxy_cache_path /usr/local/openresty/nginx/tmp_cache levels=<span class="number">1</span>:<span class="number">2</span> keys_zone=tmp_cache:<span class="number">100</span>m inactive=<span class="number">7</span>d max_size=<span class="number">10</span>g;</span><br></pre></td></tr></table></figure><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">     proxy_pass http:<span class="comment">//backend_server;</span></span><br><span class="line">     proxy_cache tmp_cache;<span class="comment">#配置一块公用的内存区域的名称，该区域可存放缓存的索引数据</span></span><br><span class="line">     proxy_cache_key $uri;<span class="comment">#配置在内存中为缓存建立索引时使用的key，使用uri</span></span><br><span class="line">     proxy_cache_valid <span class="number">200</span> <span class="number">206</span> <span class="number">304</span> <span class="number">302</span> <span class="number">7</span>d;<span class="comment">#缓存HTTP状态码为200/206/304/302的响应数据</span></span><br><span class="line"></span><br><span class="line">     proxy_set_header Host $http_host;</span><br><span class="line">     proxy_set_header X-Real-IP $remote_addr;</span><br><span class="line">     proxy_set_header X-Forwarded-<span class="keyword">For</span> %proxy_add_x_forwarded_for;</span><br><span class="line">     proxy_http_version <span class="number">1.1</span>;</span><br><span class="line">     proxy_set_header Connection <span class="string">""</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>由于缓存内容存于磁盘中，效率其实还不如Redis缓存和本地热点缓存，因此不推荐使用proxy cache，实际开发中可以使用openresty的shared dict作为前置缓存，或者使用openresty对Redis的支持。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#Redis缓存&quot;&gt;Redis缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#本地热点缓存&quot;&gt;本地热点缓存&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#Nginx代理服务器缓存&quot;&gt;Nginx代理服务器缓存&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Redis缓存&quot;&gt;&lt;
      
    
    </summary>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>(二)秒杀项目优化之Nginx反向代理与分布式会话</title>
    <link href="http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(2)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8BNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/"/>
    <id>http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(2)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8BNginx%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86%E4%B8%8E%E5%88%86%E5%B8%83%E5%BC%8F%E4%BC%9A%E8%AF%9D/</id>
    <published>2020-11-11T15:21:00.000Z</published>
    <updated>2020-11-23T14:51:23.228Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#水平扩展">水平扩展</a></p><ul><li><p><a href="#Spring Boot应用部署">Spring Boot应用部署</a></p></li><li><p><a href="#MySQL授权给远端连接">MySQL授权给远端连接</a></p></li></ul><p><a href="#Nignx反向代理">Nignx反向代理</a></p><ul><li><p><a href="#安装OpenResty">安装OpenResty</a></p></li><li><p><a href="#静态资源部署">静态资源部署</a></p></li><li><p><a href="#动态请求转发">动态请求转发</a></p><ul><li><p><a href="#设置upstream server">设置upstream server</a></p></li><li><p><a href="#设置动态请求location为proxy pass路径">设置动态请求location为proxy pass路径</a></p></li><li><p><a href="#开启tomcat access log">开启tomcat access log</a></p></li></ul></li><li><p><a href="#考虑局域网连接的建立与释放的消耗">考虑局域网连接的建立与释放的消耗</a></p></li><li><p><a href="#Nginx高性能原因">Nginx高性能原因</a></p></li></ul><p><a href="#分布式会话管理">分布式会话管理</a></p><ul><li><p><a href="#Cookie方式">Cookie方式</a></p></li><li><p><a href="#Token方式">Token方式</a></p></li></ul><h1 id="水平扩展"><a href="#水平扩展" class="headerlink" title="水平扩展"></a>水平扩展</h1><h2 id="Spring-Boot应用部署"><a href="#Spring-Boot应用部署" class="headerlink" title="Spring Boot应用部署"></a>Spring Boot应用部署</h2><p>之前的压测MySQL与Tomcat在同一台主机上，因此我们需要分布式扩展服务器，引入Nginxx做动静分离和负载均衡，静态请求由Nginx处理（注意企业级应用一般会使用NAS存储），动态请求转发给Tomcat，MySQL单独占用一台主机。其结构图如下：</p><p><img src="struc.PNG" alt=""></p><p>本实验使用阿里云ECS服务器，如图所示：</p><p><img src="aliyun_ecs.png" alt=""></p><p>修改阿里云安全组，添加开放端口号：</p><p><img src="aliyun_ecs_sec.PNG" alt=""></p><p>接着配置好各台主机的开发环境。</p><p>部署好开发环境后，将项目jar包上传到各台应用服务器上，在application配置文件中配置数据库连接池地址，覆盖我们开发时配置的本机地址：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">spring.datasource.url</span>=<span class="string">jdbc:mysql://172.30.215.166:3306/miaosha?useUnicode=true&amp;characterEncoding=UTF-8</span></span><br></pre></td></tr></table></figure><p>使用<code>telnet</code>命令测试能否连接数据库：<code>telnet 172.30.215.166 3306</code>，结果显示连接不被允许：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Trying 172.30.215.166...</span><br><span class="line">Connected to 172.30.215.166.</span><br><span class="line">Escape character is &#39;^]&#39;.</span><br><span class="line">HHost &#39;172.30.19.131&#39; is not allowed to connect to this MariaDB serverConnection closed by foreign host.</span><br></pre></td></tr></table></figure><h2 id="MySQL授权给远端连接"><a href="#MySQL授权给远端连接" class="headerlink" title="MySQL授权给远端连接"></a>MySQL授权给远端连接</h2><p>我们需要MySQL授权给应用服务器，切换至MySQL服务器进入MySQL：</p><p><code>grant all privileges on *.* to USERNAME@&#39;%&#39; identified by &#39;PASSWORD&#39;;</code>，只要用户名和密码正确，授权来自任何域名的数据库访问。</p><p><code>flush privileges;</code>：刷新权限。</p><h1 id="Nignx反向代理"><a href="#Nignx反向代理" class="headerlink" title="Nignx反向代理"></a>Nignx反向代理</h1><p>OpenResty是一个基于 Nginx与 Lua 的高性能 Web 平台，参考<a href="http://openresty.org/cn/" target="_blank" rel="noopener">OpenResty中文官网</a>。</p><h2 id="安装OpenResty"><a href="#安装OpenResty" class="headerlink" title="安装OpenResty"></a>安装OpenResty</h2><ol><li>安装依赖库：<code>yum install pcre-devel openssl-devel gcc curl</code></li><li>下载预编译包：<code>wget https://openresty.org/download/openresty-1.17.8.2.tar.gz</code></li><li>解包：<code>tar -xvzf openresty-1.17.8.2.tar.gz</code></li><li>编译：<code>./configure</code> -&gt; <code>make</code></li><li>安装：<code>make install</code>，默认安装路径为/usr/local/openresty</li><li>启动服务器：<ol><li><code>cd /usr/local/openresty/nginx</code></li><li>指定以nginx.conf配置启动，<code>sbin/nginx -c conf/nginx.conf</code></li><li>启动后若修改配置文件，<code>sbin/nginx -s reload</code>可无缝重启</li></ol></li></ol><h2 id="静态资源部署"><a href="#静态资源部署" class="headerlink" title="静态资源部署"></a>静态资源部署</h2><p>将前端相关资源上传到//usr/local/openresty/nginx/html目录下，新建目录resources，将html目录下所有静态资源移动到resources目录下。</p><p>修改nginx.conf：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">   root html;</span><br><span class="line">   index index.html index htm;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">#修改为</span></span><br><span class="line">location /resources/ &#123;</span><br><span class="line">   <span class="comment">#当访问路径命中/resources/时，将路径替换为以下路径</span></span><br><span class="line">   alias /usr/local/openresty/nginx/html/resources/;</span><br><span class="line">   index index.html index htm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="动态请求转发"><a href="#动态请求转发" class="headerlink" title="动态请求转发"></a>动态请求转发</h2><p>所有的静态页面都由Nnigx处理，例如访问<code>http://nginxserver/resources/templates/register.html</code>；所有的动态请求都转发给Tomcat，例如访问<code>http://nginxserver/item/get?id=1</code>。</p><h3 id="设置upstream-server"><a href="#设置upstream-server" class="headerlink" title="设置upstream server"></a>设置upstream server</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#设置两台应用服务器的地址，轮流访问</span></span><br><span class="line"><span class="comment">#weight即权重，两台服务器各承担一半的请求</span></span><br><span class="line">upstream backend_server &#123;</span><br><span class="line">      server <span class="number">172.30</span><span class="number">.215</span><span class="number">.165</span> weight=<span class="number">1</span>;</span><br><span class="line">      server <span class="number">172.30</span><span class="number">.19</span><span class="number">.131</span> weight=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="设置动态请求location为proxy-pass路径"><a href="#设置动态请求location为proxy-pass路径" class="headerlink" title="设置动态请求location为proxy pass路径"></a>设置动态请求location为proxy pass路径</h3><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">location / &#123;</span><br><span class="line">      proxy_pass http:<span class="comment">//backend_server; #反向代理</span></span><br><span class="line">      proxy_set_header Host $http_host:$proxy_port; <span class="comment">#设置Http的host字段</span></span><br><span class="line">      proxy_set_header X-Real-IP $remote_addr; <span class="comment">#设置客户端访问的IP，不设置则应用服务器拿到的是nginx服务器的地址</span></span><br><span class="line">      proxy_set_header X-Forwarded-<span class="keyword">For</span> %proxy_add_x_forwarded_for;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="开启tomcat-access-log"><a href="#开启tomcat-access-log" class="headerlink" title="开启tomcat access log"></a>开启tomcat access log</h3><p>开启tomcat访问日志记录，修改application配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.accesslog.enabled</span>=<span class="string">true</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.directory</span>=<span class="string">/var/www/miaosha/tomcat</span></span><br><span class="line"><span class="meta">server.tomcat.accesslog.pattern</span>=<span class="string">%h %l %u %t "%r" %s %b %D</span></span><br></pre></td></tr></table></figure><h2 id="考虑局域网连接的建立与释放的消耗"><a href="#考虑局域网连接的建立与释放的消耗" class="headerlink" title="考虑局域网连接的建立与释放的消耗"></a>考虑局域网连接的建立与释放的消耗</h2><p>由于Nginx反向代理服务器默认配置与后端服务器的连接是没有配置keepAlive的，因此大量动态资源请求时，Nginx与Tomcat的连接是短连接，会有大量连接的建立与释放，而Druid管理下应用服务器与数据库服务器之间连接则默认保持长连接。</p><p><strong>Nginx配置keepalive</strong>：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">upstream backend_server &#123;</span><br><span class="line">      server <span class="number">172.30</span><span class="number">.215</span><span class="number">.165</span> weight=<span class="number">1</span>;</span><br><span class="line">      server <span class="number">172.30</span><span class="number">.19</span><span class="number">.131</span> weight=<span class="number">1</span>;</span><br><span class="line">      keepalive <span class="number">30</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server&#123;</span><br><span class="line"></span><br><span class="line">   其他配置...</span><br><span class="line"></span><br><span class="line">   location / &#123;</span><br><span class="line">         proxy_pass http:<span class="comment">//backend_server; #反向代理</span></span><br><span class="line">         proxy_set_header Host $http_host:$proxy_port; <span class="comment">#设置Http的host字段</span></span><br><span class="line">         proxy_set_header X-Real-IP $remote_addr; <span class="comment">#设置客户端访问的IP，不设置则应用服务器拿到的是nginx服务器的地址</span></span><br><span class="line">         proxy_set_header X-Forwarded-<span class="keyword">For</span> %proxy_add_x_forwarded_for;</span><br><span class="line">         </span><br><span class="line">         proxy_http_version <span class="number">1.1</span>;<span class="comment">#Nginx默认采用http1.0，http1.1才有keepalive</span></span><br><span class="line">         proxy_set_header Connection <span class="string">""</span>;<span class="comment">#Connection为空就表示设置keepalive</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="Nginx高性能原因"><a href="#Nginx高性能原因" class="headerlink" title="Nginx高性能原因"></a>Nginx高性能原因</h2><ul><li><p>epoll多路复用</p></li><li><p>master worker进程模型</p></li><li><p>协程机制</p></li></ul><h1 id="分布式会话管理"><a href="#分布式会话管理" class="headerlink" title="分布式会话管理"></a>分布式会话管理</h1><p>我们<strong>通过将session保存到Redis服务器来实现分布式会话</strong>，有两种实现方式：</p><ul><li>基于Cookie传输JSESSIONID：Tomcat容器session实现迁移到Redis。</li><li>基于Token传输类似sessionid：Java代码session实现迁移到Redis。</li></ul><p>Windows下安装Redis用于调试程序：</p><ol><li><a href="https://github.com/microsoftarchive/redis/releases" target="_blank" rel="noopener">下载地址</a></li><li>安装完成后切换到安装目录，启动cmd</li><li>启动Redis服务器：<code>redis-server.exe redis.windows.conf</code></li><li>启动客户端：<code>redis-cli -h 127.0.0.1 -p 6379</code></li></ol><h2 id="Cookie方式"><a href="#Cookie方式" class="headerlink" title="Cookie方式"></a>Cookie方式</h2><ol><li><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.session<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-session-data-redis<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置application.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#配置SpringBoot对Redis的依赖</span></span><br><span class="line"><span class="meta">spring.redis.host</span>=<span class="string">127.0.0.1</span></span><br><span class="line"><span class="meta">spring.redis.port</span>=<span class="string">6379</span></span><br><span class="line"><span class="comment">#Redis默认16个数据库，指定其中某一个</span></span><br><span class="line"><span class="meta">spring.redis.database</span>=<span class="string">10</span></span><br><span class="line"><span class="comment">#spring.redis.password=</span></span><br><span class="line"><span class="comment">#设置Jedis连接池连接数量</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.max-active</span>=<span class="string">50</span></span><br><span class="line"><span class="meta">spring.redis.jedis.pool.min-idle</span>=<span class="string">20</span></span><br></pre></td></tr></table></figure></li><li><p>添加RedisConfig配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@EnableRedisHttpSession</span>(maxInactiveIntervalInSeconds = <span class="number">3600</span>) <span class="comment">//设置session失效时间，默认30min，修改为1h</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RedisConfig</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Session存储的对象需要实现Serializable接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request.getSession().setAttribute(<span class="string">"LOGIN_USER"</span>, userModel);</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserModel</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>本地调试登录功能，查看Redis服务器10号数据库是否有数据。</p></li><li><p>调试完没有问题后，重新生成jar包上传到应用服务器，然后云端搭建Redis服务器（为节省成本，这里Redis与MySQL使用同一台服务器）：</p><ol><li>yum安装或编译安装均可，yum安装会将相关命令放入/usr/bin，可以直接在任何地方访问，并且配置文件redis.conf在/etc/目录下。</li><li>修改redis.conf的server地址为服务器的局域网地址，以该配置文件启动：<code>redis-server /etc/redis.conf &amp;</code></li><li>修改两台应用服务器的application配置文件，配置spring.redis.host=redis所在服务器地址，启动应用。</li></ol></li></ol><h2 id="Token方式"><a href="#Token方式" class="headerlink" title="Token方式"></a>Token方式</h2><p>企业开发中应该使用这种方式，考虑到客户端的多平台特性，某些客户端可能不支持Cookie方式。</p><p>UserController的login方法中，原来的方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">request.getSession().setAttribute(<span class="string">"IS_LOGIN"</span>,<span class="keyword">true</span>);</span><br><span class="line">request.getSession().setAttribute(<span class="string">"LOGIN_USER"</span>, userModel);</span><br><span class="line"><span class="keyword">return</span> CommonReturnType.create(uuidToken);</span><br></pre></td></tr></table></figure><p>改为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RedisTemplate redisTemplate;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//3.修改为使用token的方式，将token和用户模型一起存入redis中</span></span><br><span class="line"><span class="comment">//生成登录凭证token</span></span><br><span class="line">String uuidToken = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>);</span><br><span class="line"><span class="comment">//建立token和用户登录态之间的联系</span></span><br><span class="line">redisTemplate.opsForValue().set(uuidToken, userModel);</span><br><span class="line"><span class="comment">//设置超时时间</span></span><br><span class="line">redisTemplate.expire(uuidToken, <span class="number">1</span>, TimeUnit.HOURS);</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> CommonReturnType.create(uuidToken);</span><br></pre></td></tr></table></figure><p>前端代码修改：</p><p>login.html，登录的ajax请求success回调函数中，若登录成功添加token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = data.data;</span><br><span class="line"><span class="built_in">window</span>.localStorage[<span class="string">"token"</span>] = token;</span><br></pre></td></tr></table></figure><p>获取商品下单时判断是否持有token：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> token = <span class="built_in">window</span>.localStorage[<span class="string">"token"</span>];</span><br><span class="line"><span class="keyword">if</span>(token == <span class="literal">null</span>)&#123;</span><br><span class="line">    alert(<span class="string">"没有登录，不能下单"</span>);</span><br><span class="line">    <span class="built_in">window</span>.location.href=<span class="string">"login.html"</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//修改ajax请求url，添加token登录凭证</span></span><br><span class="line">url:<span class="string">"http://"</span>+g_host+<span class="string">"/order/create?token="</span>+token,</span><br></pre></td></tr></table></figure><p>下单的Controller验证token：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">String token = request.getParameterMap().get(<span class="string">"token"</span>)[<span class="number">0</span>];</span><br><span class="line"><span class="keyword">if</span>(StringUtils.isEmpty(token))</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EnumBusinessError.USER_NOT_LOGIN,<span class="string">"用户未登录，无法下单"</span>);</span><br><span class="line">UserModel userModel = (UserModel) redisTemplate.opsForValue().get(token);</span><br><span class="line"><span class="keyword">if</span>(userModel == <span class="keyword">null</span>)</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EnumBusinessError.USER_NOT_LOGIN,<span class="string">"用户未登录，无法下单"</span>);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#水平扩展&quot;&gt;水平扩展&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#Spring Boot应用部署&quot;&gt;Spring Boot应用部署&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#MySQL授权给远端连接&quot;&gt;MySQL授权给
      
    
    </summary>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>(一)秒杀项目优化之定制化Tomcat配置</title>
    <link href="http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(1)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AE%9A%E5%88%B6%E5%8C%96Tomcat%E9%85%8D%E7%BD%AE/"/>
    <id>http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/(1)%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AE%9A%E5%88%B6%E5%8C%96Tomcat%E9%85%8D%E7%BD%AE/</id>
    <published>2020-11-09T14:21:23.000Z</published>
    <updated>2020-11-23T14:23:20.907Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#云端部署">云端部署</a></p><ul><li><p><a href="#安装JDK">安装JDK</a></p></li><li><p><a href="#安装MySQL">安装MySQL</a></p><ul><li><p><a href="#安装">安装</a></p></li><li><p><a href="#启动服务">启动服务</a></p></li><li><p><a href="#开机启动">开机启动</a></p></li><li><p><a href="#查看端口">查看端口</a></p></li><li><p><a href="#登录">登录</a></p></li></ul></li><li><p><a href="#备份本地数据库到云端">备份本地数据库到云端</a></p><ul><li><p><a href="#本地备份">本地备份</a></p></li><li><p><a href="#上传">上传</a></p></li><li><p><a href="#云端恢复">云端恢复</a></p></li></ul></li><li><p><a href="#本地应用程序打包部署到云端">本地应用程序打包部署到云端</a></p></li></ul><p><a href="#性能压测">性能压测</a></p><p><a href="#性能初步调优-定制化内嵌Tomcat配置">性能初步调优-定制化内嵌Tomcat配置</a></p><ul><li><p><a href="#修改全局配置文件">修改全局配置文件</a></p></li><li><p><a href="#修改源码">修改源码</a></p></li></ul><p><a href="#MySQL的QPS问题">MySQL的QPS问题</a></p><h1 id="云端部署"><a href="#云端部署" class="headerlink" title="云端部署"></a>云端部署</h1><p><a href="https://github.com/Laishiji/miaosha" target="_blank" rel="noopener">项目地址</a>.</p><h2 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h2><ol><li><code>yum -y install java</code></li><li><code>yum -y install java-1.8.0-openjdk-devel.x86_64</code></li></ol><h2 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h2><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><ol><li><code>yum install -y mysql*</code></li><li><code>yum install -y mariadb-server</code></li></ol><h3 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h3><p><code>systemctl start mariadb.service</code></p><h3 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h3><p><code>systemctl enable mariadb.service</code></p><h3 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h3><p><code>netstat -anp | grep 3306</code></p><h3 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h3><ol><li>初始化MySQL用户名和密码：<code>mysqladmin -u USERNAME password &#39;PASSWORD&#39;</code></li><li>登录：<code>mysql -u USERNAME -p</code></li></ol><h2 id="备份本地数据库到云端"><a href="#备份本地数据库到云端" class="headerlink" title="备份本地数据库到云端"></a>备份本地数据库到云端</h2><h3 id="本地备份"><a href="#本地备份" class="headerlink" title="本地备份"></a>本地备份</h3><p>使用<code>mysqldump</code>命令根据已有数据库创建SQL文件：<code>mysqldump -u USERNAME --databases 数据库名 -p &gt; /路径/miaosha.sql</code>。</p><h3 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h3><p>使用scp命令上传SQL文件到云端tmp目录下：<code>scp /路径/miaosha.sql USERNAME@IP:/tmp</code></p><h3 id="云端恢复"><a href="#云端恢复" class="headerlink" title="云端恢复"></a>云端恢复</h3><p>重定向IO即可：<code>mysql -u USERNAME -p &lt; ../tmp/miaosha.sql</code>。</p><h2 id="本地应用程序打包部署到云端"><a href="#本地应用程序打包部署到云端" class="headerlink" title="本地应用程序打包部署到云端"></a>本地应用程序打包部署到云端</h2><ol><li><code>mvn clean package</code>或直接IDE右侧运行maven命令，target目录中生成Spring Boot的jar包。</li><li>scp命令上传到云端。</li><li>防火墙添加端口：<code>firewall-cmd --zone=public --add-port=8080/tcp --permanent</code></li><li>更新防火墙规则：<code>firewall-cmd --reload</code></li><li>新建配置文件appication.properties，该配置文件优先级大于项目中的。</li><li>编写deploy.sh脚本部署：<code>./deploy.sh &amp;</code></li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addtion-location=/var/www/miaosha/application.properties</span><br></pre></td></tr></table></figure><h1 id="性能压测"><a href="#性能压测" class="headerlink" title="性能压测"></a>性能压测</h1><p>使用JMeter进行性能压测，测试环境：1核2g内存。简单入门：</p><ol><li><p>创建线程组</p></li><li><p>添加取样器：HTTP请求。（一定要勾选KeepAlive，此处指HTTP的connection选项而非TCP的keepAlive机制，TCP的keepAlive机制用于检测死连接，HTTP的则是为了在一个TCP连接发送多个HTTP请求）</p><p><img src="JMeterHttp.png" alt=""></p></li><li><p>添加监听器：察看结果树</p></li><li><p>添加监听器：聚合报告</p></li></ol><p>聚合报告列表的含义：</p><p><img src="JMeter.png" alt=""></p><ul><li>样本：表示进行了20次请求</li><li>平均值：平均响应时间，单位ms</li><li>中位数：中位数响应时间，单位ms</li><li>百分位：百分之多少的请求的响应时间</li><li>吞吐量：TPS, Throughput Percent Second</li></ul><p>查看Tomcat默认维护的线程池中线程数量：</p><ol><li>获取SpringBoot程序pid：<code>ps -ef | grep miaosha</code></li><li>计算线程数量：<code>pstree -p 4073 | wc -l</code>，结果为28</li></ol><h1 id="性能初步调优-定制化内嵌Tomcat配置"><a href="#性能初步调优-定制化内嵌Tomcat配置" class="headerlink" title="性能初步调优-定制化内嵌Tomcat配置"></a>性能初步调优-定制化内嵌Tomcat配置</h1><p><strong>压测</strong>：调整线程组线程数为5000，Ramp-Up时间为15秒，循环次数100，查看服务器线程数量，结果为218，压测结果显示有大量请求被拒绝。压测过程可使用<code>top -H</code>查看实时的进程动态。</p><p><strong>压测</strong>：调整线程组线程数为1000，Ramp-Up时间为15秒，循环次数50，查看服务器线程数量，结果为218，压测结果显示已经没有请求被拒绝。压测过程可使用<code>top -H</code>查看实时的进程动态。</p><p><img src="JMeter0.png" alt=""></p><h2 id="修改全局配置文件"><a href="#修改全局配置文件" class="headerlink" title="修改全局配置文件"></a>修改全局配置文件</h2><p>通过查看<strong>spring-configuration-metadata.json</strong>，查看Spring Boot内嵌Tomcat的默认配置，主要有以下几点：</p><ul><li><strong>server.tomcat.accept-count</strong>：Maximum queue length for incoming connection requests when all possible request processing threads are in use. 等待队列长度，默认为100</li><li><strong>server.tomcat.max-connections</strong>：最大可被连接数，默认8192</li><li><strong>server.tomcat.max-threads</strong>：最大工作线程数，默认200</li><li><strong>server.tomcat.min-spare-threads</strong>：最小工作线程数，默认10</li></ul><p>由此得知，默认配置下连接超过8192后出现拒绝连接情况；默认配置下，触发的请求超过最大工作线程数200+最大等待队列长度100后即300，拒绝处理。</p><p>在application.properties中配置以上参数以覆盖默认设置，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.accept-count</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.tomcat.max-threads</span>=<span class="string">400</span></span><br><span class="line"><span class="meta">server.tomcat.min-spare-threads</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure><p>一般来说4核8g内存最大线程数设置为800较为合理。杀掉进程重新部署后计算常驻线程数为118。</p><p><strong>再次压测</strong>：调整线程组线程数为1000，循环次数50，查看服务器线程数量，发现已经变为418，压测结果如下图：</p><p><img src="JMeter1.png" alt=""></p><p>由图可知，修改tomcat默认配置之后已经压测结果已经有所提升，但是单机TPS依旧只有309，响应时间依旧很长。</p><p>在实际开发中，以上四个参数需要视单个服务器具体的CPU和内存配置进行压测后才能得出最优配置。</p><h2 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h2><p>使用<code>WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;</code>类定制化内嵌Tomcat配置：</p><ul><li><p><strong>keepAliveTimeOut</strong>：多少毫秒后若客户端无请求则断开本次TCP连接。</p></li><li><p><strong>maxKeepAliveRequests</strong>：一次TCP连接支持多少个HTTP请求后断开失效。</p></li></ul><p>这两个设置可以避免DDOS攻击，以及在用户长时间不发请求时节省服务器资源。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会加载此bean到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用对应工厂类提供给我们的接口定制化Tomcat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定制化keepAliveTimeOut,30s内没有请求则服务端断开TCP连接</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定制化maxKeepAliveRequests</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="MySQL的QPS问题"><a href="#MySQL的QPS问题" class="headerlink" title="MySQL的QPS问题"></a>MySQL的QPS问题</h1><ul><li>主键查询：千万级别数据用时1-10ms；</li><li>唯一索引查询：千万级别数据用时10-100ms;</li><li>非唯一索引查询：千万级别数据用时100-1000ms；</li><li>无索引的普通字段查询：百万条数据用时1000ms+，全表扫描，不可接受。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#云端部署&quot;&gt;云端部署&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#安装JDK&quot;&gt;安装JDK&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#安装MySQL&quot;&gt;安装MySQL&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a hr
      
    
    </summary>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-03T08:41:33.000Z</published>
    <updated>2021-01-21T04:31:01.155Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#概述">概述</a></p><ul><li><a href="#设计模式的目的">设计模式的目的</a></li></ul><p><a href="#UML复习">UML复习</a></p><ul><li><p><a href="#类图">类图</a></p><ul><li><p><a href="#基础">基础</a></p></li><li><p><a href="#接口与实现">接口与实现</a></p></li><li><p><a href="#聚合">聚合</a></p></li><li><p><a href="#可见性">可见性</a></p></li></ul></li><li><p><a href="#时序图">时序图</a></p></li></ul><p><a href="#创建型模式">创建型模式</a></p><ul><li><p><a href="#单例（Singleton）">单例（Singleton）</a></p><ul><li><p><a href="#饿汉式（立即加载）">饿汉式（立即加载）</a></p><ul><li><p><a href="#静态常量">静态常量</a></p></li><li><p><a href="#静态代码块">静态代码块</a></p></li></ul></li><li><p><a href="#懒汉式（延迟加载）">懒汉式（延迟加载）</a></p><ul><li><p><a href="#线程不安全">线程不安全</a></p></li><li><p><a href="#线程不安全-同步代码块">线程不安全-同步代码块</a></p></li><li><p><a href="#线程安全-同步方法">线程安全-同步方法</a></p></li></ul></li><li><p><a href="#双重检查（Double-Check）">双重检查（Double Check）</a></p></li><li><p><a href="#静态内部类">静态内部类</a></p></li><li><p><a href="#枚举">枚举</a></p></li></ul></li><li><p><a href="#简单工厂（Simple-Factory）">简单工厂（Simple Factory）</a></p></li><li><p><a href="#工厂方法（Factory-Method）">工厂方法（Factory Method）</a></p></li><li><p><a href="#抽象工厂（Abstract-Factory）">抽象工厂（Abstract Factory）</a></p></li><li><p><a href="#原型（Prototype）">原型（Prototype）</a></p><ul><li><a href="#Shallow-Copy">Shallow Copy</a></li></ul></li></ul><ul><li><a href="#Deep-Copy">Deep Copy</a></li></ul><p><a href="#结构型模式">结构型模式</a></p><ul><li><p><a href="#适配器（Adapter）">适配器（Adapter）</a></p><ul><li><p><a href="#类适配器">类适配器</a></p></li><li><p><a href="#对象适配器">对象适配器</a></p></li><li><p><a href="#接口适配器">接口适配器</a></p></li></ul></li><li><p><a href="#装饰器（Decorator）">装饰器（Decorator）</a></p></li><li><p><a href="#代理（Proxy）">代理（Proxy）</a></p></li></ul><p><a href="#行为模式">行为模式</a></p><ul><li><p><a href="#模板方法（Template-Method）">模板方法（Template Method）</a></p></li><li><p><a href="#策略（Strategy）">策略（Strategy）</a></p></li><li><p><a href="#观察者（Observer）">观察者（Observer）</a></p></li><li><p><a href="#责任链（Chain-Of-Responsibility）">责任链（Chain Of Responsibility）</a></p></li></ul><p><a href="#Spring中的设计模式总结">Spring中的设计模式总结</a></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由Erich Gamma等人在1990年代从建筑设计领域引入到计算机科学的。</p><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)具有更好的：</p><ul><li>代码重用性 (即：相同功能的代码，不用多次编写) </li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解) </li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) </li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) </li><li>使程序呈现高内聚，低耦合的特性</li></ul><h1 id="UML复习"><a href="#UML复习" class="headerlink" title="UML复习"></a>UML复习</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>UML中的类图用于表示类、接口、实例之间相互的静态关系。如图：</p><p><img src="uml_class.png" alt=""></p><p>该图中实线空心三角箭头表示继承关系。<strong>下划线</strong>表示这是一个<strong>静态</strong>字段或<strong>静态</strong>方法，<strong>斜体</strong>表示这是一个<strong>抽象</strong>类或<strong>抽象</strong>方法。</p><h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><p><img src="uml_interface.png" alt=""></p><p>该图中虚线空心三角箭头表示实现关系。接口会在类图中使用<code>&lt;&lt;interface&gt;&gt;</code>表明。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img src="uml_aggregation.png" alt=""></p><p>聚合是一种“持有”关系，比如Basket类中持有多个Fruit实例。实际上关联、聚合、组合都是一种持有关系，依赖则属于“半持有”的关系，它们的区别如下：</p><p><a href="https://www.cnblogs.com/xrq730/p/5533019.html" target="_blank" rel="noopener">UML中：关联、聚合、组合、依赖的区别</a>.</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><img src="visualbility.png" alt=""></p><p>该图标识了方法和字段的可见性：</p><ul><li>“+”表示public</li><li>“-“表示private</li><li>“#”表示protect</li><li>“~”表示包可见</li></ul><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>UML的时序图用于表示程序在工作时其内部方法的调用顺序，以及事件的发生顺序。例：</p><p><img src="uml_sequence.png" alt=""></p><p>时序图上方的长方形表示类的实例，长方形向下延伸的虚线表示时间的流逝。黑色实线箭头表示方法调用，虚线箭头表示方法返回。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h2><p><strong>作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</strong></p><p>单例模式的使用场景：需要频繁进行创建和销毁的对象、创建对象耗时过多或耗费资源过多（重量级对象）但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象。例如：Spring中bean对象的创建默认就是singleton。</p><h3 id="饿汉式（立即加载）"><a href="#饿汉式（立即加载）" class="headerlink" title="饿汉式（立即加载）"></a>饿汉式（立即加载）</h3><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFinal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticFinal</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态常量，创建类实例，连接-准备阶段赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticFinal INSTANCE = <span class="keyword">new</span> StaticFinal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticFinal <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticFinal staticFinal = StaticFinal.getInstance();</span><br><span class="line">        StaticFinal staticFinal1 = StaticFinal.getInstance();</span><br><span class="line">        System.out.println(staticFinal == staticFinal1); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：类加载（static final变量在连接-准备阶段赋值）时就完成了对象的实例化，避免了线程同步问题。</li><li>缺点：如果从始至终没有用到该实例，会造成内存浪费。</li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticBlock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticBlock INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.静态代码块中，初始化阶段赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> StaticBlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.公有静态方法，获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticBlock staticBlock = StaticBlock.getInstance();<span class="comment">//调用类的静态方法-&gt;类初始化-&gt;静态代码块中创建实例</span></span><br><span class="line">        StaticBlock staticBlock1 = StaticBlock.getInstance();</span><br><span class="line">        System.out.println(staticBlock == staticBlock1); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点同上。</p><h3 id="懒汉式（延迟加载）"><a href="#懒汉式（延迟加载）" class="headerlink" title="懒汉式（延迟加载）"></a>懒汉式（延迟加载）</h3><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NoSync</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NoSync instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NoSync <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> NoSync();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：延迟加载，调用getInstance方法时才创建对象，不会出现浪费内存的情况。</p><p>缺点：不能保证线程安全。在多线程情况下，一个线程进入if(instance == null)判断语句块，还未来得及往下执行，另一个线程也正在判断该语句，此时便会产生多个实例。</p><p>实际开发中，不能使用该方式。</p><h4 id="线程不安全-同步代码块"><a href="#线程不安全-同步代码块" class="headerlink" title="线程不安全-同步代码块"></a>线程不安全-同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncBlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncBlock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncBlock instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SyncBlock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3.1.同步操作在条件判断之后</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SyncBlock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SyncBlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能保证线程安全，原因同上。</p><h4 id="线程安全-同步方法"><a href="#线程安全-同步方法" class="headerlink" title="线程安全-同步方法"></a>线程安全-同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncMethod instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态同步方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SyncMethod <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：延迟加载，保证了线程安全。</p><p>缺点：效率低。实例化只需要执行一次就够了，但是以后每个线程每次调用getInstance都要进行同步加锁。</p><p>实际开发中，不推荐该方式。</p><h3 id="双重检查（Double-Check）"><a href="#双重检查（Double-Check）" class="headerlink" title="双重检查（Double Check）"></a>双重检查（Double Check）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态volatile变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheck<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> DoubleCheck();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查是”线程不安全-同步代码块“与”线程安全-同步方法“的改进，volatile修饰变量保证可见性，即使有多个线程同时进行”第一个条件判断“，在同步代码块中也有第二个条件判断保证只会创建一个实例。同时解决了使用同步方法效率低的问题，因为线程多次调用getInstance只是第一次有同步加锁操作。</p><p>实际开发中，推荐使用。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClass</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span></span>&#123;</span><br><span class="line">        <span class="comment">//2.1.私有静态常量，创建对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClass INSTANCE = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时调用内部类的静态常量，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于外部类加载时不会同时加载内部类，因此只有再调用getInstance方法时才会加载内部类，并在内部类类加载阶段的连接-准备阶段赋值。</p><p>该方式是对饿汉式的改进，既能避免线程同步问题，又能做到延迟加载，避免内存的浪费。</p><p>实际开发中，推荐使用。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSingleton enumSingleton = EnumSingleton.INSTANCE;</span><br><span class="line">        EnumSingleton enumSingleton1 = EnumSingleton.INSTANCE;</span><br><span class="line">        System.out.println(enumSingleton == enumSingleton1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最简单最推荐的方式</strong>。该方式不仅能避免线程同步问题，还能防止反序列化重新创建新的对象。</p><h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</strong></p><p><strong>场景</strong>：假设现在我们要实现一个登录功能，需要满足多种登录方式，那么自然的方式就是建立一个各种登录方式都适用的接口，使用的时候再判断具体创建哪种登录方式的实现类。如图：</p><p><img src="simple_factory_0.png" alt=""></p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String telPhone , String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainLogin</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String telPhone, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordLogin</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String telPhone, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要一个工厂类LoginFactory，根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Login <span class="title">getLogin</span><span class="params">(String loginType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"password"</span>.equals(loginType))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PasswordLogin();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"passcode"</span>.equals(loginType))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DomainLogin();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到登录类型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟servlet接收前端请求，由工厂获取具体登录类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String loginType = <span class="string">"password"</span>;</span><br><span class="line">        String telPhone = <span class="string">"13799990808"</span>;</span><br><span class="line">        String password = <span class="string">"password"</span>;</span><br><span class="line">        Login login = LoginFactory.getLogin(loginType);</span><br><span class="line">        <span class="keyword">boolean</span> bool = login.verify(telPhone, password);</span><br><span class="line">        <span class="keyword">if</span> (bool) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 业务逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 业务逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的结构如下图：</p><p><img src="simple_factory_1.png" alt=""></p><p>优点：模式的核心是工厂类。这个类含有必要的逻辑判断，可以决定在什么时候创建哪一个登录验证类的实例，而<strong>调用者则可以免除直接创建对象的责任</strong>。<strong>简单工厂模式通过这种做法实现了对责任的分割，当系统引入新的登录方式的时候无需修改调用者</strong>。</p><p>缺点：工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><p>转载自：<a href="https://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html" target="_blank" rel="noopener">java_my_life</a>.</p><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>工厂方法模式：定义一个<strong>创建产品对象的工厂接口</strong>，<strong>将实际创建工作推迟到工厂子类中</strong>。</p><p><strong>场景</strong>：某财务系统需要支持对数据库中的员工薪资进行导出，并且支持多种格式如：HTML、PDF等，每种格式导出的文件结构不同，比如有标准结构和财务需要的结构两种。</p><p>如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求支持n种导出的格式以及2种导出的结构，那工厂类则需要<code>2*n</code>个if else语句来创建<code>2*n</code>种不同的类型。如果日后需求不断增加，则后果不堪设想。</p><p>这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。</p><p><strong>这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，引进一个新的产品则再创建一个新的工厂即可</strong>。这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计UML图：</p><p><img src="factory_method_1.png" alt=""></p><p>从上图可以看出，这个使用工厂方法模式的系统涉及到以下角色：</p><ul><li><strong>抽象工厂（ExportFactory）角色</strong>：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</li><li><strong>具体工厂（ExportHtmlFactory、ExportPdfFactory）角色</strong>：担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。假如我们新增了一个需求：导出CSV格式，则只需要新建一个实现ExportFactory接口的ExportCsvFactory工厂类即可。</li><li><strong>抽象导出（ExportFile）角色</strong>：具体工厂角色所创建对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</li><li><strong>具体导出（ExportStandardHtmlFile等）角色</strong>：这个角色实现了抽象导出（ExportFile）角色所声明的接口，具体工厂角色所创建的每一个对象都是某个具体导出角色的实例。</li></ul><p><a href="https://github.com/Laishiji/designpattern/tree/main/factorymethod" target="_blank" rel="noopener">源代码参见GitHub</a>.</p><p>简单工厂模式可以看作是工厂方法模式的特例，设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p><p>转载自：<a href="https://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html" target="_blank" rel="noopener">java_my_life</a>.</p><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p><strong>工厂方法模式中一个工厂类只能生产一种抽象产品类</strong>，比如上面的例子每一个具体工厂只能生产导出文件对象，<strong>而抽象工厂模式中一个具体工厂可以生产多种产品</strong>。还是以上面的场景为例，假设现在我们新增一个需求：该财务系统不仅要实现导出薪资文件功能，还要实现导入财务报表功能，假设财务报表有HTML和PDF两种格式，该怎么做？</p><ol><li>我们只需要将ExportFactory接口与ExportHtmlFactory、ExportPdfFactory实现类改名为Factory接口与HtmlFactory、PdfFactory，然后在接口与实现类种添加getImportFile方法；</li><li>创建ImportFile接口与对应的ImportHtmlFile、ImportPdfFile实现类；</li><li>在工厂类的getImportFile方法中创建ImportHtmlFile、ImportPdfFile实现类对象。</li></ol><p><a href="https://github.com/Laishiji/designpattern/tree/main/abstractfactory/src/main/java" target="_blank" rel="noopener">源代码参考GitHub</a>.</p><p>以下是一个更容易理解的例子：</p><ul><li><p>简单工厂模式：现有一个鼠标工厂，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。</p><p><img src="simplefac.jpg" alt=""></p></li><li><p>工厂方法模式：将简单工厂模式的方法中的判断逻辑抽取出来成为工作子类，实现解耦。</p><p><img src="facmethod.jpg" alt=""></p><p>当新增需求比如该鼠标工厂接了联想的订单，只需要新增一个LenovoMouseFactory即可，如果使用简单工厂模式的话则需要修改工厂类的代码，不符合开闭原则。</p></li><li><p>抽象工厂：假设我们的鼠标工厂越发红火，拓展了业务，不再只生产鼠标，同时还生产键盘等其他PC外设，那么我们只需要在原有的工厂中新增产品线即可。</p><p><img src="absfactory.jpg" alt=""></p></li></ul><h2 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h2><p>原型模式：<strong>通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。</strong></p><p>Object类提供了一个clone()方法，该方法可以将一个对象复制一份，但是需要实现了clone方法的Java类必须实现接口Cloneable，此时在另一个类中就可以通过调用该Java类的clone方法获取克隆对象了（浅拷贝）。我们可以使用该特性实现原型模式。</p><p>关于深拷贝与浅拷贝：</p><h3 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h3><ul><li><p>B对A的浅拷贝：创建新对象B，将A的字段值复制到B。</p><ol><li>如果该<strong>字段值是</strong>对对象（例如，存储器地址）的<strong>引用</strong>，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。</li><li>如果该<strong>字段值是基本数据类型</strong>，则复制值。</li></ol></li><li><p>Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法， then <code>A B = (A) new A().clone();</code></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    C object;</span><br><span class="line">    A(<span class="keyword">int</span> val, C obj)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.object = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A aObj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> C(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        A bObj = (A) aObj.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，如果bObj修改了引用类型C object中b的值为10，那么对象aObj中引用类型C object中b的值也是10，因为浅拷贝只是拷贝了aObj中object的引用（地址）给bObj。</p></li></ul><h3 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h3><ul><li>B对A的深拷贝：创建新对象B，对于A的引用类型字段，在B中创建该引用类型对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。</li><li>要实现深拷贝，不仅A需要实现Cloneable接口并重写clone方法，A中的引用类型C也需要实现Cloneable接口并重写clone方法。</li><li>深拷贝也可通过对象序列化的方式实现ByteArrayInputStream、ByteArrayOutputStream、ObjectInputStream、ObjectOutputStream。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    C object;</span><br><span class="line">    A(<span class="keyword">int</span> val, C obj)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.object = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            A a = (A) <span class="keyword">super</span>.clone();</span><br><span class="line">            a.object = (C) object.clone();</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A aObj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> C(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        A bObj = (A) aObj.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring中原型模式的应用：当指定bean的scope为prototype时，表示bean对象的创建是多例的，每次调用getBean方法都会复制一份。（深拷贝）</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h2><p><strong>适配器模式将某个类的接口转换为客户端期望的另一个接口表示</strong>（现实生活中的转接头，充电头都是适配器），主要目的是解决兼容性问题，让原本因接口不匹配不能一起工作的两个类可以协同工作。</p><p>从用户的角度来看，用户是看不到被适配者目标的，感觉只是和适配器接口交互。</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>实现方式：<strong>Adapter类（适配器类）通过：继承src类（被适配类），实现dst接口（目标接口），完成src到dst的适配。</strong></p><p><strong>场景</strong>：以电源适配器为例，我们需要将220V（被适配类）的电压转换为5V（目标接口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被适配类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出220V的电压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类继承自被适配类，实现目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="keyword">super</span>.output220V();</span><br><span class="line">        <span class="keyword">int</span> dst = src / <span class="number">44</span>;<span class="comment">//模拟变压操作</span></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟使用5V电压充电的手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Voltage5V voltage5V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> voltage = voltage5V.output5V();</span><br><span class="line">        <span class="keyword">if</span>(voltage == <span class="number">5</span>)</span><br><span class="line">            System.out.println(<span class="string">"充电中..."</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(voltage &gt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"电压过高，不能充电！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charge(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>实现方式：<strong>Adapter类（适配器类）通过：持有src类（被适配类）的实例，实现dst接口（目标接口），完成src到dst的适配。</strong></p><p>根据“组合/聚合复用原则”，在系统中尽量使用<strong>聚合关系来替代继承关系</strong>，对象适配器模式是对类适配器的改进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类持有被适配类对象，实现目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = voltage220V.output220V();</span><br><span class="line">        <span class="keyword">int</span> dst = src / <span class="number">44</span>;<span class="comment">//模拟变压操作</span></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charge(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>又叫<strong>默认适配器模式，</strong>适用情景：使用者只想使用一个接口的部分方法，此时我们就需要一个默认适配器。</p><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类适配器，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ALotOfMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdapter</span> <span class="keyword">implements</span> <span class="title">ALotOfMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultAdapter defaultAdapter = <span class="keyword">new</span> DefaultAdapter()&#123;</span><br><span class="line">            <span class="comment">//该匿名内部类是抽象类DefaultAdapter的子类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"只使用m1方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        defaultAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC中的HandlerAdapter就使用了适配器模式：</p><p><img src="spring_adapter.png" alt=""></p><p>HandlerAdapter的实现子类使得每一种Controller都有对应的适配器实现类。</p><h2 id="装饰器（Decorator）"><a href="#装饰器（Decorator）" class="headerlink" title="装饰器（Decorator）"></a>装饰器（Decorator）</h2><p><strong>装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式动态扩展对象的功能，是继承关系的一个替代方案。</strong></p><p>装饰模式的类图：</p><p><img src="decorator.png" alt=""></p><p>在装饰模式中的角色有：</p><ul><li><strong>抽象构件(Component)角色：</strong>给出一个抽象接口，以规范准备接收增强功能的对象。</li><li><strong>具体构件(ConcreteComponent)角色：</strong>定义一个将要接收增强的类。</li><li><strong>装饰(Decorator)角色：</strong>持有一个抽象构建角色，并通过构造器注入具体构件角色。</li><li><strong>具体装饰(ConcreteDecorator)角色：</strong>负责给构件对象附加增强功能。</li></ul><p>例如，我们可以通过覆盖Http请求的方法来对数据进行转义，这里使用了装饰器模式。HttpServletRequest接口属于抽象构件角色；各服务器厂商的Request实现类属于具体构件角色；装饰角色为官方提供的HttpServletRequestWrapper类，其持有厂商的Request实现类；作为用户，我们只需要继承HttpServletRequestWrapper类作为具体装饰角色，重写Wrapper类的方法即可。</p><p>装饰模式在JDK中的应用有I/O标准库的设计，以InputStream为例：</p><p><img src="decorator_JDK_IO.png" alt=""></p><p>上图中：</p><ul><li><strong>抽象构件(Component)角色：</strong>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</li><li><strong>具体构件(ConcreteComponent)角色：</strong>由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</li><li><strong>抽象装饰(Decorator)角色：</strong>由FilterInputStream扮演。它实现了InputStream所规定的接口。</li><li><strong>具体装饰(ConcreteDecorator)角色：</strong>由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</li></ul><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p>参见：<a href="https://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">JDK动态代理</a>.</p><p>代理模式与装饰模式在代码实现形式上几乎是一致的，区别只在于抽象层面我们分别赋予它们的含义。</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="模板方法（Template-Method）"><a href="#模板方法（Template-Method）" class="headerlink" title="模板方法（Template Method）"></a>模板方法（Template Method）</h2><p>模板方法模式：<strong>准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑</strong>。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p><p>JDK中对模板方法模式最经典的应用就是J.U.C包中的AbstractQueuedSynchronizer类了。参考<a href="https://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/#AQS">JUC之锁</a>。</p><p>模板方法模式的类图如下：</p><p><img src="template_method.png" alt=""></p><p>这里涉及到两个角色：</p><p><strong>抽象模板(Abstract Template)角色有如下责任：</strong></p><ul><li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li><li>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li></ul><p><strong>具体模板(Concrete Template)角色又如下责任：</strong></p><ul><li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li><li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li></ul><h2 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h2><p>策略模式：<strong>针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</strong></p><p>策略模式类图：</p><p><img src="strategy.png" alt=""></p><p>这个模式涉及到三个角色：</p><ul><li><strong>环境(Context)角色：</strong>持有一个Strategy的引用。</li><li><strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</li></ul><p><strong>在客户端通过控制反转创建具体策略角色的前提下，策略模式使得客户端可以配置式地随时插入算法（新建一个ConcreteStrategy类）或更换算法。</strong></p><p><strong>场景</strong>：假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p>根据描述，折扣是根据以下的几个算法中的一个进行的：</p><ul><li><p>算法一：对初级会员没有折扣。</p></li><li><p>算法二：对中级会员提供10%的促销折扣。</p></li><li><p>算法三：对高级会员提供20%的促销折扣。</p></li></ul><p><img src="strategy2.png" alt=""></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算图书的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> booksPrice    图书的原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    计算出打折后的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimaryMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对于初级会员的没有折扣"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntermediateMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对于中级会员的折扣为10%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对于高级会员的折扣为20%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择并创建需要使用的策略对象</span></span><br><span class="line">        MemberStrategy strategy = <span class="keyword">new</span> AdvancedMemberStrategy();</span><br><span class="line">        <span class="comment">//创建环境</span></span><br><span class="line">        Price price = <span class="keyword">new</span> Price(strategy);</span><br><span class="line">        <span class="comment">//计算价格</span></span><br><span class="line">        <span class="keyword">double</span> quote = price.quote(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"图书的最终价格为："</span> + quote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转载自：<a href="https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">java_my_life</a>.</p><h2 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h2><p>观察者模式：<strong>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</strong></p><p>一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>观察者模式类图如下：</p><p><img src="observer.png" alt=""></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对观察者对象的引用保存在一个集合（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供可以增加和删除观察者对象的方法，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong>具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来保存注册的观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer    观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        list.add(observer);</span><br><span class="line">        System.out.println(<span class="string">"Attached an observer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除观察者对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer    观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有注册的观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodifyObservers</span><span class="params">(String newState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer : list)&#123;</span><br><span class="line">            observer.update(newState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state    更新的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//观察者的状态</span></span><br><span class="line">    <span class="keyword">private</span> String observerState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        observerState = state;</span><br><span class="line">        System.out.println(<span class="string">"状态为："</span>+observerState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String newState)</span></span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">        System.out.println(<span class="string">"主题状态为："</span> + state);</span><br><span class="line">        <span class="comment">//状态发生改变，通知各个观察者</span></span><br><span class="line">        <span class="keyword">this</span>.nodifyObservers(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        subject.attach(observer);</span><br><span class="line">        subject.change(<span class="string">"new State"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拉模型与推模型</strong></p><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><ul><li>推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</li><li>拉模型：主题对象在通知观察者时，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，<strong>会把主题对象自身的引用通过update()方法传递给观察者</strong>，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</li></ul><p>很显然上述的代码示例是推模型。</p><p><strong>JAVA提供的对观察者模式的支持</strong></p><p>　在JAVA语言的java.util库里面，提供了一个<code>Observable</code>类以及一个<code>Observer</code>接口，构成JAVA语言对观察者模式的支持。</p><p><strong>Observer接口</strong></p><p>这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p><p>所有的观察者类都需要实现该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Observable类</strong></p><p><strong>被观察者类（主题类）都是java.util.Observable类的子类</strong>。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是<code>setChanged()</code>，另一个是<code>notifyObservers()</code>。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p><h2 id="责任链（Chain-Of-Responsibility）"><a href="#责任链（Chain-Of-Responsibility）" class="headerlink" title="责任链（Chain Of Responsibility）"></a>责任链（Chain Of Responsibility）</h2><p>责任链模式：<strong>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</strong></p><p>UML类图：</p><p><img src="chain_of_responsibility.png" alt=""></p><p>责任链模式涉及到的角色如下所示：</p><ul><li><p><strong>抽象处理者(Handler)角色：</strong>定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。</p></li><li><p><strong>具体处理者(ConcreteHandler)角色：</strong>具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p></li></ul><p><strong>场景</strong>：公司申请聚餐费用的管理。</p><p>​        申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。</p><p>　　不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p><p>　　也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。</p><p>​        可以使用责任链模式来实现上述功能：当某人提出聚餐费用申请的请求后，该请求会在 <strong>项目经理—〉部门经理—〉总经理</strong> 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。</p><p>类图如下：</p><p><img src="chain_of_responsibility2.png" alt=""></p><p><a href="https://github.com/Laishiji/designpattern/tree/main/chainofresponsibility/src/main/java" target="_blank" rel="noopener">源代码参考GitHub</a>.</p><p>Spring MVC中的HandlerExecutionChain就使用到了责任链模式。</p><h1 id="Spring中的设计模式总结"><a href="#Spring中的设计模式总结" class="headerlink" title="Spring中的设计模式总结"></a>Spring中的设计模式总结</h1><p>参考：<a href="https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring-Design-Patterns" target="_blank" rel="noopener">https://snailclimb.gitee.io/javaguide/#/docs/system-design/framework/spring/Spring-Design-Patterns</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;#设计模式的目的&quot;&gt;设计模式的目的&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;a href=&quot;#UML复习&quot;&gt;UML复习&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#类图&quot;&gt;类
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="设计模式" scheme="http://thmasterplan.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://thmasterplan.cn/JavaWeb/SpringBoot/"/>
    <id>http://thmasterplan.cn/JavaWeb/SpringBoot/</id>
    <published>2020-10-28T01:26:07.000Z</published>
    <updated>2021-01-21T04:32:59.526Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>SpringBoot使用一个全局的配置文件，文件名是固定的application。有两种格式的配置文件：</p><ul><li>property：application.properties</li><li>yaml：application.yml</li></ul><p>该配置文件用于修改SpringBoot自动配置的默认值。SpringBoot会扫描以下位置的全局配置文件，优先级从高到低如下：<code>项目根目录/config/</code>， <code>项目根目录/</code>，<code>resources/config/</code>，  <code>resources/</code>，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置。Spring Boot还支持多种外部配置方式。</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><ul><li><p><code>属性: 值</code>表示一对键值对，冒号后的<strong>空格是必须的</strong>。</p></li><li><p>使用空格的缩进表示层级关系，只要是左对齐的一列属性都是同一层级的。</p></li><li><p>属性和值大小写敏感。</p></li><li><p>值的类型可以有：</p><ul><li><p>基本数据类型与字符串：可以不使用单引号或双引号。</p></li><li><p>对象，Map。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写法1</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="comment">#写法2</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">&#123;name:</span> <span class="string">zhangsan,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>数组, Set, List。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写法1</span></span><br><span class="line"><span class="attr">array:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">a</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"><span class="comment">#写法2</span></span><br><span class="line"><span class="attr">array:</span> <span class="string">[a,</span> <span class="string">b,</span> <span class="string">c]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>注意：YAML不支持使用注解<code>@PropertySource</code>导入配置。</p><h3 id="获取配置文件中的值"><a href="#获取配置文件中的值" class="headerlink" title="获取配置文件中的值"></a>获取配置文件中的值</h3><p>YAML文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhaosi</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p>实体类User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//指定入口类或测试环境</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">YamlTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>)<span class="comment">//自动注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)<span class="comment">//自动注入</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProperty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">":"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@ConfigurationProperties</code>注解</strong>：把同类配置信息自动封装成一个实体类，其属性prefix指定配置文件配置项的前缀。</p><p>另一种使用<code>@ConfigurationProperties</code>该注解的方式是，不需要在实体类上注解<code>@Component和@ConfigurationProperties</code>，而是在配置类使用<code>@Bean</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入配置文件处理器，配置文件值绑定时就会有提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@ConfigurationProperties</code>只能用于SpringBoot的全局配置文件application，而<code>@PropertySource</code>可以用于加载指定的配置文件，但是后者不支持yaml格式。</p><p><code>@Value</code>只能用于基本数据类型的注入，且支持<code>#{SpEL}</code>表达式。</p><p><code>@ImportReSource</code>：用于加载Spring的XML配置文件。SpringBoot不推荐使用这种方式，而是使用全注解的方式，即创建配置类。</p><h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><h4 id="RandomValuePropertySource"><a href="#RandomValuePropertySource" class="headerlink" title="RandomValuePropertySource"></a>RandomValuePropertySource</h4><p>可以在配置文件中使用该类的随机数。使用方式：<code>${random.value}</code>, <code>${random.uuid}</code>, <code>${random.int}</code>, <code>${random.long}</code>, <code>${random.int(10)}</code>,<code>${random.(10,100)}</code>。</p><h4 id="属性配置占位符"><a href="#属性配置占位符" class="headerlink" title="属性配置占位符"></a>属性配置占位符</h4><p>可以在配置文件中引用前面配置过的属性，例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot App.</span></span><br><span class="line"><span class="comment">#或者如果前面没有配置，也可配置默认值</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name: DefaultAppName&#125; is a Spring Boot App.</span></span><br></pre></td></tr></table></figure><h3 id="配置多环境"><a href="#配置多环境" class="headerlink" title="配置多环境"></a>配置多环境</h3><p>在实际项目的开发过程中，经常需要配置多个环境（比如开发环境和生产环境），以便不同的环境使用不同配置参数。</p><h4 id="多配置文件方式"><a href="#多配置文件方式" class="headerlink" title="多配置文件方式"></a>多配置文件方式</h4><p>在resources目录下创建三个配置文件：</p><p>application-dev.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"> <span class="attr">tomcat:</span> </span><br><span class="line">  <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">development</span></span><br></pre></td></tr></table></figure><p>application-prod.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"> <span class="attr">tomcat:</span> </span><br><span class="line">  <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">produce</span></span><br></pre></td></tr></table></figure><p>application.yml： </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">development</span> <span class="comment">#指定当前活动的配置文件为application-dev.yml</span></span><br></pre></td></tr></table></figure><p>properties格式同理：<code>spring.profiles.active=development</code></p><h4 id="文档块方式"><a href="#文档块方式" class="headerlink" title="文档块方式"></a>文档块方式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8080</span> <span class="comment">#默认为8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#激活dev则使用8081</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h4 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h4><p>加入选项<code>--spring.profiles.active=prod</code>即可。</p><p>application配置文件可以配置哪些属性？参照<a href="https://docs.spring.io/spring-boot/docs/2.1.17.RELEASE/reference/html/common-application-properties.html" target="_blank" rel="noopener">官方文档</a>。</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>SLF4J(Simple Logging Facade for Java)：抽象层日志框架。</p><p>LogBack：具体的日志框架实现。</p><p><code>spring-boot-starter-logging</code>采用了SLF4J + LogBack实现日志功能，<strong>我们在开发的时候应该使用抽象层框架SLF4J，而LogBack的实现则是用于配置</strong>，这是<a href="https://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/#D%EF%BC%9A%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88Dependency-Inversion-Principle%EF%BC%89">依赖倒置原则</a>与<a href="https://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/#L%EF%BC%9A%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle%EF%BC%89">里氏替换原则</a>的体现。</p><p>当我们引入其他依赖时，该依赖使用的日志框架可能与Spring Boot的实现方案不同，比如可能是JUL，log4j, log4j2等等。为了统一日志框架，SLF4J提供了常见日志框架实现的转换方案。我们唯一要做的就是<strong>在引入其他依赖时，排除掉其使用的日志框架</strong>即可，以此来避免SLF4J提供的转换jar包与之冲突。比如，Spring使用的就是commons-logging日志框架，在引入spring-core时，我们需要如此做：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SLF4J的使用"><a href="#SLF4J的使用" class="headerlink" title="SLF4J的使用"></a>SLF4J的使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志记录器   </span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志级别</span></span><br><span class="line"><span class="comment">//由低到高：trace &lt; debug &lt; info &lt; warn &lt; error</span></span><br><span class="line">logger.trace(<span class="string">"trace..."</span>);</span><br><span class="line">logger.debug(<span class="string">"debug..."</span>);</span><br><span class="line">logger.info(<span class="string">"info..."</span>);</span><br><span class="line">logger.warn(<span class="string">"warn..."</span>);</span><br><span class="line">logger.error(<span class="string">"error..."</span>);</span><br></pre></td></tr></table></figure><p>Spring Boot默认使用info级别及以上的日志级别，所以trace和debug日志信息是不会输出到控制台的。我们可以在<code>application</code>配置文件中调整日志级别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.example</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure><p>以上配置的含义是：<code>com.example</code>包下的所有代码日志级别调整为trace及以上。</p><h4 id="常见日志配置"><a href="#常见日志配置" class="headerlink" title="常见日志配置"></a>常见日志配置</h4><p>如果我们不指定日志输出文件和路径，日志只会在控制台中输出。</p><p>在<code>application</code>配置文件中：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认生成日志文件到当前项目根目录下</span></span><br><span class="line"><span class="meta">logging.file</span>=<span class="string">mylog.log</span></span><br><span class="line"><span class="comment">#也可指定路径</span></span><br><span class="line"><span class="meta">logging.file</span>=<span class="string">G:/mylog.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者在当前磁盘下生成a目录，a目录下生成b目录，b目录下默认生成spring.log日志文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/a/b</span></span><br><span class="line"><span class="comment">#                                                            [从左显示的]  </span></span><br><span class="line"><span class="comment">#指定控制台输出的日志格式   [           时间          ]  [ 线程名 ][字符宽度][最长50个字符] [日志消息与换行符]</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; *** [%thread] *** %-5level *** %logger&#123;50&#125; ： %msg%n</span></span><br></pre></td></tr></table></figure><p>我们也可在resources下放入各个日志框架自己的配置文件，Spring Boot就不会使用默认配置了。</p><div class="table-container"><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table></div><h4 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h4><p>假设要替换为log4j：</p><ol><li>在pom.xml中选中<code>spring-boot-starter-logging</code>，右键Diagrams打开依赖树；</li><li>选中logback-classic，右键Exclude; </li><li>选中log4j-over-slf4j，右键Exclude，也即删除SLF4J的覆盖方案；</li><li>导入SLF4J对log4j的适配方案依赖<code>slf4j-log4j12</code>。</li></ol><h2 id="JSR-303-–-Bean-Validation"><a href="#JSR-303-–-Bean-Validation" class="headerlink" title="JSR 303 – Bean Validation"></a>JSR 303 – Bean Validation</h2><p>JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。<a href="https://jcp.org/en/jsr/detail?id=303" target="_blank" rel="noopener">JSR - 303</a> 为 JavaBean 验证定义了相应的元数据模型和 API。</p><p>在任何时候，当你要处理一个应用程序的业务逻辑，数据校验是你必须要考虑和面对的事情。应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在通常的情况下，应用程序是分层的，不同的层由不同的开发人员来完成。很多时候同样的数据验证逻辑会出现在不同的层，这样就会导致代码冗余和一些管理的问题，比如说语义的一致性等。为了避免这样的情况发生，最好是将验证逻辑与相应的域模型进行绑定。</p><p>Hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p><h3 id="Bean-Validation中的constraint"><a href="#Bean-Validation中的constraint" class="headerlink" title="Bean Validation中的constraint"></a>Bean Validation中的constraint</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Constraint</strong></th><th style="text-align:left"><strong>被注解的属性：</strong></th></tr></thead><tbody><tr><td style="text-align:left"><code>@Valid</code></td><td style="text-align:left">是一个对象，需要检查此对象的所有字段值（级联验证）</td></tr><tr><td style="text-align:left"><code>@Null</code></td><td style="text-align:left">必须为 <code>null</code></td></tr><tr><td style="text-align:left"><strong><code>@NotNull</code></strong></td><td style="text-align:left"><strong>必须不为 <code>null</code></strong></td></tr><tr><td style="text-align:left"><code>@AssertTrue</code></td><td style="text-align:left">必须为 <code>true</code></td></tr><tr><td style="text-align:left"><code>@AssertFalse</code></td><td style="text-align:left">必须为 <code>false</code></td></tr><tr><td style="text-align:left"><code>@Min(value)</code></td><td style="text-align:left">必须是一个数字，其最小值为value</td></tr><tr><td style="text-align:left"><code>@Max(value)</code></td><td style="text-align:left">必须是一个数字，其最大值为value</td></tr><tr><td style="text-align:left"><code>@DecimalMin(value)</code></td><td style="text-align:left">必须是一个数字，其最小值为value</td></tr><tr><td style="text-align:left"><code>@DecimalMax(value)</code></td><td style="text-align:left">必须是一个数字，其最大值为value</td></tr><tr><td style="text-align:left"><code>@Size(max, min)</code></td><td style="text-align:left">大小必须在指定的范围内</td></tr><tr><td style="text-align:left"><code>@Digits (integer, fraction)</code></td><td style="text-align:left">必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td style="text-align:left"><code>@Past</code></td><td style="text-align:left">必须是一个过去的日期</td></tr><tr><td style="text-align:left"><code>@Future</code></td><td style="text-align:left">必须是一个将来的日期</td></tr><tr><td style="text-align:left"><code>@Pattern(value)</code></td><td style="text-align:left">必须符合指定的正则表达式</td></tr></tbody></table></div><h3 id="Hibernate-Validator-附加的-constraint"><a href="#Hibernate-Validator-附加的-constraint" class="headerlink" title="Hibernate Validator 附加的 constraint"></a>Hibernate Validator 附加的 constraint</h3><div class="table-container"><table><thead><tr><th><strong>Constraint</strong></th><th><strong>被注解的属性：</strong></th></tr></thead><tbody><tr><td><code>@Email</code></td><td>必须是电子邮箱地址</td></tr><tr><td><code>@Length(min=, max=)</code></td><td>必须是字符串，其大小必须在指定的范围内</td></tr><tr><td><strong><code>@NotEmpty</code></strong></td><td><strong>若是字符串，则必须不为null；若是集合，则集合size &gt; 0</strong></td></tr><tr><td><code>@Range(min=, max=)</code></td><td>必须在合适的范围内</td></tr><tr><td><strong><code>@NotBlank</code></strong></td><td><strong>必须是字符串，且trim()后的length &gt; 0</strong></td></tr><tr><td><code>@URL</code></td><td>必须是字符串，且是一个有效的url</td></tr><tr><td><code>@CreditCardNumber</code></td><td>必须是字符串，且是合法的银行卡/信用卡</td></tr><tr><td><code>@ScriptAssert</code></td><td>要有JSR 223 - Java Scripting API的实现</td></tr><tr><td><code>@SafeHtml</code></td><td>classpath中要有jsoup包</td></tr></tbody></table></div><p>随着Hibernate Validator版本的迭代，也更新了一些其他的constraint，可在IDEA右侧工具栏的Bean Validation中查看。</p><h3 id="使用Hibernate-Validator"><a href="#使用Hibernate-Validator" class="headerlink" title="使用Hibernate Validator"></a>使用Hibernate Validator</h3><p>可以写一个统一的校验类，然后在service层或controller层中调用校验类的校验方法。若有参数不合法，则可使用自定义的异常类抛出参数不合法的异常信息。<a href="https://github.com/Laishiji/miaosha/tree/main/src/main/java/com/laishiji/miaosha/validator" target="_blank" rel="noopener">参考</a></p><h3 id="自定义constraint"><a href="#自定义constraint" class="headerlink" title="自定义constraint"></a>自定义constraint</h3><ol><li>自定义注解，参考Hibernate实现的注解。</li><li>自定义validator实现<code>ConstraintValidator</code>接口，并实现isValid方法。</li><li>将自定义validator赋值给<code>@Constraint</code>的validateBy属性。</li></ol><p>示例：自定义constraint, 校验参数必须是3的倍数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.Field&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validateBy = &#123;MultipleOfThreeForInteger<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MultipleOfThree</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "必须是3的倍数"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MultipleOfThreeForInteger implements ConstraintValidator&lt;MultipleOfThree, Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(MultipleOfThree constraintAnnotation)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>@MultipleOfThree</code>就可以用于参数验证了。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;SpringBoot使用一个全局的配置文件，文件名是固定的application。有两种格式的配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prop
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="SpringBoot" scheme="http://thmasterplan.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>IDEA使用技巧</title>
    <link href="http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-10-25T07:25:43.000Z</published>
    <updated>2021-01-07T06:10:42.207Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#IDEA插件推荐">IDEA插件推荐</a></p><ul><li><p><a href="#Material Theme UI">Material Theme UI</a></p></li><li><p><a href="#Lombok">Lombok</a></p></li><li><p><a href="#Alibaba Java Coding Guidelines">Alibaba Java Coding Guidelines</a></p></li><li><p><a href="#Generate SerialVersionUID">Generate SerialVersionUID</a></p></li><li><p><a href="#Maven Helper">Maven Helper</a></p></li><li><p><a href="#Codota">Codota</a></p></li><li><p><a href="#SequenceDiagram">SequenceDiagram</a></p></li><li><p><a href="#Stack trace to UML">Stack trace to UML</a></p></li></ul><p><a href="#快捷键">快捷键</a></p><p><a href="#自定义高复用代码块">自定义高复用代码块</a></p><p><a href="#设置代码模板">设置代码模板</a></p><p><a href="#Debug">Debug</a></p><ul><li><a href="#条件断点">条件断点</a></li></ul><h1 id="IDEA插件推荐"><a href="#IDEA插件推荐" class="headerlink" title="IDEA插件推荐"></a>IDEA插件推荐</h1><h2 id="Material-Theme-UI"><a href="#Material-Theme-UI" class="headerlink" title="Material Theme UI"></a>Material Theme UI</h2><p>该插件可更改IDEA的主题，默认的主题就很吼看啦：</p><p><img src="五彩斑斓的黑.PNG" alt=""></p><p>五彩斑斓的黑！Ohhhhhhhhhhhhhhhhh~</p><p>该插件可结合插件Atom Materail Icons修改UI图标。</p><h2 id="Lombok"><a href="#Lombok" class="headerlink" title="Lombok"></a>Lombok</h2><p>使用该插件可以在编辑器中简化冗长的代码，尤其是POJO类。使用Lombok需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lombok使用注解来开启相应的功能：</p><ul><li><code>@Data</code>：自动生成Getter/Setter/toString/equals/hashCode方法，以及不带参数的构造方法。</li><li><code>@NonNull</code>：帮助处理NPE异常。</li><li><code>@CleanUp</code>：自动管理资源，不用再在finally中添加资源的close方法。</li><li><code>@Setter/@Getter</code>：自动生成Setter/Getter方法。</li><li><code>@ToString</code>：自动生成toString方法。</li><li><code>@EqualsAndHashCode</code>：从对象的字段中重写hashCode和equals方法。</li><li><code>@NoArgsConstructor/RequiredArgsConstructor/@AllArgsConstructor</code>：自动生成构造方法。</li><li><code>@Value</code>：用于注解final类。</li><li><code>@Builder</code>：产生复杂的构建器API类。</li><li><code>SneakyThrows</code>：用于异常处理。</li><li><code>@Synchronized</code>：同步方法的转化。</li><li><code>@Log</code>：支持使用各种日志对象。</li></ul><h2 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h2><p>与”阿里巴巴Java开发规范手册”对应的插件，可自动检测代码中不符合规范的地方。</p><h2 id="Generate-SerialVersionUID"><a href="#Generate-SerialVersionUID" class="headerlink" title="Generate SerialVersionUID"></a>Generate SerialVersionUID</h2><p>当你的一个类实现了序列化接口后，按<code>Alt+Insert</code>就可以自动生成序列化ID了。</p><h2 id="Maven-Helper"><a href="#Maven-Helper" class="headerlink" title="Maven Helper"></a>Maven Helper</h2><p>该插件可自动检测Maven依赖是否有jar包冲突，帮助我们进行依赖管理。</p><h2 id="Codota"><a href="#Codota" class="headerlink" title="Codota"></a>Codota</h2><p>该插件支持：</p><ol><li>智能代码自动提示，该功能可以增强 IDEA 的代码提示功能。</li><li>JDK 和知名第三方库的函数的使用方法搜索，可以看到其他知名开源项目对该函数的用法。</li></ol><h2 id="SequenceDiagram"><a href="#SequenceDiagram" class="headerlink" title="SequenceDiagram"></a>SequenceDiagram</h2><p>该插件可根据代码调用链路自动生成时序图。光标停止在调用函数上，右键’Sequence Diagram’即可生成时序图。</p><h2 id="Stack-trace-to-UML"><a href="#Stack-trace-to-UML" class="headerlink" title="Stack trace to UML"></a>Stack trace to UML</h2><p>该插件可根据 JVM 异常堆栈画 UML时序图和通信图。使用方式： <em>Analyze &gt; Open Stack trace to UML plugin</em> 。</p><h1 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h1><p>修改快捷键：File -&gt; Settings -&gt; Keymap.</p><ul><li>自动代码补全：<code>Ctrl+Shift+Space</code>。</li><li><strong>查看类的源码</strong>：在光标所在的类名上<code>Ctrl+B</code>。</li><li><strong>搜索类并查看源码</strong>：<code>Ctrl+N</code>。</li><li>自动生成setter/getter/构造器/测试方法/Copyright/SerialVersionUID等：<code>Alt+Insert</code>。</li><li>提示方法参数列表：<code>Ctrl+P</code>。</li><li><strong>快速修复错误：<code>Alt+Enter</code>。（超常用，比如导入光标所在类的包）</strong></li><li>提交修改到新版本（Git）：<code>Ctrl+K</code>。</li></ul><h1 id="自定义高复用代码块"><a href="#自定义高复用代码块" class="headerlink" title="自定义高复用代码块"></a>自定义高复用代码块</h1><p>File -&gt; Settings -&gt; Editor -&gt; Live Templates -&gt; 右键<code>+</code>，Abbreviation代表添加缩写语句。IDEA内置常用的高复用代码块如下：</p><ul><li><code>psvm</code>/<code>main</code>：生成<code>public static void main(String[] args) {}</code></li><li><code>sout/soutp</code>：生成<code>System.out.println();</code>，区别是后者光标在<code>;</code>后面。</li><li><code>fori</code>：生成<code>for (int i = 0; i &lt; ; i++) {}</code></li><li><code>foreach</code>：<code>for (:) {}</code></li><li><code>psf/psfi/psfs</code>：<code>public static final</code>/<code>public static final int</code>/<code>public static final String</code></li><li><code>prsf</code>：<code>private static final</code></li><li><code>ifn</code>：<code>if ( == null) {}</code></li></ul><h1 id="设置代码模板"><a href="#设置代码模板" class="headerlink" title="设置代码模板"></a>设置代码模板</h1><p>File -&gt; Settings -&gt; Editor -&gt; File and Code Template.</p><p>Includes中可以添加注释信息，之后每一个新生成的Java类头部都会生成该注释。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span>: lsj</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span>: $&#123;DATE&#125; $&#123;TIME&#125;</span></span><br><span class="line"><span class="comment"> * Description: </span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure><h1 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h1><p>调试栏的按钮用处如下表：</p><div class="table-container"><table><thead><tr><th>按钮</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td><img src="Show_Execution_Point.jpg" alt=""></td><td style="text-align:left">(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可<strong>跳转到当前代码执行的行</strong></td></tr><tr><td><img src="step_over.jpg" alt=""></td><td style="text-align:left">(F8)：步过，<strong>一行一行地往下走，如果这一行上有方法不会进入方法</strong>。</td></tr><tr><td><img src="step_into.jpg" alt=""></td><td style="text-align:left">(F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入<strong>自定义方法</strong>内，不会进入官方类库的方法。</td></tr><tr><td><img src="force_step_into.jpg" alt=""></td><td style="text-align:left">(Alt + Shift + F7)：强制步入，<strong>能进入任何方法</strong>，查看底层源码的时候可以用这个进入官方类库的方法。</td></tr><tr><td><img src="step_out.jpg" alt=""></td><td style="text-align:left">(Shift + F8)：步出，从步入的方法内<strong>退出到方法调用处</strong>，此时方法已执行完毕，只是还没有完成赋值。</td></tr><tr><td><img src="drop_frame.jpg" alt=""></td><td style="text-align:left">回退断点。</td></tr><tr><td><img src="run_to_cursor.jpg" alt=""></td><td style="text-align:left">(Alt + F9)：<strong>运行到光标处</strong>，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</td></tr><tr><td><img src="evaluate_expression.jpg" alt=""></td><td style="text-align:left">(Alt + F8)：计算表达式。可以输入对象调用其set方法设置值，而不用修改源码或重新请求。</td></tr><tr><td><img src="resume.JPG" alt=""></td><td style="text-align:left">跳转到下一个断点处。</td></tr><tr><td><img src="view_breakpoints.JPG" alt=""></td><td style="text-align:left">查看并设置所有断点信息。</td></tr><tr><td><img src="mute_breakpoints.JPG" alt=""></td><td style="text-align:left">禁止所有断点。</td></tr><tr><td><img src="thread_dump.JPG" alt=""></td><td style="text-align:left">获取线程的运行状态、标识和调用的堆栈信息。</td></tr></tbody></table></div><h2 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h2><p>右键单击断点处即可设置条件断点，通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p><img src="condition_breakpoint.jpg" alt=""></p><p>多线程调试时，需要调整断点挂起级别为Thread。</p><p><img src="multi_thread_debug.jpg" alt=""></p><h1 id="CMD切换编码"><a href="#CMD切换编码" class="headerlink" title="CMD切换编码"></a>CMD切换编码</h1><ul><li>chcp命令：chcp 65001 -&gt; 切换为UTF-8；chcp 936 -&gt; 切换为GBK。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#IDEA插件推荐&quot;&gt;IDEA插件推荐&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#Material Theme UI&quot;&gt;Material Theme UI&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#Lombok&quot;&gt;Lo
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="杂项" scheme="http://thmasterplan.cn/tags/%E6%9D%82%E9%A1%B9/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/Git/"/>
    <id>http://thmasterplan.cn/%E6%9D%82%E9%A1%B9/Git/</id>
    <published>2020-10-25T06:33:13.000Z</published>
    <updated>2020-11-23T14:23:21.002Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#版本控制">版本控制</a></p><ul><li><p><a href="#本地版本控制系统">本地版本控制系统</a></p></li><li><p><a href="#集中化版本控制系统">集中化版本控制系统</a></p></li><li><p><a href="#分布式版本控制系统">分布式版本控制系统</a></p></li></ul><p><a href="#Git配置">Git配置</a></p><p><a href="#Git的原理">Git的原理</a></p><ul><li><p><a href="#Git三大区域">Git三大区域</a></p></li><li><p><a href="#实体、引用与索引">实体、引用与索引</a></p><ul><li><p><a href="#实体">实体</a></p></li><li><p><a href="#引用">引用</a></p></li><li><p><a href="#索引">索引</a></p></li></ul></li></ul><p><a href="#Git项目搭建">Git项目搭建</a></p><ul><li><p><a href="#本地新建">本地新建</a></p></li><li><p><a href="#远程克隆">远程克隆</a></p></li></ul><p><a href="#Git文件操作">Git文件操作</a></p><ul><li><p><a href="#文件的四种状态">文件的四种状态</a></p></li><li><p><a href="#常用命令">常用命令</a></p></li><li><p><a href="#忽略文件">忽略文件</a></p></li></ul><p><a href="#为注释">为注释</a></p><p><a href="#Git分支">Git分支</a></p><ul><li><a href="#分支合并">分支合并</a></li></ul><p><a href="#Idea集成Git">Idea集成Git</a></p><ul><li><a href="#克隆云端项目到IDEA">克隆云端项目到IDEA</a></li></ul><h1 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h1><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便<strong>查看更改历史记录</strong>，<strong>备份以便恢复以前的版本</strong>的软件工程技术。最重要的是可以实现<strong>跨区域多人协同开发</strong>。</p><h2 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h2><p>最流行的是<strong>RCS</strong>。</p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件（补丁指文件修订前后的变化），适合个人用。</p><p><img src="local.png" alt=""></p><h2 id="集中化版本控制系统"><a href="#集中化版本控制系统" class="headerlink" title="集中化版本控制系统"></a>集中化版本控制系统</h2><p>最流行的是<strong>SVN</strong>。</p><p>所有的版本数据都保存在服务器上，用户在服务器上同步更新或上传自己的修改。用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。</p><p>管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>缺点是服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。当然可以在服务端进行主从备份。</p><p><img src="centralized.png" alt=""></p><h2 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h2><p>最流行的是<strong>Git</strong>。</p><p>客户端拥有代码仓库的完整镜像，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><p>对于数据权限敏感性高的公司来说不适用。</p><p><img src="distributed.png" alt=""></p><h1 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h1><p>使用<code>git config</code>命令查看所有的配置选项。其中：</p><ul><li><p>查看系统配置：<code>git config --system -l</code>，其配置文件所在：<code>安装路径\Git\etc\gitconfig</code>。</p></li><li><p>查看用户配置：<code>git config --global -l</code> ，其配置文件所在：<code>C:\Users\用户名\.gitconfig</code>。</p></li><li><p>设置用户名与邮箱（必要）：每次提交都会用到该用户标识。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"zhangsan"</span></span><br><span class="line">git config --global user.email <span class="string">"1234@126.com"</span></span><br></pre></td></tr></table></figure></li></ul><h1 id="Git的原理"><a href="#Git的原理" class="headerlink" title="Git的原理"></a>Git的原理</h1><h2 id="Git三大区域"><a href="#Git三大区域" class="headerlink" title="Git三大区域"></a>Git三大区域</h2><ul><li>工作区：存放项目代码的地方。</li><li>暂存区：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li>本地版本库：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据，每提交一次修改就会有一个新的版本。其中HEAD指向最新放入仓库的版本。</li></ul><p>三大区域与远程库交互的图示如下：</p><p><img src="git.png" alt=""></p><h2 id="实体、引用与索引"><a href="#实体、引用与索引" class="headerlink" title="实体、引用与索引"></a>实体、引用与索引</h2><h3 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h3><ul><li><p>提交到本地仓库中的所有文件，包括每个提交的说明信息，目录结构等都会转换成实体。</p></li><li><p>所有实体均存在于.git/objects/目录中。</p></li><li><p>git中每一个实体以一个40字符长度的十六进制字符串来唯一标识。</p></li><li>git中包括四种类型的实体：<ul><li>blob：文件内容。</li><li>tree：文件名与目录结构。</li><li>commit：提交的作者、日期与说明等。</li><li>tag：指向某提交对象的引用。</li></ul></li></ul><h3 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h3><ul><li><p>Git 中，<strong>一个分支（branch）、远程分支（remote branch）或一个标签（tag）仅是指向一个实体的一个指针</strong>，这里的实体通常是一个commit实体。这些引用以文本文件的形式存储在目录 .git/refs/ 中。</p></li><li><p>Git 有一种特殊的引用，称为符号引用。它并不直接指向一个实体，而是指向另一个引用。比如，.git/HEAD就是一个符号引用。它指向你正在工作的当前分支的最新版本，初始为main分支。</p></li></ul><h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h3><ul><li>索引是一个暂存区，以二进制文件的形式存储为文件 .git/index 中。当<code>git add</code> 一个文件，git 将该文件的信息添加到索引中；当<code>git commit</code>时，git 仅提交索引文件中列出的文件到 git 本地仓库。</li></ul><p>实体、引用与索引的关系如图：</p><p><img src="entity_ref_index.png" alt=""></p><h1 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h1><h2 id="本地新建"><a href="#本地新建" class="headerlink" title="本地新建"></a>本地新建</h2><ol><li>在项目根目录下：<code>git init</code>，就会生成.git目录。</li><li>本地生成SSH公钥：<code>ssh-keygen rsa</code>命令生成公钥，生成目录为用户目录下的<code>.ssh</code>文件夹，拷贝公钥<code>id_rsa.pub</code>的文本到github/gitee/gitlab对应处，即可无需密码登录。</li><li><code>git branch -M main</code>：重命名默认分支名master为主分支main。</li><li>在项目根目录下：<code>git remote add origin [远程仓库地址]</code>，给远程仓库地址命名为origin，方便后续使用。远程仓库地址SSH方式示例：<code>git@github.com:Github用户名/项目名.git</code>。</li><li>在项目根目录下：<code>git push -u origin main</code>，将main分支push到远程仓库。</li></ol><h2 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h2><ul><li>在本地没有项目的情况下初次克隆：<code>git clone [url]</code>。</li><li>在本地已有项目的情况下：<code>git pull origin main</code>。</li></ul><h1 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h1><h2 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h2><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态。</p><p>使用<code>git status</code>查看文件状态。</p><ul><li>Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。</li><li>Staged：暂存状态。</li><li>Committed：文件已经提交到本地仓库。</li><li>Modified： 工作目录中文件若已修改，通过<code>git add</code>可进入暂存staged状态，<code>git commit</code>提交修改到本地仓库；也可使用<code>git checkout</code>丢弃修改，即从仓库中取出之前的版本覆盖当前修改。</li></ul><p>git状态转换如图所示：</p><p><img src="git_file_state.png" alt=""></p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><ul><li><code>git add .</code>：添加当前目录所有文件到暂存区。</li><li><code>git commit -m &quot;提交信息&quot;</code>：提交。</li></ul><h2 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h2><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立<code>.gitignore</code>文件(IDEA项目会自动生成)，此文件有如下规则：</p><ul><li>空行或以<code>#</code>开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：<code>*</code>代表任意多个字符，<code>?</code>代表一个字符，<code>[abc]</code>代表可选字符范围，<code>{string1,string2,...}</code>代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号<code>!</code>，表示例外规则，将不被忽略。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">&#x2F;temp        #忽略temp同级目录其他文件和目录，不忽略temp目录</span><br><span class="line">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure><h1 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h1><p><strong>每个分支有多个版本，每提交一次修改就会有一个新的版本</strong>，HEAD指向当前分支的最新版本。</p><p>Git默认创建分支master，使用<code>git branch</code>查看当前所有分支。</p><p><strong>在商业项目开发中，不会轻易在主分支上操作，而是建立一个开发用的分支，最后将成熟的代码添加到主分支上。</strong></p><ul><li>创建新分支：<code>git branch 分支名</code>。新分支与当前分支指向同一个提交点（版本），切换到新分支后的提交才是新分支独有的。</li><li>切换到另一个分支：<code>git checkout 分支名</code>。</li><li>查看分支提交日志：<code>git log --oneline</code>或<code>git log</code>。</li></ul><h2 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h2><ul><li><p><strong>快速合并：</strong></p><ol><li><p>假设某时刻在main分支，<code>git branch dev</code>创建dev分支，<code>git checkout dev</code>切换到dev分支，此时main和dev都指向最新的同一个版本，如图所示：</p><p><img src="fast_merge_1.jpg" alt=""></p></li><li><p>添加某个文件test，<code>git add test</code>-&gt;<code>git commit -m &quot;test merge&quot;</code>提交形成新版本后，dev指向了新版本而main还在前一个版本，如何让main分支与dev合并呢？如图所示：</p><p><img src="fast_merge_2.jpg" alt=""></p></li><li><p><code>git checkout main</code>先切回main分支，然后<code>git merge dev</code>，此时Git的实际操作是将main指针指向dev指向的同一个版本实体，因此称为快速合并。 </p><p><img src="fast_merge.jpg" alt=""></p></li></ol></li></ul><p>快速合并前提：一个分支没有变化，另一个分支有新版本的情况。如果两个分支都有修改则不适用。</p><ul><li><p><strong>三方合并：</strong></p><p>适用于两个分支都有新版本的情况。</p><ol><li>假设某时刻在main分支，<code>git branch dev</code>创建dev分支，<code>git checkout dev</code>切换到dev分支，此时main和dev都指向最新的同一个版本；</li><li>添加某个文件test，<code>git add test</code>-&gt;<code>git commit -m &quot;test merge&quot;</code>提交形成新版本，dev指向了新版本；</li><li><code>git checkout main</code>切换回main分支，修改某个文件，提交形成新版本，main指向了新版本；</li><li><code>git merge dev</code>，创建新版本，该版本是main分支的修改版本与dev修改版本的合并，main指针指向该新版本，dev则不变，依旧指向其修改的那个版本。</li></ol></li><li><p><strong>合并冲突：</strong>两个分支都对以前相同版本的某个文件进行了修改，如何合并呢？</p><p>Git会将两个分支的修改都保留下，由用户协商进行保留。</p></li></ul><h1 id="Idea集成Git"><a href="#Idea集成Git" class="headerlink" title="Idea集成Git"></a>Idea集成Git</h1><p>IDEA在顶部菜单栏VCS选项下集成了版本控制功能，选择<code>Import into Version Control</code>，选择<code>Create Git Repository</code>即可。</p><p>项目目录中，红色表示该文件状态为Untracked，蓝色表示文件被修改（Modified），否则则是被忽略。</p><p>VCS-&gt;Git-&gt;Push-&gt;Define remote设置远程仓库URL，即可push本地仓库到云端。</p><p><img src="idea_git.png" alt=""></p><h2 id="克隆云端项目到IDEA"><a href="#克隆云端项目到IDEA" class="headerlink" title="克隆云端项目到IDEA"></a>克隆云端项目到IDEA</h2><p>VCS-&gt;Checkout from Version Control-&gt;Git，填入URL</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#版本控制&quot;&gt;版本控制&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#本地版本控制系统&quot;&gt;本地版本控制系统&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#集中化版本控制系统&quot;&gt;集中化版本控制系统&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;
      
    
    </summary>
    
    
      <category term="杂项" scheme="http://thmasterplan.cn/categories/%E6%9D%82%E9%A1%B9/"/>
    
    
      <category term="Git" scheme="http://thmasterplan.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://thmasterplan.cn/JavaWeb/MyBatis/"/>
    <id>http://thmasterplan.cn/JavaWeb/MyBatis/</id>
    <published>2020-10-21T04:12:46.000Z</published>
    <updated>2021-01-27T08:59:40.536Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="#全局配置文件">全局配置文件</a></p><ul><li><p><a href="#约束">约束</a></p></li><li><p><a href="#properties标签（不常用）">properties标签（不常用）</a></p></li><li><p><a href="#settings标签">settings标签</a></p></li><li><p><a href="#typeAliases标签">typeAliases标签</a></p></li><li><p><a href="#typeHandlers标签">typeHandlers标签</a></p></li><li><p><a href="#enviroments标签">enviroments标签</a></p><ul><li><p><a href="#事务管理器（transactionManager）">事务管理器（transactionManager）</a></p></li><li><p><a href="#数据源（DataSource）">数据源（DataSource）</a></p></li></ul></li><li><p><a href="#databaseIdProvider标签">databaseIdProvider标签</a></p></li><li><p><a href="#mappers标签">mappers标签</a></p><ul><li><p><a href="#mapper子标签">mapper子标签</a></p></li><li><p><a href="#package子标签">package子标签</a></p></li></ul></li><li><p><a href="#plugins标签">plugins标签</a></p></li><li><p><a href="#objectFactory标签">objectFactory标签</a></p></li></ul></li><li><p><a href="#映射文件">映射文件</a></p><ul><li><p><a href="#约束">约束</a></p></li><li><p><a href="#select, insert, update和delete标签">select, insert, update和delete标签</a></p></li><li><p><a href="#sql标签">sql标签</a></p></li><li><p><a href="#DAO接口方法参数值与SQL语句字段值的传递">DAO接口方法参数值与SQL语句字段值的传递</a></p></li><li><p><a href="#结果映射(ORM">结果映射(ORM)</a>)</p><ul><li><p><a href="#自动映射">自动映射</a></p></li><li><p><a href="#自定义结果集映射: resultMap">自定义结果集映射: resultMap</a></p></li></ul></li></ul></li><li><p><a href="#动态SQL">动态SQL</a></p><ul><li><p><a href="#if标签">if标签</a></p></li><li><p><a href="#trim标签">trim标签</a></p></li><li><p><a href="#choose标签">choose标签</a></p></li><li><p><a href="#set标签">set标签</a></p></li><li><p><a href="#foreach标签">foreach标签</a></p></li><li><p><a href="#script">script</a></p></li><li><p><a href="#bind标签">bind标签</a></p></li></ul></li><li><p><a href="#缓存">缓存</a></p><ul><li><p><a href="#一级缓存">一级缓存</a></p></li><li><p><a href="#二级缓存">二级缓存</a></p></li><li><p><a href="#缓存相关配置">缓存相关配置</a></p></li></ul></li><li><p><a href="#逆向工程">逆向工程</a></p></li></ul><h2 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="properties标签（不常用）"><a href="#properties标签（不常用）" class="headerlink" title="properties标签（不常用）"></a>properties标签（不常用）</h3><p>使用该标签可引入外部properties配置文件的内容，或在子标签property中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/config.properties"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dev_user"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"F2Fa3!33TYyg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h3><p>该配置用于配置全局参数，参见官方文档。</p><h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><p> 为Java的全类名设置缩短的别名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Author"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Author"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名(批量设置别名)，MyBatis 会在包名下面搜索需要的 Java Bean。每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain.blog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias</span>(<span class="string">"author"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我们设置的别名不能与MyBatis的<strong>内置别名</strong>（见文档）冲突。</p><h3 id="typeHandlers标签"><a href="#typeHandlers标签" class="headerlink" title="typeHandlers标签"></a>typeHandlers标签</h3><p>MyBatis在设置PreparedStatement中的参数或从结果集取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。在<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">官方文档</a>中描述了一些默认的类型处理器。</p><p>我们可以重写已有的类型处理器或自己创建类型处理器来处理不支持的或非标准的类型：实现 <code>org.apache.ibatis.type.TypeHandler</code>接口， 或继承 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 并且可以（可选地）将它映射到一个 JDBC 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.mybatis.example.ExampleTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用上述的类型处理器将会覆盖默认的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。</p><h3 id="enviroments标签"><a href="#enviroments标签" class="headerlink" title="enviroments标签"></a>enviroments标签</h3><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span> <span class="tag">&lt;<span class="name">！--指定默认使用哪种环境</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--测试使用的环境--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">           .....</span><br><span class="line">       <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">   <span class="comment">&lt;!--开发使用的环境--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，<strong>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong>所以，需要连接N个数据库，就需要创建N个SqlSessionFactory实例，<strong>每个数据库对应一个SqlSessionFactory</strong>。</p><h4 id="事务管理器（transactionManager）"><a href="#事务管理器（transactionManager）" class="headerlink" title="事务管理器（transactionManager）"></a>事务管理器（transactionManager）</h4><p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）。如果使用 Spring + MyBatis，则没有必要配置事务管理器，因为 <strong>Spring 模块会使用自带的管理器来覆盖MyBatis的配置</strong>。</p><h4 id="数据源（DataSource）"><a href="#数据源（DataSource）" class="headerlink" title="数据源（DataSource）"></a>数据源（DataSource）</h4><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）:</p><ul><li><p>UNPOOLED：不使用连接池，每次请求时打开和关闭连接。</p></li><li><p>POOLED：使用连接池。该别名对应的类为PooledDataSourceFactory，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>常用属性见<a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments" target="_blank" rel="noopener">官方文档</a>。</p></li></ul><ul><li>JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</li></ul><p>使用自定义数据源：实现接口<code>org.apache.ibatis.datasource.DataSourceFactory</code>或者继承<code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code>，dataSource标签的type属性指定实现类的全类名。</p><h3 id="databaseIdProvider标签"><a href="#databaseIdProvider标签" class="headerlink" title="databaseIdProvider标签"></a>databaseIdProvider标签</h3><p> 为支持多厂商特性，MyBatis 可以根据不同的数据库厂商执行不同的语句。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--DB_VENDOR：VendorDatabaseIdProvider的别名，其作用是得到数据库厂商的标识--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为不同的数据库厂商取别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"MySQL"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"SQL Server"</span> <span class="attr">value</span>=<span class="string">"sqlserver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Oracle"</span> <span class="attr">value</span>=<span class="string">"oracle"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"DB2"</span> <span class="attr">value</span>=<span class="string">"db2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在映射文件具体的SQL语句配置中指定数据库厂商别名(databaseId属性)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span> <span class="attr">databaseId</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">         select id, last_name lastName, gender,email from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><p>该标签告诉MyBatis去哪里找映射文件。</p><h4 id="mapper子标签"><a href="#mapper子标签" class="headerlink" title="mapper子标签"></a>mapper子标签</h4><p>有如下属性：</p><ul><li>resource：引用相对类路径下的映射文件。</li><li>url：引用网络或磁盘路径下的映射文件。</li><li>class：使用DAO接口的全类名。（注解配置）</li></ul><h4 id="package子标签"><a href="#package子标签" class="headerlink" title="package子标签"></a>package子标签</h4><p>name属性指定DAO所在的包名：将包内的所有DAO接口实现全部注册为映射器（所谓映射器就是dao接口的代理对象）。(注解配置)</p><h3 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h3><p>MyBatis 允许我们在映射语句执行过程中的某一点进行拦截调用（动态代理）。默认情况下，MyBatis 允许使用插件来拦截的方法有：</p><ul><li>Executor ：update, query, flushStatements, commit, rollback, getTransaction, close, isClosed.</li><li>ParameterHandler ：getParameterObject, setParameters.</li><li>ResultSetHandler ：handleResultSets, handleOutputParameters.</li><li>StatementHandler ：prepare, parameterize, batch, update, query.</li></ul><h3 id="objectFactory标签"><a href="#objectFactory标签" class="headerlink" title="objectFactory标签"></a>objectFactory标签</h3><p>每次 MyBatis <strong>创建结果对象的新实例时</strong>，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。具体使用参见文档。</p><p>使用场景：比如在学校系统中，学生除了有基础信息，我们还想临时添加一个总成绩的属性用来表示最近一次成绩总分。这个时候我们就可以通过自定义ObjectFactory来实现了。在创建好对象后在去查询数据进行填充。</p><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><h3 id="约束-1"><a href="#约束-1" class="headerlink" title="约束"></a>约束</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="select-insert-update和delete标签"><a href="#select-insert-update和delete标签" class="headerlink" title="select, insert, update和delete标签"></a>select, insert, update和delete标签</h3><p><a href="https://github.com/Laishiji/FrameworkLearningDemo/tree/main/MyBatisDemo" target="_blank" rel="noopener">CRUD Demo</a>。mapper.xml示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--增--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">        insert into user(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用useGeneratedKeys和keyProperty属性获取自增长ID并将其封装给pojo对应的成员变量id，这两个属性仅适用于insert和update标签</span></span><br><span class="line"><span class="comment">    &lt;insert id="addUser" useGeneratedKeys="true" keyProperty="id"&gt;</span></span><br><span class="line"><span class="comment">        insert into user(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span></span><br><span class="line"><span class="comment">    &lt;/insert&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUserById"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update user set last_name=#&#123;lastName&#125;, gender=#&#123;gender&#125;, email=#&#123;email&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--查--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">         select id, last_name, gender,email from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCRUD</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(<span class="string">"MyBatisConfig.xml"</span>);</span><br><span class="line"></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">//sqlSessionFactory.openSession(true);表示自动提交</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();<span class="comment">//需要手动提交</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        IUserMapper userMapper = openSession.getMapper(IUserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        <span class="comment">//userMapper.addUser(new User(null, "张三", "abd@gmail.com", "男"));</span></span><br><span class="line">        <span class="comment">//删</span></span><br><span class="line">        <span class="comment">//userMapper.deleteUserById(5);</span></span><br><span class="line">        <span class="comment">//改</span></span><br><span class="line">        <span class="comment">//userMapper.updateUser(new User(1, "Tom", "abcdefg@126.com","男"));</span></span><br><span class="line">        <span class="comment">//查</span></span><br><span class="line">        System.out.println(userMapper.getUserById(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//手动提交</span></span><br><span class="line">        openSession.commit();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，MyBatis允许增删改的DAO接口方法定义以下类型返回值（不需要在mapper.xml中定义返回属性）：Integer/Long/Boolean/void。</p><h3 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h3><p>用于<strong>定义可重用的sql片段</strong>，方便后面引用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"insertColumn"</span>&gt;</span></span><br><span class="line">    id,last_name,email,gender</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">    insert into user(</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"insertColumn"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    ) values</span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DAO接口方法参数值与SQL语句字段值的传递"><a href="#DAO接口方法参数值与SQL语句字段值的传递" class="headerlink" title="DAO接口方法参数值与SQL语句字段值的传递"></a>DAO接口方法参数值与SQL语句字段值的传递</h3><ul><li>dao接口方法只有一个参数：#{参数名}直接取出参数的值。</li><li><p>dao接口方法有多个参数：</p><ul><li>默认情况下：多个参数会被MyBatis封装成一个map，其key是MyBatis指定的固定形式：param1, param2, …paramN；value才是传入的参数值。SQL语句通过固定形式#{param1}, #{param2}, …取值。</li><li>我们也可以明确指定key的值：在DAO接口方法参数列表的每一个参数前使用<code>Param(&quot;key&quot;)</code>注解 。</li><li>若多个参数正好是POJO的成员变量，则直接传入POJO。</li><li>也可以传入一个Map，然后在SQL语句中使用#{key}来取值。</li></ul></li><li><p>示例：</p><ul><li><p>接口方法：<code>public User getUser(@Param(&quot;id&quot;)Integer id, String lastName);</code></p><p>SQL语句取值：id==&gt;#{id}/#{param1}, lastName==&gt;#{param2}</p></li><li><p>接口方法：<code>public User getUser(Integer id, User user);</code></p><p>SQL语句取值：id==&gt;#{param1}, lastName==&gt;#{param2.lastName}</p></li><li><p>接口方法：<code>public User getUser(List&lt;Integer&gt; ids);</code></p><p>SQL语句取值（固定形式）：#{list[0]}, #{list[1]}…</p><p>注意：若参数列表是集合类型或数组，取值都是固定形式。比如#{list[0]}, #{array[0]}。</p></li></ul></li><li><p>SQL语句中也可使用<code>${key}</code>取值，它与<code>#{key}</code>的区别是：前者取值后直接赋值给SQL语句对应字段，后者是以预编译（PreparedStatement）的形式将参数设置到SQL语句中。<code>${key}</code>的使用场景是：SQL不支持占位符的地方（非字段）使用。</p></li><li><code>#{}</code>使用时可以指定一些规则：jdbcType, javaType等，参见文档。</li></ul><h3 id="结果映射-ORM"><a href="#结果映射-ORM" class="headerlink" title="结果映射(ORM)"></a>结果映射(ORM)</h3><h4 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h4><p>全局配置中setting标签有一个属性autoMappingBehavior，其值默认为PARTIAL，开启自动映射的功能，唯一的要求是表的列名和POJO成员变量名一致。另外，可以通过设置mapUnderscoreToCamelCase=true来使数据库字段命名规范中的A_COLUMN自动映射为Java中的驼峰命名法aColumn。</p><p>以下是一些自动映射的例子：</p><ul><li><p>DAO接口方法返回POJO类或List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByLastNameLike</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByLastNameLike"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from user where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DAO接口方法返回单条记录的Map，key是字段名，值是记录对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getUserByIdReturnMap</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByIdReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DAO接口方法返回多条记录的Map，key是记录的主键，值是POJO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"id"</span>)<span class="comment">//该注解用于指定key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Integer, User&gt; <span class="title">getUserByLastNameLikeReturnMap</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByLastNameLikeReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from user where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义结果集映射-resultMap"><a href="#自定义结果集映射-resultMap" class="headerlink" title="自定义结果集映射: resultMap"></a>自定义结果集映射: resultMap</h4><p>resultMap属性和resultMap标签用于自定义结果集映射规则，resultMap和resultType属性只能选择一个使用。mapper.xml示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义某个POJO类的封装规则</span></span><br><span class="line"><span class="comment">        type: 自定义规则的POJO全类名</span></span><br><span class="line"><span class="comment">        id: 用于引用</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span> <span class="attr">id</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定主键列的封装规则</span></span><br><span class="line"><span class="comment">            column: 指定哪一列</span></span><br><span class="line"><span class="comment">            property: 指定对应的POJO类成员变量</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--定义普通列的封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其他不指定的列会自动封装，建议都指定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用场景示例：</p><ol><li><p>查询User的同时查询其对应的Department。<a href="https://github.com/Laishiji/FrameworkLearningDemo/tree/main/MyBatisDemoWithResultMap" target="_blank" rel="noopener">demo</a></p><p>IUserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义User类的封装规则1, 使用级联属性的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"myMap"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下是Department的映射,使用级联属性的方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"department.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"department.departmentName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义User类的封装规则2, 使用association标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"myMap2"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下是Department的映射，使用association标签</span></span><br><span class="line"><span class="comment">            property: 指定User中哪个属性是联结的对象</span></span><br><span class="line"><span class="comment">            javaType: 指定该属性对象的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">javaType</span>=<span class="string">"org.example.pojo.Department"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserAndDept"</span> <span class="attr">resultMap</span>=<span class="string">"myMap2"</span>&gt;</span></span><br><span class="line">          select u.id, u.last_name, u.gender, u.email, u.dept_id, d.dept_name</span><br><span class="line">        from user u , dept d where u.dept_id=d.id and u.id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义User类的封装规则3, 使用association进行分步查询</span></span><br><span class="line"><span class="comment">        1.使用User的id查询User所有信息</span></span><br><span class="line"><span class="comment">        2.根据返回信息中的dept_id值去dept表查询Department信息</span></span><br><span class="line"><span class="comment">        3.将Department信息设置到User中</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"myMap3"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--select属性：表明当前User的属性department是通过getDepartmentById方法查询得到</span></span><br><span class="line"><span class="comment">            column属性：将dept_id列的值作为参数传递给getDepartmentById方法</span></span><br><span class="line"><span class="comment">                       当column要传递多个参数时，可使用&#123;key1=column1,key2=column2..&#125;</span></span><br><span class="line"><span class="comment">                       的形式。</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">"org.example.dao.IDepartmentMapper.getDepartmentById"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">column</span>=<span class="string">"dept_id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"myMap3"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用分步查询的好处是，可以使用延迟加载，我们只在需要查询部门信息的时候再去查询它，大大提升了效率。</span></span><br><span class="line"><span class="comment">        实现延迟加载：只需要再分步查询的基础上在全局配置文件的setting中设置lazyLoadingEnabled为true，</span></span><br><span class="line"><span class="comment">        aggressiveLazyLoading为false即可；或者在association/collection标签中配置fetchType="lazy"。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>IDepartmentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IDepartmentMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentById"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.Department"</span>&gt;</span></span><br><span class="line">        select  id, dept_name departmentName from dept where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Department中添加成员变量<code>List&lt;User&gt; users</code>，查询一个Department时查询对应的users。<a href="https://github.com/Laishiji/FrameworkLearningDemo/tree/main/MyBatisDemoWithResultMap2" target="_blank" rel="noopener">demo</a></p><p>IDepartmentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyDeptMap"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.Department"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--collection标签定义关联集合类型的属性的封装规则</span></span><br><span class="line"><span class="comment">        property: 指定集合类型的成员变量</span></span><br><span class="line"><span class="comment">        ofType: 指定集合内元素类型</span></span><br><span class="line"><span class="comment">        select: 用于分步查询，参考association</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义集合中元素的封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentById2"</span> <span class="attr">resultMap</span>=<span class="string">"MyDeptMap"</span>&gt;</span></span><br><span class="line">     select d.id did, d.dept_name, u.id uid, u.last_name, u.email, u.gender</span><br><span class="line">     from dept d left join user u</span><br><span class="line">     on d.id=u.dept_id where d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>discriminator鉴别器：resultMap子标签，使用该标签可<strong>根据某列（column）的值改变封装行为</strong>。例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--某列字段的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"String"</span> <span class="attr">column</span>"<span class="attr">gender</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"女"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">select</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">""</span> <span class="attr">property</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">""</span> <span class="attr">property</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><p>用于动态拼接SQL语句。</p><p>test属性：值为判断表达式（OGNL），从DAO接口方法参数列表中取值进行判断。特殊符号需要转义<code>&quot; -&gt; &amp;quot;</code>, <code>&#39; -&gt; &amp;apos;</code>, <code>&amp; -&gt; &amp;amp;</code>, <code>&lt; -&gt; &amp;lt;</code>, <code>&gt; -&gt; &amp;gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionIf"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null and lastName.trim()!=''"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--多余的and--&gt;</span>and last_name like #&#123;lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email!=''"</span>&gt;</span></span><br><span class="line">                and email=#&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender=='男' or gender=='女'"</span>&gt;</span></span><br><span class="line">                and gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userMapper.getUserByConditionIf(<span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">"Tom"</span>, <span class="string">"abcdefg@126.com"</span>, <span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><p>对于调用方法参数中第一个条件为null的情况，可以使用where标签消除第一个and关键字，避免SQL语句错误。</p><h3 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h3><p>属性：</p><ul><li>prefix：给trim标签中拼接后的字符串添加一个前缀。</li><li>prefixOverrides：去掉trim标签中拼接后的字符串前面多余的字符。</li><li>suffix：给trim标签中拼接后的字符串添加一个后缀。</li><li>suffixOverrides：去掉trim标签中拼接后的字符串后面多余的字符。</li></ul><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionTrim"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">suffixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null and lastName.trim()!=''"</span>&gt;</span></span><br><span class="line">               last_name like #&#123;lastName&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email!=''"</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125; and <span class="comment">&lt;!--多余的and--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender=='男' or gender=='女'"</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125; </span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span>           </span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userMapper.getUserByConditionTrim(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"Tom"</span>, <span class="string">"abcdefg@126.com"</span>, <span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><h3 id="choose标签"><a href="#choose标签" class="headerlink" title="choose标签"></a>choose标签</h3><p>分支选择，类似于switch-case。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionChoose"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span><span class="comment">&lt;!--switch--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span> <span class="comment">&lt;!--case--&gt;</span></span><br><span class="line">                    id=#&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">                    last_name like #&#123;lastName&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--前面的条件都不满足则--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    1=1</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><p>用于update的SQL语句，去除多余的<code>,</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">                last_name=#&#123;lastName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionForeach"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">  select * from user where id in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item_id"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item_id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByConditionForeach</span><span class="params">(@Param(<span class="string">"ids"</span>)</span>List&lt;Integer&gt; idList)</span>;</span><br></pre></td></tr></table></figure><p>可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是key，item 是value。</p><p>foreach标签也常用于<strong>批量insert操作</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUsers"</span>&gt;</span></span><br><span class="line">    insert into user(last_name, email, gender) values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"user"</span> <span class="attr">collection</span>=<span class="string">"users"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (#&#123;user.lastName&#125;, #&#123;user.email&#125;, #&#123;user.gender&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUsers</span><span class="params">(@Param(<span class="string">"users"</span>)</span>List&lt;User&gt; users)</span>;</span><br></pre></td></tr></table></figure><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>注解方式配置dao接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(&#123;<span class="string">"&lt;script&gt;"</span>,</span><br><span class="line">     <span class="string">"update Author"</span>,</span><br><span class="line">     <span class="string">"  &lt;set&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='username != null'&gt;username=#&#123;username&#125;,&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='password != null'&gt;password=#&#123;password&#125;,&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='email != null'&gt;email=#&#123;email&#125;,&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='bio != null'&gt;bio=#&#123;bio&#125;&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"  &lt;/set&gt;"</span>,</span><br><span class="line">     <span class="string">"where id=#&#123;id&#125;"</span>,</span><br><span class="line">     <span class="string">"&lt;/script&gt;"</span>&#125;)</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="bind标签"><a href="#bind标签" class="headerlink" title="bind标签"></a>bind标签</h3><p>该标签可以将OGNL表达式的值绑定到一个变量中，方便后面引用该变量的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"变量名"</span> <span class="attr">value</span>=<span class="string">"OGNL表达式"</span>&gt;</span><span class="tag">&lt;/<span class="name">bind</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache" target="_blank" rel="noopener">MyBatis官方文档</a></p><p>Mybatis 的缓存是针对SQL语句查询的优化，极大地提升了查询效率。实际开发中使用Redis实现缓存。</p><p>MyBatis默认定义了两级缓存：</p><ul><li>默认情况下，只开启了一级缓存（SqlSession级别，也称本地缓存）。</li><li>二级缓存需要手动开启和配置（基于命名空间，全局缓存）。</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存。MyBatis中的缓存就是一个HashMap。</li></ul><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>与数据库同一次会话期间查询到的数据会放在本地缓存中，下次获取相同的数据时（需要SqlSession, mapper方法和参数，SQL语句都相同）直接从缓存中获取。</p><p>两次相同的查询之间若执行了增删改操作，清除缓存。</p><p>可以使用openSession.clearCache()方法清除一级缓存。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>一个namespace对应一个二级缓存。<strong>一个会话查询一条数据，该数据会被放在当前会话的一级缓存中。若会话关闭，则一级缓存数据会被保存到二级缓存中</strong>，<u><strong>新的会话查询数据会先参照二级缓存</strong></u>。二级缓存的使用：在映射文件中添加<code>&lt;cache/&gt;</code>即可，<strong>缓存只作用于该映射文件下的SQL语句</strong>，该标签有如下属性：</p><ul><li>eviction：缓存的清除策略。有如下取值：<ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用：当<strong>系统将要发生OOM异常时</strong>，软引用指向的对象才被真正回收。</li><li><code>WEAK</code> – 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。</li></ul></li><li>flushInterval：缓存刷新间隔，即多长时间清空一次缓存，单位ms。默认不清空。</li><li>size：缓存引用数目。默认1024。</li><li>readOnly：是否只读。默认false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化，POJO类需要实现Serializable接口）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</li><li>type：自定义缓存的全类名。</li></ul><p><code>&lt;cache/&gt;</code>标签的效果默认如下：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><h3 id="缓存相关配置"><a href="#缓存相关配置" class="headerlink" title="缓存相关配置"></a>缓存相关配置</h3><ul><li>全局配置文件：<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&gt;</code>, 默认开启二级缓存。一级缓存默认开启无法关闭。</li><li>全局配置文件：<code>&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;&gt;</code>。MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</li><li>select标签的属性useCache，默认为true，为false则关闭二级缓存。</li><li>insert, update, delete标签的属性flushCache, 默认为true，即增删改后默认清除一级缓存和二级缓存。</li></ul><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p><a href="http://mybatis.org/generator/" target="_blank" rel="noopener">mybatis generator doc</a>.</p><p>使用mybatis generator根据数据库表自动生成POJO类，DAO接口以及映射文件。</p><p>注意：生成的只包含单表查询，多表联查需要自行编写。</p><p>使用步骤：</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>与pom.xml同级目录下编写myBatisGenerator.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用逆向工程生成数据库对应表的POJO类、DAO接口和映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"DB2Tables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不生成注释--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置数据库连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/ssm_crud?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定POJO类生成位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"org.example.bean"</span> <span class="attr">targetProject</span>=<span class="string">".\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定SQL映射文件生成位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span>  <span class="attr">targetProject</span>=<span class="string">".\src\main\resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定DAO接口生成位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"org.example.dao"</span>  <span class="attr">targetProject</span>=<span class="string">".\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定数据库每个表的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"employee"</span> <span class="attr">domainObjectName</span>=<span class="string">"Employee"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"department"</span> <span class="attr">domainObjectName</span>=<span class="string">"Department"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>MBGTest.java</code>并运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MBGTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        File configFile = <span class="keyword">new</span> File(<span class="string">"myBatisGenerator.xml"</span>);</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>生成的类中包含XXXExample.java的，表示条件查询。条件查询使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求：查询雇员名字中包含e字母并且性别为1</span></span><br><span class="line">EmployeeMapper mapper = openSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">Criteria criteria = example.createCriteria();<span class="comment">//Criteria对象封装查询的条件</span></span><br><span class="line">criteria.andLastNameLike(<span class="string">"%e%"</span>);</span><br><span class="line">criteria.andGenderEqualTo(<span class="string">"1"</span>);</span><br><span class="line">List&lt;Employee&gt; list = mapper.selectByExample(example);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#全局配置文件&quot;&gt;全局配置文件&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#约束&quot;&gt;约束&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#properties标签（不常用）&quot;&gt;properties标签（不常用
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="MyBatis" scheme="http://thmasterplan.cn/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://thmasterplan.cn/JavaWeb/SpringMVC/"/>
    <id>http://thmasterplan.cn/JavaWeb/SpringMVC/</id>
    <published>2020-10-18T06:42:34.000Z</published>
    <updated>2020-11-23T14:23:21.096Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><a href="#B/S三层架构与MVC模型">B/S三层架构与MVC模型</a></p><ul><li><p><a href="#三层架构">三层架构</a></p></li><li><p><a href="#MVC模型">MVC模型</a></p></li></ul></li><li><p><a href="#环境搭建">环境搭建</a></p></li><li><p><a href="#简单案例">简单案例</a></p><ul><li><p><a href="#案例代码">案例代码</a></p></li><li><p><a href="#简单案例的执行流程">简单案例的执行流程</a></p></li><li><p><a href="#Spring MVC九大组件">Spring MVC九大组件</a></p><ul><li><p><a href="#HandlerMapping">HandlerMapping</a></p></li><li><p><a href="#HandlerAdapters">HandlerAdapters</a></p></li><li><p><a href="#ViewResolver">ViewResolver</a></p></li><li><p><a href="#HandlerExceptionResolver">HandlerExceptionResolver</a></p></li><li><p><a href="#MultipartResolver">MultipartResolver</a></p></li><li><p><a href="#LocaleResolver">LocaleResolver</a></p></li><li><p><a href="#ThemeResolver">ThemeResolver</a></p></li><li><p><a href="#RequestToViewNameTranslator">RequestToViewNameTranslator</a></p></li><li><p><a href="#FlashMapManager">FlashMapManager</a></p></li></ul></li></ul></li><li><p><a href="#请求参数的绑定">请求参数的绑定</a></p><ul><li><p><a href="#基本数据类型与字符串对象的绑定">基本数据类型与字符串对象的绑定</a></p></li><li><p><a href="#POJO类及其关联类对象的绑定">POJO类及其关联类对象的绑定</a></p></li><li><p><a href="#集合类型对象的绑定">集合类型对象的绑定</a></p></li><li><p><a href="#请求参数中文乱码解决">请求参数中文乱码解决</a></p><ul><li><p><a href="#POST请求方式">POST请求方式</a></p></li><li><p><a href="#GET请求方式">GET请求方式</a></p></li></ul></li><li><p><a href="#自定义类型转换器">自定义类型转换器</a></p></li><li><p><a href="#在控制器中使用原生的ServletAPI">在控制器中使用原生的ServletAPI</a></p></li></ul></li><li><p><a href="#常用注解">常用注解</a></p><ul><li><p><a href="#@RequestMapping">@RequestMapping</a></p></li><li><p><a href="#@RequestParam">@RequestParam</a></p></li><li><p><a href="#@RequestBody">@RequestBody</a></p></li><li><p><a href="#@PathVarible">@PathVarible</a></p></li><li><p><a href="#@RequestHeader">@RequestHeader</a></p></li><li><p><a href="#@CookieValue">@CookieValue</a></p></li><li><p><a href="#@ModelAttribute">@ModelAttribute</a></p></li><li><p><a href="#@SessionAttributes">@SessionAttributes</a></p></li><li><p><a href="#@CrossOrigin">@CrossOrigin</a></p><ul><li><p><a href="#[前端解决方案](https://zhuanlan.zhihu.com/p/50416743"><a href="https://zhuanlan.zhihu.com/p/50416743" target="_blank" rel="noopener">前端解决方案</a></a>)</p></li><li><p><a href="#[后端Spring MVC解决方案](https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.htmlmvc-cors"><a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.htmlmvc-cors" target="_blank" rel="noopener">后端Spring MVC解决方案</a></a>)</p></li></ul></li></ul></li><li><p><a href="#控制器方法返回值类型与结果视图">控制器方法返回值类型与结果视图</a></p><ul><li><p><a href="#返回字符串">返回字符串</a></p></li><li><p><a href="#返回类型为void">返回类型为void</a></p></li><li><p><a href="#返回类型为ModelAndView">返回类型为ModelAndView</a></p></li><li><p><a href="#转发与重定向">转发与重定向</a></p><ul><li><p><a href="#转发">转发</a></p></li><li><p><a href="#重定向">重定向</a></p></li></ul></li><li><p><a href="#@ResponseBody响应JSON">@ResponseBody响应JSON</a></p></li></ul></li><li><p><a href="#文件上传">文件上传</a></p><ul><li><p><a href="#本服务器文件上传">本服务器文件上传</a></p></li><li><p><a href="#跨服务器文件上传">跨服务器文件上传</a></p></li></ul></li><li><p><a href="#异常处理">异常处理</a></p><ul><li><p><a href="#自定义异常类">自定义异常类</a></p></li><li><p><a href="#自定义异常处理器并配置">自定义异常处理器并配置</a></p></li><li><p><a href="#@ExceptionHandler">@ExceptionHandler</a></p></li></ul></li><li><p><a href="#拦截器">拦截器</a></p><ul><li><p><a href="#自定义拦截器">自定义拦截器</a></p></li><li><p><a href="#HandlerInterceptor接口方法">HandlerInterceptor接口方法</a></p></li><li><p><a href="#preHandle">preHandle</a></p></li><li><p><a href="#postHandle">postHandle</a></p></li><li><p><a href="#afterCompletion">afterCompletion</a></p></li></ul></li></ul><h2 id="B-S三层架构与MVC模型"><a href="#B-S三层架构与MVC模型" class="headerlink" title="B/S三层架构与MVC模型"></a>B/S三层架构与MVC模型</h2><p><a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">SpringMVC Doc</a>.</p><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>表现层：WEB层，用来和客户端进行数据交互。表现层一般会采用MVC的设计模型 。</li><li>业务层：处理公司具体的业务逻辑 。</li><li>持久层：用来操作数据库。</li></ul><h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><ul><li>MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 </li><li>Model：数据模型，JavaBean的类，用来进行数据封装。 </li><li>View：指JSP、HTML用来展示数据给用户。</li><li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><p>选择原型<code>maven-archetype-webapp</code>，创建工程。</p></li><li><p>补全工程目录结构如下：</p><p><img src="webproj_dirstructure.png" alt=""></p></li><li><p>导入maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>web.xml</code>中配置Servlet控制器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置tomcat服务器：</p><p><img src="serverdeploy.png" alt=""></p><p><img src="serverdeploy2.png" alt=""></p></li></ol><p>web路径：不以<code>/</code>开始的相对路径，以当前资源所在目录为基准；以<code>/</code>开始的相对路径，以服务器的路径（<a href="http://localhost:3306）为基准。可通过设置服务器路径到变量APP_PATH：">http://localhost:3306）为基准。可通过设置服务器路径到变量APP_PATH：</a></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% pageContext.setAttribute(<span class="string">"APP_PATH"</span>, request.getContextPath()); %&gt;</span><br></pre></td></tr></table></figure><p>然后通过<code>${APP_PATH}/某路径</code>来设置路径。</p><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><ol><li><p>配置DispatcherServlet(前端控制器)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载spring配置文件并创建IoC容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--Tomcat启动时加载DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--拦截所有请求--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置springmvc.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启SpringMVC框架注解的支持--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用该标签自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写index.jsp和HelloController控制器类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门案例<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"hello"</span>&gt;</span>入门案例<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在WEB-INF目录下创建pages目录，编写success.jsp页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Success!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动Tomcat测试</p></li></ol><h3 id="简单案例的执行流程"><a href="#简单案例的执行流程" class="headerlink" title="简单案例的执行流程"></a>简单案例的执行流程</h3><ol><li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件。</li><li>开启了注解扫描，那么HelloController对象就会被创建，另外springmvc.xml中配置的InternalResourceViewResolver也会被创建，这两个对象进入IoC容器。</li><li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法。</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 。</li><li>Tomcat服务器渲染页面，做出响应。</li></ol><h3 id="Spring-MVC九大组件"><a href="#Spring-MVC九大组件" class="headerlink" title="Spring MVC九大组件"></a>Spring MVC九大组件</h3><p><img src="springmvc_flow.jpg" alt=""></p><p>用户请求到达dispatcherServlet，它就相当于 mvc 模式中的 c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。Handler即我们编写的Controller类，由 dispatcherServlet把用户请求转发到 Handler， Handler再对具体的用户请求进行处理。</p><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>处理器映射器。HandlerMapping 负责根据用户请求URI找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><h4 id="HandlerAdapters"><a href="#HandlerAdapters" class="headerlink" title="HandlerAdapters"></a>HandlerAdapters</h4><p>处理器适配器。通过 HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>视图处理器。ViewResolver负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p><h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>异常处理器。</p><h4 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h4><p>文件处理器，用于处理上传的文件。</p><h4 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h4><p>当前环境处理器。这就相当于配置数据库的方言一样，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</p><h4 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h4><p>主题处理器，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源，如图片、css样式等。</p><h4 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h4><p>视图名称翻译器。有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。</p><h4 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h4><p>参数传递管理器。用于管理FlashMap，FlashMap主要用在redirect重定向中传递参数。</p><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><h3 id="基本数据类型与字符串对象的绑定"><a href="#基本数据类型与字符串对象的绑定" class="headerlink" title="基本数据类型与字符串对象的绑定"></a>基本数据类型与字符串对象的绑定</h3><p>要求前端页面的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)</p><p>前端页面代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="account/findAccount?accountId=10&amp;accountName=zhangsan"&gt;查询账户&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">(Integer accountId,String accountName)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"查询了账户"</span>+accountId+<span class="string">","</span>+accountName);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POJO类及其关联类对象的绑定"><a href="#POJO类及其关联类对象的绑定" class="headerlink" title="POJO类及其关联类对象的绑定"></a>POJO类及其关联类对象的绑定</h3><p>要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</p><p>POJO类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String provinceName;</span><br><span class="line">    <span class="keyword">private</span> String cityName;</span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"account/saveAccount"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    账户名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户省份：&lt;input type=<span class="string">"text"</span> name=<span class="string">"address.provinceName"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户城市：&lt;input type=<span class="string">"text"</span> name=<span class="string">"address.cityName"</span> &gt;&lt;br/&gt;</span><br><span class="line">            &lt;input type=<span class="string">"submit"</span> value=<span class="string">"保存"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/saveAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"保存了账户。。。。"</span>+account);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合类型对象的绑定"><a href="#集合类型对象的绑定" class="headerlink" title="集合类型对象的绑定"></a>集合类型对象的绑定</h3><ol><li>要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。</li><li>接收的请求参数是 json 格式数据。需要借助注解@RequestParam或@RequestBody实现。</li></ol><p>pojo类包含集合类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Account&gt; accountMap;</span><br><span class="line">    <span class="comment">//getters, setters and toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"account/updateAccount"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    用户名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> &gt;&lt;br/&gt;</span><br><span class="line">    用户密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span> &gt;&lt;br/&gt;</span><br><span class="line">    用户年龄：&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">1</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[0].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">1</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[0].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">2</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[1].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">2</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[1].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">3</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['one'].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">3</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['one'].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">4</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['two'].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">4</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['two'].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"保存"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/updateAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateAccount</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"更新了账户。。。。"</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求参数中文乱码解决"><a href="#请求参数中文乱码解决" class="headerlink" title="请求参数中文乱码解决"></a>请求参数中文乱码解决</h3><h4 id="POST请求方式"><a href="#POST请求方式" class="headerlink" title="POST请求方式"></a>POST请求方式</h4><p>在web.xml中配置过滤器来转换请求数据的编码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filterclass</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 springmvc的配置文件中可以配置，静态资源不过滤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/css/"</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/images/"</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/scripts/"</span> <span class="attr">mapping</span>=<span class="string">"/javascript/**"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="GET请求方式"><a href="#GET请求方式" class="headerlink" title="GET请求方式"></a>GET请求方式</h4><p>Tomacat 对 GET 和 POST 请求处理方式是不同的，GET 请求的编码问题，要改 Tomcat 的 server.xml 配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span></span></span><br><span class="line"><span class="tag"><span class="attr">useBodyEncodingForURI</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果遇到 ajax 请求仍然乱码，把 useBodyEncodingForURI=”true”改为 URIEncoding=”UTF-8”即可。</p><h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>表单提交的任何数据类型全部都是字符串类型，假如后台定义Integer类型，数据也可以封装上，说明 Spring框架内部会默认进行数据类型转换。</p><p>如果想自定义数据类型转换，可以实现Converter接口并重写convert方法。比如表单提交”2020/11/11”，Spring可以正常转换为Date类型，但是表单提交的是”2020-11-11”，这时就需要我们自定义类型转换器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把字符串转换成日期的转换器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行类型转换的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            <span class="comment">// 解析字符串</span></span><br><span class="line">            Date date = df.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类型转换错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在springmvc.xml中配置StringToDateConverter对象：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建类型转换器工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给工厂注入一个新的类型转换器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--创建自定义类型转换器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.itcast.utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在控制器中使用原生的ServletAPI"><a href="#在控制器中使用原生的ServletAPI" class="headerlink" title="在控制器中使用原生的ServletAPI"></a>在控制器中使用原生的ServletAPI</h3><p>在控制器的方法参数中使用HttpServletRequest、HttpServletResponse、HttpSession等即可。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><ul><li>作用：是建立请求URL和处理方法之间的对应关系。</li><li>属性<ul><li>path/value: 指定请求路径的url</li><li>method: 指定该方法的请求方式（post,get…）</li><li>headers: 发送的请求中必须包含请求头</li><li>params: 限制请求参数的条件，它支持简单的表达式，要求请求参数的 key和value 必须和配置的一模一样。例如： params = {“accountName”}，表示请求参数必须有 accountName；params = {“moeny!100”}，表示请求参数中 money 不能是 100。</li></ul></li><li>RequestMapping注解可以作用在方法和类上：作用在类上，path属性表示第一级的访问目录；作用在方法上，path属性表示第二级的访问目录。</li></ul><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><ul><li>作用：作用于参数。把请求中指定名称的参数给控制器中的形参赋值。</li><li><p>属性</p><ul><li>value/name: 请求参数中的名称。</li><li>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</li></ul></li><li><p>示例</p><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="springmvc/useRequestParam?name=test"&gt;requestParam 注解&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/useRequestParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestParam</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value=<span class="string">"age"</span>,required=<span class="keyword">false</span>)</span>Integer age)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">","</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><ul><li>作用：作用于参数。用于获取请求体内容，并将其绑定到Bean上或者分别绑定到对应的变量上。直接使用得到是 key=value&amp;key=value…结构的数据。 get 请求方式不适用。</li><li>属性：required。是否必须有请求体。默认值是：true。当取值为 true 时，get 请求方式会报错。如果取值 为 false，get 请求得到的是 null。</li></ul><h3 id="PathVarible"><a href="#PathVarible" class="headerlink" title="@PathVarible"></a>@PathVarible</h3><ul><li><p>作用：作用于参数。用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</p></li><li><p>属性</p><ul><li>value/name：指定url中占位符名称。</li><li>required：请求url中是否必须提供占位符。</li></ul></li><li><p>示例</p><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="springmvc/usePathVariable/100"&gt;pathVariable 注解&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/usePathVariable/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">usePathVariable</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RESTful编程风格</p><ul><li>HTTP 协议里，四个表示操作方式的动词：GET 、POST 、PUT、 DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来 删除资源。</li><li><code>@RestController</code>：创建处理http请求的对象。Spring4之后加入的注解，原来在<code>@Controller</code>中返回json需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式。</li><li>RESTful在SpringMVC里的应用：请求同一个Controller，<strong>具体到每个方法method上的路径path一样</strong>(不再是每个方法上都配置一个具体的路径来进行匹配)，但每个method请求方式不一样，根据GET、PUT、POST 和 DELETE的不同方式，匹配不同的method。</li><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 省略setter和getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/users"</span>)     <span class="comment">// 通过这里配置使下面的映射都在/users下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程安全的Map</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Long, User&gt; users = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Long, User&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/"的GET请求，用来获取用户列表</span></span><br><span class="line">        <span class="comment">// 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递</span></span><br><span class="line">        List&lt;User&gt; r = <span class="keyword">new</span> ArrayList&lt;User&gt;(users.values());</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/"</span>, method=RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postUser</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/"的POST请求，用来创建User</span></span><br><span class="line">        <span class="comment">// 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数</span></span><br><span class="line">        users.put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/&#123;id&#125;"的GET请求，用来获取url中id值的User信息</span></span><br><span class="line">        <span class="comment">// url中的id可通过@PathVariable绑定到函数的参数中</span></span><br><span class="line">        <span class="keyword">return</span> users.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.PUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">(@PathVariable Long id, @ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/&#123;id&#125;"的PUT请求，用来更新User信息</span></span><br><span class="line">        User u = users.get(id);</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        users.put(id, u);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.DELETE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User</span></span><br><span class="line">        users.remove(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HiddenHttpMethodFilter</p><p>由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添 加了该过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p></li></ul><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><ul><li>作用：作用于参数。用于获取请求消息头。</li><li>属性：<ul><li>value：提供消息头名称。</li><li>required：是否必须有此消息头。</li></ul></li></ul><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><ul><li>作用：作用于参数。用于把指定 cookie 名称的值传入控制器方法参数。</li><li>属性<ul><li>value：指定cookie名称。</li><li>required：是否必须有此cookie。</li></ul></li></ul><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><ul><li><p>作用：该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。</p><ul><li>修饰<strong>方法</strong>：<strong>当前方法会在控制器的每个方法执行之前先执行一次。</strong></li><li>修饰<strong>参数</strong>：获取指定的数据给参数赋值。</li></ul></li><li><p>属性：value/name。：用于获取数据的 key。key 可以是 POJO的属性名称，也可以是 map 结构的 key。</p></li><li><p>应用场景：当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据时肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解修饰方法解决问题。</p><ul><li><p>基于 Map 的应用场景示例 1：ModelAttribute 修饰方法带返回值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改用户信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/updateUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">name</span>=<span class="string">"username"</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"保存"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">showModel</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟去数据库查询并设置表单中没有的字段password</span></span><br><span class="line">    User abc = findUserByName(username);</span><br><span class="line">    System.out.println(<span class="string">"执行了 showModel 方法"</span>+abc);</span><br><span class="line">    <span class="keyword">return</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">findUserByName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(username);</span><br><span class="line">    user.setAge(<span class="number">19</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/updateUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"控制器中处理请求的方法：修改用户："</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于 Map 的应用场景示例 2：ModelAttribute 修饰方法不带返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showModel</span><span class="params">(String username,Map&lt;String,User&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟去数据库查询并设置表单中没有的字段password</span></span><br><span class="line">    <span class="comment">//使用map来传递user对象</span></span><br><span class="line">    User user = findUserByName(username);</span><br><span class="line">    System.out.println(<span class="string">"执行了 showModel 方法"</span>+user);</span><br><span class="line">    map.put(<span class="string">"abc"</span>,user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/updateUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(@ModelAttribute(<span class="string">"abc"</span>)</span>User user) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"控制器中处理请求的方法：修改用户："</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h3><ul><li>作用：作用于类上。<code>@SessionAttributes</code> is used to store model attributes in the HTTP Servlet session between requests. </li><li><p>属性</p><ul><li>name/value：存入Session域的属性名称，可以存入多个。</li><li>types：指定存入的数据类型。</li></ul></li><li><p>示例</p><p>jsp代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testPut"</span>&gt;</span>存入 SessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testGet"</span>&gt;</span>取出 SessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testClean"</span>&gt;</span>清除 SessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">"sessionAttributeController"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/springmvc"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(value =&#123;<span class="string">"username"</span>,<span class="string">"password"</span>&#125;,types=&#123;Integer<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SessionAttributeController</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把数据存入Servlet session</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* Model是spring提供的一个接口，该接口有一个实现类 ExtendedModelMap</span></span><br><span class="line"><span class="comment">* 该类继承了ModelMap，而 ModelMap就是LinkedHashMap子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testPut"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPut</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"username"</span>, <span class="string">"tom"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"password"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"age"</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/testGet"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(ModelMap model)</span></span>&#123;</span><br><span class="line">    System.out.println(model.get(<span class="string">"username"</span>)+<span class="string">";"</span>+model.get(<span class="string">"password"</span>)+<span class="string">";"</span>+model.get(<span class="string">"age"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/testClean"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">complete</span><span class="params">(SessionStatus sessionStatus)</span></span>&#123;</span><br><span class="line">     sessionStatus.setComplete();</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>当我们使用前后端分离的方式开发项目，前端使用<code>XMLHttpReques</code>，也即AJAX请求页面时，浏览器访问的URI与AJAX请求的URI（我们RequestMapping定义的虚拟地址）是不同的，因此请求会报错。</p><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。<strong>CORS需要浏览器和服务器同时支持</strong>。</p><h4 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><a href="https://zhuanlan.zhihu.com/p/50416743" target="_blank" rel="noopener">前端解决方案</a></h4><ol><li>JSONP</li><li>CORS【推荐】</li><li>HTML5 API：postMessage</li><li>Web Sockets</li></ol><h4 id="后端Spring-MVC解决方案"><a href="#后端Spring-MVC解决方案" class="headerlink" title="后端Spring MVC解决方案"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.html#mvc-cors" target="_blank" rel="noopener">后端Spring MVC解决方案</a></h4><ol><li>细粒度方式，仅限于类或方法：<code>@CrossOrigin</code><ul><li>跨域：<code>@CrossOrigin(origins = {&quot;*&quot;},allowedHeaders = &quot;*&quot;)</code></li><li>跨域传递Cookie：<code>@CrossOrigin(origins = {&quot;*&quot;},allowCredentials = &quot;true&quot;,allowedHeaders = &quot;*&quot;)</code></li></ul></li><li>全局配置：Java类+注解配置，或XML配置。</li><li>过滤器方式：使用内置的<code>CorsFilter</code>。</li></ol><h2 id="控制器方法返回值类型与结果视图"><a href="#控制器方法返回值类型与结果视图" class="headerlink" title="控制器方法返回值类型与结果视图"></a>控制器方法返回值类型与结果视图</h2><h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>控制器方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定逻辑视图名，经过视图解析器解析为物理路径：/WEB-INF/pages/success.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testReturnString"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testReturnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AccountController的testReturnString 方法执行了。。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回类型为void"><a href="#返回类型为void" class="headerlink" title="返回类型为void"></a>返回类型为void</h3><p>使用Servlet的request和response对象返回页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnVoid</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用request跳转</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/success.jsp"</span>).forward(request, response);</span><br><span class="line">    <span class="comment">//使用response重定向</span></span><br><span class="line">    response.sendRedirect(<span class="string">"index.jsp"</span>);</span><br><span class="line">    <span class="comment">//使用response指定响应结果,例如JSON数据</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">    response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    response.getWriter().write(<span class="string">"json 串"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回类型为ModelAndView"><a href="#返回类型为ModelAndView" class="headerlink" title="返回类型为ModelAndView"></a>返回类型为ModelAndView</h3><p>ModelAndView是SpringMVC的内置对象。通过该对象的addObject方法添加对象，setViewName方法设置逻辑视图名称，视图解析器会根据名称返回指定的页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testReturnModelAndView"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testReturnModelAndView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">"username"</span>, <span class="string">"张三"</span>);</span><br><span class="line">    mv.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--success.jsp--&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;执行成功&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        执行成功！</span><br><span class="line">        $&#123;requestScope.username&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h3><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>控制器方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testForward"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AccountController 的 testForward 方法执行了。。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/WEB-INF/pages/success.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果用了formward则路径必须写成<strong>实际视图 url</strong>，不能写逻辑视图(不会交给视图解析器解析)。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，<strong>既可以转发到 jsp，也可以转发到其他的控制器方法</strong>。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testRedirect"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AccountController 的 testRedirect 方法执行了。。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:testReturnModelAndView"</span>;<span class="comment">//重定向到另一个控制器方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不 能写在 WEB-INF 目录中，否则无法找到。</p><h3 id="ResponseBody响应JSON"><a href="#ResponseBody响应JSON" class="headerlink" title="@ResponseBody响应JSON"></a>@ResponseBody响应JSON</h3><p>该注解用于<strong>将控制器方法的返回值对象</strong>，通过HttpMessageConverter接口<strong>转换为指定格式的数据</strong>如json, xml等<strong>响应给客户端</strong>，而不再需要视图渲染。SpringMVC默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入如下jackson的包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        $(<span class="string">"#testJson"</span>).click(function()&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type:<span class="string">"post"</span>,</span><br><span class="line">                url:<span class="string">"$&#123;pageContext.request.contextPath&#125;/testResponseJson"</span>,</span><br><span class="line">                contentType:<span class="string">"application/json;charset=utf-8"</span>,</span><br><span class="line">                data:<span class="string">'&#123;"id":1, "name":"test", "money":999.0&#125;'</span>,</span><br><span class="line">                dataType:<span class="string">"json"</span>,</span><br><span class="line">                success:function(data)&#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 测试异步请求 --&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"测试ajax, 请求json和响应json"</span> id=<span class="string">"testJson"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">"jsonController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testResponseJson"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Account <span class="title">testResponseJson</span><span class="params">(@RequestBody Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异步请求："</span>+account);</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="本服务器文件上传"><a href="#本服务器文件上传" class="headerlink" title="本服务器文件上传"></a>本服务器文件上传</h3><p>前端页面form表单的enctype属性（表示<strong>表单请求正文的类型</strong>）的默认值是application/x-www-form-urlencoded，要实现文件上传必须将该属性的值设置为multipart/form-data，并且表单的method属性必须是POST，同时提供一个文件选择域<code>&lt;input type=&quot;file&quot;/&gt;</code>。</p><p>SpringMVC实现文件上传需要导入以下包，会用到commons-fileupload包的文件上传解析器，而该包依赖于commons-io：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp页面：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;form action=<span class="string">"test/fileUpload"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">       图片：&lt;input type=<span class="string">"file"</span> name=<span class="string">"uploadFile"</span>&gt;</span><br><span class="line">       &lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span>&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileUpload"</span>)</span><br><span class="line">    <span class="comment">//SpringMVC提供了MultipartFile类来接收上传文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFileUpload</span><span class="params">(MultipartFile uploadFile, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String fileName = uploadFile.getOriginalFilename();</span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>).toUpperCase();</span><br><span class="line">        fileName = uuid + <span class="string">"_"</span> + fileName;</span><br><span class="line"></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) file.mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//transferTo(File file)方法写入文件到路径</span></span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> File(path,fileName));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件上传解析器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意id的值是固定的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置上传文件的最大尺寸为 5MB --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>5242880<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跨服务器文件上传"><a href="#跨服务器文件上传" class="headerlink" title="跨服务器文件上传"></a>跨服务器文件上传</h3><p>在实际开发中，会有很多处理不同功能的服务器。例如： 应用服务器：负责部署应用。数据库服务器：运行数据库。缓存和消息服务器：负责处理大并发访问的缓存和消息。文件服务器：负责存储用户上传文件的服务器。 (注意：此处说的不是服务器集群）此时我们就需要将用户上传的文件从应用服务器上传到文件服务器。</p><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制器代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileUpload"</span>)</span><br><span class="line">    <span class="comment">//SpringMVC提供了MultipartFile类来接收上传文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFileUpload</span><span class="params">(MultipartFile uploadFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String path = <span class="string">"文件服务器的存储路径/"</span>;</span><br><span class="line"></span><br><span class="line">        String fileName = uploadFile.getOriginalFilename();</span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>).toUpperCase();</span><br><span class="line">        fileName = uuid + <span class="string">"_"</span> + fileName;</span><br><span class="line">        <span class="comment">//创建客户端对象</span></span><br><span class="line">        Client client = Client.create();</span><br><span class="line">        <span class="comment">//和文件服务器连接</span></span><br><span class="line">        WebResource webResource = client.resource(path+fileName);</span><br><span class="line">        <span class="comment">//上传</span></span><br><span class="line">        webResource.put(uploadFile.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>一旦产生异常则向上抛出，持久层DAO -&gt; 业务层Service -&gt; 表现层Controlller  ，最终由SpringMVC的DispatherServlet匹配异常处理器组件进行处理。</p><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stirng message;</span><br><span class="line">    <span class="comment">//构造器.setter and getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller方法中抛出该自定义异常，由我们定义的异常处理器捕获并处理。</p><h3 id="自定义异常处理器并配置"><a href="#自定义异常处理器并配置" class="headerlink" title="自定义异常处理器并配置"></a>自定义异常处理器并配置</h3><p>自定义异常处理器需要实现HandlerExceptionResolver接口，该接口提供了<code>resolveException(Exception, Hanlder)</code>方法的一个实现，方法会返回一个<code>ModelAndView</code>。</p><p>另外，我们也可以使用框架已有的异常处理器实现类<code>SimpleMappingExceptionResolver</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span></span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"errorMsg"</span>, ex.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">"error"</span>);<span class="comment">//返回error.jsp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.example.exception.MyExceptionResolver"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p><code>HandlerExceptionResolver</code>接口以及<code>SimpleMappingExceptionResolver</code>解析器类的实现使得你能<strong>声明式地将异常映射到特定的视图</strong>上，还可以在异常被转发（forward）到对应的视图前使用Java代码做些判断和逻辑。不过在一些场景，<strong>特别是依靠<code>@ResponseBody</code>返回响应而非依赖视图解析机制的场景</strong>（比如Restful风格）下，<strong>直接设置响应的状态码并将客户端需要的错误信息直接写回响应体</strong>中，可能是更方便的方法。</p><p>如果<code>@ExceptionHandler</code>方法是在控制器内部定义的，那么它会<strong>接收并处理由控制器（或其任何子类）中的<code>@RequestMapping</code>方法抛出的异常。</strong></p><p>此外，<code>@ExceptionHandler</code>注解还可以接受一个异常类型的数组作为参数值。若抛出了已在列表中声明的异常，那么相应的<code>@ExceptionHandler</code>方法将会被调用。如果没有给注解任何参数值，那么默认处理的异常类型将是方法参数所声明的那些异常。</p><p><code>@ExceptionHandler</code>方法的返回值可以是<code>String</code>类型——这种情况下会被解析为视图名——可以是<code>ModelAndView</code>类型的对象，也可以是<code>ResponseEntity</code>。或者你还可以在方法上添加<code>@ResponseBody</code>注解以使用消息转换器会转换信息为特定类型的数据，然后把它们写回到响应流中。<a href="https://github.com/Laishiji/miaosha/blob/main/src/main/java/com/laishiji/miaosha/controller/CommonController.java" target="_blank" rel="noopener">例如</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//直接返回e或者businessException的话, json中会包含很多虚拟机栈跟踪信息,</span></span><br><span class="line">    <span class="comment">//因此使用map取出错误状态码和错误信息即可</span></span><br><span class="line">    Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BusinessException)&#123;</span><br><span class="line">        BusinessException businessException = (BusinessException)e;</span><br><span class="line"></span><br><span class="line">        responseData.put(<span class="string">"errorCode"</span>, businessException.getErrorCode());</span><br><span class="line">        responseData.put(<span class="string">"errorMessage"</span>, businessException.getErrorMessage());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        responseData.put(<span class="string">"errorCode"</span>, EnumBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">        responseData.put(<span class="string">"errorMessage"</span>, EnumBusinessError.UNKNOWN_ERROR.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归一化处理，返回通用对象</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(responseData, <span class="string">"fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>Spring MVC的处理器拦截器类似于Servlet的过滤 Filter，用于对处理器进行预处理和后处理。它们的区别是：过滤器在 url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者js是不会进行拦截的。</p><p>我们也可以定义拦截器链，在访问被拦截的方法时，拦截器链 中的拦截器会按照定义的顺序执行。</p><p>拦截器是AOP思想的具体应用，由动态代理实现。要自定义拦截器，需要实现HandlerInterceptor接口。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * controller方法执行前，进行拦截的方法</span></span><br><span class="line"><span class="comment">    * return true放行</span></span><br><span class="line"><span class="comment">    * return false拦截</span></span><br><span class="line"><span class="comment">    * 可以使用转发或者重定向直接跳转到指定的页面。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springmvc.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法进行拦截 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/*"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法不进行拦截 &lt;mvc:exclude-mapping path=""/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册拦截器对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.itcast.demo1.MyInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HandlerInterceptor接口方法"><a href="#HandlerInterceptor接口方法" class="headerlink" title="HandlerInterceptor接口方法"></a>HandlerInterceptor接口方法</h3><h3 id="preHandle"><a href="#preHandle" class="headerlink" title="preHandle"></a>preHandle</h3><p>控制器方法执行前拦截的方法。</p><ul><li>可以使用request或者response跳转到指定的页面 。</li><li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li><li>return false不放行，不会执行controller中的方法。</li></ul><h3 id="postHandle"><a href="#postHandle" class="headerlink" title="postHandle"></a>postHandle</h3><p>控制器方法执行后执行的方法，在JSP视图执行前。</p><ul><li>可以使用request或者response跳转到指定的页面。</li><li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li></ul><h3 id="afterCompletion"><a href="#afterCompletion" class="headerlink" title="afterCompletion"></a>afterCompletion</h3><p>最后执行的方法，JSP视图执行后执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#B/S三层架构与MVC模型&quot;&gt;B/S三层架构与MVC模型&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#三层架构&quot;&gt;三层架构&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#MVC模型&quot;&gt;MVC模型&lt;/a&gt;&lt;
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务处理</title>
    <link href="http://thmasterplan.cn/JavaWeb/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2020-10-17T01:55:38.000Z</published>
    <updated>2020-11-23T14:23:21.098Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#概述">概述</a></p><p><a href="#Spring事务控制的API">Spring事务控制的API</a></p><ul><li><p><a href="#PlatFormTransactionManager">PlatFormTransactionManager</a></p></li><li><p><a href="#DataSourceTransactionManager">DataSourceTransactionManager</a></p></li><li><p><a href="#TransactionDefinition">TransactionDefinition</a></p></li><li><p><a href="#TransactionStatus">TransactionStatus</a></p></li></ul><p><a href="#Spring声明式事务控制">Spring声明式事务控制</a></p><ul><li><p><a href="#XML配置实现">XML配置实现</a></p></li><li><p><a href="#注解配置实现">注解配置实现</a></p></li><li><p><a href="#纯注解配置实现">纯注解配置实现</a></p></li></ul><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了业务层的事务处理解决方案。</p><p>Spring为我们提供了一组事务控制的接口，在<code>spring-tx</code>jar包中。</p><p>Spring的事务控制基于AOP，可以通过编程和配置两种方式实现。主要使用配置的方式。</p><h1 id="Spring事务控制的API"><a href="#Spring事务控制的API" class="headerlink" title="Spring事务控制的API"></a>Spring事务控制的API</h1><h2 id="PlatFormTransactionManager"><a href="#PlatFormTransactionManager" class="headerlink" title="PlatFormTransactionManager"></a>PlatFormTransactionManager</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取事务状态</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h2><p>真正管理事务的对象。该类继承自PlatFormTransactionManager的抽象实现类AbstractPlatformTransactionManager。</p><h2 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前没有事务，则新建一个事务，如果已经存在一个事务，则加入到这个事务中。默认值</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//支持当前事务，如果当前没有事务，则以非事务方式运行</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//使用当前的事务，若当前没有事务，则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//新建事务，如果当前在事务中，把当前事务挂起</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//以非事务方式执行操作，如果当前存在事务，把当前事务挂起</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//以非事务方式运行，若当前存在事务，抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//若当前存在事务，则在嵌套事务内执行。若当前没有事务，则执行REQUIRED类似的操作。</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;<span class="comment">//默认使用数据库的事务隔离级别，归属下别某一种</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;<span class="comment">//可以读取未提交数据</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;<span class="comment">//只能读取已提交数据，解决脏读问题（Oracle默认级别）</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;<span class="comment">//是否读取其他事务提交修改后的数据，解决不可重复读问题</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;<span class="comment">//是否读取其他事务提交添加后的数据，解决幻影读问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;<span class="comment">//默认没有超时时间，正数时单位为秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取事务传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取事务隔离级别，默认使用数据库的事务隔离级别</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取事务超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务是否只读，建议查询时设置为只读。</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取事务名称</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取默认的事务定义信息对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TransactionDefinition <span class="title">withDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h2><p>该接口描述了某个时间点上事务对象的状态信息，包含6个具体的操作。</p><ul><li>void flush()：刷新事务。</li><li>boolean hasSavepoint()：是否存在存储点。</li><li>boolean isCompleted()：事务是否完成。</li><li>boolean isNewTransaction()：是否是新的事务。</li><li>boolean isRollbackOnly()：事务是否回滚。</li><li>void setRollbackOnly()：设置事务回滚。</li></ul><h1 id="Spring声明式事务控制"><a href="#Spring声明式事务控制" class="headerlink" title="Spring声明式事务控制"></a>Spring声明式事务控制</h1><h2 id="XML配置实现"><a href="#XML配置实现" class="headerlink" title="XML配置实现"></a>XML配置实现</h2><p><a href="https://github.com/Laishiji/SpringLearningDemo/tree/master/SpringTransactionDemo" target="_blank" rel="noopener">案例代码</a>。配置步骤如下：</p><ol><li><p>导入命名空间和约束：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务管理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--需要先配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务的通知：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置AOP中通用的切入点表达式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>建立事务通知和切入点表达式的关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立事务通知和切入点表达式的关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在事务通知标签内配置事务的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--5.配置事务的属性</span></span><br><span class="line"><span class="comment">                isolation: 指定事务隔离级别。默认DEFAULT,表示使用数据库默认事务隔离级别</span></span><br><span class="line"><span class="comment">                propagation: 指定事务的传播行为。默认值是REQUIRED,增删改的选择。查询可选用SUPPORTS</span></span><br><span class="line"><span class="comment">                read-only: 指定事务是否只读。只有查询才能设置为true</span></span><br><span class="line"><span class="comment">                rollback-for: 指定一个异常，产生该异常时，事务回滚；产生其他异常时，事务不回滚。不指定则任何异常都回滚。</span></span><br><span class="line"><span class="comment">                no-rollback-for: 指定一个异常，产生该异常时，事务不回滚；产生其他异常时，事务回滚。不指定则任何异常都回滚。</span></span><br><span class="line"><span class="comment">                timeout:指定超时时间，默认没有</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="注解配置实现"><a href="#注解配置实现" class="headerlink" title="注解配置实现"></a>注解配置实现</h2><p><a href="https://github.com/Laishiji/SpringLearningDemo/tree/master/SpringTransactionAnnotationDemo" target="_blank" rel="noopener">案例代码</a>。配置步骤如下：</p><ol><li><p>导入命名空间和约束：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务管理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--需要先配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>纯注解方式则创建配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建事务管理器配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">createTransactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启Spring对注解事务的支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>纯注解方式在主配置类上使用<code>@EnableTransactionManagement</code>来开启。</p></li><li><p>在需要事务支持的地方使用<code>@Transactional</code>标记。比如业务层接口实现类上或者其方法（切入点方法）之上。</p></li></ol><h2 id="纯注解配置实现"><a href="#纯注解配置实现" class="headerlink" title="纯注解配置实现"></a>纯注解配置实现</h2><p><a href="https://github.com/Laishiji/SpringLearningDemo/tree/master/SpringTransactionAnnoDemo2" target="_blank" rel="noopener">案例代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#概述&quot;&gt;概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#Spring事务控制的API&quot;&gt;Spring事务控制的API&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#PlatFormTransactionManager&quot;&gt;PlatFormTr
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring模板类JdbcTemplate</title>
    <link href="http://thmasterplan.cn/JavaWeb/Spring%E6%A8%A1%E6%9D%BF%E7%B1%BBJdbcTemplate/"/>
    <id>http://thmasterplan.cn/JavaWeb/Spring%E6%A8%A1%E6%9D%BF%E7%B1%BBJdbcTemplate/</id>
    <published>2020-10-17T01:55:21.000Z</published>
    <updated>2020-11-23T14:23:21.100Z</updated>
    
    <content type="html"><![CDATA[<p><a href="#JdbcTemplate概述">JdbcTemplate概述</a></p><p><a href="#JdbcTemplate实现CRUD">JdbcTemplate实现CRUD</a></p><ul><li><p><a href="#增加（Create）">增加（Create）</a></p></li><li><p><a href="#删除（Delete）">删除（Delete）</a></p></li><li><p><a href="#更新（Update）">更新（Update）</a></p></li><li><p><a href="#检索（Retrieve）">检索（Retrieve）</a></p></li></ul><p><a href="#JdbcDaoSupport">JdbcDaoSupport</a></p><h1 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h1><p>JdbcTemplate是对原始JDBC API的简单封装。除该模板类以外，Spring还提供了操作关系型数据库的HibernateTemplate，操作NoSQL数据库的RedisTemplate，操作消息队列的JmsTemplate。</p><p>Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="JdbcTemplate实现CRUD"><a href="#JdbcTemplate实现CRUD" class="headerlink" title="JdbcTemplate实现CRUD"></a>JdbcTemplate实现CRUD</h1><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Float money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jdbcTemplate =(JdbcTemplate) applicationContext.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">        <span class="comment">//CRUD操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="增加（Create）"><a href="#增加（Create）" class="headerlink" title="增加（Create）"></a>增加（Create）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"insert into account(name,money) values(?,?)"</span>,<span class="string">"bbb"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h2 id="删除（Delete）"><a href="#删除（Delete）" class="headerlink" title="删除（Delete）"></a>删除（Delete）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"delete from account where id=?"</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><h2 id="更新（Update）"><a href="#更新（Update）" class="headerlink" title="更新（Update）"></a>更新（Update）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"update account set name=?,money=? where id=?"</span>, <span class="string">"aaa"</span>, <span class="number">1000</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h2 id="检索（Retrieve）"><a href="#检索（Retrieve）" class="headerlink" title="检索（Retrieve）"></a>检索（Retrieve）</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义Account的封装策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将结果集的数据封装到Account中，然后Spring将Account加到List&lt;Account&gt;中</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            Account account = <span class="keyword">new</span> Account();</span><br><span class="line">            account.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">            account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">            account.setMoney(resultSet.getFloat(<span class="string">"money"</span>));</span><br><span class="line">            <span class="keyword">return</span> account;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">"select * from account where money &gt; ?"</span>,<span class="keyword">new</span> AccountRowMapper(),<span class="number">1000f</span>);</span><br></pre></td></tr></table></figure><p>实际使用中不需要自己实现RowMapper，可使用Spring提供的BeanPropertyRowMapper类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">"select * from account where money &gt; ?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>),1000<span class="title">f</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用聚合函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long count = jdbcTemplate.queryForObject(<span class="string">"select count(*) from account where money &gt; ?"</span>, Long<span class="class">.<span class="keyword">class</span>, 500<span class="title">f</span>)</span>;</span><br></pre></td></tr></table></figure><h1 id="JdbcDaoSupport"><a href="#JdbcDaoSupport" class="headerlink" title="JdbcDaoSupport"></a>JdbcDaoSupport</h1><p>使DAO类继承自JdbcDaoSupport，则DAO类不再需要在代码中注入数据源和JdbcTemplate变量，而是在代码中使用<code>super.getJdbcTemplate()</code>获取。这样写的好处是当有大量DAO时，可以减少重复代码，适用于XML配置的方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;#JdbcTemplate概述&quot;&gt;JdbcTemplate概述&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;#JdbcTemplate实现CRUD&quot;&gt;JdbcTemplate实现CRUD&lt;/a&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;a href=&quot;#增加（Cre
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
</feed>
