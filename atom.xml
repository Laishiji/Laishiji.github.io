<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2020-04-09T09:10:12.297Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>检索技巧</title>
    <link href="http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
    <id>http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/</id>
    <published>2020-04-09T09:00:06.000Z</published>
    <updated>2020-04-09T09:10:12.297Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github搜索"><a href="#Github搜索" class="headerlink" title="Github搜索"></a>Github搜索</h3><ul><li><code>in:name example</code>：项目名中包含”example“</li><li><code>in:readme example</code>：readme.md中包含”example“</li><li><code>in:description example</code>：描述中包含”example“</li><li><code>stars:&gt;1000</code>：项目 star数大于1000</li><li><code>forks:&gt;1000</code>：项目fork数大于1000</li><li><code>pushed:&gt;2020-03-05</code>：项目在该日期后有更新</li><li><code>language:java</code>：项目用Java编写</li><li>以上条件可组合使用</li></ul><h3 id="搜索引擎检索"><a href="#搜索引擎检索" class="headerlink" title="搜索引擎检索"></a>搜索引擎检索</h3><ul><li><code>&quot;example&quot;</code>：完全匹配</li><li><code>example site:www.xxx.com</code>：站点内搜索</li><li><code>example -csdn.net</code>：排除关键字</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Github搜索&quot;&gt;&lt;a href=&quot;#Github搜索&quot; class=&quot;headerlink&quot; title=&quot;Github搜索&quot;&gt;&lt;/a&gt;Github搜索&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in:name example&lt;/code&gt;：项目名中包含”exam
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-08T14:47:15.000Z</published>
    <updated>2020-04-09T12:20:41.849Z</updated>
    
    <content type="html"><![CDATA[<h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ul><li><p>String</p><ul><li><p>String类是final的，因此不能被继承。源码是一个<strong>final修饰的字符数组</strong>，因此一旦创建就是一个不可变的</p></li><li><p>字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure></li><li><p>判断字符串是否相等？ <strong>[涉及JVM的部分待补充]</strong></p><ol><li><p>值在编译阶段确定（相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a = &quot;helloWorld&quot;;</span><br><span class="line">String b = &quot;helloWorld&quot;;</span><br><span class="line">String c = &quot;hello&quot; + &quot;World&quot;;</span><br><span class="line">System.out.println(a==b);//true</span><br><span class="line">System.out.println(a==c);//true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：字符串常量在<strong>编译阶段</strong>会存入<strong>常量池</strong>中<strong>共享</strong>，编译阶段完成字符串的拼接（无引用的情况下），因此在运行期a,b,c均指向同一个地址。</p></li><li><p>值在编译器无法确定（不相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a = &quot;helloWorld&quot;;</span><br><span class="line">String b = new String(&quot;helloWorld&quot;);</span><br><span class="line">String c = &quot;hello&quot; + new String(&quot;World&quot;);</span><br><span class="line">System.out.println(a==b);//false</span><br><span class="line">System.out.println(a==c);//false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：b,c均在运行期创建，存在于堆内存。</p></li><li><p>涉及引用操作，编译期值无法确定（不相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a = &quot;helloWorld2&quot;;</span><br><span class="line">String b = a + 2;</span><br><span class="line">System.out.println(a==b);//false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：引用a的值在编译阶段无法确定，在运行期才给其分配内存来指向常量池中的字符串，因此a+2是在运行期创建的，两个对象地址并不相同。</p></li><li><p>涉及引用操作，编译期值确定（相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a = &quot;helloWorld&quot;;</span><br><span class="line">final String b = &quot;hello&quot;;</span><br><span class="line">String c = b + &quot;World&quot;;</span><br><span class="line">System.out.println(a==c);//true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：变量b被final修饰，在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中，此时b已经确定指向”hello”,可以被引用。</p></li></ol></li><li><p><strong>字符串的拼接</strong>：由于常量池中字符串不可变，一个字符串和另一个字符串拼接需要开辟<strong>三块</strong>内存空间，效率低下。建议使用StringBuffer或StringBuilder，这两者的区别稍后讲解。</p></li><li><p>String常用方法</p><ul><li>比较<ul><li><code>equals(Object obj)</code>：如果比较双方一个常量一个变量，应把常量写在前面，如<code>&quot;abc&quot;.equals(str)</code>。因为如使用<code>str.equals(&quot;abc&quot;)</code>，假如str为空会导致空指针异常。</li><li><code>equalsIgnoreCase(String str)</code>：忽略大小写。</li><li><code>endsWith(String suffix)</code>：比较suffix是否为串的后缀。</li></ul></li><li>获取<ul><li><code>length()</code>：获取长度。</li><li><code>concat(String str)</code>：获取拼接后的串。</li><li><code>charAt(int index)</code>：获取指定索引字符。</li><li><code>public int indexOf(String str)</code>：查找参数串在本串中首次出现的索引位置，如无匹配结果返回-1。可用于<strong>字符串匹配</strong>。</li></ul></li><li>截取<ul><li><code>subString(int index)</code>：截取从参数位置开始后的子串。</li><li><code>subString(int begin, int end)</code>：截取[begin, end)子串。</li><li><code>trim()</code>：去除字符串的前后空格。</li></ul></li><li>转换<ul><li><code>toCharArray()</code>：串转换为字符数组</li><li><code>getBytes()</code>：串转换为底层的字节数组</li><li><code>toUpperCase()和toLowerCase()</code>：大小写转换。</li><li><code>replaceAll(String regex, String replacement)</code>：使用给定的replacement替换所有符合regex规则的子串。</li></ul></li><li>分割：<code>split(String regex)</code>：按照参数规则分割字符串为若干子串。</li></ul></li></ul></li><li><p>StringBuffer与StringBuilder</p><ul><li>都由final修饰，不能被继承。</li><li>都继承于<strong>AbstractStringBuilder</strong>，底层使用的字符数组没有final修饰，因此在做字符串拼接就在原来的内存上拼接（<code>append()方法</code>），不会浪费内存空间。</li><li>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是  synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。</li><li>StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。</li></ul></li><li><p>jdk1.9后String/StringBuffer/StringBuilder均不再使用字符数组，而是直接使用字节数组byte[] value。</p></li></ul><h3 id="七个关键字"><a href="#七个关键字" class="headerlink" title="七个关键字"></a>七个关键字</h3><h4 id="static-涉及JVM的部分待补充"><a href="#static-涉及JVM的部分待补充" class="headerlink" title="static  [涉及JVM的部分待补充]"></a>static  [涉及JVM的部分待补充]</h4><ul><li><p>修饰成员变量或成员方法</p></li><li><p>不需要创建对象就可通过类名调用，它们均属于类，而非某个对象</p></li><li><p>修饰内部类（不允许修饰普通类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line"></span><br><span class="line">public static class Inner&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;====静态内部类静态代码块====&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Inner() &#123;</span><br><span class="line">System.out.println(&quot;====静态内部类构造方法====&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void innerMethod()&#123;</span><br><span class="line">System.out.println(&quot;====静态内部类普通方法====&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Inner inner = new Inner();</span><br><span class="line">inner.innerMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：====静态内部类静态代码块====</p><pre><code>       ====静态内部类构造方法====       ====静态内部类普通方法====</code></pre><p><strong>结论：想要在普通类中创建内部类实例，可以用static修饰内部类</strong>。</p></li><li><p>静态代码块</p><ul><li>第一次使用类时，类的静态代码块执行唯一的一次。</li><li>静态代码块先于构造方法执行。</li></ul></li><li><p>Tips:</p><ul><li>静态不能直接访问非静态</li><li>静态方法中不能用this, this代表当前对象。</li></ul></li></ul><h4 id="final-涉及JVM的部分待补充"><a href="#final-涉及JVM的部分待补充" class="headerlink" title="final   [涉及JVM的部分待补充]"></a>final   [涉及JVM的部分待补充]</h4><ul><li>修饰类：当前类不能有任何子类。</li><li>修饰方法：该方法不能被子类重写。（显然对于类、方法来说，abstract和final无法同时使用）</li><li>修饰变量：对于基本数据类型，其值不能再改变。对于引用数据类型，不能再改为存储其他对象的地址或引用。</li><li>修饰成员变量：对于基本数据类型，其值不能再改变。对于引用数据类型，不能再改为存储其他对象的地址或引用（对象自身是可以改变的）。并且该变量必须直接赋值或在构造方法中赋值。</li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><h4 id="native"><a href="#native" class="headerlink" title="native"></a>native</h4><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><h4 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h4><h4 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h4><h3 id="权限修饰符作用范围"><a href="#权限修饰符作用范围" class="headerlink" title="权限修饰符作用范围"></a>权限修饰符作用范围</h3><p><img src="权限修饰符.png" alt=""></p><h3 id="Arrays常用方法"><a href="#Arrays常用方法" class="headerlink" title="Arrays常用方法"></a>Arrays常用方法</h3><ul><li><code>static List&lt;T&gt; asList&lt;T... a&gt;</code>：返回参数列表的List，例<code>List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</code></li><li><code>binarySearch()</code>：有多个重载的方法，二分查找</li><li><code>static String toString(数组)</code>：将参数数组变成字符串，默认格式为[元素1, 元素2, 元素3….]</li><li><code>sort(数组)</code>：按照默认升序对数组元素排序；自定义类型需要实现Comparator接口。</li></ul><h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>Java类是<strong>单继承</strong>的，不允许子类继承多个父类的原因在于，编译器无法确定使用哪个父类方法。</li><li>在父子类的继承关系中，创建父或子类对象，访问成员方法的规则：优先使用创建的对象的方法，没有则向上找。</li><li><p>继承关系中，父子构造方法访问的特点</p><ul><li>子类构造方法有一个默认隐含的super()调用，因此一定是先调用的父类构造，后执行子类构造。</li><li>子类构造可以通过显示使用super()来调用<strong>父类重载构造</strong>，并且必须是子类构造的第一条语句。</li></ul></li><li><p>重载与重写</p><ul><li>重写：子类重写方法与父类方法名相同，参数列表相同。</li><li>重载：一个类中有多个相同的方法名，但参数列表不同。</li></ul></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>概念：父类引用指向子类对象。</li><li><p>多态代码中</p><ul><li>成员<strong>重写方法</strong>的访问规则：先在子类对象中找，没有则向上找。</li><li><strong>成员变量</strong>访问规则：直接使用父类成员变量。</li></ul></li><li><p>向上转型即多态：父类引用指向子类对象；引用无法调用原本<strong>子类特有的方法</strong>。</p></li><li>向下转型，例如<code>Anaimal a = new Cat();Cat cat = (Cat) a;</code>，这个过程将父类变量还原为子类类型，使其又可以访问<strong>子类特有的方法</strong>。</li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装通过将类属性定义为私有，对外提供类属性的setters/getters方法来修改和获取属性值实现。</li><li>封装可以减少耦合，防止类数据被外部类定义的代码随机访问。</li></ul><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><ul><li><p>抽象类：<code>public abstract class Name{}</code>；<strong><em>抽象类是描述一个对象是什么</em></strong>，它可以包含成员变量、成员方法、构造方法等，与普通类不同的点只在于：它可能包含抽象方法；它必须要<strong>被非抽象子类继承</strong>才能实例化，并且非抽象子类必须实现抽象方法（假如父类有抽象方法的话）。</p><ul><li>单继承。</li><li><p>抽象类的构造方法与静态方法不能用abstract修饰。</p></li><li><p>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；抽象方法没有方法体。</p></li><li>抽象类使用：<ul><li>创建子类继承抽象父类。</li><li>子类重写父类抽象方法，去掉abstract关键字，实现方法体。</li></ul></li></ul></li><li><p>接口：<code>public interface IName{}</code>；接口是多个类的<strong>公共规范</strong>。<strong><em>接口描述一个接口提供什么功能。</em></strong></p><ul><li><p>接口可以继承多个接口，实现类可以实现多个接口。（<strong>多继承，多实现</strong>）</p></li><li><p>接口的成员变量默认都是<code>public static final</code>的：假如两个接口有相同的成员变量，一个类实现了这两个接口，那么实现类只能通过接口名.变量名来调用以避免歧义，因此必须为static。声明为final的原因是实现类不能够修改接口成员变量的值。</p></li><li><p>Java7：常量，抽象方法</p></li><li><p>Java8：新增了<strong>默认方法</strong>(default修饰)，<strong>静态方法</strong>。</p><ul><li><p>增加默认方法的原因：Java升级后的兼容性问题。如果想在老版本接口中添加某个功能，在添加抽象方法的情况下，所有的老版本实现类都需要修改代码；而通过增加default方法来增加功能就不会有这种问题。</p></li><li><p>考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法。解决方案：<strong>重写方法，并使用<code>接口名.super.方法名()</code>调用指定接口的方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public interface Vehicle &#123;</span><br><span class="line">  default void print()&#123;</span><br><span class="line">  System.out.println(&quot;vehicle...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public interface FourWheeler &#123;</span><br><span class="line">  default void print()&#123;</span><br><span class="line">  System.out.println(&quot;fourWheeler...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void print() &#123;</span><br><span class="line">FourWheeler.super.print();</span><br><span class="line">Vehicle.super.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Vehicle car = new Car();</span><br><span class="line">car.print();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>}</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">输出：fourWheeler...</span><br><span class="line">              vehicle...</span><br></pre></td></tr></table></figure></li><li><p>Java9：新增了<strong>私有方法</strong>，<strong>私有静态方法</strong></p></li></ul></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><ul><li><p>成员内部类</p><ul><li><p>三种方法使用成员内部类</p><ul><li>在外部类的方法中创建内部类实例</li><li>main方法中：<code>Inner inner = new Outer.new Inner();</code></li><li>main方法中直接new，前提是静态内部类</li></ul></li><li><p>在内部类中访问重名的外部类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">private int num = 10;//外部类私有变量，内部类也可访问</span><br><span class="line"></span><br><span class="line">class Inner&#123;</span><br><span class="line">private int num = 20;</span><br><span class="line"></span><br><span class="line">public void innerMethod()&#123;</span><br><span class="line">int num = 30;</span><br><span class="line"></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(this.num);</span><br><span class="line">System.out.println(Outer.this.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Inner inner  = new Outer().new Inner();</span><br><span class="line">inner.innerMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>局部内部类</p><ul><li>该类定义在方法内部，只有在该方法内部才能使用。</li></ul></li><li><p>局部内部类中的匿名内部类</p><ul><li><p>如果接口的实现类（或者父类的子类）只需要使用一次，那么这种情况下可以省略掉该类的定义，而使用匿名内部类。</p></li><li><p>最常见的使用：通过将Runnable接口的实现类的实例对象作为参数传给Thread，创建线程。不仅省略了类定义，同时完成了向上转型。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li><p>包装类通过将基本数据类型封装起来，在类中提供一些方法，便于操作这些基本数据类型。</p></li><li><p>Java自jdk5后提供自动装箱与自动拆箱机制。</p></li><li><p>基本类型与字符串的转换</p><ul><li>基本类型 -&gt; String：基本类型值+””</li><li>String -&gt; 基本类型：使用包装类的静态方法<code>parseXXX(&quot;str&quot;)</code><ul><li>Integer：<code>static int parseInt(String s)</code></li><li>Double：<code>static double parseDouble(String s)</code></li></ul></li></ul></li></ul><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><ul><li><p>实参与形参：</p><ul><li>形式参数：<strong>定义函数时使用的参数</strong>，用来接收实际参数。</li><li>实际参数：<strong>调用有参函数时</strong>，传入的内容。</li></ul></li><li><p>基本数据类型与引用类型</p><ul><li>基本数据类型：直接存储值。</li><li>引用类型：存储的是对象的地址。对象在堆中。</li></ul></li><li><p>求值策略（Evaluation Strategy）：值传递与引用传递，属于函数调用时参数的求值策略，是对调用函数时求值和传值的方式的描述，而非传递的内容的类型。（内容的类型是指：值类型还是引用类型。）值类型与引用类型，用于区分两种内存分配方式，值类型在调用栈上分配，引用类型在堆上分配。[<a href="https://www.zhihu.com/question/20628016" target="_blank" rel="noopener">https://www.zhihu.com/question/20628016</a>]  <strong>[JVM部分后面补充修改]</strong></p></li><li><p>值传递概念：调用函数时，将<strong>实际参数拷贝</strong>一份传递给函数。因此不管函数如何修改形参，都不会改变实际参数的值。</p></li><li>引用传递概念：调用函数时，将实际参数的地址传递给函数。因此如果函数对参数修改，实际参数也会改变。</li><li><strong>Java中只有值传递</strong>：对于基本数据类型，传递的是<strong>基本数据类型的值的拷贝</strong>；对于引用类型，传递的是<strong>对象的地址值的拷贝</strong>，形参与实参都保存的是堆内存中同一个对象的地址，因此通过形参更改了对象（此时地址并没有改变），也会影响到实参。</li></ul><h3 id="集合的三种遍历方式"><a href="#集合的三种遍历方式" class="headerlink" title="集合的三种遍历方式"></a>集合的三种遍历方式</h3><ul><li>for<ul><li>形式：<code>for(初始化;结束条件;自增操作等)</code></li><li>需要知道集合的<strong>大小</strong>和元素<strong>类型</strong>，使用索引。</li></ul></li><li>foreach<ul><li>形式：<code>for(T element : colletion)</code></li><li>需要知道集合元素的<strong>类型</strong>，不需要索引。</li></ul></li><li><p>iterator</p><ul><li>形式：<code>Iterator it = collection.iterator();while(it.hasNext()){ object o =it.next(); ...}</code></li><li>集合的大小和类型都无需知道，也无需索引。</li></ul></li><li><p>Tips:</p><ul><li>foreach是iterator的语法糖，底层使用iterator实现。</li><li>不能使用foreach语句进行add/remove操作，会报异常。</li><li>使用for循环进行remove操作时，每一次操作完成后索引需要自减。</li></ul></li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>Java异常图解</p><p><img src="Exception.png" alt=""></p></li><li><p>Throwable类中定义了一些查看异常的方法：</p><ul><li><code>public String getMessage()</code>：获取异常的描述信息。</li><li><code>public String toString()</code>：获取异常的类型和异常描述信息。</li><li><code>void printStackTrace()</code>：打印异常的跟踪栈信息。最常用。</li></ul></li><li><p>捕获异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    //可能产生异常的代码</span><br><span class="line">&#125;catch(异常类型1 e)&#123;</span><br><span class="line">    //异常的处理逻辑；一般会记录到日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> catch(异常类型n e)&#123;</span><br><span class="line">     </span><br><span class="line"> &#125;finally&#123;</span><br><span class="line">     //无论是否出现异常都会执行，常用于资源释放</span><br><span class="line"> &#125;</span><br><span class="line">//jdk1.8之后支持try with resource写法</span><br><span class="line">try(需要释放资源的代码)&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常类</p><ul><li><pre><code>public class XXXException extends Exception{    //添加一个空参构造    public XXXException(){       super();    }    //添加一个带异常信息的构造    public XXXException(String message){       super(message);//所有的子类异常都交给父类处理    }}</code></pre></li><li><p>自定义异常类一般以命名Exception结尾</p></li><li>必须继承Exception类或者RuntimeException类。<ul><li>继承自Exception：自定义异常为编译期异常，必须处理。</li><li>继承自RuntimeException：运行期异常无需处理。</li></ul></li></ul></li></ul><h3 id="File"><a href="#File" class="headerlink" title="File"></a>File</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;String类是final的，因此不能被继承。源码是一个&lt;stron
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java并发</title>
    <link href="http://thmasterplan.cn/JUC/Java%E5%B9%B6%E5%8F%91/"/>
    <id>http://thmasterplan.cn/JUC/Java%E5%B9%B6%E5%8F%91/</id>
    <published>2020-04-08T14:28:41.000Z</published>
    <updated>2020-04-08T14:42:04.429Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="JUC" scheme="http://thmasterplan.cn/categories/JUC/"/>
    
    
      <category term="JUC" scheme="http://thmasterplan.cn/tags/JUC/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/</id>
    <published>2020-04-08T14:23:56.000Z</published>
    <updated>2020-04-08T15:15:14.234Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2020-04-08T14:23:38.000Z</published>
    <updated>2020-04-08T14:41:16.437Z</updated>
    
    <content type="html"><![CDATA[<h4 id="容器关系图"><a href="#容器关系图" class="headerlink" title="容器关系图"></a>容器关系图</h4><h4 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h4><h4 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h4><h6 id="List"><a href="#List" class="headerlink" title="List"></a>List</h6><h6 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h6><h4 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h4><h4 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;容器关系图&quot;&gt;&lt;a href=&quot;#容器关系图&quot; class=&quot;headerlink&quot; title=&quot;容器关系图&quot;&gt;&lt;/a&gt;容器关系图&lt;/h4&gt;&lt;h4 id=&quot;泛型&quot;&gt;&lt;a href=&quot;#泛型&quot; class=&quot;headerlink&quot; title=&quot;泛型&quot;&gt;&lt;/a&gt;泛
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理</title>
    <link href="http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2020-04-05T08:53:39.000Z</published>
    <updated>2020-04-05T17:38:15.118Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个小需求引入静态代理"><a href="#一个小需求引入静态代理" class="headerlink" title="一个小需求引入静态代理"></a>一个小需求引入静态代理</h3><ul><li><p>假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  public int add(int a, int b)&#123;</span><br><span class="line">     return a+b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int subtract(int a, int b)&#123;</span><br><span class="line">     return a-b;</span><br><span class="line">  &#125;</span><br><span class="line">  //其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案：直接在Calculator类每个方法前后插入日志代码。缺点：</p><ol><li>直接修改源码，不符合<strong>开闭原则</strong>。应该<strong>对扩展开放，对修改关闭</strong>。</li><li>如果Calculator类有许多方法，修改量太大。</li><li>重复代码太多。</li><li>日志代码硬编码在代理类中，不利于后期维护。</li></ol></li></ul><h3 id="静态代理实现日志打印"><a href="#静态代理实现日志打印" class="headerlink" title="静态代理实现日志打印"></a>静态代理实现日志打印</h3><ul><li><p>代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于<strong>在目标实现的基础上增加额外的功能操作</strong>，以满足自身的业务需求。</p></li><li><p>静态代理的实现：编写一个代理类，<strong>实现与目标对象相同的接口</strong>，<strong>并在内部维护一个目标对象的引用</strong>。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。</p></li><li><p>静态代理实现日志打印：</p><ul><li><p>将Calculator抽取为接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Calculator &#123;</span><br><span class="line">int add(int a, int b);</span><br><span class="line">int subtract(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorImpl implements Calculator &#123;</span><br><span class="line"></span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int subtract(int a, int b) &#123;</span><br><span class="line">return a - b;</span><br><span class="line">&#125;</span><br><span class="line">//其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorProxy implements Calculator &#123;</span><br><span class="line">        //代理对象内部维护一个目标对象引用</span><br><span class="line">private Calculator target;</span><br><span class="line">        </span><br><span class="line">        //构造方法，传入目标对象</span><br><span class="line">public CalculatorProxy(Calculator target) &#123;</span><br><span class="line">this.target = target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        //调用目标对象的add，并在前后打印日志</span><br><span class="line">@Override</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;add方法开始...&quot;);</span><br><span class="line">int result = target.add(a, b);</span><br><span class="line">System.out.println(&quot;add方法结束...&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        //调用目标对象的subtract，并在前后打印日志</span><br><span class="line">@Override</span><br><span class="line">public int subtract(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;subtract方法开始...&quot;);</span><br><span class="line">int result = target.subtract(a, b);</span><br><span class="line">System.out.println(&quot;subtract方法结束...&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用代理对象实现计算器并打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Calculator calculator = new CalculatorProxy(new CalculatorImpl());</span><br><span class="line">calculator.add(1, 2);</span><br><span class="line">calculator.subtract(2, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。</p></li><li><p>静态代理的缺点：</p><ul><li><strong>代理者与委托者一一对应</strong>，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。</li><li>如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。</li></ul></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>我们的目标只是为了实现增强功能，如何才能不编写代理类，只<strong>提供接口和目标对象</strong>就直接<strong>得到代理对象</strong>呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。</p></li><li><p>Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了<strong>JVM动态生成的代理类</strong>的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。实际开发中采用newProxyInstance方法，直接返回代理对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">/**</span><br><span class="line"> * 测试</span><br><span class="line"> * @param args</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Calculator calculatorProxy =(Calculator) getProxy(new CalculatorImpl());</span><br><span class="line">        calculatorProxy.add(1, 2);</span><br><span class="line">        calculatorProxy.subtract(3, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 传入目标对象，得到代理对象</span><br><span class="line"> * @param targetObj</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">private static Object getProxy(final Object targetObj) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">//传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口</span><br><span class="line">//proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象</span><br><span class="line">Class&lt;?&gt; proxyClass =</span><br><span class="line">Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces());</span><br><span class="line"></span><br><span class="line">//得到代理类（com.sun.proxy.$Proxy0）的构造器</span><br><span class="line">Constructor&lt;?&gt; constructor = proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">//通过构造器创建代理对象</span><br><span class="line">Object proxyObj = constructor.newInstance(new InvocationHandler()&#123;</span><br><span class="line"></span><br><span class="line">//在重写invoke方法中编写增强功能代码</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);//增强功能代码</span><br><span class="line">Object result = method.invoke(targetObj,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);//增强功能代码</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object getProxy1(final Object targetObj) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Object proxyObj = Proxy.getProxyClass(</span><br><span class="line">targetObj.getClass().getClassLoader(),</span><br><span class="line">targetObj.getClass().getInterfaces()</span><br><span class="line">)</span><br><span class="line">.getConstructor(InvocationHandler.class)</span><br><span class="line">.newInstance(new InvocationHandler()&#123;</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);//增强功能代码</span><br><span class="line">Object result = method.invoke(targetObj,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);//增强功能代码</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">     &#125;);</span><br><span class="line">return proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 实际使用的方法newProxyInstance</span><br><span class="line"> * @param target</span><br><span class="line"> * @return</span><br><span class="line"> * @throws Exception</span><br><span class="line"> */</span><br><span class="line">public static Object getProxy2(final Object target) throws Exception &#123;</span><br><span class="line">Object proxy = Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">target.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);//增强功能代码</span><br><span class="line">Object result = method.invoke(target,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);//增强功能代码</span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。</p></li><li><p>mybatis Mapper以及springAOP都是通过动态代理实现。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个小需求引入静态代理&quot;&gt;&lt;a href=&quot;#一个小需求引入静态代理&quot; class=&quot;headerlink&quot; title=&quot;一个小需求引入静态代理&quot;&gt;&lt;/a&gt;一个小需求引入静态代理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;假设现有一个类Calculator，代表一个计算器
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>mybatisHelloWorld</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/</id>
    <published>2020-04-05T08:39:41.000Z</published>
    <updated>2020-04-05T08:40:46.856Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。<strong>开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务）</strong>，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li></ul><h3 id="MybatisHelloWorld"><a href="#MybatisHelloWorld" class="headerlink" title="MybatisHelloWorld"></a>MybatisHelloWorld</h3><ul><li><p>工程文件结构如图</p><p><img src="mybatisHelloWorld.jpg" alt=""></p></li></ul><ol><li><p>创建Maven工程，配置pom.xml，插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.1.48&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.5.4&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;junit&lt;/groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;junit&lt;/artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.12&lt;/version&gt;</span><br><span class="line">      &lt;/dependency&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;/dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建实体类和DAO接口</p><ul><li><p>实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;//包装类默认为null</span><br><span class="line">    private String lastName;</span><br><span class="line">    private String email;</span><br><span class="line">    private String gender;</span><br><span class="line">    //getters and setters, toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DAO接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    public User getUserById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建sql映射文件：<code>UserMapper.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace=&quot;com.laishiji.mybatis.dao.UserMapper&quot;&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt;</span><br><span class="line">    &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt;</span><br><span class="line">    &lt;select id=&quot;getUserById&quot; resultType=&quot;com.laishiji.mybatis.bean.User&quot;&gt;</span><br><span class="line">         select id, last_name lastName, gender,email from user where id = #&#123;id&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：<code>mybatisConfig.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line"></span><br><span class="line">              &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                  &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;</span><br><span class="line">                  &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/mybatis&quot;/&gt;</span><br><span class="line">                  &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;</span><br><span class="line">                  &lt;property name=&quot;password&quot; value=&quot;admin&quot;/&gt;</span><br><span class="line">              &lt;/dataSource&gt;</span><br><span class="line"></span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line"></span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;UserMapper.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>mysql中建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists mybatis;</span><br><span class="line">create database mybatis default character set utf8;</span><br><span class="line"></span><br><span class="line">create table user(</span><br><span class="line">  id int(11) primary key auto_increment,</span><br><span class="line">  last_name varchar(255),</span><br><span class="line">  gender char(1),</span><br><span class="line">  email varchar(255)</span><br><span class="line">)engine=innodb default charset=utf8;</span><br><span class="line"></span><br><span class="line">insert into user(id,last_name,gender,email) values (1,&apos;Tom&apos;,&apos;男&apos;,&apos;123@qq.com&apos;),</span><br><span class="line">                                   (2,&apos;Jim&apos;,&apos;男&apos;,&apos;234@qq.com&apos;),</span><br><span class="line">                                    (3,&apos;Lisa&apos;,&apos;女&apos;,&apos;324@qq.com&apos;);</span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.laishiji.mybatis;</span><br><span class="line"></span><br><span class="line">import com.laishiji.mybatis.bean.User;</span><br><span class="line">import com.laishiji.mybatis.dao.UserMapper;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> *  SqlSession代表和数据库的一次会话，用完必须关闭；</span><br><span class="line"> *  SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量；</span><br><span class="line"> *  mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。</span><br><span class="line"> */</span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatisConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory =  new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession session = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        User user = session.selectOne(&quot;com.laishiji.mybatis.dao.UserMapper.getUserById&quot;,1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    /**</span><br><span class="line">     *   接口式编程：</span><br><span class="line">     *    原生：DAO类 ---&gt; DAOImpl实现类</span><br><span class="line">     *    mybatis：xxxMapper接口 ---&gt; xxxMapper.xml</span><br><span class="line">     * @throws IOException</span><br><span class="line">     */</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatisConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory =  new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession openSession = sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        //通过反射+动态代理获取接口的实现类对象</span><br><span class="line">        UserMapper mapper = openSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user = mapper.getUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        openSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。&lt;strong&gt;开发者只需要关注sql语句本身（在配置文件
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://thmasterplan.cn/tags/Mybatis/"/>
    
  </entry>
  
  <entry>
    <title>Maven入门</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Maven%E5%85%A5%E9%97%A8/</id>
    <published>2020-04-05T03:18:27.000Z</published>
    <updated>2020-04-05T03:20:55.615Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Maven配置踩坑"><a href="#Maven配置踩坑" class="headerlink" title="Maven配置踩坑"></a>Maven配置踩坑</h3><ul><li><p><strong>修改本地仓库路径</strong>：找到conf目录下的settings.xml，添加<code>&lt;localRepository&gt;PATH&lt;/localRepository&gt;</code>，PATH即为仓库路径。</p></li><li><p><strong>修改Maven云仓库为国内镜像站</strong>：同样在conf目录下的settings.xml下，找到<code>&lt;mirrors&gt;</code>标签，添加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;mirror&gt;</span><br><span class="line">       &lt;id&gt;alimaven&lt;/id&gt;</span><br><span class="line">       &lt;name&gt;aliyun maven&lt;/name&gt;</span><br><span class="line">       &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;!-- 改为阿里云镜像 --&gt;</span><br><span class="line">       &lt;mirrorOf&gt;central&lt;/mirrorOf&gt;        </span><br><span class="line">     &lt;/mirror&gt;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Maven项目目录结构"><a href="#Maven项目目录结构" class="headerlink" title="Maven项目目录结构"></a>Maven项目目录结构</h3><p><img src="MavenDirStruc.jpg" alt=""></p><h3 id="项目对象模型（POM）"><a href="#项目对象模型（POM）" class="headerlink" title="项目对象模型（POM）"></a>项目对象模型（POM）</h3><ul><li><p>POM详解：<a href="https://www.runoob.com/maven/maven-pom.html。" target="_blank" rel="noopener">https://www.runoob.com/maven/maven-pom.html。</a></p></li><li><p>POM是 Maven 工程的基本工作单元，是一个XML文件，包含了项目的基本信息，用于描述项目如何构建，声明项目依赖，等等。</p></li><li>所有 POM 文件都需要 project 元素和三个必需字段：groupId，artifactId，version。<ul><li>groupId：公司或者组织的唯一标志。</li><li>artifactId：项目的唯一ID。</li></ul></li></ul><h3 id="Maven构建生命周期"><a href="#Maven构建生命周期" class="headerlink" title="Maven构建生命周期"></a>Maven构建生命周期</h3><ul><li><em>clean</em> <strong>-&gt;</strong> <em>default(build)</em> {validate <strong>-&gt;</strong> compile <strong>-&gt;</strong> test <strong>-&gt;</strong> package <strong>-&gt;</strong> verify <strong>-&gt;</strong> install <strong>-&gt;</strong> deploy } <strong>-&gt;</strong> <em>site</em></li></ul><h3 id="依赖管理模型"><a href="#依赖管理模型" class="headerlink" title="依赖管理模型"></a>依赖管理模型</h3><ul><li><p>Maven 通过读取项目文件（pom.xml），找出库文件之间的依赖关系并从仓库自动下载。</p></li><li><p>引入外部依赖：先在 src 文件夹下添加 lib 文件夹，然后将工程需要的 jar 文件复制到 lib 文件夹下。然后添加以下依赖到pom.xml：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">        &lt;groupId&gt;xxx&lt;/groupId&gt;  </span><br><span class="line">        &lt;artifactId&gt;xxx&lt;/artifactId&gt;    </span><br><span class="line">        &lt;version&gt;1.0&lt;/version&gt; </span><br><span class="line">        &lt;scope&gt;system&lt;/scope&gt; &lt;!--作用域--&gt;</span><br><span class="line">        &lt;systemPath&gt;$&#123;basedir&#125;\src\lib\yyy.jar&lt;/systemPath&gt; </span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Maven配置踩坑&quot;&gt;&lt;a href=&quot;#Maven配置踩坑&quot; class=&quot;headerlink&quot; title=&quot;Maven配置踩坑&quot;&gt;&lt;/a&gt;Maven配置踩坑&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;修改本地仓库路径&lt;/strong&gt;：找到conf目
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Maven" scheme="http://thmasterplan.cn/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Filter_Listener</title>
    <link href="http://thmasterplan.cn/JavaWeb/Filter-Listener/"/>
    <id>http://thmasterplan.cn/JavaWeb/Filter-Listener/</id>
    <published>2020-04-03T07:52:10.000Z</published>
    <updated>2020-04-03T14:29:23.154Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Filter（过滤器）"><a href="#Filter（过滤器）" class="headerlink" title="Filter（过滤器）"></a>Filter（过滤器）</h3><ul><li><p><strong>概念</strong>：客户端访问服务器资源时，filter拦截请求，作特殊处理：<strong>登录验证</strong>、<strong>统一编码处理</strong>、<strong>敏感字符过滤等</strong>。</p></li><li><p><strong>使用</strong></p><ul><li><p>实现<code>javax.servlet.Filter</code>接口</p></li><li><p>覆写<code>init()/doFilter()/destroy()</code>方法</p><ul><li>doFilter()放行代码：<code>filterChain.doFilter(servletRequest, servletResponse);</code></li></ul></li><li><p>配置拦截路径</p><ul><li><p>注解配置：<code>@WebFilter(&quot;/path&quot;)</code></p></li><li><p>web.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;name&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;filterClassName&lt;/filter-class&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line"></span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;name&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/path&lt;/url-pattern&gt; &lt;!-- 拦截路径 --&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><strong>filter的执行流程</strong></p><ul><li>客户端请求 -&gt;</li><li>经过filter -&gt;</li><li>执行doFilter()：<ul><li>对request对象请求消息处理 -&gt;</li><li>放行 -&gt;</li><li>(服务器servlet执行后响应) 对response对象的响应消息处理 </li></ul></li></ul></li><li><p><strong>filter的生命周期</strong></p><ul><li><code>init()</code>：服务器启动后，创建filter对象，调用init()方法，只执行一次。用于加载资源。</li><li><code>doFilter()</code>：<strong>每一次请求</strong>被拦截资源时，都会执行。</li><li><code>destroy()</code>：服务器关闭，filter对象被销毁。正常关闭情况下，会执行destroy()方法。用于释放资源。</li></ul></li><li><p><strong>拦截方式配置</strong>，设置dispatcherTypes属性</p><ul><li><p>注解方式</p><ul><li>DispatcherType.REQUEST：默认值。浏览器直接请求资源时，才会执行filter。</li><li>DispatcherType.FORWARD：转发访问资源。</li><li>DispatcherType.INCLUDE：包含访问资源。</li><li>DispatcherType.ERROR：错误跳转资源。</li><li>DispatcherType.ASYNC：异步访问资源。</li></ul></li><li><p>web.xml方式</p><ul><li>添加<code>&lt;dispatcher&gt; &lt;/dispatcher&gt;</code>标签，标签中文本取上述取值即可。</li></ul></li></ul></li><li><p><strong>过滤器链的执行顺序</strong>：filter1 -&gt; filter2… -&gt; 资源执行 -&gt;…filter2 -&gt; filter1。</p><ul><li>注解配置：按照类名的字符串比较规则比较，值小的先执行。例如filterA与filterB，则filterA先执行。</li><li>web.xml配置：按照<code>&lt;filter-mapping&gt;</code>的定义顺序执行。</li></ul></li></ul><h3 id="Listener-监听器"><a href="#Listener-监听器" class="headerlink" title="Listener(监听器)"></a>Listener(监听器)</h3><ul><li><p>概念：监听器就是一个实现了特定<strong>接口</strong>的普通Java程序，这个程序专门用于监听另一个Java对象的方法调用或者属性改变（事件）。当被监听对象发生上述事件后，监听器某个方法将立即被执行。</p></li><li><p>常用的监听器”6 + 2”：</p><ul><li><p><strong>6个常规监听器</strong>，对应JavaWeb<strong>三大域对象</strong></p><ul><li><p><strong>ServletContext</strong></p><ul><li>ServletContextListener(生命周期监听)，<strong>项目启动时</strong>，ServletContext创建后创建该接口的实现类对象。注：Spring框架的ContextLoaderListener类实现了该接口。</li><li>ServletContextAttributeListener(属性监听)</li></ul></li><li><p><strong>HttpSession</strong></p><ul><li>HttpSessionListener(生命周期监听)，只有在servlet中调用了request.getSession()方法且根据JSESSIONID找不到对应的session时才会创建新的session对象，触发监听。</li><li>HttpSessionAttributeListener(属性监听)</li></ul></li><li><p><strong>ServletRequest</strong></p><ul><li>ServletRequestListener(生命周期监听)，每一次请求都会创建request对象并触发监听，每一次请求结束都会销毁request对象并触发监听。</li><li>ServletRequestAttributeListener(属性监听)</li></ul></li><li><p><strong>生命周期监听</strong>：每当tomcat<strong>创建或销毁三大域对象</strong>时，都会被其对应的Listener察觉并调用其特定的方法。</p></li><li><strong>属性监听</strong>：每当调用域对象的setAttribute()或getAttribute()，都会被对应的属性监听器察觉并调用其特定的方法。</li></ul></li><li><p><strong>2个感知监听</strong></p><ul><li>HttpSessionBindingListener：需要通过<code>session.setAttribute(&quot;key&quot;, new Object())</code>存储的对象Object实现该监听器接口，其有两个方法<code>valueBound()/valueUnbound</code>，当该对象被<strong>绑定(存储)</strong>时，触发该对象的<code>valueBound()</code>方法；当该对象被session<strong>解绑</strong>时<code>session.removeAttribute(&quot;key&quot;);</code>时触发该对象的<code>valueUnbound()</code>方法。</li><li>HttpSessionActivationListener：需要通过<code>session.setAttribute(&quot;key&quot;, new Object())</code>存储的对象Object实现该监听器接口。当该session即将被<strong>钝化(序列化)</strong>时，触发该监听器的<code>sessionWillPassivate()</code>方法；当该session<strong>活化</strong>时，触发该监听器的<code>sessionDidActivate</code>方法。</li></ul></li></ul></li><li><p><strong>设计模式：观察者模式</strong>（待补充）</p></li><li><p><code>javax.servlet.ServletContextListener</code>接口：用于监听ServletContext对象的销毁与创建</p><ul><li><code>void contextDestroyed(ServletContextEvent sce)</code>：ServletContext对象<strong>被销毁</strong>之前会调用该方法。</li><li><p><code>void contextInitialized(ServletContextEvent sce)</code>：ServletContext对象<strong>创建</strong>后会调用该方法，服务器启动后自动调用。</p></li><li><p>使用：实现接口 -&gt; 覆写方法 -&gt; 配置</p><ul><li><p>web.xml配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;listener&gt;</span><br><span class="line">   &lt;listener-class&gt;监听器类名&lt;/listener-class&gt;</span><br><span class="line">&lt;/listener&gt;</span><br></pre></td></tr></table></figure></li><li><p>注解配置：<code>@WebListener</code></p></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Filter（过滤器）&quot;&gt;&lt;a href=&quot;#Filter（过滤器）&quot; class=&quot;headerlink&quot; title=&quot;Filter（过滤器）&quot;&gt;&lt;/a&gt;Filter（过滤器）&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;概念&lt;/strong&gt;：客户端访问
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Cookie_Session</title>
    <link href="http://thmasterplan.cn/JavaWeb/Cookie-Session/"/>
    <id>http://thmasterplan.cn/JavaWeb/Cookie-Session/</id>
    <published>2020-04-01T12:55:36.000Z</published>
    <updated>2020-04-03T07:49:07.529Z</updated>
    
    <content type="html"><![CDATA[<h3 id="会话"><a href="#会话" class="headerlink" title="会话"></a>会话</h3><ul><li>会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一<strong>标识一个用户并记录其状态</strong>。由于HTTP协议是无状态的，也就是说浏览器的每一次请求都是独立的，服务器并不知道这个浏览器之前是否请求过，这才有了会话机制。</li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li><p>概念：客户端会话技术，将数据保存到客户端。<code>javax.servlet.http.Cookie</code>(类)。</p></li><li><p>主要作用：避免多次登录验证，一次登录后服务器便使用cookie验证身份。cookie的作用就像是身份凭证。</p></li><li><p>使用</p><ul><li><p>创建Cookie对象，绑定数据：<code>new Cookie(String name, String value)</code></p></li><li><p>发送Cookie对象到客户端：<code>response.addCookie(Cookie cookie)</code></p></li><li><p>获取Cookie，拿到数据：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Cookie[] cookies = request.getCookies();</span><br><span class="line">if(cookies != null)&#123;</span><br><span class="line">   for(Cookie c : cookies)&#123;</span><br><span class="line">      String name = c.getName();</span><br><span class="line">      String val = c.getValue();</span><br><span class="line">      //..........</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>原理</p><ul><li>客户端发送请求-&gt;</li><li>服务器创建Cookie并发送到客户端 -&gt; </li><li>http响应头增加Set-Cookie：name=value字段 -&gt;</li><li>客户端存储cookie数据 -&gt; </li><li>客户端下一次请求http请求头设置cookie -&gt; </li><li>服务器验证</li></ul></li><li><p>Tips</p><ul><li><p>一次可以创建多个Cookie并发送</p></li><li><p>Cookie在浏览器中存活时间</p><ul><li>默认情况下，浏览器关闭后Cookie数据销毁</li><li><strong>持久化存储</strong>：<code>cookie.setMaxAge(int seconds)</code><ul><li>正数：将cookie数据写到硬盘的文件中，seconds时间之后文件被删除。</li><li>负数：默认值</li><li>0：删除已经存在于客户端的cookie数据</li></ul></li></ul></li><li><p>Tomcat8之后Cookie支持中文</p></li><li><p><strong>Cookie共享问题</strong></p><ul><li><p>假设在一个Tomcat服务器中部署了多个web项目：</p><ul><li><p>默认情况下不同web项目的cookie不能共享</p></li><li><p><code>cookie.setPath(String path)</code>：设置Cookie的获取范围。默认情况下，设置当前的虚拟目录。如果要共享，可将path设置为”/“。</p></li></ul></li><li><p>服务器集群共享Cookie：</p><ul><li><code>setDomain(String path)</code>：设置一级域名</li><li>例如<code>setDomain(&quot;.baidu.com&quot;)</code>，则tieba.baidu.com和news.baidu.com中cookie可以共享</li></ul></li></ul></li></ul></li></ul><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li><p>概念：服务器端会话技术，在<strong>一次会话的多次请求间共享数据</strong>，将数据保存在服务器端的对象中。<code>javax.servlet.http.HttpSession</code>（接口）。</p></li><li><p>主要作用</p><ul><li>用于存储一次会话的多次请求的数据</li><li>可以存储任意类型、任意大小的数据</li></ul></li><li><p>使用</p><ul><li><p>获取session对象：<code>HttpSession session = request.getSession();</code></p></li><li><p>存储数据：<code>session.setAttribute(&quot;name&quot;, Object);</code></p></li><li><p>获取数据：<code>session.getAttribute(&quot;name&quot;);</code></p></li></ul></li><li><p>原理：<strong>Session的实现依赖于Cookie</strong>，服务器通过Cookie确保多次请求获取的Session对象为同一个。</p><ul><li>客户端发送请求-&gt;</li><li>创建Session对象，若没有Cookie，则http响应头增加Set-Cookie：JSESSIONID=sessionID字段 -&gt;</li><li>客户端存储cookie数据 -&gt; </li><li>客户端下一次请求http请求头设置cookie -&gt; </li><li>服务器验证sessionID</li></ul></li><li><p>Tips</p><ul><li><p>浏览器关闭，服务器不关闭，浏览器重启，两次获取的session对象是否相同？</p><ul><li><p>默认情况下不是。</p></li><li><p>为避免这种情况，可手动设置持久化存储JSESSIONID</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Cookie cookie = new Cookie(&quot;JSESSIONID&quot;, session.getId());</span><br><span class="line">cookie.setMaxAge(60*60);//持久化存储cookie</span><br><span class="line">response.addCookie(cookie);</span><br></pre></td></tr></table></figure></li></ul></li><li><p>浏览器不关闭，服务器关闭，服务器开启，两次获取的session对象是否相同？</p><ul><li>新对象地址与原对象不同</li><li>为避免服务器重启数据丢失，采用<strong>session的钝化和活化技术</strong>。<ul><li>session钝化：在服务器正常关闭前，将session对象序列化到硬盘上</li><li>session活化：服务器启动后，将session文件转化为内存中的session对象，删除文件</li><li>Tomcat已经集成了钝化与活化技术，正常关闭tomcat后，会在work工作目录的项目文件夹下生成一个SESSIONS.ser文件</li><li>session钝化与活化不仅仅是服务器关闭时发生，当在线用户过多时，大量session对象存在于服务器内存中。为减轻服务器内存负担，当一个session长时间没有被访问，也会被序列号到磁盘上（注意session中存储的对象所在的类必须要实现序列化接口）。可在tomcat的<code>conf/context.xml</code>中配置。</li></ul></li></ul></li><li><p>session何时被销毁？</p><ul><li><p>服务器关闭</p></li><li><p>session对象调用invalidate()方法</p></li><li><p>session默认失效时间为30分钟(可在tomcat的conf/web.xml中配置)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;session-config&gt;</span><br><span class="line">        &lt;session-timeout&gt;30&lt;/session-timeout&gt;</span><br><span class="line">    &lt;/session-config&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;会话&quot;&gt;&lt;a href=&quot;#会话&quot; class=&quot;headerlink&quot; title=&quot;会话&quot;&gt;&lt;/a&gt;会话&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;会话机制：会话机制的目的是帮助服务器记住客户端的状态，是为了唯一&lt;strong&gt;标识一个用户并记录其状态&lt;/strong&gt;。由于
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>Servlet</title>
    <link href="http://thmasterplan.cn/JavaWeb/Servlet/"/>
    <id>http://thmasterplan.cn/JavaWeb/Servlet/</id>
    <published>2020-04-01T08:10:10.000Z</published>
    <updated>2020-04-03T15:17:16.496Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Servlet-Server-applet"><a href="#Servlet-Server-applet" class="headerlink" title="Servlet(Server applet)"></a>Servlet(Server applet)</h3><ul><li>用于处理请求与业务逻辑。</li><li><strong>调用流程</strong>：<ul><li>用户访问html页面，表单提交</li><li>xml文件<code>url-pattern</code>与url匹配，若符合Tomcat则加载<code>servlet-class</code>对应的class文件进内存（反射）</li><li>实例化Servlet（class.newInstance()）得到一个Servlet对象</li><li>调用service()方法，根据表单的method，在该方法中调用doGet或doPost方法</li><li>request对象获取参数，response对象返回数据</li><li>服务器通过http协议返回数据</li></ul></li><li><p>Servlet<strong>生命周期</strong>：</p><ul><li>实例化：无论访问多少次该Servlet，构造方法只执行一次，只存在一个对象（单实例）<ul><li>注：多个用户同时访问时，可能存在线程安全问题。因此尽量不要在Servlet中定义成员变量。</li></ul></li><li><strong>初始化</strong>：在构造方法执行后，执行<strong>init()</strong>方法，无论访问多少次该Servlet，init()方法<strong>只执行一次</strong>。init()方法的参数ServletConfig对象实例，通过解析web.xml文件创建。</li><li><strong>提供服务</strong>：tomcat创建req和resp对象，将这两个对象作为参数传递给service()，执行<strong>service()</strong>方法，在该方法中判断执行doGet()还是doPost()</li><li><p><strong>销毁</strong>：当在server.xml的Context字段中配置了reloadable=”true”时，表示web应用有任何类型的更新都会自动重启，重启就会调用<strong>destroy()</strong>方法；tomcat服务器关闭时destroy()方法会被调用。</p></li><li><p>被回收：等待下一次GC回收</p></li></ul></li><li><strong>自启动</strong>：假如需要在tomacat一启动就执行一些初始化的代码，比如校验数据库的完整性。但是Servlet的生命周期是在用户访问对应路径开始的，这就需要Servlet自启动，执行init()方法中的业务代码：在web.xml中增加<code>&lt;load-on-startup&gt;10&lt;/load-on-startup&gt;</code>，取值范围是1-99，数字表示启动顺序，数字越小启动的优先级越高。</li><li><p><strong>注解配置</strong>（Servlet3.0后支持，不再需要web.xml配置文件）</p><ul><li>Servlet类上使用<code>@WebServlet(&quot;/URI&quot;)</code>配置</li></ul></li><li><p><strong>页面跳转</strong>：</p><ul><li>服务端跳转<strong>forward(转发)</strong>：<code>request.getRequestDispatcher(&quot;success.html&quot;).forward(request, response);</code>,服务器内部访问success.html，并将其发送给浏览器。<strong>客户端只请求一次，服务器内部跳转</strong>。</li><li>客户端跳转<strong>redirect(重定向)</strong>：<code>response.sendRedirect(&quot;fail.html&quot;);</code>，发送一条消息给浏览器让其访问fail.html，浏览器访问，服务器获取fail.html发送给浏览器。<strong>客户端一共请求了两次</strong>。</li></ul></li><li><p><strong>Servlet映射器(Mapper)</strong>：每一个请求，对应的URL要交给哪一个Servlet处理，由Tomcat中的映射器Mapper类处理。</p></li><li><p><strong>request对象</strong>：封装请求消息数据</p><ul><li><p>获取参数：</p><p><code>request.getParameter()</code>：用于获取单值的参数<br><code>request.getParameterValues()</code>：用于获取具有多值的参数，比如注册时候提交的 “hobits”，可以是多选的。<br><code>request.getParameterMap()</code>：用于遍历所有的参数，并返回Map类型。</p></li><li><p>获取头信息：</p><p><code>request.getHeader()</code>：获取浏览器传递过来的头信息。<br><code>request.getHeaderNames()</code>：获取浏览器所有的头信息名称，根据头信息名称就能遍历出所有的头信息</p></li><li><p>服务端传参：<code>request.setAttribute()</code>与<code>request.getAttribute()</code></p></li><li><p>设置编码：<code>request.setCharacterEncoding(&quot;UTF-8&quot;);</code></p></li><li><p>常见方法：</p><p><code>request.getRequestURL()</code>：浏览器发出请求时的完整URL，包括协议 主机名 端口(如果有)”<br><code>request.getRequestURI()</code>：浏览器发出请求的资源名部分，去掉了协议和主机名”<br><code>request.getQueryString()</code>：请求行中的参数部分，只能显示以get方式发出的参数，post方式的看不到<br><code>request.getRemoteAddr()</code>：浏览器所处于的客户机的IP地址<br><code>request.getRemoteHost()</code>：浏览器所处于的客户机的主机名<br><code>request.getRemotePort()</code>：浏览器所处于的客户机使用的网络端口<br><code>request.getLocalAddr()</code>：服务器的IP地址<br><code>request.getLocalName()</code>：服务器的主机名<br><code>request.getMethod()</code>：得到客户机请求方式，一般是GET或者POST                 </p></li></ul></li><li><p><strong>response对象</strong>：通过response对象设置响应消息数据</p><ul><li><p>设置响应内容：<code>response.getWriter()</code>获取PrintWriter对象，使用println(),append(),write(),format()等等方法设置返回给浏览器的html内容。             </p></li><li><p>设置响应格式与编码：<code>response.setContentType(&quot;text/html;charset=utf-8&quot;)</code>或<code>response.setCharacterEncoding(&quot;UTF-8&quot;)</code></p></li></ul></li><li><p><strong>ServletContext对象</strong>：服务器启动后自动创建，在整个Web应用的动态资源（Servlet/JSP…）之间共享数据，与servlet容器通信，服务器关闭时销毁。</p><ul><li>通过request.getServletContext()或this.getServletContext()获取</li><li>获取MIME(text/html, image/jpeg…)类型数据：<code>getMimeType(String file)</code></li><li>作为域对象共享数据：<code>setAttribute() getAttribute() removeAttribute()</code>，共享所有用户请求的数据</li><li>获取文件的真实路径：<code>getRealPath(String file)</code></li></ul></li><li><p><strong>ServletContext, ServletContextListener, Filter以及自启动Servlet的执行顺序</strong>（对称）</p><ul><li>ServletContext -&gt;</li><li>ServletContextListener -&gt;</li><li>Filter -&gt;</li><li>自启动Servlet -&gt;</li><li>浏览器请求访问普通Servlet -&gt;</li><li>销毁自启动Servlet -&gt;</li><li>销毁Filter-&gt;</li><li>销毁ServletContextListener -&gt;</li><li>销毁ServletContext</li></ul></li><li><p>Listener, Filter, Servlet的实现类对象均是<strong>服务器通过反射创建</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Servlet-Server-applet&quot;&gt;&lt;a href=&quot;#Servlet-Server-applet&quot; class=&quot;headerlink&quot; title=&quot;Servlet(Server applet)&quot;&gt;&lt;/a&gt;Servlet(Server applet)
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>JSON</title>
    <link href="http://thmasterplan.cn/JavaWeb/JSON/"/>
    <id>http://thmasterplan.cn/JavaWeb/JSON/</id>
    <published>2020-04-01T08:09:57.000Z</published>
    <updated>2020-04-01T08:11:33.597Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JSON简介"><a href="#JSON简介" class="headerlink" title="JSON简介"></a>JSON简介</h3><ul><li>概念：JavaScript对象表示法(JavaScript Object Notation)。</li><li>作用：JSON是存储和交换文本信息的语法，常用于信息传输，比XML更小、更快、更易解析。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>基本语法：</p><ul><li>数据由键值对构成，值的取值类型有：<ul><li>整数或浮点数</li><li>字符串：<code>&quot;string&quot;</code></li><li>布尔值：<code>true/false</code></li><li>数组：<code>[]</code></li><li>对象：<code>{name:&quot;Tom&quot;,age:23,gender:&quot;male&quot;}</code></li><li>null</li></ul></li><li>数据由<code>,</code>分隔</li><li><code>{}</code>保存对象，同时也定义了JSON格式</li><li><code>[]</code>保存数组</li></ul></li><li><p>获取数据方式：JSON对象.键名；JSON对象[“键名”]；数组对象[索引]。</p></li></ul><h3 id="JSON在Java中的解析"><a href="#JSON在Java中的解析" class="headerlink" title="JSON在Java中的解析"></a>JSON在Java中的解析</h3><ul><li><p>Java常用的JSON解析类库：GSON, FastJson, Jackson；以Jackson为例。</p></li><li><p>Java对象转JSON</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">public class Person&#123;</span><br><span class="line">   private String name;</span><br><span class="line">   private int age;</span><br><span class="line">   private String gender;</span><br><span class="line">   //getter and setter</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class JacksonTest&#123;</span><br><span class="line">   //创建Java对象</span><br><span class="line">    Person p = new Person();</span><br><span class="line">    p.setName(&quot;Tom&quot;);</span><br><span class="line">    p.setAge(23);</span><br><span class="line">    p.setGender(&quot;男&quot;);</span><br><span class="line">   //创建Jackson对象</span><br><span class="line">   ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">   //转换方法：</span><br><span class="line">   /*</span><br><span class="line">      writeValue(args, obj):</span><br><span class="line">         args: </span><br><span class="line">            File:将obj对象转换为JSON字符串，并保存到指定文件；</span><br><span class="line">            Writer:转换，并将json数据填充到字符输出流</span><br><span class="line">            OutputStream:转换，并将json数据填充到字节输出流</span><br><span class="line">      writeValueAsString(obj):将对象转换为json字符串</span><br><span class="line">   */</span><br><span class="line">   String json = mapper.writeValueAsString(p);</span><br><span class="line">   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注解：<ul><li>@JsonIgnore：排除属性（该注解置于要忽略的属性上），指定属性不会被转换</li><li>@JsonFormat：属性值格式化（该注解置于要格式化的属性上），例<code>@JsonFormat(pattern=&quot;yyyy-MM-dd&quot;)</code></li></ul></li></ul></li><li><p>JSON转Java对象</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String json = &quot;&#123;name:\&quot;Tom\&quot;,age:23&#125;&quot;;</span><br><span class="line">ObjectMapper mapper = new ObjectMapper();</span><br><span class="line">Person p = mapper.readValue(json, Person.class);</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JSON简介&quot;&gt;&lt;a href=&quot;#JSON简介&quot; class=&quot;headerlink&quot; title=&quot;JSON简介&quot;&gt;&lt;/a&gt;JSON简介&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;概念：JavaScript对象表示法(JavaScript Object Notation)。&lt;
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>XML</title>
    <link href="http://thmasterplan.cn/JavaWeb/XML/"/>
    <id>http://thmasterplan.cn/JavaWeb/XML/</id>
    <published>2020-03-30T14:00:41.000Z</published>
    <updated>2020-03-30T14:15:08.072Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>扩展标记语言（Extensible Markup Language），标签可自定义。</p><h3 id="功能"><a href="#功能" class="headerlink" title="功能"></a>功能</h3><ul><li>用于<strong>存储</strong>与<strong>传输</strong>数据<ul><li>配置文件</li><li>在网络中传输</li></ul></li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><ul><li><p>基本语法：</p><ul><li>第一行必须定义为文档声明，例如<code>&lt;? xml version=&#39;1.0&#39; ?&gt;</code>。</li><li><p>xml文档中有且仅有一个<strong>根标签</strong></p></li><li><p>属性值必须用使用引号</p></li><li>标签必须正确关闭</li><li>标签名称严格区分大小写</li></ul></li><li><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">  &lt;?xml version=&apos;1.0&apos; ?&gt;</span><br><span class="line">  &lt;users&gt;</span><br><span class="line">      &lt;user id=&apos;1&apos;&gt;</span><br><span class="line">          &lt;name&gt;Tom&lt;/name&gt;</span><br><span class="line">          &lt;age&gt;23&lt;/age&gt;</span><br><span class="line">          &lt;br/&gt;</span><br><span class="line">      &lt;/user&gt;</span><br><span class="line">      </span><br><span class="line">      &lt;user id=&apos;2&apos;&gt;</span><br><span class="line">          &lt;name&gt;Lisa&lt;/name&gt;</span><br><span class="line">          &lt;age&gt;20&lt;/age&gt;</span><br><span class="line">      &lt;/user&gt;</span><br><span class="line">&lt;/users&gt;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>组成部分：</p><ul><li>文档声明：<code>&lt;?xml version=&#39;1.0&#39; encoding=&#39;utf-8&#39;?&gt;</code></li><li>标签：自定义标签</li><li>属性：id属性值唯一</li><li>文本</li></ul></li><li><p>XML<strong>命名空间</strong>（XML Namespaces）：提供避免元素命名冲突的方法，比如不同的两个XML被同时使用，且他们有一个相同的标签时，可通过命名空间避免冲突。</p><ul><li>XML<strong>命名空间属性</strong>被放置于<strong>元素的开始标签</strong>中，语法为<code>xmlns:namespace-prefix=&#39;namespaceURI&#39;</code></li><li>当命名空间被定义在元素的开始标签中时，所有带有相同前缀的子元素都会与同一个命名空间相关联</li></ul></li></ul><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><ul><li><p>约束：规定xml文档的书写规则。一般来说，框架提供约束，框架使用者按照约束来编写xml。</p></li><li><p>DTD：简单的约束技术，文件后缀为.dtd</p><ul><li><p><code>&lt;!ELEMENT &gt;</code>定义标签，<code>&lt;!ATTLIST &gt;</code>定义属性，<code>()</code>定义子标签</p></li><li><p>约束内容例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!ELEMENT students (student*)&gt;</span><br><span class="line">&lt;!ELEMENT student (name,age,sex)&gt;</span><br><span class="line">&lt;!ELEMENT name (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT age (#PCDATA)&gt;</span><br><span class="line">&lt;!ELEMENT sex (#PCDATA)&gt;</span><br><span class="line">&lt;!ATTLIST student number ID #REQUIRED&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入dtd文档到xml中</p><ul><li>内部dtd：将约束规则定义在xml文档中<ul><li><code>&lt;!DOCTYPE 根标签名 [约束内容] &gt;</code></li></ul></li><li>外部dtd：将约束规则定义在外部的dtd文件中<ul><li>本地：<code>&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的绝对路径&quot;&gt;</code></li><li>网络：<code>&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名&quot; &quot;URL路径&quot;&gt;</code></li></ul></li></ul></li></ul></li><li><p>Schema：复杂的约束技术，本质上就是xml，文件后缀为.xsd</p><ul><li><p>可定义xml中文本的类型，文本取值的范围，标签出现的顺序等</p></li><li><p>引入.xsd约束文件到xml</p><ul><li><p>引入无命名空间的.xsd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">      xsi:noNamespaceSchemaLocation=&quot;无命名空间XSD文件的URI&quot;&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">   1.第一步，添加xmlns:xsi属性，引入xsi命名空间</span><br><span class="line">   2.第二步，通过xsi命名空间下的属性noNamespaceSchemaLocation指定XSD文件的URI</span><br><span class="line">--&gt;</span><br><span class="line">&lt;/root&gt;</span><br></pre></td></tr></table></figure></li><li><p>引入有命名空间的.xsd</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;root xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; </span><br><span class="line">          xmlns:ns1=&quot;前缀ns1对应命名空间&quot; </span><br><span class="line">          xmlns:ns2=&quot;前缀ns2对应命名空间&quot; </span><br><span class="line">          xsi:schemaLocation=&quot;ns1前缀对应命名空间 前缀ns1对应命名空间XSD文件的URI </span><br><span class="line">                       ns2前缀对应命名空间 前缀ns2对应命名空间XSD文件的URI&quot;&gt;</span><br><span class="line">    &lt;!--</span><br><span class="line">       1.第一步，添加xmlns:xsi属性，引入xsi命名空间</span><br><span class="line">       2.第二步，添加命名空间，可添加多个，但没有前缀的命名空间最多只能有1个</span><br><span class="line">       3.第三步，通过xsi命名空间下的属性schemaLocation指定每个命名空间XSD文件的URI，命名空间和相应URI一一对应，多个命名空间用空格分隔</span><br><span class="line">    --&gt;</span><br><span class="line">    &lt;/root&gt;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;扩展标记语言（Extensible Markup Language），标签可自定义。&lt;/p&gt;
&lt;h3 id=&quot;功能&quot;&gt;&lt;a href=&quot;#功
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>动态规划入门</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E5%85%A5%E9%97%A8/</id>
    <published>2020-03-28T13:38:15.000Z</published>
    <updated>2020-03-29T02:30:37.680Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动态规划题目特点"><a href="#动态规划题目特点" class="headerlink" title="动态规划题目特点"></a>动态规划题目特点</h3><ul><li><p><strong>计数</strong></p><ul><li><p>有多少种方式走到右下角</p></li><li><p>有多少种方法选出k个数使得和为Sum</p></li><li><p>例：lintcode114</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> m: positive integer (1 &lt;= m &lt;= 100)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> n: positive integer (1 &lt;= n &lt;= 100)</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: An integer</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write your code here</span></span><br><span class="line">        <span class="keyword">int</span>[][] dp = <span class="keyword">new</span> <span class="keyword">int</span>[m][n];<span class="comment">//dp[i][j]表示机器人有多少种方式从左上角走到(i,j)</span></span><br><span class="line">        <span class="comment">//dp[i][j] = dp[i-1][j]+dp[i][j-1]</span></span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; ++i)&#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> || j == <span class="number">0</span>) dp[i][j] = <span class="number">1</span>;<span class="comment">//第0行(列)的所有格子都只有一种方式到达</span></span><br><span class="line">                <span class="keyword">else</span> dp[i][j] = dp[i-<span class="number">1</span>][j] + dp[i][j-<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>求最值</strong></p><ul><li><p>从左上角走到右下角路径的最大数字和</p></li><li><p>最长上升序列长度</p></li><li><p>例：lintcode669</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> coins: a list of integer</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> amount: a total amount of money amount</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: the fewest number of coins that you need to make up</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">coinChange</span><span class="params">(<span class="keyword">int</span>[] coins, <span class="keyword">int</span> amount)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">        <span class="keyword">int</span>[] dp = <span class="keyword">new</span> <span class="keyword">int</span>[amount+<span class="number">1</span>];<span class="comment">//记录组成从0-amount分别需要的最少的硬币数</span></span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= amount; ++i)&#123;</span><br><span class="line">            dp[i] = Integer.MAX_VALUE;<span class="comment">//表示不存在组成i所需要的最少硬币数,同时看作min变量，储存dp[i-coins[j]]+1,j=1,2...中的最小值</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; coins.length; ++j)&#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j] &lt;= i &amp;&amp; dp[i-coins[j]] != Integer.MAX_VALUE &amp;&amp; dp[i-coins[j]]+<span class="number">1</span> &lt; dp[i])&#123;</span><br><span class="line">                    dp[i] = dp[i-coins[j]] + <span class="number">1</span>;<span class="comment">//组成总数为i需要的最少的硬币数为：组成总数为i-coins[j],j=1,2...coins.length需要的最少硬币数中最小的一个,再加1</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dp[amount] == Integer.MAX_VALUE) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">return</span> dp[amount];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><p><strong>求存在性</strong></p><ul><li><p>取石子游戏，先手是否必胜</p></li><li><p>能不能选出k个数使得和为Sum</p></li><li><p>例：lintcode116</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> A: A list of integers</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>: A boolean</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="comment">//动态规划</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJump</span><span class="params">(<span class="keyword">int</span>[] A)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> len = A.length;</span><br><span class="line">        <span class="keyword">boolean</span>[] dp = <span class="keyword">new</span> <span class="keyword">boolean</span>[len];</span><br><span class="line">        </span><br><span class="line">        dp[<span class="number">0</span>] = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//思路:最后一步A[len-1]可达，当且仅当前面某个下标i可达且i+A[i]&gt;=A[len-1]；推广到对任意j = 1,2,...len-1，i &lt; j都必须满足dp[i] &amp;&amp; i + A[i] &gt;= j</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; len; ++j)&#123;</span><br><span class="line">            dp[j] = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; ++i)&#123;</span><br><span class="line">                <span class="keyword">if</span>(dp[i] &amp;&amp; i + A[i] &gt;= j)&#123;<span class="comment">//状态方程：能够到达i，并且i+A[i]&gt;=j即表示从i能到达j</span></span><br><span class="line">                     dp[j] = <span class="keyword">true</span>;</span><br><span class="line">                     <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> dp[len-<span class="number">1</span>];</span><br><span class="line">        </span><br><span class="line">    &#125; </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">     </span><br><span class="line">    <span class="comment">//贪心算法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canJumpGreedy</span><span class="params">(<span class="keyword">int</span>[] A)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//[3,2,1,0,4]</span></span><br><span class="line">        <span class="keyword">if</span>(A == <span class="keyword">null</span> || A.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> farthest = A[<span class="number">0</span>];<span class="comment">//farthest变量记录当前能够到达的最远距离</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; A.length; ++i)&#123;</span><br><span class="line">            <span class="keyword">if</span>(farthest &lt; i) <span class="keyword">return</span> <span class="keyword">false</span>;<span class="comment">//farthest比i小，表示不能到达i，return false</span></span><br><span class="line">            <span class="keyword">else</span> farthest = i + A[i] &gt; farthest ? i + A[i] : farthest;<span class="comment">//更新farthest</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="动态规划组成部分"><a href="#动态规划组成部分" class="headerlink" title="动态规划组成部分"></a>动态规划组成部分</h3><ul><li><p><strong>确定状态</strong>：创建数组，<strong>数组的每个元素代表什么</strong>？</p><ul><li><p>两个要点</p><ul><li>最后一步</li><li>子问题</li></ul></li><li><p>递归算法的问题：重复计算，效率低下</p></li></ul></li><li><p><strong>转移方程</strong>：<strong>根据子问题定义</strong>得到。将计算结果保存下来，并改变计算顺序，空间换时间</p></li><li><strong>初始条件和边界情况</strong></li><li><strong>计算顺序</strong>：利用之前的计算结果</li></ul><h3 id="常见动态规划类型"><a href="#常见动态规划类型" class="headerlink" title="常见动态规划类型"></a>常见动态规划类型</h3><ul><li>坐标型</li><li>序列型</li><li>划分型</li><li>区间型</li><li>背包型</li><li>最长序列型</li><li>博弈型</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;动态规划题目特点&quot;&gt;&lt;a href=&quot;#动态规划题目特点&quot; class=&quot;headerlink&quot; title=&quot;动态规划题目特点&quot;&gt;&lt;/a&gt;动态规划题目特点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;strong&gt;计数&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;有
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="lintcode" scheme="http://thmasterplan.cn/tags/lintcode/"/>
    
  </entry>
  
  <entry>
    <title>常量与反编译及助记符</title>
    <link href="http://thmasterplan.cn/JVM/%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6/"/>
    <id>http://thmasterplan.cn/JVM/%E5%B8%B8%E9%87%8F%E4%B8%8E%E5%8F%8D%E7%BC%96%E8%AF%91%E5%8F%8A%E5%8A%A9%E8%AE%B0%E7%AC%A6/</id>
    <published>2020-03-26T06:11:57.000Z</published>
    <updated>2020-03-26T06:13:58.910Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>JVM参数，均以<code>-XX:</code>开始，其中<code>-XX:+&lt;option&gt;</code>，表示开启option选项；<code>-XX:-&lt;option&gt;</code>，表示关闭option选项；<code>-XX:&lt;option&gt;=&lt;value&gt;</code>，表示将option选项的值设置为value。</p></li><li><p><code>-XX:+TraceClassLoading</code>，用于追踪类的加载信息并打印。</p></li><li><p><strong>常量的本质</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(MyParent2.string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent2</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String string = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyParent2 static block"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>输出为：hello world</li><li>原理：<em>常量在<strong>编译阶段</strong>会存入调用该常量所在类的<strong>常量池</strong>中</em>，本质上调用类并没有直接引用常量所在的类，因此不会触发常量所在类的初始化。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.UUID;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest3</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(MyParent3.string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent3</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> String string = UUID.randomUUID().toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyParent3 static block"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>输出为：MyParent3 static block</p><pre><code>016933b5-7da0-46b5-88fa-b662d6f01494</code></pre></li><li><p>原理：常量string在<strong>编译期未知</strong>，在<strong>运行期间才赋值</strong>，故而静态代码块会初始化。</p></li></ul></li><li><p>反编译.class文件：<code>javap -c 全类名</code></p></li><li><p>反编译代码助记符：</p><ul><li><code>getstatic</code>：获取类的静态字段</li><li><code>ldc</code>：表示将int, float或是String类型的常量值从常量池推送至栈顶</li><li><code>bipush</code>：表示将单字节（-128-127）的常量值从常量池推送至栈顶</li><li><code>sipush</code>：表示将一个短整型（-32768—32767）常量值推送至栈顶</li><li><code>iconst_1</code>：表示将int类型的1推送至栈顶（iconst_0 - iconst_5）</li><li><code>anewarray</code>：创建一个引用类型数组，并将其引用值压入栈顶</li><li><code>newarray</code>：创建一个基本类型的数组，并将其引用值压入栈顶</li></ul></li><li><p>数组创建本质：new一个数组，对于数组实例来说，其类型是由JVM在运行期间动态生成的，动态生成的类型其父类为Object。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;JVM参数，均以&lt;code&gt;-XX:&lt;/code&gt;开始，其中&lt;code&gt;-XX:+&amp;lt;option&amp;gt;&lt;/code&gt;，表示开启option选项；&lt;code&gt;-XX:-&amp;lt;option&amp;gt;&lt;/code&gt;，表示关闭option选项；&lt;code&gt;
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>贪心</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E8%B4%AA%E5%BF%83/</id>
    <published>2020-03-26T06:11:35.000Z</published>
    <updated>2020-03-26T06:13:26.316Z</updated>
    
    <content type="html"><![CDATA[<h3 id="贪心算法"><a href="#贪心算法" class="headerlink" title="贪心算法"></a>贪心算法</h3><ul><li><p>解决贪心问题的步骤：</p><ul><li>将原问题分解为子问题</li><li>找出贪心策略（寻找局部最优解）</li><li>得到每一个子问题的最优解</li><li>将所有局部最优解的集合构成称为原问题的一个解</li></ul></li><li><p>leetcode455：分发饼干</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findContentChildren</span><span class="params">(<span class="keyword">int</span>[] g, <span class="keyword">int</span>[] s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> child = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> cookie = <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(g);  <span class="comment">//先将饼干 和 孩子所需大小都进行排序</span></span><br><span class="line">        Arrays.sort(s);</span><br><span class="line">        <span class="keyword">while</span> (child &lt; g.length &amp;&amp; cookie &lt; s.length )&#123; <span class="comment">//当其中一个遍历就结束</span></span><br><span class="line">            <span class="keyword">if</span> (g[child] &lt;= s[cookie])&#123; <span class="comment">//当用当前饼干可以满足当前孩子的需求，可以满足的孩子数量+1</span></span><br><span class="line">                child++;</span><br><span class="line">            &#125;</span><br><span class="line">            cookie++; <span class="comment">// 饼干只可以用一次，因为饼干如果小的话，就是无法满足被抛弃，满足的话就是被用了</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> child; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode435：无重叠区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//思路：按区间开始处升序排序后，尽量保留结尾小的</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">eraseOverlapIntervals</span><span class="params">(<span class="keyword">int</span>[][] intervals)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (intervals.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        Arrays.sort(intervals, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] - o2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//按照区间开始升序排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, count = <span class="number">0</span>;<span class="comment">//变量prev保存遍历时的前一个区间</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; intervals.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (intervals[prev][<span class="number">1</span>] &gt; intervals[i][<span class="number">0</span>]) &#123;<span class="comment">//前一个区间的结尾&gt;后一个区间的开始，表明有重叠</span></span><br><span class="line">                <span class="keyword">if</span> (intervals[prev][<span class="number">1</span>] &gt; intervals[i][<span class="number">1</span>]) prev = i;<span class="comment">//前一个区间的结尾&gt;后一个区间的结尾，表明前一个区间覆盖后一个区间，删除结尾大的区间</span></span><br><span class="line">                </span><br><span class="line">                count++;</span><br><span class="line">            &#125; <span class="keyword">else</span> prev = i;<span class="comment">//无重叠</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode452：用最少数量的箭引爆气球</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似于435，删除k个区间后便无重叠区间，则该题答案为n-k，n为总区间个数</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMinArrowShots</span><span class="params">(<span class="keyword">int</span>[][] points)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(points.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        Arrays.sort(points, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] point1, <span class="keyword">int</span>[] point2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> point1[<span class="number">0</span>] - point2[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);<span class="comment">//升序排序</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> prev = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; points.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(points[prev][<span class="number">1</span>] &gt;= points[i][<span class="number">0</span>] )&#123;</span><br><span class="line">                <span class="keyword">if</span>(points[prev][<span class="number">1</span>] &gt; points[i][<span class="number">1</span>]) prev = i;</span><br><span class="line">                count++;</span><br><span class="line">            &#125;<span class="keyword">else</span> prev = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> points.length - count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode406：根据身高重建队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将最高的人按照 k 值升序排序，然后将它们放置到输出队列中与 k 值相等的索引位置上。</span></span><br><span class="line"><span class="comment">//按降序取下一个高度，同样按 k 值对该身高的人升序排序，然后逐个插入到输出队列中与 k 值相等的索引位置上。</span></span><br><span class="line"><span class="comment">//直到完成为止。</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.排序：按高度降序排列；在同一高度的人中，按 k 值的升序排列。</span></span><br><span class="line">    <span class="comment">//2.逐个地把它们放在输出队列中，索引等于它们的 k 值。</span></span><br><span class="line">    <span class="comment">//3.返回输出队列</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[][] reconstructQueue(<span class="keyword">int</span>[][] people) &#123;</span><br><span class="line">        Arrays.sort(people, <span class="keyword">new</span> Comparator&lt;<span class="keyword">int</span>[]&gt;()&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compare</span><span class="params">(<span class="keyword">int</span>[] o1, <span class="keyword">int</span>[] o2)</span></span>&#123;</span><br><span class="line">                <span class="keyword">return</span> o1[<span class="number">0</span>] == o2[<span class="number">0</span>] ? o1[<span class="number">1</span>] - o2[<span class="number">1</span>]: o2[<span class="number">0</span>] - o1[<span class="number">0</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        List&lt;<span class="keyword">int</span>[]&gt; list = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>[] p : people)&#123;</span><br><span class="line">            list.add(p[<span class="number">1</span>],p);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> list.toArray(<span class="keyword">new</span> <span class="keyword">int</span>[people.length][<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode121：买卖股票的最佳时机</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span> prices[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>, min = prices[<span class="number">0</span>];<span class="comment">//min记录前面的最小价格</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> profit = prices[i] - min;<span class="comment">//利润等于当前价格减去最小价格</span></span><br><span class="line">            result = result &gt; profit ? result : profit;<span class="comment">//更新最大利润</span></span><br><span class="line">            min = prices[i] &gt; min ? min : prices[i];<span class="comment">//每一天更新最小价格</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode122：买卖股票的最佳时机2</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.length == <span class="number">0</span> || prices.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>, buy = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; prices.length; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; prices[i-<span class="number">1</span>]) buy = prices[i];<span class="comment">//股票降了，抄底买入</span></span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                result += prices[i] - buy;<span class="comment">//股票涨的阶段，卖掉前一天的股票</span></span><br><span class="line">                buy = prices[i];<span class="comment">//买入当天的股票，利润最大化</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode605：种花问题</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">canPlaceFlowers</span><span class="params">(<span class="keyword">int</span>[] flowerbed, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; flowerbed.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (flowerbed[i] == <span class="number">0</span> &amp;&amp; (i == <span class="number">0</span> || flowerbed[i - <span class="number">1</span>] == <span class="number">0</span>) &amp;&amp; (i == flowerbed.length - <span class="number">1</span> || flowerbed[i + <span class="number">1</span>] == <span class="number">0</span>)) &#123;<span class="comment">//数组元素为0，并且其左右两边均为0，或者该数组下标位于首（尾）</span></span><br><span class="line">                flowerbed[i++] = <span class="number">1</span>;</span><br><span class="line">                n--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode392：判断子序列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubsequence</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sLen = s.length();</span><br><span class="line">        <span class="keyword">if</span>(sLen == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; t.length(); i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; sLen &amp;&amp; t.charAt(i) == s.charAt(j)) j++;</span><br><span class="line">            <span class="keyword">if</span>(j == sLen) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode53：最大子数组和</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxSubArray</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> currMaxSum = nums[<span class="number">0</span>], maxSum = nums[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; ++i) &#123;</span><br><span class="line">      currMaxSum = Math.max(nums[i], currMaxSum + nums[i]);<span class="comment">//计算以当前元素nums[i]为终点的所有的子数组的最大和</span></span><br><span class="line">      maxSum = Math.max(maxSum, currMaxSum);<span class="comment">//maxSum是所有currMaxSum中的最大值</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxSum;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>leetcode763：划分字母区间</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;Integer&gt; <span class="title">partitionLabels</span><span class="params">(String S)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>[] last = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];<span class="comment">//定义一个大小为26的数组，用于存储每个字母最后一次出现的下标</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)&#123;</span><br><span class="line">            last[S.charAt(i) - <span class="string">'a'</span>] = i;<span class="comment">//遍历字符串，更新每个字符的下标</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>;</span><br><span class="line">        List&lt;Integer&gt; res = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; S.length(); ++i)&#123;</span><br><span class="line">            end = Math.max(end, last[S.charAt(i) - <span class="string">'a'</span>]);<span class="comment">//遍历字符串时扩展区间末端end</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(i == end)&#123;<span class="comment">//当前下标等于区间末端end时，为一次划分，更新start=end+1</span></span><br><span class="line">                res.add(end-start+<span class="number">1</span>);</span><br><span class="line">                start = end+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;贪心算法&quot;&gt;&lt;a href=&quot;#贪心算法&quot; class=&quot;headerlink&quot; title=&quot;贪心算法&quot;&gt;&lt;/a&gt;贪心算法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;解决贪心问题的步骤：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将原问题分解为子问题&lt;/li&gt;
&lt;li&gt;找出贪心策略（寻找
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://thmasterplan.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>注解</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E6%B3%A8%E8%A7%A3/</id>
    <published>2020-03-25T09:58:33.000Z</published>
    <updated>2020-04-05T14:37:47.629Z</updated>
    
    <content type="html"><![CDATA[<h3 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h3><ul><li><p>注解（Annotation），也叫元数据，JDK1.5后引入的特性，与类、接口、枚举在同一层次。它可以声明在包、类、字段、方法、局部变量、方法参数等的前面，用于对这些元素进行说明。</p></li><li><p>定义注解 -&gt; 使用注解 -&gt;读取注解</p></li><li><p><strong>作用分类</strong></p><ul><li><strong>编写文档</strong> ：命令行输入<code>javadoc xxx.java</code>，通过代码里标识的注解自动生成doc文档</li><li><strong>代码分析</strong>：通过代码里标识的注解对代码进行分析（使用反射机制）</li><li><strong>编译检查</strong> ：编译器对代码进行编译检查</li></ul></li><li><p><strong>JDK预定义的注解</strong></p><ul><li>@Override：检测被注解的方法是否继承自父类（接口）</li><li>@Deprecated：被注解的内容已过时，不建议使用</li><li>@SuppressWarnings：压制警告，一般传递参数all</li></ul></li><li><p><strong>自定义注解</strong></p><ul><li><p>注解通过<code>@interface</code>定义，例如<code>public @interface MyAnnotation{}</code></p></li><li><p><strong>本质是接口</strong>：<code>public interface MyAnnotation extends java.lang.annotation.Annotation{}</code></p></li><li><p>注解的属性：接口中的抽象方法</p><ul><li><p>属性的返回值类型</p><ul><li>基本数据类型</li><li>String</li><li>枚举</li><li>注解</li><li>以上类型的数组</li></ul></li><li><p>使用注解时，需要对属性赋值，例<code>@SuppressWarning(&quot;all&quot;)</code>；亦可以在定义注解时使用default设置默认值，使用时就不用赋值；如果只有一个属性需要赋值，且属性名为value，则value可以省略可直接赋值，上述压制警告就是这种情形。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno&#123;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">a</span><span class="params">()</span> <span class="keyword">default</span> 5</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>元注解</strong>：可以注释到注解上的注解，一共有五种。</p><ul><li><p><strong>@Retention</strong>：描述注解被保留的阶段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy&#123;</span><br><span class="line">    SOURCE,<span class="comment">//注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视</span></span><br><span class="line">    CLASS,<span class="comment">//注解只被保留到编译进行的时候，它并不会被加载到 JVM 中</span></span><br><span class="line">    RUNTIME<span class="comment">//注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，所以在程序运行时才能获取到它们（常用）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnno&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>@Documented：描述注解是否被抽取到doc文档中</p></li><li><p><strong>@Target</strong>：当一个注解被 @Target 注解时，这个注解就被限定了运用的场景</p><ul><li>ElementType.ANNOTATION_TYPE：可以给一个<strong>注解</strong>进行注解</li><li>ElementType.CONSTRUCTOR：可以给<strong>构造方法</strong>进行注解</li><li>ElementType.FIELD：可以给<strong>成员变量</strong>进行注解</li><li>ElementType.LOCAL_VARIABLE：可以给<strong>局部变量</strong>进行注解</li><li>ElementType.METHOD：可以给<strong>方法</strong>进行注解</li><li>ElementType.PACKAGE：可以给一个<strong>包</strong>进行注解</li><li>ElementType.PARAMETER：可以给一个<strong>方法内的参数</strong>进行注解</li><li>ElementType.TYPE：可以给一个<strong>类型</strong>进行注解，<strong>比如类、接口、枚举</strong></li></ul></li><li><p>@Inherited：描述注解是否被子类继承</p></li><li><p>@Repeatable</p></li></ul></li></ul></li><li><p><strong>在程序中使用（解析）注解</strong>：获取注解中定义的属性值</p><ul><li><p>例如在反射中的自定义框架，使用注解后便不需要使用配置文件传参数，通过更改注解的属性值即可实现创建不同的对象、使用对象的方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 描述需要执行的类名和方法名</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Pro &#123;</span><br><span class="line"><span class="function">String <span class="title">className</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">String <span class="title">methodName</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><pre><code><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> annotation;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Pro</span>(className = <span class="string">"model.Person"</span>,methodName=<span class="string">"eat"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrame2</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.获取注解对象</span></span><br><span class="line">Class&lt;MyFrame2&gt; myFrame2Class = MyFrame2<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">Pro anno = myFrame2Class.getAnnotation(Pro<span class="class">.<span class="keyword">class</span>)</span>;<span class="comment">//在内存中生成了一个该注解接口的子类的实现对象</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.调用注解对象中定义的抽象方法，获取返回值</span></span><br><span class="line">String className = anno.className();</span><br><span class="line">String methodName = anno.methodName();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.加载类进入内存</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建对象</span></span><br><span class="line"><span class="comment">//Object object = cls.newInstance();</span></span><br><span class="line">Constructor&lt;?&gt; c = cls.getConstructor();</span><br><span class="line">Object object = c.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.获取Method对象</span></span><br><span class="line">Method method = cls.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.执行方法</span></span><br><span class="line">method.invoke(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></code></pre><ul><li><p>使用注解方式创建DBUtil工具类（降低耦合度）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> anno;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.METHOD;</span><br><span class="line"><span class="keyword">import</span> <span class="keyword">static</span> java.lang.annotation.ElementType.TYPE;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Documented;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Target</span>(&#123;METHOD,TYPE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> JDBCConfig &#123;</span><br><span class="line">     <span class="function">String <span class="title">ip</span><span class="params">()</span></span>; </span><br><span class="line">     <span class="function"><span class="keyword">int</span> <span class="title">port</span><span class="params">()</span> <span class="keyword">default</span> 3306</span>; </span><br><span class="line">     <span class="function">String <span class="title">database</span><span class="params">()</span></span>; </span><br><span class="line">     <span class="function">String <span class="title">encoding</span><span class="params">()</span></span>; </span><br><span class="line">     <span class="function">String <span class="title">loginName</span><span class="params">()</span></span>; </span><br><span class="line">     <span class="function">String <span class="title">password</span><span class="params">()</span></span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> util;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> anno.JDBCConfig;</span><br><span class="line"></span><br><span class="line"><span class="meta">@JDBCConfig</span>(ip = <span class="string">"127.0.0.1"</span>, database = <span class="string">"test"</span>, encoding = <span class="string">"UTF-8"</span>, loginName = <span class="string">"root"</span>, password = <span class="string">"admin"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DBUtil</span> </span>&#123;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">&#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">e.printStackTrace();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Connection <span class="title">getConnection</span><span class="params">()</span> <span class="keyword">throws</span> SQLException, NoSuchMethodException, SecurityException </span>&#123;</span><br><span class="line">JDBCConfig config = DBUtil<span class="class">.<span class="keyword">class</span>.<span class="title">getAnnotation</span>(<span class="title">JDBCConfig</span>.<span class="title">class</span>)</span>;<span class="comment">//通过反射获取DBUtil类上的注解对象</span></span><br><span class="line"></span><br><span class="line">String ip = config.ip();</span><br><span class="line"><span class="keyword">int</span> port = config.port();</span><br><span class="line">String database = config.database();</span><br><span class="line">String encoding = config.encoding();</span><br><span class="line">String loginName = config.loginName();</span><br><span class="line">String password = config.password();</span><br><span class="line"></span><br><span class="line">String url = String.format(<span class="string">"jdbc:mysql://%s:%d/%s?characterEncoding=%s"</span>, ip, port, database, encoding);</span><br><span class="line"><span class="keyword">return</span> DriverManager.getConnection(url, loginName, password);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> NoSuchMethodException, SecurityException, SQLException </span>&#123;</span><br><span class="line">Connection c = getConnection();</span><br><span class="line">System.out.println(c);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;注解&quot;&gt;&lt;a href=&quot;#注解&quot; class=&quot;headerlink&quot; title=&quot;注解&quot;&gt;&lt;/a&gt;注解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;注解（Annotation），也叫元数据，JDK1.5后引入的特性，与类、接口、枚举在同一层次。它可以声明在包、类、字段、
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>类加载过程</title>
    <link href="http://thmasterplan.cn/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/"/>
    <id>http://thmasterplan.cn/JVM/%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/</id>
    <published>2020-03-24T09:08:23.000Z</published>
    <updated>2020-03-24T11:55:23.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载的阶段分解"><a href="#类加载的阶段分解" class="headerlink" title="类加载的阶段分解"></a>类加载的阶段分解</h3><ul><li>Java代码中，class的加载、连接与初始化都是在程序<strong>运行期间</strong>完成。.java -&gt; 编译为.class(磁盘) -&gt;ClassLoader将类加载到内存中 -&gt;连接（确定类与类之间的关系）-&gt;初始化。</li><li><p>如下几种情况，JVM将结束自身进程：</p><ul><li>执行了System.exit()方法</li><li>正常执行结束</li><li>异常或错误（常见）</li><li>操作系统错误导致JVM进程终止</li></ul></li></ul><h3 id="类的加载、连接与初始化过程"><a href="#类的加载、连接与初始化过程" class="headerlink" title="类的加载、连接与初始化过程"></a>类的加载、连接与初始化过程</h3><ul><li><p>ClassLoader将类从磁盘加载到内存中的三个阶段：</p></li><li><p>加载：查找并加载类的二进制数据。</p><ul><li>连接：<ul><li>验证：确保被加载类的正确性。</li><li>准备：为类的<strong>静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong>（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型默认为null）。</li><li>解析：把类中的<strong>符号引用</strong>（涉及字符串，用文本形式表示引用关系，JVM间接使用）转换为<strong>直接引用</strong>（JVM能直接找到对象的内存位置）。(<a href="https://www.zhihu.com/question/30300585" target="_blank" rel="noopener">https://www.zhihu.com/question/30300585</a>)</li></ul></li></ul></li><li><p>初始化：<strong>为类的静态变量赋予正确的初始值</strong>（此时才赋予程序员设定的值），执行静态代码块。</p></li><li><p>类的加载：</p><ul><li>概念：将类的.class文件中的二进制数据读入内存，将其放在运行时数据区的<strong>方法区</strong>中，然后在内存中创建一个java.lang.Class对象用于封装类在方法区内的数据结构。</li><li>加载方式：<ul><li>本地加载</li><li>网络下载.class文件</li><li>从zip, jar等归档文件中加载</li><li>从专有数据库中提取.class文件</li><li><strong>将.java动态编译为.class文件</strong>（动态代理；JSP-&gt;Servlet类）</li></ul></li></ul></li><li><p>Java程序对类的使用方式可分为两种：主动使用与被动使用，每个类或接口只有被Java程序“<strong>首次主动使用</strong>”时才<strong>初始化</strong>。</p><ul><li><p>主动使用：</p><ul><li>new一个对象</li><li>访问某个类或接口的静态变量，或对其赋值，或调用类的静态方法</li><li>反射，获取类的Class对象</li><li>初始化某类的子类（对父类的主动使用）</li><li>启动类（带main方法的类）</li><li>JDK1.7开始提供的动态语言支持 *</li></ul></li><li><p>被动使用：除上述情况以外，其他使用Java类的方式都不会导致类的初始化。</p></li></ul></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> classloader;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTest1</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">System.out.println(MyChild1.string);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyParent1</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String string = <span class="string">"hello world"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyParent1 static block"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyChild1</span> <span class="keyword">extends</span> <span class="title">MyParent1</span></span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line">System.out.println(<span class="string">"MyChild1 static block"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>​          控制台输出为：<br>​          MyParent1 static block<br>​          hello world</p><p>​          原因：并没有主动使用Mychild1类，也就没有初始化Mychild1类</p><ul><li><pre><code class="lang-java">package classloader;public class MyTest1 {    public static void main(String[] args) {        System.out.println(MyChild1.string2);    }}class MyParent1{    public static String string = &quot;hello world&quot;;    static{        System.out.println(&quot;MyParent1 static block&quot;);    }}class MyChild1 extends MyParent1{    public static String string2 = &quot;welcome&quot;;    static{        System.out.println(&quot;MyChild1 static block&quot;);    }}</code></pre><p> 控制台输出为：</p><p>MyParent1 static block<br>MyChild1 static block<br>welcome</p><p>原因：因为使用了子类的变量，子类被初始化的前提是<strong>其所有的父类已被初始化</strong>。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类加载的阶段分解&quot;&gt;&lt;a href=&quot;#类加载的阶段分解&quot; class=&quot;headerlink&quot; title=&quot;类加载的阶段分解&quot;&gt;&lt;/a&gt;类加载的阶段分解&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Java代码中，class的加载、连接与初始化都是在程序&lt;strong&gt;运行期间
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>反射</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/%E5%8F%8D%E5%B0%84/</id>
    <published>2020-03-24T09:08:10.000Z</published>
    <updated>2020-04-05T14:37:30.392Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>反射：将类的各个组成部分封装为其他对象。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。</p></li><li><p>反射的好处</p><ul><li>可以在程序运行期间操作封装好的对象（Field,Constructor,Method）</li><li>解耦，提高程序的可扩展性</li></ul></li><li><p>获取Class对象</p><ul><li><p>Class对象中将类的成员变量封装到Field[]中，将类的构造方法封装到Constructor[]中，将类的方法封装到Method[]中。</p></li><li><p>三种方式</p><ul><li>Class.forName(“全类名”)：将字节码文件加载进内存，返回Class对象。此种方式<strong>多用于配置文件，将类名定义在配置文件中，通过读取文件加载类。</strong></li><li>类名.class：通过类名的class属性获取。<strong>多用于参数的传递。</strong></li><li>new 类名().getClass() ：getClass()方法在Object类中定义。<strong>通过对象获取类的字节码。</strong></li><li>注：不论使用哪种方式，同一个.class文件在一次程序运行中只会被加载一次，因此在一次运行中即使使用三种方式各获取一次，获取的都是同一个对象。</li></ul></li><li><p>获取类的Class对象是Java程序对类的主动使用，会初始化该类（静态代码块，静态变量）。</p></li><li>静态synchronized方法的同步对象是：静态同步方法所在类的Class对象。</li></ul></li><li><p>Class对象功能</p><ul><li><p>获取所有成员变量</p><ul><li>Field[] getFields() 获取public修饰的,包括所有父类的</li><li>Field getField(String name)</li><li>Field[] getDeclaredFields() 不考虑修饰符，但是不能获取父类的</li><li>Field getDeclaredFields(String name)</li></ul></li><li><p>获取所有构造方法</p><ul><li>getConstructors()</li><li>getDeclaredConstructors()</li></ul></li><li><p>获取所有成员方法</p><ul><li>getMethods()</li><li>getDeclaredMethods()</li></ul></li><li><p>获取全类名（包括包名在内）: getName()</p></li><li><p>Field对象常用方法: set(),get(),setAccessible(true)【暴力反射】</p></li><li><p>Constructor对象常用方法:newInstance(Object… initargs)</p></li><li><p>Method对象常用方法：invoke(Object obj, Object… args), getName()</p></li><li><p>测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.reflect.Field;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ReflectTest</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">Class&lt;Test&gt; testClass = Test<span class="class">.<span class="keyword">class</span></span>;<span class="comment">//获取Class对象</span></span><br><span class="line"></span><br><span class="line">Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">Field a = testClass.getDeclaredField(<span class="string">"a"</span>);<span class="comment">//获取指定变量</span></span><br><span class="line">a.set(test, <span class="number">100</span>);<span class="comment">//给指定变量设置值</span></span><br><span class="line"></span><br><span class="line">Field[] fields = testClass.getDeclaredFields();<span class="comment">//获取所有变量</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (Field field : fields) &#123;</span><br><span class="line">field.setAccessible(<span class="keyword">true</span>);<span class="comment">//暴力反射，使得可以访问private修饰的成员变量</span></span><br><span class="line">System.out.print(<span class="string">" "</span>+field.get(test));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">protected</span> <span class="keyword">int</span> b = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> c = <span class="number">7</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> d = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getD</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setD</span><span class="params">(<span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.d = d;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>控制台输出：100 6 7 8</p></li></ul></li><li><p>练习：写一个“框架”，可以创建任意类的对象，并能够执行其中任意方法</p><ul><li><p>思路：使用反射，不需要更改框架的代码，只需更改配置文件的参数，就可以体现泛用性。（平时创建不同的对象是需要不同的代码的，比如 new Person(), new Student()）</p></li><li><p>步骤：1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中</p><p>​           2.在框架程序中读取配置文件</p><p>​           3.使用反射技术来加载要创建的对象的类文件进内存</p><p>​           4.创建对象（使用newInstance()方法）</p><p>​           5.执行方法（使用invoke()方法）</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> reflect;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.InputStream;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Constructor;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.util.Properties;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyFrame</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"><span class="comment">//1.加载配置文件</span></span><br><span class="line">Properties properties = <span class="keyword">new</span> Properties();</span><br><span class="line">ClassLoader classLoader = MyFrame<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>()</span>;</span><br><span class="line">InputStream iStream = classLoader.getResourceAsStream(<span class="string">"pro.properties"</span>);</span><br><span class="line">properties.load(iStream);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.获取配置文件中定义的数据</span></span><br><span class="line">String className = properties.getProperty(<span class="string">"className"</span>);</span><br><span class="line">String methodName = properties.getProperty(<span class="string">"methodName"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.加载类进入内存</span></span><br><span class="line">Class&lt;?&gt; cls = Class.forName(className);</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.创建对象</span></span><br><span class="line"><span class="comment">//Object object = cls.newInstance();本质仍然是调用Constructor对象的newInstance()方法</span></span><br><span class="line">Constructor&lt;?&gt; c = cls.getConstructor();</span><br><span class="line">Object object = c.newInstance();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.获取Method对象</span></span><br><span class="line">Method method = cls.getMethod(methodName);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//6.执行方法</span></span><br><span class="line">method.invoke(object);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Person类</span></span><br><span class="line"><span class="keyword">package</span> model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">eat</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"eating..."</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//pro.properties配置文件内容</span></span><br><span class="line">className=model.Person</span><br><span class="line">methodName=eat</span><br></pre></td></tr></table></figure></li></ul><ul><li><a href="https://zhuanlan.zhihu.com/p/66853751" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/66853751</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;反射：将类的各个组成部分封装为其他对象。在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。&lt;/p&gt;
&lt;/li&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JDBC</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JDBC/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JDBC/</id>
    <published>2020-03-07T08:01:05.000Z</published>
    <updated>2020-04-05T14:36:58.806Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>JDBC概念：官方定义的一套操作所有关系型数据库的接口，各个数据库厂商实现这套接口，提供数据库驱动jar包。</p></li><li><p>基础</p><ul><li><p>初始化驱动类：<code>Class.forName(&quot;com.mysql.jdbc.Driver&quot;);</code></p></li><li><p>建立与数据库的连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> String ip = <span class="string">"127.0.0.1"</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> port = <span class="number">3306</span>;</span><br><span class="line"><span class="keyword">static</span> String database = <span class="string">"tmall"</span>;</span><br><span class="line"><span class="keyword">static</span> String encoding = <span class="string">"UTF-8"</span>;</span><br><span class="line"><span class="keyword">static</span> String loginName = <span class="string">"root"</span>;</span><br><span class="line"><span class="keyword">static</span> String password = <span class="string">"admin"</span>;</span><br><span class="line"><span class="comment">//mysql数据库url写法：jdbc:mysql://ip:端口号/数据库名称</span></span><br><span class="line">String url = String.format(<span class="string">"jdbc:mysql://%s:%d/%s?characterEncoding=%s"</span>, ip, port, database, encoding);</span><br><span class="line">Connection connection =  DriverManager.getConnection(url, loginName, password);</span><br></pre></td></tr></table></figure></li><li><p>创建Statement并执行sql语句：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Statement statement = connection.createStatement();</span><br><span class="line">String sql = <span class="string">"insert into tableName values(null,"</span> + <span class="string">"'test'"</span> + <span class="string">","</span> + <span class="number">20</span> + <span class="string">")"</span>;</span><br><span class="line">statement.execute(sql);</span><br></pre></td></tr></table></figure></li><li><p>使用try-with-resource自动关闭连接：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> (Connection connection =  DriverManager.getConnection(url, loginName, password);Statement statement = c.createStatement();)&#123;</span><br><span class="line">   String sql = <span class="string">"insert into tableName values(null,"</span> + <span class="string">"'test'"</span> + <span class="string">","</span> + <span class="number">20</span> + <span class="string">")"</span>;</span><br><span class="line">   statement.execute(sql);</span><br><span class="line">   &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>PreparedStatement</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String sql = <span class="string">"insert into hero values(null,?,?,?)"</span>;</span><br><span class="line"><span class="keyword">try</span> (Connection c = DriverManager.getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>,<span class="string">"root"</span>, <span class="string">"admin"</span>);</span><br><span class="line">   <span class="comment">// 根据sql语句创建PreparedStatement</span></span><br><span class="line">   PreparedStatement ps = c.prepareStatement(sql);) &#123;</span><br><span class="line">   <span class="comment">// 设置参数</span></span><br><span class="line">   ps.setString(<span class="number">1</span>, <span class="string">"提莫"</span>);</span><br><span class="line">   ps.setFloat(<span class="number">2</span>, <span class="number">313.0f</span>);</span><br><span class="line">   ps.setInt(<span class="number">3</span>, <span class="number">50</span>);</span><br><span class="line">   <span class="comment">// 执行</span></span><br><span class="line">   ps.execute();                                                    </span><br><span class="line">  &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">      e.printStackTrace();         </span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><ul><li>使用预编译statement优点：<ul><li>参数设置，可读性好，不需要进行字符串拼接</li><li>预编译机制性能比Statement好</li><li>可防止SQL注入攻击</li></ul></li></ul></li><li><p>execute/executeQuery/executeUpdate</p><ul><li><p><strong>executeQuery</strong>: 返回一个结果集，这个方法用来执行select语句.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ResultSet rs = statement.executeQuery(sql);</span><br><span class="line"><span class="keyword">while</span> (rs.next()) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="string">"id"</span>);<span class="comment">// 可以使用字段名</span></span><br><span class="line">    String name = rs.getString(<span class="number">2</span>);<span class="comment">// 也可以使用字段的顺序</span></span><br><span class="line">    <span class="keyword">float</span> hp = rs.getFloat(<span class="string">"hp"</span>);</span><br><span class="line">    <span class="keyword">int</span> damage = rs.getInt(<span class="number">4</span>);</span><br><span class="line">    System.out.printf(<span class="string">"%d\t%s\t%f\t%d%n"</span>, id, name, hp, damage);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>executeUpdate</strong>:用于执行insert，delete，update等SQL语句，executeupdate返回的值是一个整数，表示受影响的行数，对于create table等不操作行的语句，executeupdate的返回值为0。</p></li><li><p><strong>execute</strong>: 可执行任何sql语句，其返回值为布尔类型，是true时，表示执行的是查询语句，可以通过getResultSet方法获取结果；返回值为false时，执行的是更新语句或DDL语句，getUpdateCount方法获取更新的记录数量 </p></li></ul></li><li><p>获取<strong>自增长ID</strong>：在执行完插入语句后，为获取新增记录的id</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在执行完插入语句后，MySQL会为新插入的数据分配一个自增长id</span></span><br><span class="line"><span class="comment">// JDBC通过getGeneratedKeys获取该id</span></span><br><span class="line">ResultSet rs = prepareStatement.getGeneratedKeys();</span><br><span class="line"><span class="keyword">if</span> (rs.next()) &#123;</span><br><span class="line">    <span class="keyword">int</span> id = rs.getInt(<span class="number">1</span>);</span><br><span class="line">    System.out.println(id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用<strong>事务</strong>：在mysql中，只有当表的类型是innodb时才支持事务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">connection.setAutoCommit(<span class="keyword">false</span>);</span><br><span class="line"><span class="comment">//事务代码块</span></span><br><span class="line">connection.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//回滚事务:connection.rollback()</span></span><br></pre></td></tr></table></figure></li><li><p>ORM：Object Relationship Database Mapping，即对象与关系数据库的映射，对象中的各成员变量值与关系数据库里一条记录相对应。</p></li><li><p>DAO：Database Access Object，数据库访问对象，把对数据库某张表相关的操作都封装在这个类里面</p></li><li><p><strong>数据库连接池</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdbc;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"><span class="keyword">import</span> java.util.ArrayList;</span><br><span class="line"><span class="keyword">import</span> java.util.List;</span><br><span class="line"> </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionPool</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">    List&lt;Connection&gt; cs = <span class="keyword">new</span> ArrayList&lt;Connection&gt;();</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">int</span> size;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConnectionPool</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.size = size;</span><br><span class="line">        init();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">         </span><br><span class="line">        <span class="comment">//这里恰恰不能使用try-with-resource的方式，因为这些连接都需要是"活"的，不要被自动关闭了</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Class.forName(<span class="string">"com.mysql.jdbc.Driver"</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++) &#123;</span><br><span class="line">                Connection c = DriverManager</span><br><span class="line">                        .getConnection(<span class="string">"jdbc:mysql://127.0.0.1:3306/how2java?characterEncoding=UTF-8"</span>, <span class="string">"root"</span>, <span class="string">"admin"</span>);</span><br><span class="line"> </span><br><span class="line">                cs.add(c);</span><br><span class="line"> </span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (SQLException e) &#123;</span><br><span class="line">            <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> Connection <span class="title">getConnection</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (cs.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.wait();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                <span class="comment">// TODO Auto-generated catch block</span></span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        Connection c = cs.remove(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> c;</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">returnConnection</span><span class="params">(Connection c)</span> </span>&#123;</span><br><span class="line">        cs.add(c);</span><br><span class="line">        <span class="keyword">this</span>.notifyAll();</span><br><span class="line">    &#125;</span><br><span class="line"> </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;JDBC概念：官方定义的一套操作所有关系型数据库的接口，各个数据库厂商实现这套接口，提供数据库驱动jar包。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;基础&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;初始化驱动类：&lt;code&gt;Class.forName(&amp;quot;com.
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
