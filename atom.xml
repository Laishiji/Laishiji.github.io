<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2020-10-16T11:34:07.902Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CGLib动态代理</title>
    <link href="http://thmasterplan.cn/JavaWeb/CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2020-10-16T02:50:22.000Z</published>
    <updated>2020-10-16T11:34:07.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CGLib是一个强大、高性能的字节码生产类库，可以实现运行期动态扩展Java类和实现Java接口，Spring在运行期间通过 CGlib<strong>继承被代理类</strong>，重写父类的方法，实现AOP面向切面编程。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用Enhancer类的create方法得到代理对象，该方法的参数列表：</p><ul><li>Class ：被代理类的class对象</li><li>Callback：用于提供增强的代码，一般写该接口的实现类MethodInterceptor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object cgLibProxy = Enhancer.create(XXX.getClass(), <span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">    <span class="comment">//执行被代理类的任何方法都会经过该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="JDK与CGLib动态代理区别"><a href="#JDK与CGLib动态代理区别" class="headerlink" title="JDK与CGLib动态代理区别"></a>JDK与CGLib动态代理区别</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>JDK动态代理是面向接口，<strong>通过创建代理实现类实现</strong>，创建代理速度比CGLib快。</p></li><li><p><strong>CGLib动态代理是通过继承被代理类实现</strong>（如果被代理类被final关键字所修饰，那么会失败），创建代理没有JDK动态代理快，但是运行速度比JDK动态代理要快。</p></li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）</p><p>如果被代理类不是实现类，Spring会强制使用CGLib来实现动态代理。</p><h4 id="Spring中如何选择代理机制？"><a href="#Spring中如何选择代理机制？" class="headerlink" title="Spring中如何选择代理机制？"></a>Spring中如何选择代理机制？</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过配置Spring的中aop:config标签来显示的指定使用动态代理机制 proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK动态代理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;CGLib是一个强大、高性能的字节码生产类库，可以实现运行期动态扩展Java类和实现Java接口，Spring在运行期间通过 CGlib&lt;s
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>24大设计模式</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-10-13T07:23:48.000Z</published>
    <updated>2020-10-14T05:45:45.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="创建型"><a href="#创建型" class="headerlink" title="创建型"></a>创建型</h1><h2 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h2><p>*</p><h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p>*</p><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>*</p><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p>*</p><h2 id="生成器（Builder）"><a href="#生成器（Builder）" class="headerlink" title="生成器（Builder）"></a>生成器（Builder）</h2><h2 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h2><h1 id="结构型"><a href="#结构型" class="headerlink" title="结构型"></a>结构型</h1><h2 id="外观（Facade）"><a href="#外观（Facade）" class="headerlink" title="外观（Facade）"></a>外观（Facade）</h2><h2 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h2><p>*</p><h2 id="桥接（Bridge）"><a href="#桥接（Bridge）" class="headerlink" title="桥接（Bridge）"></a>桥接（Bridge）</h2><h2 id="组合（Composite）"><a href="#组合（Composite）" class="headerlink" title="组合（Composite）"></a>组合（Composite）</h2><h2 id="装饰（Decorator）"><a href="#装饰（Decorator）" class="headerlink" title="装饰（Decorator）"></a>装饰（Decorator）</h2><p>*</p><h2 id="享元（Flyweight）"><a href="#享元（Flyweight）" class="headerlink" title="享元（Flyweight）"></a>享元（Flyweight）</h2><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p>*</p><h1 id="行为型"><a href="#行为型" class="headerlink" title="行为型"></a>行为型</h1><h2 id="责任链（Chain-Of-Responsibility）"><a href="#责任链（Chain-Of-Responsibility）" class="headerlink" title="责任链（Chain Of Responsibility）"></a>责任链（Chain Of Responsibility）</h2><h2 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h2><p>*</p><h2 id="模板方法（Template-Method）"><a href="#模板方法（Template-Method）" class="headerlink" title="模板方法（Template Method）"></a>模板方法（Template Method）</h2><p>*</p><h2 id="命令（Commmand）"><a href="#命令（Commmand）" class="headerlink" title="命令（Commmand）"></a>命令（Commmand）</h2><h2 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h2><p>*</p><h2 id="访问者（Visitor）"><a href="#访问者（Visitor）" class="headerlink" title="访问者（Visitor）"></a>访问者（Visitor）</h2><h2 id="状态（State）"><a href="#状态（State）" class="headerlink" title="状态（State）"></a>状态（State）</h2><h2 id="解释器（Interpreter）"><a href="#解释器（Interpreter）" class="headerlink" title="解释器（Interpreter）"></a>解释器（Interpreter）</h2><h2 id="迭代器（Iterator）"><a href="#迭代器（Iterator）" class="headerlink" title="迭代器（Iterator）"></a>迭代器（Iterator）</h2><p>*</p><h2 id="中介（Mediator）"><a href="#中介（Mediator）" class="headerlink" title="中介（Mediator）"></a>中介（Mediator）</h2><h2 id="备忘录（Memento）"><a href="#备忘录（Memento）" class="headerlink" title="备忘录（Memento）"></a>备忘录（Memento）</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;创建型&quot;&gt;&lt;a href=&quot;#创建型&quot; class=&quot;headerlink&quot; title=&quot;创建型&quot;&gt;&lt;/a&gt;创建型&lt;/h1&gt;&lt;h2 id=&quot;单例（Singleton）&quot;&gt;&lt;a href=&quot;#单例（Singleton）&quot; class=&quot;headerlink&quot; ti
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>开发原则</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</id>
    <published>2020-10-13T07:23:38.000Z</published>
    <updated>2020-10-14T06:44:08.664Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式， 不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。</p><p>面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有 <code>迪米特法则</code>和<code>合成复用原则</code>。</p><h3 id="S：单一职责原则（Single-Responsibility-Principle）"><a href="#S：单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="S：单一职责原则（Single-Responsibility Principle）"></a>S：单一职责原则（Single-Responsibility Principle）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</strong>。</p><h4 id="原则分析"><a href="#原则分析" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>一个类(或者大到模块，小到方法)承担的职责越多，它被复用的可能性越小；如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</li><li>类的职责主要包括两个方面: 数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。</li><li>单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否合理，但是“职责”和“变化原因”都是没有具体标准的，一个类到底要负责那些职责? 这些职责怎么细化? 细化后是否都要有一个接口或类? 这些都需从实际的情况考虑。因项目而异，因环境而异。</p><p>例：SpringMVC 中Entity, DAO, Service, Controller, Util等的分离。</p><h3 id="O：开闭原则（Open-Closed-Principle）"><a href="#O：开闭原则（Open-Closed-Principle）" class="headerlink" title="O：开闭原则（Open - Closed Principle）"></a>O：开闭原则（Open - Closed Principle）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭</strong>。</p><h4 id="原则分析-1"><a href="#原则分析-1" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>当软件实体因需求要变化时, 尽量通过扩展已有软件实体，可以提供新的行为，以满足对软件的新的需求，而不是修改已有的代码，使变化中的软件有一定的适应性和灵活性 。已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性。</li><li>实现开闭原则的关键就是抽象化：<strong>在开闭原则中，不允许修改抽象类或者接口，允许扩展的是具体的实现类。</strong>抽象类和接口在开闭原则中扮演着极其重要的角色，既要预知可能变化的需求，又要预见所有可能已知的扩展，所以在这里”抽象化”是关键!</li><li>可变性的封闭原则：找到系统的可变因素，将它封装起来。 不要把可变因素放在多个类中，或者散落在程序的各个角落，应该将可变因素封装起来，并且切忌不要把所用的可变因素封装在一起，应该分块封装可变因素。</li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>设计模式中模板方法模式和观察者模式都是开闭原则的极好体现。</p><h3 id="L：里氏替换原则（Liskov-Substitution-Principle）"><a href="#L：里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="L：里氏替换原则（Liskov Substitution Principle）"></a>L：里氏替换原则（Liskov Substitution Principle）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p> <strong>所有引用父类的地方必须能透明地替换为其子类的对象</strong>。</p><h4 id="原则分析-2"><a href="#原则分析-2" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li><p>讲的是基类和子类的关系，只有这种关系存在时，里氏替换原则才存在。正方形是长方形是理解里氏替换原则的经典例子。</p></li><li><p>里氏替换原则可以<strong>通俗表述</strong>为： <strong>在软件中如果能够使用基类对象，那么一定能够使用其子类对象</strong>。把基类都替换成它的子类，程序将不会产生任何错误和异常，<strong>反之不成立</strong>，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</p></li><li><p><strong>里氏替换原则是实现开闭原则的重要方式之一【抽象类和接口（不允许修改）看作基类，实现类（允许扩展）看作子类）】，由于使用基类对象的地方都可以使用子类对象，因此<u>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</u>。</strong></p></li></ul><h3 id="I：接口隔离原则（Interface-Segregation-Principle）"><a href="#I：接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="I：接口隔离原则（Interface Segregation Principle）"></a>I：接口隔离原则（Interface Segregation Principle）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>客户端不应该依赖那些它不需要的接口。</strong></p><p>另一种定义方法：一旦一个接口太大，则需要将它分割成一些更细小的接口，使用该接口的客户端仅需知道与之相关的方法即可。 注意，在该定义中的接口指的是所定义的方法。例如调用某个类的public方法。这个方法对外就是接口。</p><h4 id="原则分析-3"><a href="#原则分析-3" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>使用多个专门的接口，而不使用单一的总接口。</li><li>使用接口隔离原则拆分接口时，首先必须满足单一职责原则，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li></ul><h3 id="D：依赖倒置原则（Dependency-Inversion-Principle）"><a href="#D：依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="D：依赖倒置原则（Dependency-Inversion Principle）"></a>D：依赖倒置原则（Dependency-Inversion Principle）</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p><strong>高层模块不应该依赖（使用）低层模块</strong>，它们都应该依赖抽象。抽象不应该依赖（使用）具体，具体应该依赖（使用）抽象。</p><h4 id="原则分析-4"><a href="#原则分析-4" class="headerlink" title="原则分析"></a>原则分析</h4><p>如果说开闭原则是面向对象设计的目标，依赖倒置原则则是手段。依赖倒置原则也是里氏替换原则的补充。</p><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>依赖倒置原则的常用实现方式之一是在代码中使用抽象类，而将具体类放在配置文件中。</p><p>例：Spring中的依赖注入。</p><h3 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle）"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle）" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle）</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><h4 id="原则分析-5"><a href="#原则分析-5" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用。</li><li>其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</li></ul><h3 id="迪米特法则（Law-of-Demeter）"><a href="#迪米特法则（Law-of-Demeter）" class="headerlink" title="迪米特法则（Law of Demeter）"></a>迪米特法则（Law of Demeter）</h3><p>系统中的类尽量不要与其他类互相作用，以减少类之间的耦合度。又叫最少知识原则(Least Knowledge Principle)。</p><p>目标：实现高内聚、低耦合。</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>设计模式Facade模式、Mediator模式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式， 不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。&lt;/p&gt;
&lt;p&gt;面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有 &lt;code&gt;迪米特法则&lt;/code&gt;和&lt;code&gt;合成复
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件开发过程模型</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-13T07:23:02.000Z</published>
    <updated>2020-10-14T05:18:35.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件开发过程模型"><a href="#软件开发过程模型" class="headerlink" title="软件开发过程模型"></a>软件开发过程模型</h2><h3 id="瀑布模型（Waterfall-Model）"><a href="#瀑布模型（Waterfall-Model）" class="headerlink" title="瀑布模型（Waterfall Model）"></a>瀑布模型（Waterfall Model）</h3><p>瀑布模型（经典生命模型）提出了软件开发的系统化的、顺序的方法。其流程从用户需求规格说明开始，通过策划、建模、构建和部署过程，最终提供一个完整的软件并提供持续的技术支持。</p><p><img src="Waterfall.png" alt=""></p><h4 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h4><ul><li>必须等前一阶段的工作完成之后，才能开始后一段的工作。</li><li>每一阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</li><li>前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能得到正确的结果。</li><li>每个阶段结束前都要对所完成的文档进行评审，以便及早发现问题，改正错误。事实上越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正错误所需付出的代价也越高。因此，及时审查，是保证软件质量，降低软件成本的重要措施。</li></ul><h4 id="模型优点"><a href="#模型优点" class="headerlink" title="模型优点"></a>模型优点</h4><ul><li>强调了开发的阶段性，各阶段具有顺序性和依赖性</li><li>强调早期调研和需求分析，推迟编码实现的观点</li><li>提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</li></ul><h4 id="模型局限"><a href="#模型局限" class="headerlink" title="模型局限"></a>模型局限</h4><ul><li>瀑布模型是一种线性模型，要求项目严格按规程推进，必须等到所有开发工作全部完成以后才能获得可以交付的软件产品。不能对软件系统进行快速创建，对于一些急于交付的软件系统的开发很不方便。</li><li>瀑布模型适合于需求明确，且无大的需求变更的软件开发（编译系统、操作系统等）。而对于分析初期需求模糊的项目，瀑布模型也并不适合。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>适用于需求确定，无大的需求变更，工作能够采用线性的方式完成的软件。</p><h3 id="演化模型（Evolutionary-Model）"><a href="#演化模型（Evolutionary-Model）" class="headerlink" title="演化模型（Evolutionary Model）"></a>演化模型（Evolutionary Model）</h3><h4 id="快速原型（Rapid-Prototype）"><a href="#快速原型（Rapid-Prototype）" class="headerlink" title="快速原型（Rapid Prototype）"></a>快速原型（Rapid Prototype）</h4><p>软件开发过程中，开发初期很难得到一个完整的、准确的需求规格说明，开发者往往对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。为了适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）开发方法。</p><h5 id="模型特点-1"><a href="#模型特点-1" class="headerlink" title="模型特点"></a>模型特点</h5><ul><li><strong>快速原型是用来获取用户需求的，或是用来试探设计是否有效的。一旦需求或设计确定下来了，原型就将被抛弃。</strong>因此，快速原型要求快速构件、容易修改，以节约原型创建的成本、加快开发速度。</li><li>快速原型是暂时适用使用的，因此并不要求完整。它往往针对某个局部问题建立专门原型，如界面原型、工作流原型等。</li><li>快速原型不能贯穿软件的整个生命周期，它需要和其他的过程模型相结合才能产生作用。例如，在瀑布模型中应用快速原型，以解决瀑布模型在需求分析时期存在的不足。</li></ul><h5 id="模型优点-1"><a href="#模型优点-1" class="headerlink" title="模型优点"></a>模型优点</h5><ul><li>能渐进地启发客户提出新的要求或任务，促使开发人员和用户达成共识。</li><li>减少了开发风险，避免了因为需求不确定而在开发过程中浪费了大量的资源。</li></ul><h5 id="模型局限-1"><a href="#模型局限-1" class="headerlink" title="模型局限"></a>模型局限</h5><ul><li>没有考虑到软件的整体和长期的可维护性。</li><li>可能由于达不到质量要求而导致产品被抛弃，从而采用新的模型重新设计。</li></ul><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><p>原型方法比较适用于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。</p><h4 id="原型进化（-Prototype-Evolution）"><a href="#原型进化（-Prototype-Evolution）" class="headerlink" title="原型进化（ Prototype Evolution）"></a>原型进化（ Prototype Evolution）</h4><p>原型进化对开发过程的考虑是，针对有待开发的软件系统，先开发一个原型系统给用户使用，然后根据用户使用情况的意见反馈，对原型系统不断修改，使它逐步接近并最终到达开发目标。<strong>跟快速原型不同的是，快速原型在完成需求定义后将被抛弃，而原型进化所要创建的原型则是一个今后将要投入应用的系统</strong>，只是所创建的原型系统在功能、性能等方面还有许多不 足，还没有达到最终开发目标，需要不断改进。 原型进化的工作流程如图 2-3 所示。</p><p><img src="PrototypeEvolution.png" alt=""></p><p>从图中可以看到，它具有以下两个特点：</p><ul><li>原型进化模型将软件的需求细部定义、产品开发和有效性验证放在同一个工作进程中交替或并行运作。因此，在获得了软件需求框架以后，例如软件的基本功能被确定以后，就可以直接进入到对软件的开发中。</li><li>原型进化模型是通过不断发布新的软件版本而使软件逐步完善的，因此，这种开发模式特别<strong>适合于那些用户急需的软件产品开发</strong>。它能够快速地向用户交付可以投入实际运行的软件成果，并能够很好地适应软件用户对需求规格的变更。 原型进化模型能够适应软件需求的中途变更，但在应用的时候，以下问题需要得到足够的重视：<ol><li>原型进化模型虽说使开发进程加快了，但不能像瀑布模型那样提供明确的里程碑管理，随着开发过程中版本的快速更新，项目管理、软件配置管理会变得复杂起来，管理者难以把握开发进度。因此，<strong>对于大型软件项目，原型进化模型缺乏有效的管理规程</strong>。</li><li><strong>开发过程中软件版本的快速变更，还可能损伤软件的内部结构，使其缺乏整体性和稳定性</strong>。另外，用于反映软件版本变更的文档也有可能跟不上软件的变更速度。这些问题必将影响到今后软件的维护。</li></ol></li></ul><h3 id="增量模型（Incremental-Model）"><a href="#增量模型（Incremental-Model）" class="headerlink" title="增量模型（Incremental Model）"></a>增量模型（Incremental Model）</h3><p>增量模型融合了瀑布模型的基本成分和原型进化模型的迭代特征，它对软件过程的考虑是：在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际开发中，则<strong>将软件系统按功能分解为许多增减构件，并以构件为单位逐个地创建与交付</strong>，直到全部增量构件创建完成，并都被集成到系统之中交付用户使用。</p><p><img src="Incremental.jpg" alt=""></p><p><img src="Incremental.png" alt=""></p><h4 id="模型特点-2"><a href="#模型特点-2" class="headerlink" title="模型特点"></a>模型特点</h4><ul><li>当使用增量模型时，第一个增量往往是核心的产品。</li><li>客户对每个增量的使用和评估都作为下一个增量发布的新特性和功能。</li><li>该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。</li></ul><h4 id="模型优点-2"><a href="#模型优点-2" class="headerlink" title="模型优点"></a>模型优点</h4><ul><li>第一个可交付版本所需要的成本和时间很少。</li><li>开发由增量表示的小系统所承担的风险不大。</li><li>由于很快发布了第一个版本，因此可以减少用户需求的变更。</li><li>运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。</li></ul><h4 id="模型局限-2"><a href="#模型局限-2" class="headerlink" title="模型局限"></a>模型局限</h4><ul><li>管理发生的成本、进度和配置的复杂性可能会超出组织的能力。</li><li>如果没有对用户的变更要求进行规划，那么产生的出事增量可能会造成后来增量的不稳定。</li><li>如果需求不想早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。</li></ul><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>项目在既定的商业要求期限之前不可能找到足够的开发人员的情况。</p><h3 id="螺旋模型（Spiral-Model）"><a href="#螺旋模型（Spiral-Model）" class="headerlink" title="螺旋模型（Spiral Model）"></a>螺旋模型（Spiral Model）</h3><p>对于复杂的大型软件，开发一个原型往往达不到要求。<strong>螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析</strong>，弥补了这两种模型的不足。</p><p><img src="Spiral.png" alt=""></p><p>螺旋线中的每个回路都被分成为四个步骤：</p><ol><li>制定计划：确定软件的目标，选定实施方案，明确项目开发的限制条件；</li><li>风险评估：分析所选的方案，识别风险，消除风险；</li><li>实施工程：实施软件开发，验证阶段性产品；</li><li>用户评估：评价开发工作，提出修正建议，建立下一个周期的开发计划。</li></ol><h4 id="模型特点-3"><a href="#模型特点-3" class="headerlink" title="模型特点"></a>模型特点</h4><ul><li>与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便。</li><li>使用螺旋模型进行软件开发，需要开发人员具有相当丰富的风险评估经验和专门知识。</li></ul><h4 id="模型优点-3"><a href="#模型优点-3" class="headerlink" title="模型优点"></a>模型优点</h4><ul><li>关注软件的重用。</li><li>关注早期错误的消除。</li><li>将质量目标放在首位。</li><li>将开发阶段与维护阶段结合在一起。</li></ul><h4 id="模型局限-3"><a href="#模型局限-3" class="headerlink" title="模型局限"></a>模型局限</h4><ul><li>开发人员需要有较强的风险评估的经验。</li><li>契约开发通常需要事先指定过程模型和发布产品。</li></ul><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型适合用于庞大、复杂并且具有高风险的系统。</p><h3 id="喷泉模型（Water-Fountain-Model）"><a href="#喷泉模型（Water-Fountain-Model）" class="headerlink" title="喷泉模型（Water Fountain Model）"></a>喷泉模型（Water Fountain Model）</h3><p>喷泉模型是专门<strong>针对面向对象软件开发方法而提出</strong>的。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性。</p><p>无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限，由于对象概念的引入，表达分析、设计、实现等活动只用对象类和关系，从而可以较为容易地实现活动的迭代和无间隙，使其开发自然地包括复用。</p><p>在面向对象方法中，对象既是对现实问题中实体的抽象，也是构造软件系统的基本元素。 因此，建立对象模型在面向对象方法中，既可以用于分析，也可以用于设计，而且分析阶段所获得的对象框架模型可以无缝过渡到设计阶段，以作为软件实现的依据。</p><p><img src="WaterFountain.jpg" alt=""></p><p>开发步骤：</p><ol><li>第一阶段软件开发的目标可以是软件的基本功能；</li><li>第二阶段可以是在第一阶段建立的软件 的基础上，对软件进行进一步的完善，并实现软件的主要功能；</li><li>第三阶段则是在第二阶段的基 础上，对软件进行更加完整的开发，并以实现软件全部功能作为创建目标。 应该说，喷泉模型能够较有效地平衡软件系统的近期需求与远期规划，因此能够较好地满足用户在软件应用上的发展需要。</li></ol><h4 id="模型优点-4"><a href="#模型优点-4" class="headerlink" title="模型优点"></a>模型优点</h4><p>喷泉模型不像瀑布模型那样，需要分析活动结束后才开始设计活动，设计活动结束后才开始编码活动。该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。其优点是可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。</p><h4 id="模型局限-4"><a href="#模型局限-4" class="headerlink" title="模型局限"></a>模型局限</h4><p>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，因此不利于项目的管理。此外这种模型要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。 </p><h3 id="基于构件的开发模型（Component-based-Development-Model）"><a href="#基于构件的开发模型（Component-based-Development-Model）" class="headerlink" title="基于构件的开发模型（Component-based Development Model）"></a>基于构件的开发模型（Component-based Development Model）</h3><p>基于构件的开发方法是指利用预先包装的构件来构造应用系统。构件可以是组织内部开发的构件，也可以是商品化成品构件。基于构件的开发模型具有许多螺旋模型的特点，它本质上是演化模型，需要以迭代方式构件软件。其不同之处在于，基于构件的开发模型<strong>采用预先打包的软件构件开发应用</strong>。</p><h2 id="具体开发流程参考"><a href="#具体开发流程参考" class="headerlink" title="具体开发流程参考"></a>具体开发流程参考</h2><p>类似于螺旋模型，结合了瀑布模型和演化模型。</p><p><img src="dev_workflow.png" alt=""></p><p>本文参考：</p><ol><li><a href="https://www.cnblogs.com/jojop/p/11801241.html" target="_blank" rel="noopener">https://www.cnblogs.com/jojop/p/11801241.html</a></li><li><a href="https://www.cnblogs.com/youcong/p/9498489.html" target="_blank" rel="noopener">https://www.cnblogs.com/youcong/p/9498489.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件开发过程模型&quot;&gt;&lt;a href=&quot;#软件开发过程模型&quot; class=&quot;headerlink&quot; title=&quot;软件开发过程模型&quot;&gt;&lt;/a&gt;软件开发过程模型&lt;/h2&gt;&lt;h3 id=&quot;瀑布模型（Waterfall-Model）&quot;&gt;&lt;a href=&quot;#瀑布模型（Wat
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>阿里Java开发规范</title>
    <link href="http://thmasterplan.cn/Others/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/"/>
    <id>http://thmasterplan.cn/Others/%E9%98%BF%E9%87%8CJava%E5%BC%80%E5%8F%91%E8%A7%84%E8%8C%83/</id>
    <published>2020-10-02T08:42:19.000Z</published>
    <updated>2020-10-13T07:22:16.195Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://github.com/mysterin/alibaba-java-specification" target="_blank" rel="noopener">https://github.com/mysterin/alibaba-java-specification</a></p><h1 id="阿里巴巴-Java-开发手册-v1-2-0"><a href="#阿里巴巴-Java-开发手册-v1-2-0" class="headerlink" title="阿里巴巴 Java 开发手册 v1.2.0"></a>阿里巴巴 Java 开发手册 v1.2.0</h1><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《阿里巴巴 Java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、MySQL 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。  </p><p>本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血<br>液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代<br>软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规<br>矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实<br>际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对<br>软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度<br>个性化，以一种普遍认可的统一方式一起做事，提升协作效率。  </p><p>《阿里巴巴 Java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- MarkdownTOC --><ul><li><a href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83">编程规范</a><ul><li><a href="#%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC">命名风格</a></li><li><a href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89">常量定义</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">代码格式</a></li><li><a href="#oop-%E8%A7%84%E7%BA%A6">OOP 规约</a></li><li><a href="#%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86">集合处理</a></li><li><a href="#%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86">并发处理</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">控制语句</a></li><li><a href="#%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6">注释规约</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul></li><li><a href="#%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97">异常日志</a><ul><li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li><li><a href="#%E6%97%A5%E5%BF%97%E8%A7%84%E7%BA%A6">日志规约</a></li></ul></li><li><a href="#mysql-%E6%95%B0%E6%8D%AE%E5%BA%93">MYSQL 数据库</a><ul><li><a href="#%E5%BB%BA%E8%A1%A8%E8%A7%84%E7%BA%A6">建表规约</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E8%A7%84%E7%BA%A6">索引规约</a></li><li><a href="#sql-%E8%AF%AD%E5%8F%A5">SQL 语句</a></li><li><a href="#orm-%E6%98%A0%E5%B0%84">ORM 映射</a></li></ul></li><li><a href="#%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84">工程结构</a><ul><li><a href="#%E5%BA%94%E7%94%A8%E5%88%86%E5%B1%82">应用分层</a></li><li><a href="#%E4%BA%8C%E6%96%B9%E5%BA%93%E4%BE%9D%E8%B5%96">二方库依赖</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></li></ul></li><li><a href="#%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6">安全规约</a></li><li><a href="#%E9%99%84-1%EF%BC%9A%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2">附 1：版本历史</a></li><li><a href="#%E9%99%84-2%EF%BC%9A%E6%9C%AC%E6%89%8B%E5%86%8C%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D">附 2：本手册专有名词</a></li></ul><!-- /MarkdownTOC --><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><ol><li><p>【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br><strong>反例：</strong> <code>_name / __name / $Object / name_ / name$ / Object$</code></p></li><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。<br><strong>正例：</strong> <code>alibaba / taobao / youku / hangzhou</code> 等国际通用的名称，可视同英文。<br><strong>反例：</strong> <code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p></li><li><p>【强制】类名使用 <code>UpperCamelCase</code> 风格，必须遵从驼峰形式，但以下情形例外：<code>DO / BO / DTO / VO / AO</code><br><strong>正例：</strong> <code>MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</code><br><strong>反例：</strong> <code>macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</code></p></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用 <code>lowerCamelCase</code> 风格，必须遵从驼峰形式。<br><strong>正例：</strong> <code>localValue / getHttpMessage() / inputUserId</code></p></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br><strong>正例：</strong> <code>MAX_STOCK_COUNT</code><br><strong>反例：</strong> <code>MAX_COUNT</code></p></li><li><p>【强制】抽象类命名使用 <code>Abstract</code> 或 <code>Base</code> 开头；异常类命名使用 <code>Exception</code> 结尾；测试类命名以它要测试的类的名称开始，以 <code>Test</code> 结尾。</p></li><li><p>【强制】中括号是数组类型的一部分，数组定义如下：<code>String[] args</code>。<br><strong>反例：</strong> 使用 <code>String args[]</code> 的方式来定义。</p></li><li><p>【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。<br><strong>反例：</strong> 定义为基本数据类型 <code>Boolean isDeleted</code>；的属性，它的方法也是 <code>isDeleted()</code>，RPC 框架在反向解析的时候，“以为”对应的属性名称是 <code>deleted</code>，导致属性获取不到，进而抛出异常。</p></li><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br><strong>正例：</strong> 应用工具类包名为 <code>com.alibaba.open.util</code>、类名为 <code>MessageUtils</code>（此规则参考 spring 的框架结构）</p></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。<br><strong>反例：</strong> <code>AbstractClass</code> “缩写”命名成 <code>AbsClass</code>；<code>condition</code> “缩写”命名成 <code>condi</code>，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。<br><strong>说明：</strong> 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br><strong>正例：</strong>  </p><pre><code>public class OrderFactory;public class LoginProxy;public class ResourceObserver;</code></pre></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（<code>public</code> 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。<br><strong>正例：</strong> 接口方法签名：<code>void f();</code>  </p><pre><code>    接口基础常量表示：`String COMPANY = &quot;alibaba&quot;;`  </code></pre><p><strong>反例：</strong> 接口方法定义：<code>public abstract void f();</code><br><strong>说明：</strong> JDK8 中接口允许有默认实现，那么这个 <code>default</code> 方法，是对所有实现类都有价值的默认实现。</p></li><li><p>接口和实现类的命名有两套规则：<br>1） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。  </p><pre><code>**正例：** `CacheServiceImpl` 实现 `CacheService` 接口。  </code></pre><p>2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。  </p><pre><code>**正例：** `AbstractTranslator` 实现 `Translatable`。</code></pre></li><li><p>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br><strong>说明：</strong> 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br><strong>正例：</strong> 枚举名字：<code>DealStatusEnum</code>，成员名称：<code>SUCCESS / UNKOWN_REASON</code>。</p></li><li><p>【参考】各层命名规约：  </p><ol><li><code>Service/DAO</code> 层方法命名规约<br>1） 获取单个对象的方法用 <code>get</code> 做前缀。<br>2） 获取多个对象的方法用 <code>list</code> 做前缀。<br>3） 获取统计值的方法用 <code>count</code> 做前缀。<br>4） 插入的方法用 <code>save</code>（推荐）或 <code>insert</code> 做前缀。<br>5） 删除的方法用 <code>remove</code>（推荐）或 <code>delete</code> 做前缀。<br>6） 修改的方法用 <code>update</code> 做前缀。  </li><li>领域模型命名规约<br>1） 数据对象：<code>xxxDO</code>，<code>xxx</code> 即为数据表名。<br>2） 数据传输对象：<code>xxxDTO</code>，<code>xxx</code> 为业务领域相关的名称。<br>3） 展示对象：<code>xxxVO</code>，<code>xxx</code> 一般为网页名称。<br>4） <code>POJO</code> 是 <code>DO/DTO/BO/VO</code> 的统称，禁止命名成 <code>xxxPOJO</code>。</li></ol></li></ol><h4 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h4><ol><li><p>【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。<br><strong>反例：</strong> </p><pre><code>String key = &quot;Id#taobao_&quot; + tradeId;  cache.put(key, value);</code></pre></li><li><p>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。<br>说明：<code>Long a = 2l;</code> 写的是数字的 21，还是 Long 型的 2?</p></li><li><p>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。<br><strong>说明：</strong> 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p></li><li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>1） 跨应用共享常量：放置在二方库中，通常是 <code>client.jar</code> 中的 <code>constant</code> 目录下。<br>2） 应用内共享常量：放置在一方库的 <code>modules</code> 中的 <code>constant</code> 目录下。  </p><pre><code>**反例：** 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：      类 A 中：public static final String YES = &quot;yes&quot;;      类 B 中：public static final String YES = &quot;y&quot;;      A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。  </code></pre><p>3） 子工程内部共享常量：即在当前子工程的 <code>constant</code> 目录下。<br>4） 包内共享常量：即在当前包下单独的 <code>constant</code> 目录下。<br>5） 类内共享常量：直接在类内部 <code>private static final</code> 定义。  </p></li><li><p>【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。<br><strong>正例：</strong> <code>public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);}</code></p></li></ol><h4 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h4><ol><li><p>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：<br>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。  </p></li><li><p>【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见<br>第 5 条下方正例提示。<br> <strong>反例：</strong> <code>if (空格 a == b 空格)</code></p></li><li><p>【强制】<code>if/for/while/switch/do</code> 等保留字与括号之间都必须加空格。</p></li><li><p>【强制】任何二目、三目运算符的左右两边都需要加一个空格。<br><strong>说明：</strong> 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p></li><li><p>【强制】缩进采用 4 个空格，禁止使用 tab 字符。<br><strong>说明：</strong> 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 <code>Use tab character</code>；而在 eclipse 中，必须勾选 <code>insert spaces for tabs</code>。<br><strong>正例：</strong> （涉及 1-5 点）  </p><pre><code> public static void main(String[] args) {     // 缩进 4 个空格     String say = &quot;hello&quot;;     // 运算符的左右必须有一个空格     int flag = 0;     // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格     if (flag == 0) {         System.out.println(say);     }     // 左大括号前加空格且不换行；左大括号后换行     if (flag == 1) {         System.out.println(&quot;world&quot;);     // 右大括号前换行，右大括号后有 else，不用换行     } else {         System.out.println(&quot;ok&quot;);     // 在右大括号后直接结束，则必须换行     } } </code></pre></li><li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2） 运算符与下文一起换行。<br>3） 方法调用的点符号与下文一起换行。<br>4） 在多个参数超长，在逗号后换行。<br>5） 在括号前不要换行，见反例。<br> <strong>正例：</strong> </p><pre><code> StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;);</code></pre><p> <strong>反例：</strong> </p><pre><code> StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append (&quot;huang&quot;); //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); </code></pre></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。<br><strong>正例：</strong> 下例中实参的”a”,后边必须要有一个空格。<code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p></li><li><p>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。<br><strong>正例：</strong> </p><pre><code>int a = 3;long b = 4L;float c = 5F;StringBuffer sb = new StringBuffer();</code></pre><p><strong>说明：</strong> 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。</p></li><li><p>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。<br><strong>说明：</strong> 没有必要插入多个空行进行隔开。</p></li></ol><h4 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h4><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p></li><li><p>【强制】所有的覆写方法，必须加@Override 注解。<br><strong>说明：</strong> <code>getObject()</code> 与 <code>get0bject()</code> 的问题。一个是字母的 O，一个是数字的 0，加 <code>@Override</code>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 <code>Object</code>。<br><strong>说明：</strong> 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br><strong>正例：</strong> <code>public User getUsers(String type, Integer... ids) {...}</code></p></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 <code>@Deprecated</code> 注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>【强制】不能使用过时的类或方法。<br><strong>说明：</strong> <code>java.net.URLDecoder</code> 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时，应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></li></ol><ol><li>【强制】<code>Object</code> 的 <code>equals</code> 方法容易抛空指针异常，应使用常量或确定有值的对象来调用<br><code>equals</code>。<br><strong>正例：</strong> <code>&quot;test&quot;.equals(object);</code><br><strong>反例：</strong> <code>object.equals(&quot;test&quot;);</code><br><strong>说明：</strong> 推荐使用 <code>java.util.Objects#equals</code> （JDK7 引入的工具类）</li></ol><ol><li><p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。<br>说明：对于 <code>Integer var = ?</code> 在-128 至 127 范围内的赋值，<code>Integer</code> 对象是在<br><code>IntegerCache.cache</code> 产生，会复用已有对象，这个区间内的 <code>Integer</code> 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 <code>equals</code> 方法进行判断。</p></li><li><p>关于基本数据类型与包装数据类型的使用标准如下：<br>1） 【强制】所有的 <code>POJO</code> 类属性必须使用包装数据类型。<br>2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。<br>3） 【推荐】所有的局部变量使用基本数据类型。<br><strong>说明：</strong> <code>POJO</code> 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何<br>NPE 问题，或者入库检查，都由使用者来保证。<br><strong>正例：</strong> 数据库的查询结果可能是 <code>null</code>，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br><strong>反例：</strong> 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 <code>null</code> 值，能够表示额外的信息，如：远程调用失败，异常退出。</p></li><li><p>【强制】定义 <code>DO/DTO/VO</code> 等 <code>POJO</code> 类时，不要设定任何属性默认值。<br><strong>反例：</strong> <code>POJO</code> 类的 <code>gmtCreate</code> 默认值为 <code>new Date()</code>;但是这个属性在数据提取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></li><li><p>【强制】序列化类新增属性时，请不要修改 <code>serialVersionUID</code> 字段，避免反序列失败；如<br>果完全不兼容升级，避免反序列化混乱，那么请修改 <code>serialVersionUID</code> 值。<br><strong>说明：</strong> 注意 <code>serialVersionUID</code> 不一致会抛出序列化运行时异常。</p></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 <code>init</code> 方法中。</p></li><li><p>【强制】<code>POJO</code> 类必须写 <code>toString</code> 方法。使用 IDE 的中工具：<code>source&gt; generate toString</code><br>时，如果继承了另一个 <code>POJO</code> 类，注意在前面加一下 <code>super.toString</code>。<br><strong>说明：</strong> 在方法执行抛出异常时，可以直接调用 <code>POJO</code> 的 <code>toString()</code>方法打印其属性值，便于排查问题。</p></li><li><p>【推荐】使用索引访问用 <code>String</code> 的 <code>split</code> 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 <code>IndexOutOfBoundsException</code> 的风险。<br><strong>说明：</strong> </p><pre><code>String str = &quot;a,b,c,,&quot;;String[] ary = str.split(&quot;,&quot;);//预期大于 3，结果是 3System.out.println(ary.length);</code></pre></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</p></li><li><p>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; <code>getter/setter</code> 方法。<br><strong>说明：</strong> 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 <code>Service</code> 和 <code>DAO</code> 的 <code>getter/setter</code> 方法放在类体最后。</p></li></ol><ol><li><p>【推荐】<code>setter</code> 方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。在 <code>getter/setter</code> 方法中，不要增加业务逻辑，增加排查问题的难度。<br><strong>反例：</strong> </p><pre><code>public Integer getData() {    if (true) {        return this.data + 100;    } else {        return this.data - 100;    }}</code></pre></li><li><p>【推荐】循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。<br><strong>说明：</strong> 反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行 <code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。<br><strong>反例：</strong> </p><pre><code>    String str = &quot;start&quot;;    for (int i = 0; i &lt; 100; i++) {        str = str + &quot;hello&quot;;    }</code></pre></li><li><p>【推荐】<code>final</code> 可以声明类、成员变量、方法、以及本地变量，下列情况使用 <code>final</code> 关键字：<br>1） 不允许被继承的类，如：<code>String</code> 类。<br>2） 不允许修改引用的域对象，如：<code>POJO</code> 类的域变量。<br>3） 不允许被重写的方法，如：<code>POJO</code> 类的 <code>setter</code> 方法。<br>4） 不允许运行过程中重新赋值的局部变量。<br>5） 避免上下文重复使用一个变量，使用 <code>final</code> 描述可以强制重新定义一个变量，方便更好地进行重构。  </p></li><li><p>【推荐】慎用 <code>Object</code> 的 <code>clone</code> 方法来拷贝对象。<br><strong>说明：</strong> 对象的 <code>clone</code> 方法默认是浅拷贝，若想实现深拷贝需要重写 <code>clone</code> 方法实现属性对象的拷贝。</p></li><li><p>【推荐】类成员与方法访问控制从严：<br>1） 如果不允许外部直接通过 <code>new</code> 来创建对象，那么构造方法必须是 <code>private。</code><br>2） 工具类不允许有 <code>public</code> 或 <code>default</code> 构造方法。<br>3） 类非 <code>static</code> 成员变量并且与子类共享，必须是 <code>protected</code>。<br>4） 类非 <code>static</code> 成员变量并且仅在本类使用，必须是 <code>private</code>。<br>5） 类 <code>static</code> 成员变量如果仅在本类使用，必须是 <code>private</code>。<br>6） 若是 <code>static</code> 成员变量，必须考虑是否为 <code>final</code>。<br>7） 类成员方法只供类内部调用，必须是 <code>private</code>。<br>8） 类成员方法只对继承类公开，那么限制为 <code>protected</code>。<br><strong>说明：</strong> 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。<br>思考：如果是一个 <code>private</code> 的方法，想删除就删除，可是一个 <code>public</code> 的 <code>service</code> 方法，或者一个 <code>public</code> 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p></li></ol><h4 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h4><ol><li><p>【强制】关于 <code>hashCode</code> 和 <code>equals</code> 的处理，遵循如下规则：<br>1） 只要重写 <code>equals</code>，就必须重写 <code>hashCode。</code><br>2） 因为 <code>Set</code> 存储的是不重复的对象，依据 <code>hashCode</code> 和 <code>equals</code> 进行判断，所以 <code>Set</code> 存储的对象必须重写这两个方法。<br>3） 如果自定义对象做为 <code>Map</code> 的键，那么必须重写 <code>hashCode</code> 和 <code>equals</code>。<br><strong>说明：</strong> <code>String</code> 重写了 <code>hashCode</code> 和 <code>equals</code> 方法，所以我们可以非常愉快地使用 <code>String</code> 对象作为 <code>key</code> 来使用。</p></li><li><p>【强制】<code>ArrayList</code> 的 <code>subList</code> 结果不可强转成 <code>ArrayList</code>，否则会抛出 <code>ClassCastException</code> 异常：<code>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList</code> ;<br><strong>说明：</strong> <code>subList</code> 返回的是 <code>ArrayList</code> 的内部类 <code>SubList</code>，并不是 <code>ArrayList</code> ，而是<br><code>ArrayList</code> 的一个视图，对于 <code>SubList</code> 子列表的所有操作最终会反映到原列表上。</p></li><li><p>【强制】 在 <code>subList</code> 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增<br>加、删除均产生 <code>ConcurrentModificationException</code> 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一样的数组，大小就是 <code>list.size()</code>。<br><strong>说明：</strong> 使用 <code>toArray</code> 带参方法，入参分配的数组空间不够大时，<code>toArray</code> 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为<code>[ list.size() ]</code>的数组元素将被置为 <code>null</code>，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。<br> <strong>正例：</strong> </p><pre><code> List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;); list.add(&quot;bao&quot;); String[] array = new String[list.size()]; array = list.toArray(array);</code></pre><p> <strong>反例：</strong> 直接使用 <code>toArray</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code>类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误。</p></li><li><p>【强制】使用工具类 <code>Arrays.asList()</code>把数组转换成集合时，不能使用其修改集合相关的方<br>法，它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。<br><strong>说明：</strong> <code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code> 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><pre><code>  String[] str = new String[] { &quot;a&quot;, &quot;b&quot; };  List list = Arrays.asList(str);</code></pre><p> 第一种情况：<code>list.add(&quot;c&quot;);</code> 运行时异常。<br> 第二种情况：<code>str[0] = &quot;gujin&quot;;</code> 那么 list.get(0)也会随之修改。</p></li><li><p>【强制】泛型通配符 <code>&lt;? extends T&gt;</code> 来接收返回的数据，此写法的泛型集合不能使用 <code>add</code> 方法，而 <code>&lt;? super T&gt;</code> 不能使用 <code>get</code> 方法，做为接口调用赋值时易出错。<br><strong>说明：</strong> 扩展说一下 <code>PECS(Producer Extends Consumer Super)</code> 原则：1）频繁往外读取内容<br>的，适合用上界 <code>Extends</code>。2）经常往里插入的，适合用下界 <code>Super</code>。</p></li><li><p>【强制】不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> <code>操作。remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。<br><strong>正例：</strong> </p><pre><code>Iterator&lt;String&gt; it = a.iterator();while (it.hasNext()) {    String temp = it.next();    if (删除元素的条件) {        it.remove();    }}</code></pre><p><strong>反例：</strong> </p><pre><code>List&lt;String&gt; a = new ArrayList&lt;String&gt;();a.add(&quot;1&quot;);a.add(&quot;2&quot;);for (String temp : a) {    if (&quot;1&quot;.equals(temp)) {        a.remove(temp);    }}</code></pre><p><strong>说明：</strong> 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p></li><li><p>【强制】 在 JDK7 版本及以上，<code>Comparator</code> 要满足如下三个条件，不然 <code>Arrays.sort</code>，<code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> 异常。<br><strong>说明：</strong><br>1） x，y 的比较结果和 y，x 的比较结果相反。<br>2） x&gt;y，y&gt;z，则 x&gt;z。<br>3） x=y，则 x，z 比较结果和 y，z 比较结果相同。<br><strong>反例：</strong> 下例中没有处理相等的情况，实际使用中可能会出现异常：</p><pre><code> new Comparator&lt;Student&gt;() {     @Override     public int compare(Student o1, Student o2) {         return o1.getId() &gt; o2.getId() ? 1 : -1;     } };</code></pre></li><li><p>【推荐】集合初始化时，指定集合初始值大小。<br><strong>说明：</strong> <code>HashMap</code> 使用 <code>HashMap(int initialCapacity)</code> 初始化，<br><strong>正例：</strong> <code>initialCapacity = (需要存储的元素个数 / 负载因子) + 1</code>。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。<br><strong>反例：</strong> <code>HashMap</code> 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。</p></li><li><p>【推荐】使用 <code>entrySet</code> 遍历 <code>Map</code> 类集合 KV，而不是 <code>keySet</code> 方式进行遍历。<br><strong>说明：</strong> <code>keySet</code> 其实是遍历了 2 次，一次是转为 <code>Iterator</code> 对象，另一次是从 <code>hashMap</code> 中取出 <code>key</code> 所对应的 <code>value</code>。而 <code>entrySet</code> 只是遍历了一次就把 <code>key</code> 和 <code>value</code> 都放到了 <code>entry</code> 中，效率更高。如果是 JDK8，使用 <code>Map.foreach</code> 方法。<br><strong>正例：</strong> <code>values()</code> 返回的是 V 值集合，是一个 <code>list</code> 集合对象；<code>keySet()</code> 返回的是 K 值集合，是一个 <code>Set</code> 集合对象；<code>entrySet()</code> 返回的是 K-V 值组合集合。</p></li><li><p>【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</p><p>| 集合类            | Key           | Value         | Super       | 说明       |<br>| :———————— | :—————— | :—————— | :————— | :————- |<br>| HashTable         | 不允许为 null | 不允许为 null | Dictionary  | 线程安全   |<br>| ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 分段锁技术 |<br>| TreeMap           | 不允许为 null | 允许为 null   | AbstractMap | 线程不安全 |<br>| HashMap           | 允许为 null   | 允许为 null   | AbstractMap | 线程不安全 |</p><p><strong>反例：</strong> 由于 <code>HashMap</code> 的干扰，很多人认为 <code>ConcurrentHashMap</code> 是可以置入 <code>null</code> 值，而事实上，存储 <code>null</code> 值时会抛出 NPE 异常。</p></li><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。<br><strong>说明：</strong> 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次<br>序是一定的。如： <code>ArrayList</code> 是 order/unsort；<code>HashMap</code> 是 unorder/unsort；<code>TreeSet</code> 是 order/sort。</p></li><li><p>【参考】利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains</code> 方法进行遍历、对比、去重操作。</p></li></ol><h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。<br><strong>说明：</strong> 资源驱动类、工具类、单例工厂类都需要注意。</p></li><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br><strong>正例：</strong> </p><pre><code> public class TimerTaskThread extends Thread {     public TimerTaskThread() {         super.setName(&quot;TimerTaskThread&quot;); ...     } }</code></pre></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br><strong>说明：</strong> 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></li><li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br><strong>说明：</strong> <code>Executors</code> 返回的线程池对象的弊端如下：  </p><ol><li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。  </li><li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>:<br>允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM。</li></ol></li><li><p>【强制】<code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为 <code>static</code>，必须加锁，或者使用 <code>DateUtils</code> 工具类。<br><strong>正例：</strong> 注意线程安全，使用 <code>DateUtils</code>。亦推荐如下处理：</p><pre><code> private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {     @Override     protected DateFormat initialValue() {         return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);     } };</code></pre><p> <strong>说明：</strong> 如果是 JDK8 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>，<code>LocalDateTime</code> 代替 <code>Calendar</code>，<code>DateTimeFormatter</code> 代替 <code>Simpledateformatter</code>，官方给出的解释：simple beautiful strong<br>immutable thread-safe。</p></li><li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。<br><strong>说明：</strong> 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p></li><li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。<br><strong>说明：</strong> 线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。</p></li><li><p>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。<br><strong>说明：</strong> 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p></li><li><p>【强制】多线程并行处理定时任务时，<code>Timer</code> 运行多个 <code>TimeTask</code> 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 <code>ScheduledExecutorService</code> 则没有这个问题。</p></li><li><p>【推荐】使用 <code>CountDownLatch</code> 进行异步转同步操作，每个线程退出前必须调用 <code>countDown</code> 方法，线程执行代码注意 catch 异常，确保 <code>countDown</code> 方法可以执行，避免主线程无法执行至 <code>await</code> 方法，直到超时才返回结果。<br><strong>说明：</strong> 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p></li><li><p>【推荐】避免 <code>Random</code> 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。<br><strong>说明：</strong> <code>Random</code> 实例包括 <code>java.util.Random</code> 的实例或者 <code>Math.random()</code> 的方式。<br><strong>正例：</strong> 在 JDK7 之后，可以直接使用 API <code>ThreadLocalRandom</code>，而在 JDK7 之前，需要编码保证每个线程持有一个实例。</p></li><li><p>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 <code>volatile</code> 型。<br><strong>反例：</strong> </p><pre><code>class Foo {    private Helper helper = null;    public Helper getHelper() {        if (helper == null) synchronized(this) {            if (helper == null)                helper = new Helper();        }        return helper;    }    // other functions and members...}</code></pre></li><li><p>【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：<br><code>AtomicInteger count = new AtomicInteger(); count.addAndGet(1);</code> 如果是 JDK8，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好（减少乐观锁的重试次数）。</p></li><li><p>【参考】  在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。</p></li><li><p>【参考】<code>ThreadLocal</code> 无法解决共享对象的更新问题，<code>ThreadLocal</code> 对象建议使用 <code>static</code> 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p></li></ol><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ol><li><p>【强制】在一个 <code>switch</code> 块内，每个 <code>case</code> 要么通过 <code>break/return</code> 等来终止，要么注释说明程序将继续执行到哪一个 <code>case</code> 为止；在一个 <code>switch</code> 块内，都必须包含一个 <code>default</code> 语句并且放在最后，即使它什么代码也没有。</p></li><li><p>【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;</p></li><li><p>【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</p><pre><code>if (condition) { ... return obj;}// 接着写 else 的业务逻辑代码;</code></pre><p><strong>说明：</strong> 如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。<br><strong>正例：</strong> 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下：</p><pre><code>public void today() {    if (isBusy()) {        System.out.println(“change time.”);        return;    }    if (isFree()) {        System.out.println(“go to travel.”);        return;    }    System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”);    return;}</code></pre></li><li><p>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。<br><strong>说明：</strong> 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br> <strong>正例：</strong> </p><pre><code> //伪代码如下 final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) {  ... }</code></pre><p> <strong>反例：</strong> </p><pre><code> if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) {  ... }</code></pre></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p></li><li><p>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</p></li><li><p>【参考】下列情形，需要进行参数校验：<br>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参<br>数错误导致中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。<br>5） 敏感权限入口。</p></li><li><p>【参考】下列情形，不需要进行参数校验：<br>1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。<br>2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底<br>层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。<br>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h4 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h4><ol><li><p>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用<code>/**内容*/格式，不得使用 //xxx 方式</code>。<br><strong>说明：</strong> 在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p></li><li><p>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<br><strong>说明：</strong> 对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p>【强制】所有的类都必须添加创建者和创建日期。</p></li><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/<em> </em>/注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。<br><strong>反例：</strong> “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。<br><strong>说明：</strong> 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p></li><li><p>【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。<br><strong>说明：</strong> 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p></li><li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br><strong>反例：</strong>  </p><pre><code>// put elephant into fridgeput(elephant, fridge);</code></pre><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。<br>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p></li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><p>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br>说明：不要在方法体内定义：<code>Pattern pattern = Pattern.compile(规则);</code></p></li><li><p>【强制】<code>velocity</code> 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。<br><strong>说明：</strong> 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p></li><li><p>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。<br><strong>说明：</strong> 如果 <code>var=null</code> 或者不存在，那么${var}会直接显示在页面上。</p></li><li><p>【强制】注意 <code>Math.random()</code> 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p></li><li><p>【强制】获取当前毫秒数 <code>System.currentTimeMillis()</code>; 而不是 <code>new Date().getTime()</code>;<br><strong>说明：</strong> 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p></li><li><p>【推荐】不要在视图模板中加入任何复杂的逻辑。<br><strong>说明：</strong> 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。</p></li><li><p>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p></li><li><p>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</p></li></ol><h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ol><li><p>【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： <code>IndexOutOfBoundsException</code> ， <code>NullPointerException</code> 等等。<br><strong>说明：</strong> 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch<br>NumberFormatException 来实现。<br><strong>正例：</strong> <code>if (obj != null) {...}</code><br><strong>反例：</strong> <code>try { obj.method() } catch (NullPointerException e) {...}</code>  </p></li><li><p>【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</p></li><li><p>【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</p></li><li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p>【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p></li><li><p>【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<br><strong>说明：</strong> 如果 JDK7 及以上，可以使用 try-with-resources 方式。</p></li><li><p>【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。</p></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br><strong>说明：</strong> 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。<br><strong>说明：</strong> 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</p></li><li><p>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<br>1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。  </p><pre><code>**反例：** `public int f() { return Integer 对象}`， 如果为 null，自动解箱抛 NPE。  </code></pre><p>2） 数据库的查询结果可能为 null。<br>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br>5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。<br>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。<br><strong>正例：</strong> 使用 JDK8 的 Optional 类来防止 NPE 问题。</p></li><li><p>【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 <code>new RuntimeException()</code>，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。</p></li><li><p>【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。<br><strong>说明：</strong> 关于 RPC 方法返回方式使用 Result 方式的理由：<br>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li><li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。<br><strong>说明：</strong> 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。<br><strong>正例：</strong> 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br><code>private boolean checkParam(DTO dto) {...}</code></p></li></ol><h4 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h4><ol><li><p>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class);</code></pre></li><li><p>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br><strong>正例：</strong> mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log<br><strong>说明：</strong> 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于<br>通过日志对系统进行及时监控。</p></li><li><p>【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方<br>式。<br><strong>说明：</strong> logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br> <strong>正例：</strong> （条件）</p><pre><code> if (logger.isDebugEnabled()) {     logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol); }</code></pre><p> <strong>正例：</strong> （占位符）</p><pre><code> logger.debug(&quot;Processing trade with id: {} symbol : {} &quot;, id, symbol);</code></pre></li><li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。<br><strong>正例：</strong> <code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p></li><li><p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。<br><strong>正例：</strong> logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e);</p></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘<br>撑爆，并记得及时删除这些观察日志。<br><strong>说明：</strong> 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p></li><li><p>【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。</p></li></ol><h2 id="MYSQL-数据库"><a href="#MYSQL-数据库" class="headerlink" title="MYSQL 数据库"></a>MYSQL 数据库</h2><h4 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h4><ol><li><p>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。<br><strong>说明：</strong> 任何字段如果为非负数，必须是 unsigned。<br><strong>正例：</strong> 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br><strong>正例：</strong> getter_admin，task_config，level3_name<br><strong>反例：</strong> GetterAdmin，taskConfig，level_3_name</p></li><li><p>【强制】表名不使用复数名词。<br><strong>说明：</strong> 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p></li><li><p>【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br><strong>说明：</strong> pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></li><li><p>【强制】小数类型为 decimal，禁止使用 float 和 double。<br><strong>说明：</strong> float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。<br><strong>说明：</strong> 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。</p></li><li><p>【推荐】表的命名最好是加上“业务名称_表的作用”。<br><strong>正例：</strong> tiger_task / tiger_reader / mpp_config</p></li><li><p>【推荐】库名与应用名称尽量一致。</p></li><li><p>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>1）不是频繁修改的字段。<br>2）不是 varchar 超长字段，更不能是 text 字段。<br><strong>正例：</strong> 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存<br>储类目名称，避免关联查询。</p></li><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br><strong>说明：</strong> 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br><strong>正例：</strong> 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p><p>| 对象     | 年龄区间   | 类型              | 表示范围                       |<br>| :———- | :————- | :———————— | :——————————————- |<br>| 人       | 150 岁之内 | unsigned tinyint  | 无符号值：0 到 255             |<br>| 龟       | 数百岁     | unsigned smallint | 无符号值：0 到 65535           |<br>| 恐龙化石 | 数千万年   | unsigned int      | 无符号值：0 到约 42.9 亿       |<br>| 太阳     | 约 50 亿年 | unsigned bigint   | 无符号值：0 到约 10 的 19 次方 |</p></li></ol><h4 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h4><ol><li><p>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></li><li><p>【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br><strong>说明：</strong> 即使双表 join 也要注意表索引、SQL 性能。</p></li><li><p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br><strong>说明：</strong> 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p></li><li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br><strong>说明：</strong> 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br><strong>正例：</strong> where a=? and b=? order by c; 索引：a_b_c<br><strong>反例：</strong> 索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p></li><li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。<br><strong>说明：</strong> 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br><strong>正例：</strong> 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种<br>效果，用 explain 的结果，extra 列会出现：using index。</p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。<br><strong>说明：</strong> MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br><strong>正例：</strong> 先快速定位需要获取的 id 段，然后再关联：<br> SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p></li><li><p>【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。<br><strong>说明：</strong>  </p><pre><code>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。  2） ref 指的是使用普通的索引（normal index）。  3） range 对索引进行范围检索。  </code></pre><p><strong>反例：</strong> explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。</p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。<br><strong>正例：</strong> 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。<br><strong>说明：</strong> 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;?<br>and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p></li><li><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p>【参考】创建索引时避免有如下极端误解：<br>1）宁滥勿缺。误认为一个查询就需要建一个索引。<br>2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。<br>3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p></li></ol><h4 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h4><ol><li><p>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br><strong>说明：</strong> count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p></li><li><p>【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p></li><li><p>【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。<br><strong>正例：</strong> 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</p></li><li><p>【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。<br><strong>说明：</strong><br> 1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。<br> 2） NULL=NULL 的返回结果是 NULL，而不是 true。<br> 3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。  </p></li><li><p>【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br><strong>说明：</strong> （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p>【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p></li><li><p>【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p></li><li><p>【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。<br><strong>说明：</strong><br> SELECT LENGTH(“轻松工作”)； 返回为 12<br> SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4<br> 如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。</p></li><li><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。<br><strong>说明：</strong> TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><h4 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h4><ol><li><p>【强制】在表查询中，一律不要使用 <em> 作为查询的字段列表，需要哪些字段必须明确写明。<br><em>*说明：</em></em> 1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。</p></li><li><p>【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。<br><strong>说明：</strong> 参见定义 POJO 类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p></li><li><p>【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。<br><strong>说明：</strong> 配置映射关系，使字段与 DO 类解耦，方便维护。</p></li><li><p>【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p>【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。<br><strong>说明：</strong> 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList<br>取 start,size 的子集合。<br><strong>正例：</strong> </p><pre><code> Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;start&quot;, start); map.put(&quot;size&quot;, size);</code></pre></li><li><p>【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。<br><strong>说明：</strong> resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li><li><p>【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p></li><li><p>【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p>【参考】<isEqual>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为 null 时执行；<isNotNull>表示不为 null 值时执行。 </p></li></ol><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</p><p><img src="E:/ChromeDownload/alibaba-java-specification-master/app_layout.png" alt="未加载图片"></p><ul><li><strong>开放接口层：</strong>可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</li><li><strong>终端显示层：</strong>各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li><li><strong>Web 层：</strong>主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li><strong>Service 层：</strong>相对具体的业务逻辑服务层。</li><li><strong>Manager 层：</strong>通用业务处理层，它有如下特征：  <ol><li>对第三方平台封装的层，预处理返回结果及转化异常信息；  </li><li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；  </li><li>与 DAO 层交互，对多个 DAO 的组合复用。</li></ol></li><li><strong>DAO 层：</strong>数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。</li><li><strong>外部接口或第三方平台：</strong>包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</li></ul></li><li><p>【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印<br>日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约：</p><ul><li><strong>DO（Data Object）：</strong>与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li><strong>DTO（Data Transfer Object）：</strong>数据传输对象，Service 和 Manager 向外传输的对象。</li><li><strong>BO（Business Object）：</strong>业务对象。可以由 Service 层输出的封装业务逻辑的对象。</li><li><strong>Query：</strong>数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li><li><strong>VO（View Object）：</strong>显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li></ul></li></ol><h4 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h4><ol><li><p>【强制】定义 GAV 遵从以下规则：<br>1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。<br><strong>说明：</strong> {公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。<br><strong>正例：</strong> com.taobao.jstorm 或 com.alibaba.dubbo.register<br>2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br><strong>正例：</strong> dubbo-client / fastjson-api / jstorm-tool<br>3） Version：详细规定参考下方。</p></li><li><p>【强制】二方库版本号命名方式：主版本号.次版本号.修订号<br>1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。<br>2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。<br>3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。<br><strong>说明：</strong> 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0</p></li><li><p>【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。<br><strong>说明：</strong> 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，<br>必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一<br>致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。</p></li><li><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚<br>举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。<br>说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一<br>个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。</p></li><li><p>【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的<br>Version。<br><strong>说明：</strong> 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号<br>出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。</p></li><li><p>【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<br><dependencyManagement>语句块中。<br>说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声<br>明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的<br><dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。</p></li><li><p>【推荐】二方库不要有配置项，最低限度不要再增加配置项。</p></li><li><p>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：<br>1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对<br>象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用<br>者去依赖具体版本号；无 log 具体实现，只依赖日志框架。<br>2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能<br>方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol><li><p>【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。<br>说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服<br>务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上<br>调小此等待值。<br><strong>正例：</strong> 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：<br>net.ipv4.tcp_fin_timeout = 30</p></li><li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。<br><strong>说明：</strong> 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对<br>应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux<br>服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p></li><li><p>【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出<br>dump 信息。<br><strong>说明：</strong> OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错<br>非常有价值。</p></li><li><p>【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则<br>会带来 URL 维护不一致的问题和潜在的安全风险。</p></li></ol><h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><ol><li><p>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。<br><strong>说明：</strong> 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信<br>内容、修改他人的订单。</p></li><li><p>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br><strong>说明：</strong> 查看个人手机号码会显示成:158<em>**</em>9119，隐藏中间 4 位，防止隐私泄露。</p></li><li><p>【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，<br>禁止字符串拼接 SQL 访问数据库。</p></li><li><p>【强制】用户请求传入的任何参数必须做有效性验证。<br><strong>说明：</strong> 忽略参数校验可能导致：</p><ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS  </li></ul><p><strong>说明：</strong> Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，<br>但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p></li><li><p>【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。<br><strong>说明：</strong> CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在<br>CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户<br>不知情情况下对数据库中用户参数进行相应修改。</p></li><li><p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，<br>如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。<br>说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其<br>它用户，并造成短信平台资源浪费。</p></li><li><p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过<br>滤等风控策略。</p></li></ol><h2 id="附-1：版本历史"><a href="#附-1：版本历史" class="headerlink" title="附 1：版本历史"></a>附 1：版本历史</h2><div class="table-container"><table><thead><tr><th style="text-align:left">版本号</th><th style="text-align:left">更新日期</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">1.0.0</td><td style="text-align:left">2017.2.9</td><td style="text-align:left">阿里巴巴集团正式对外发布</td></tr><tr><td style="text-align:left">1.0.1</td><td style="text-align:left">2017.2.13</td><td style="text-align:left">1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。</td></tr><tr><td style="text-align:left">1.0.2</td><td style="text-align:left">2017.2.20</td><td style="text-align:left">1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final 描述。5）去除 Comparator 部分描述。</td></tr><tr><td style="text-align:left">1.1.0</td><td style="text-align:left">2017.2.27</td><td style="text-align:left">1）增加前言。2）增加&lt;? extends T&gt;描述和说明。3）增加版本历史。4）增加专有名词解释。</td></tr><tr><td style="text-align:left">1.1.1</td><td style="text-align:left">2017.3.31</td><td style="text-align:left">修正页码总数和部分示例</td></tr><tr><td style="text-align:left">1.2.0</td><td style="text-align:left">2017.5.20</td><td style="text-align:left">1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加 final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为 is_deleted</td></tr></tbody></table></div><h2 id="附-2：本手册专有名词"><a href="#附-2：本手册专有名词" class="headerlink" title="附 2：本手册专有名词"></a>附 2：本手册专有名词</h2><ol><li><p><strong>POJO</strong>（Plain Ordinary Java Object）：在本手册中，POJO 专指只有 setter / getter<br>/ toString 的简单类，包括 DO/DTO/BO/VO 等。</p></li><li><p><strong>DO</strong>（Data Object）：本手册指数据库表一一对应的 POJO 类。</p></li><li><p><strong>GAV</strong>（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。</p></li><li><p><strong>OOP</strong>（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</p></li><li><p><strong>ORM</strong>（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，<br>本文泛指 iBATIS, mybatis 等框架。</p></li><li><p><strong>NPE</strong>（java.lang.NullPointerException）: 空指针异常。</p></li><li><p><strong>SOA</strong>（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散<br>耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</p></li><li><p><strong>一方库</strong>：本工程内部子项目模块依赖的库（jar 包）。</p></li><li><p><strong>二方库</strong>：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</p></li><li><p><strong>三方库</strong>：公司之外的开源库（jar 包）。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转载自：&lt;a href=&quot;https://github.com/mysterin/alibaba-java-specification&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mysterin/alibaba
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>JUC之常见工具类</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-09-30T07:57:37.000Z</published>
    <updated>2020-10-12T13:29:07.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。在CountDownLatch出现之前一般都使用线程的join方法来实现这一点，但是在使用ExecutorService时我们就没办法了。</p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"child threadOne over!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"child threadTwo over!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"mainThread wait for all childThread over"</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"all childThread over"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果如下：</span><br><span class="line">mainThread wait for all childThread over</span><br><span class="line">child threadTwo over!</span><br><span class="line">child threadOne over!</span><br><span class="line">all childThread over</span><br></pre></td></tr></table></figure><p>在如上代码中，因为有两个子线程所以构造函数传入参数为2。主线程调用CountDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使内部计数器(state)减1，所有子线程执行完毕后计数器为0，此时主线程的await方法才会返回。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>CountDownLatch基于AQS实现。</p><p><img src="CountDownLatch.png" alt=""></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类Sync继承自AQS，其构造方法如下</span></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法可知CountDownLatch的计数器实际就是AQS的state。</p><h4 id="void-await"><a href="#void-await" class="headerlink" title="void await()"></a>void await()</h4><p>调用await后当前线程被阻塞，只有当计数器值为0或者被中断该方法才会返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//被中断则抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//查看计数器是否为0，不是则进入AQS阻塞队列</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync实现的AQS的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boolean-await-long-timeout-TimeUnit-unit"><a href="#boolean-await-long-timeout-TimeUnit-unit" class="headerlink" title="boolean await(long timeout, TimeUnit unit)"></a>boolean await(long timeout, TimeUnit unit)</h4><p>相比void await()多了一个超时设置，设置的timeout时间到了，因为超时而返回false。</p><h4 id="void-countDown"><a href="#void-countDown" class="headerlink" title="void countDown()"></a>void countDown()</h4><p>线程调用该方法后，计数器值减1，减1后若计数器为0则唤醒<strong>所有</strong>因调用await方法而被阻塞的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒AQS中所有阻塞的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync实现的AQS的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//CAS更新state</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="long-getCount"><a href="#long-getCount" class="headerlink" title="long getCount()"></a>long getCount()</h4><p>获取state的值，该方法一般用于测试。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CountDownLatch的计数器是一次性的，当计数器值为0后，再调用await和countdown方法均会立即返回。为了满足计数器可以重置的需要，这才有了CyclicBarrier（回环屏障）。屏障的含义是：当线程调用await方法就会被阻塞，这个阻塞点就称为屏障点，当所有线程都调用了await方法后，线程就会冲破屏障，所有线程被唤醒继续向下执行（注意：最后一个调用await的线程不会被阻塞）。回环的含义是：所有线程到达屏障点后，CyclicBarrier的状态会被重置，因此它可以被重用。</p><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><p>下面的例子实现的是：使用两个线程执行一个被分解的任务，两个线程并发执行任务的两个步骤后再由CyclicBarrier汇总。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": task merge result"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": task step-1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": enter in barrier"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": out from barrier"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": task step-2"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": enter in barrier"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": out from barrier"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1: task step-1</span><br><span class="line">pool-1-thread-1: enter in barrier</span><br><span class="line">pool-1-thread-2: task step-2</span><br><span class="line">pool-1-thread-2: enter in barrier</span><br><span class="line">pool-1-thread-2: task merge result</span><br><span class="line">pool-1-thread-1: out from barrier</span><br><span class="line">pool-1-thread-2: out from barrier</span><br></pre></td></tr></table></figure><p>CyclicBarrier的构造方法参数列表中，第一个参数是计数器的初始值，第二个参数Runnable是当计数器值为0时由CyclicBarrier执行的任务。</p><p>在线程中CyclicBarrier对象调用await方法后，其计数器值-1，若此时计数器值不为0，当前线程被阻塞；若计数器值为0，则执行CyclicBarrier构造方法中传入的任务，然后唤醒条件队列中所有阻塞线程，重置计数器并新建Generation（重置broken标志）。</p><p>以下例子体现了CyclicBarrier的可复用性（所谓回环）：</p><p>以下任务被分为三个阶段，由两个线程并发执行该任务，只有当两个线程都完成了step1后才能进入step2，只有当两个线程都完成了step2才能进入step3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": step-1"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-2"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-3"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": step-1"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-2"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-3"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1: step-1</span><br><span class="line">pool-1-thread-2: step-1</span><br><span class="line">pool-1-thread-2: step-2</span><br><span class="line">pool-1-thread-1: step-2</span><br><span class="line">pool-1-thread-1: step-3</span><br><span class="line">pool-1-thread-2: step-3</span><br></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>CyclicBarrier基于ReentrantLock实现。</p><p><img src="CyclicBarrier.png" alt=""></p><p>parties用于记录线程个数，当parties个线程都调用await方法后所有线程才会冲破屏障点。count才是真正的计数器，一开始等于parties，每当有线程调用await方法后就-1，当count==0时所有线程都到了屏障点，此时会重置count的值为parties。</p><p>独占锁lock首先保证了更新计数器count的原子性，另外使用lock的条件变量trip支持线程间同步操作。</p><p>最后，在Generation对象内部有一个变量broken，用于记录当前屏障是否被打破。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="int-await"><a href="#int-await" class="headerlink" title="int await()"></a>int await()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">                          BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boolean-await-long-timeout-TimeUnit-unit-1"><a href="#boolean-await-long-timeout-TimeUnit-unit-1" class="headerlink" title="boolean await(long timeout, TimeUnit unit)"></a>boolean await(long timeout, TimeUnit unit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时返回。</p><h4 id="int-dowait-boolean-timed-long-nanos"><a href="#int-dowait-boolean-timed-long-nanos" class="headerlink" title="int dowait(boolean timed, long nanos)"></a>int dowait(boolean timed, long nanos)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//index==0说明所有线程都到达了屏障点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//激活其他因调用await而被阻塞的线程，并重置CyclicBarrier</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//index!=0则阻塞当前线程（进入条件队列）</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">             ...</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有线程节点进入AQS队列并唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">//重置CyclicBarrier</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。</p><h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors</span><br><span class="line">.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.acquire();</span><br><span class="line"><span class="comment">//存储到数据库操作</span></span><br><span class="line">s.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>Semaphore基于AQS实现。</p><p><img src="Semaphore.png" alt=""></p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    <span class="keyword">super</span>(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    <span class="keyword">super</span>(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法传入许可证数量，许可证数量对应于AQS中的state，默认采用非公平策略。</p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><p>在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减1，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。</p><p>该方法可被中断。</p><h4 id="acquire-int-permits"><a href="#acquire-int-permits" class="headerlink" title="acquire(int permits)"></a>acquire(int permits)</h4><p>在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减permits，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。</p><p>该方法可被中断。</p><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>许可证个数加1，并根据公平策略在AQS阻塞队列中选择一个“许可证个数可以被满足”的线程唤醒。</p><h4 id="release-int-permits"><a href="#release-int-permits" class="headerlink" title="release(int permits)"></a>release(int permits)</h4><p>许可证个数加permits。</p><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;在日常开发中经常会遇到需要在主线程中开启多个
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程池</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-09-30T07:52:36.000Z</published>
    <updated>2020-10-12T14:06:02.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>FutureTask 为 Future 提供了基础实现，如<strong>获取任务执行结果</strong>(get)和<strong>取消任务</strong>(cancel)等。<strong>若任务尚未完成，获取任务执行结果时主线程将会阻塞</strong>。</p><p>FutureTask 的线程安全由CAS来保证。</p><h3 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="java-thread-x-juc-futuretask-1.png" alt=""></p><p>以上几个接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;<span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把传入的Runnable封装成一个Callable对象，若任务执行成功返回传入的result</span></span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由类图和构造方法可知，FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ol><li>提供较好的性能：线程池中的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。</li><li>统一分配和管理：比如可以限制线程的个数、动态新增线程等。</li></ol><h3 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="java-thread-x-juc-executors-1.png" alt=""></p><p>以上类图中主要接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line"><span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,<span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,</span><br><span class="line"><span class="keyword">long</span> delay,TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor原理"><a href="#ThreadPoolExecutor原理" class="headerlink" title="ThreadPoolExecutor原理"></a>ThreadPoolExecutor原理</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>JDK实现的线程池核心主要为两大部分：一个<strong>线程集合workerSet</strong>和一个<strong>阻塞队列workQueue</strong>。当用户向线程池提交一个任务时，该任务将先被放入workQueue中，workerSet中的线程会不断从workQueue中获取线程然后执行，当workQueue中没有任务时，worker就会阻塞，直至队列中又有任务了。</p><p><img src="java-thread-x-executors-1.png" alt=""></p><h4 id="部分属性"><a href="#部分属性" class="headerlink" title="部分属性"></a>部分属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//工作线程集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//创建线程的工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">//饱和策略：当workQueue满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//线程池中超出corePoolSize的闲置状态的worker的存活时间，单位为纳秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//核心worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制新增worker线程操作的原子性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件队列，在线程调用awaitTermination时用于存放阻塞的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录线程池状态与线程个数</span></span><br><span class="line"><span class="comment">//对于int是32位的平台，高3位表示线程池状态,低29位记录worker数量</span></span><br><span class="line"><span class="comment">//默认是RUNNING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//线程数量掩码位数：对于int是32位的平台，该值是29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程最大数量：000111...111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受新任务并处理阻塞队列中的任务：高3位111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//拒绝新任务但是处理阻塞队列中的任务：高3位000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务：高3位001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//所有任务（含阻塞队列中的）都执行完后当前活动线程为0，将要调用terminated方法：高3位010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//terminated执行完成后的状态：高3位011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取运行状态：高3位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获取线程数量：低29位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//计算ctl新值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>线程池状态转换图如下：</p><p><img src="java-thread-x-executors-2.png" alt=""></p><h4 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h4><p>ThreadPoolExecutor核心构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Executors工厂类提供创建的线程池类型如下：</p><ul><li><p>newFixedThreadPool：创建一个corePoolSize和maximunPoolSize都为nThreads的线程池，并且阻塞队列长度为<code>Integer.MAX_VALUE</code>。keepAliveTime为0说明只要有多于corePoolSize的空闲线程则回收。由于使用了无界队列，因此饱和策略失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>newSingleThreadExecutor：创建一个corePoolSize和maximunPoolSize都为1的线程池，并且阻塞队列长度为<code>Integer.MAX_VALUE</code>。keepAliveTime为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>newCachedThreadPool：创建一个<strong>按需自动创建线程</strong>的线程池，corePoolSize为0，maximunPoolSize为<code>Integer.MAX_VALUE</code>，阻塞队列为SynchronousQueue。keepAliveTime为60纳秒。</p><p>该类型的特殊之处在于使用了同步阻塞队列，加入队列的任务会马上执行，同步队列中最多只能有一个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><p>execute方法的作用是提交Runnable实例到线程池执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Runnable实例为null则抛出NPE</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池状态和线程数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前线程池线程个数是否小于corePoolSize，小于则新增worker</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//新增成功后直接返回</span></span><br><span class="line">        c = ctl.get();<span class="comment">//新增失败则重新获取ctl</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若线程池状态为RUNNING，则任务进入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//二次检查：添加任务时线程池状态可能已变化</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//不是RUNNING则从阻塞队列删除任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//worker数量为0则添加一个worker</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞队列满则新增worker，新增失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的内部类Worker源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知，Worker继承自AQS并实现了Runnable接口，是具体承载任务的对象。Worker类实现了简单的不可重入独占锁，state=0表示锁未被获取状态，state=1表示锁已经被获取，state=-1是创建Worker实例默认的状态。</p><p>addWorker与runWorker方法源码分析（有空再看）。</p><h4 id="sumbit方法"><a href="#sumbit方法" class="headerlink" title="sumbit方法"></a>sumbit方法</h4><p>sumbit方法在ThreadPoolExecutor的父抽象类AbstractExecutorService中实现，Runnable或Callable对象被封装为FutureTask对象传入execute方法，最终执行的是FutureTask的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown与shutdownNow"><a href="#shutdown与shutdownNow" class="headerlink" title="shutdown与shutdownNow"></a>shutdown与shutdownNow</h4><ul><li>shutdown方法：调用后线程池状态变为SHUTDOWN，此时拒绝新任务但是处理阻塞队列中的任务。</li><li>shutdownNow方法：调用后线程池状态变为STOP，此时拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务。</li></ul><h4 id="awaitTermination方法"><a href="#awaitTermination方法" class="headerlink" title="awaitTermination方法"></a>awaitTermination方法</h4><p>当线程调用该方法后会被阻塞，直到线程池状态变为TERMINATED才返回，或者等待时间超时才返回。</p><h3 id="为什么不建议使用Executors创建线程池？"><a href="#为什么不建议使用Executors创建线程池？" class="headerlink" title="为什么不建议使用Executors创建线程池？"></a>为什么不建议使用Executors创建线程池？</h3><p>阿里巴巴Java开发手册并发处理部分中，不允许使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 的构造方法，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><ul><li><p>newFixedThreadPool和newSingleThreadExecutor:  阻塞队列允许的长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量请求，从而导致OOM。</p></li><li><p>newCachedThreadPool和newScheduledThreadPool:  maximunPoolSize是Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。</p></li></ul><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor内部使用DelayQueue来存放任务。</p><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay,TimeUnit unit) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> delay,TimeUnit unit)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用是提交一个延迟执行的任务。从提交时间算起，delay时间后开始执行任务，unit为delay的时间单位。任务只执行一次。</p><h3 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit) &#123;&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用是，当任务执行完毕后，让其延迟固定时间后再次运行(fixed-delay任务)。</p><p>initialDelay表示提交任务后延迟多少时间开始执行任务command，delay表示当任务初次执行完毕后延迟多少时间后再次运行command任务，unit是initialDelay和delay的时间单位。任务会一直重复运行，直到任务运行抛出异常、被取消了、或者关闭了线程池。</p><h3 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit) &#123;&#125;</span><br></pre></td></tr></table></figure><p>fixed-rate任务的执行规则为：从提交时间算起，在时间点为initialDealy+n*period(n = 0, 1, 2, 3…)的时刻执行任务。若前一次任务还没执行完毕，下一次任务的执行时刻就到了，则下次任务要等到前一次任务执行完毕后才执行。</p><p>具体执行流程为：当任务提交后，initialDelay时间后执行command，然后在initialDelay+period时刻再次执行，而后在initialDelay+2*period时刻再次执行，循环往复，直到抛出异常、调用了任务的cancel方法取消了任务或关闭了线程池。</p><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>Fork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p><p>待后续补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FutureTask&quot;&gt;&lt;a href=&quot;#FutureTask&quot; class=&quot;headerlink&quot; title=&quot;FutureTask&quot;&gt;&lt;/a&gt;FutureTask&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器之并发队列</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</id>
    <published>2020-09-27T02:30:32.000Z</published>
    <updated>2020-10-01T09:48:09.289Z</updated>
    
    <content type="html"><![CDATA[<p>JUC提供了一系列场景的并发安全队列，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，后者使用CAS非阻塞算法实现。</p><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是线程安全的<strong>无界非阻塞</strong>队列，其底层使用单向链表实现，对于入队和出队操作使用CAS来实现线程安全，因此执行该队列的方法失败不会导致线程阻塞。</p><h4 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ConcurrentLinkedQueue.png" alt=""></p><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认头尾节点都是指向item为null的哨兵节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casTail</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casHead</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentLinkedQueue<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">        tailOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><strong>offer</strong>：通过CAS操作来控制某时只有一个线程可以添加元素到队列末尾，<strong>进行CAS竞争失败的线程会不断自旋，直至成功，其余出入队操作均是如此</strong>。相比阻塞算法，这是使用CPU资源换取阻塞所带来的开销。</li><li><strong>add</strong>：调用offer方法。</li><li><strong>poll</strong>：该方法在移除队首元素时，只是简单地使用CAS操作把节点的item值设置为null，然后重新设置head到下一个节点。移除的对象会在GC时被回收。</li><li><strong>peek</strong>：peek方法的实现与poll类似，只是没有删除步骤。另外，在第一次调用peek操作时，会删除哨兵节点，并让head指向队列的第一个元素或者null。</li><li><strong>size</strong>：该方法遍历链表计数，由于无锁策略，并发环境下结果并不准确。问：为什么不使用一个原子变量count来记录元素个数？因为这需要保证“入队操作+(count++)”或者“出队操作+(count—)”是原子操作，而ConcurrentLinkedQueue采用CAS无阻塞算法无法做到这一点。</li><li><strong>remove</strong>：删除遍历时第一个匹配的元素。</li><li><strong>contains</strong>：遍历链表查找元素，由于无锁策略，该方法并发环境下不准确。</li></ul><h4 id="延迟更新策略"><a href="#延迟更新策略" class="headerlink" title="延迟更新策略"></a>延迟更新策略</h4><p>通过对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：</p><ul><li><code>tail更新触发时机</code>：tail的下一个节点不为null时，定位真正的队尾，找到队尾节点并完成插入之后才会通过casTail进行tail更新；<strong>当tail的下一个节点为null时，只插入节点不更新tail。</strong></li><li><code>head更新触发时机</code>：当head的item域为null时，定位真正的队头，找到队头节点并完成删除之后才会通过updateHead进行head更新；<strong>当head的item域不为null时，只删除节点不更新head。</strong></li></ul><p><strong>在高并发写（大量出队入队）的情景下，通过延迟更新head和tail，减少了head和tail更新（CAS自旋）带来的CPU损耗</strong>。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>ConcurrentLinkedQueue通过无锁做到了更高的并发量，在并发量特别大的情况下，是个不错的选择，性能上好很多。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue通常用于生产者消费者场景。</p><p><img src="java-thread-x-blocking-queue-1.png" alt=""></p><p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p><h4 id="BlockingQueue常见方法"><a href="#BlockingQueue常见方法" class="headerlink" title="BlockingQueue常见方法"></a>BlockingQueue常见方法</h4><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:</p><p><img src="BlockingQueue_method.png" alt=""></p><p>四组不同的行为方式解释:</p><ul><li>抛异常: 如果试图的操作无法立即执行，抛一个异常。</li><li>特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li><li>阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li></ul><p>另外，BlockingQueue不接受null值，插入null会导致NullPointerException。</p><h3 id="BlockingDeque"><a href="#BlockingDeque" class="headerlink" title="BlockingDeque"></a>BlockingDeque</h3><p>BlockingDeque是一个双端队列，我们可以从队列两端进行入队和出队操作。该接口继承自BlockingQueue接口。</p><p><img src="java-thread-x-blocking-deque-1.png" alt=""></p><p>在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。</p><h4 id="BlockingDeque常见方法"><a href="#BlockingDeque常见方法" class="headerlink" title="BlockingDeque常见方法"></a>BlockingDeque常见方法</h4><p><img src="BlockingDeque_method.png" alt=""></p><h2 id="BlockingQueue实现类"><a href="#BlockingQueue实现类" class="headerlink" title="BlockingQueue实现类"></a>BlockingQueue实现类</h2><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><img src="LinkedBlockingQueue_uml.png" alt=""></p><p>LinkedBlockingQueue是一个<strong>有界</strong>链表，创建时可指定容量，默认上限为<code>Integer.MAX_VALUE</code>（没指定就是无界），由原子变量计数器count计数。其内部以 FIFO的顺序对元素进行存储。</p><p>如下图所示：</p><p><img src="LinkedBlockingQueue.png" alt=""></p><p>LinkedBlockingQueue对头、尾节点的操作分别使用了单独的独占锁从而保证了并发下出入队的正确性，竞争锁失败的线程进入相应的AQS阻塞队列。头尾节点的独占锁都有一个自己的条件队列，用于存放队列空(满)时执行take(put)操作的被阻塞的线程。另外，<strong>有两个独占锁意味着该队列可以同时进行出入队操作，因此count必须要使用原子变量</strong>。</p><p>注意：LinkedBlockingQueue的remove方法执行时会同时获取takeLock和putLock。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><img src="ArrayBlockingQueue_uml.png" alt=""></p><p>ArrayBlockingQueue是一个<strong>有界</strong>数组，创建时必须指定容量，并且一旦指定容量便不能更改。其内部以 FIFO的顺序对元素进行存储。</p><p>如下图所示：</p><p><img src="ArrayBlockingQueue.png" alt=""></p><p>ArrayBlockingQueue只有一个独占锁，这个锁的粒度较大，只要是对数组更改就必须加锁，因此<strong>不能同时进行入队出队操作</strong>。其中offer和poll操作通过简单的加锁实现，而put和take则使用锁加条件变量实现。另外，ArrayBlockingQueue的size方法相比LinkedBlockingQueue则是完全精确的，因为计算前加了全局锁。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><img src="PriorityBlockQueue_uml.png" alt=""></p><p>PriorityBlockingQueue是一个<strong>无界</strong>二叉堆（数组实现），每次出队的元素都是堆的根节点，保证返回的是优先级最高(低)的元素。 默认使用对象的compareTo方法提供比较规则，因此入队元素必须实现Comparable接口。如果需要自定义比较规则，也可在创建队列时传入Comparator比较器。</p><p>PriorityBlockingQueue的数组是可<strong>自动扩容</strong>的，其默认初始容量为11。当当前元素个数&gt;=容量时会通过CAS算法扩容。allocationSpinLock是个自旋锁，其使用<strong>volatile修饰和CAS操作</strong>来保证同时只有一个线程可以扩容队列，状态为0表示当前没有进行扩容，状态为1表示正在进行扩容。</p><p>如下图所示：</p><p><img src="PriorityBlockingQueue.png" alt=""></p><p>PriorityBlockingQueue只有一个条件变量notEmpty，存放take操作时因队列空而阻塞的线程，因为该队列是无界队列，所以可以一直put，没有notFull条件变量。</p><p>使用案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Task</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> priority, String taskName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">            <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Task o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.priority &gt;= o.priority) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(taskName + <span class="string">":"</span> + priority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityBlockingQueue&lt;Task&gt; priorityBlockingQueue =</span><br><span class="line">                <span class="keyword">new</span> PriorityBlockingQueue&lt;Task&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Task task = <span class="keyword">new</span> Task(random.nextInt(<span class="number">10</span>), <span class="string">"taskName"</span>+i);</span><br><span class="line">            priorityBlockingQueue.offer(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!priorityBlockingQueue.isEmpty())&#123;</span><br><span class="line">            priorityBlockingQueue.poll().printTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">taskName1:1</span><br><span class="line">taskName7:2</span><br><span class="line">taskName4:3</span><br><span class="line">taskName0:3</span><br><span class="line">taskName9:4</span><br><span class="line">taskName5:7</span><br><span class="line">taskName2:8</span><br><span class="line">taskName6:9</span><br><span class="line">taskName8:9</span><br><span class="line">taskName3:9</span><br></pre></td></tr></table></figure><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p><img src="DelayQueue_uml.png" alt=""></p><p>DelayQueue是一个<strong>无界</strong>阻塞延迟队列，队列中的每个元素都有一个过期时间，<strong>每个元素都必须实现<code>java.util.concurrent.Delayed</code>接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队时判断元素是否过期，<strong>只有过期元素才会出队列</strong>，队列头元素是最快要过期的元素。</p><p>由类图知，DelayQueue内部使用PriorityQueue存放数据。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p><h2 id="BlockingDeque实现类"><a href="#BlockingDeque实现类" class="headerlink" title="BlockingDeque实现类"></a>BlockingDeque实现类</h2><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>BlockingDeque唯一的一个实现类。LinkedBlockingDeque是一个有界链表双端队列，默认容量为<code>Integer.MAX_VALUE</code>。但与LinkedBlockingQueue不同的是，<strong>该队列不能同时进行出入队操作，因为只有一个独占锁</strong>。并且count计数器不是原子变量，size方法会在调用count时加锁，因此该方法返回值是精确的。</p><h2 id="BlockingQueue实现生产者消费者"><a href="#BlockingQueue实现生产者消费者" class="headerlink" title="BlockingQueue实现生产者消费者"></a>BlockingQueue实现生产者消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"生产了"</span>+<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                Integer integer = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    integer = blockingQueue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"消费了"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Producer producer1 = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line"></span><br><span class="line">        Consumer consumer1 = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        Consumer consumer2 = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(producer1);</span><br><span class="line">        executorService.execute(consumer1);</span><br><span class="line">        executorService.execute(consumer2);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JUC提供了一系列场景的并发安全队列，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，后者使用CAS非阻塞算法实现。&lt;/p&gt;
&lt;h2 id=&quot;非阻塞队列&quot;&gt;&lt;a href=&quot;#非阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;非阻塞队列&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器之ConcurrentHashMap</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/</id>
    <published>2020-09-26T09:10:01.000Z</published>
    <updated>2020-10-13T06:34:12.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#juc%e9%9b%86%e5%90%88-concurrenthashmap%e8%af%a6%e8%a7%a3" target="_blank" rel="noopener">ConcurrentHashMap详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#juc%e9%9b%86%e5%90%88-concurrenthashmap
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器之CopyOnWriteArrayList</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/</id>
    <published>2020-09-26T07:50:39.000Z</published>
    <updated>2020-09-27T02:41:51.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CopyOnWriteArrayList是一个线程安全的ArrayList，底层采用<code>private transient volatile Object[] array;</code>存储数据，使用独占锁ReentrantLock保证同时只有一个线程对array进行修改。另外，该类采用了<strong>写时复制策略</strong>，也即<strong>对array的修改操作都是在一个复制的数组上进行的</strong>。</p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造创建大小为0的Object数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用传入数组的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[]<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用集合元素的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">elements</span> </span>= ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elements</span> </span>= Arrays.copyOf(elements,elements.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//获取独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();<span class="comment">//获取array</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//复制一个新数组</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//在新数组中添加</span></span><br><span class="line">        setArray(newElements);<span class="comment">//将引用指向新数组，旧数组等待GC</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于采用<strong>写时复制策略</strong>，即使我们在调用get方法时没有进行同步，也不会导致获取到错误的值。因为删除操作是在复制的数组上进行的，最后才会将array指向复制的数组。</p><h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="comment">//在新数组上修改指定位置的元素值并设置新数组到array</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果要删除的是最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//复制前半段</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">//复制后半段</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">            <span class="comment">//设置新数组到array</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h4><p>迭代器的弱一致性是指：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。该容器迭代器源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;<span class="comment">//array的快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//数组下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，迭代器的snapshot引用指向旧数组，在迭代的过程中如果有其他线程进行增删改，都是在新创建的数组中进行的，它们操作的是不同的两个数组。</p><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>该容器底层使用CopyOnWriteArrayList实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;CopyOnWriteArrayList是一个线程安全的ArrayList，底层采用&lt;code&gt;private transient vola
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC之锁</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/</id>
    <published>2020-09-21T05:25:08.000Z</published>
    <updated>2020-10-11T13:11:55.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>锁相关类关系图：</p><p><img src="java-thread-x-juc-overview-lock.png" alt=""></p><h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。</p><p>悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。</p><p>乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁，在事务提交时才检测是否存在冲突。乐观锁的实现一般是在表中添加version字段或者使用业务状态。</p><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>公平锁表示线程获取锁的顺序是按照线程请求锁的时间顺序来决定，而非公平锁则按调度策略决定。在没有公平性需求的前提下尽量使用非公平锁，因为公平锁开销较大。</p><p>ReentrantLock提供了公平锁和非公平锁。</p><p>公平锁：<code>ReentrantLock pairLock = new ReentrantLock(true);</code></p><p>非公平锁：<code>ReentrantLock pairLock = new ReentrantLock(false);</code>。如果构造函数不传递参数，则默认为false。</p><h4 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h4><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。</p><p>独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是独占锁。独占锁是一种悲观锁，由于读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，因此限制了并发性。</p><p>共享锁则可以同时多个线程持有，例如ReadWriteLock。共享锁是一种乐观锁，它允许多个线程同时进行读操作。</p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>一个线程再次获取它自己已经获取的锁时不会被阻塞，那么该锁就是可重入锁。synchronized锁和ReentrantLock均为可重入锁。</p><p>可重入锁的原理是在锁内部维护一个线程标识和一个计数器。计数器初始值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁，计数器值+1。当获取了该锁的线程再次获取锁时发现线程标识是自己，计数器值再+1。释放一次锁则计数器值-1。当计数器值为0时，线程标识置null，阻塞线程被唤醒竞争该锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁的思想是<strong>让一个线程在请求一个共享数据的锁时执行忙循环</strong>（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。可以通过<code>-XX:PreBlockSpinsh</code>设置尝试次数，默认为10次。</p><p>JDK层面的锁由java.util.concurrent.locks包提供，其接口和类如下图所示：</p><p><img src="juc_locks.png" alt=""></p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport类是个工具类，其主要作用是挂起和唤醒线程，它是创建锁和其他同步类的基础。</p><p>LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport的方法的线程是<strong>不</strong>持有许可证的。该类是使用Unsafe类实现的。</p><p>LockSupport的构造方法为私有构造方法，无法被实例化，其方法基本为静态方法。</p><h4 id="Unsafe的park和unpark方法"><a href="#Unsafe的park和unpark方法" class="headerlink" title="Unsafe的park和unpark方法"></a>Unsafe的park和unpark方法</h4><p>因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br></pre></td></tr></table></figure><p>对两个函数的说明如下:</p><ul><li>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，给予该线程许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li><li>unpark函数，给予线程许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li></ul><h4 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h4><p>初次调用该方法后，当前线程挂起。</p><p>由于可能存在虚假唤醒的情况，所以调用时最好也使用循环条件判断方式。</p><p>如当前线程被其他线程中断，不会抛出InterruptedException。</p><h4 id="park-Object-blocker"><a href="#park-Object-blocker" class="headerlink" title="park(Object blocker)"></a>park(Object blocker)</h4><p>Thread类中有个变量<code>volatile Object parkBlocker</code>，用于存放该方法传递的blocker对象，也就是把blocker变量存放到了调用该方法的线程成员变量中。</p><p>使用该类的好处是，方便使用诊断工具查看阻塞原因。</p><h4 id="parkNanos-long-nanos"><a href="#parkNanos-long-nanos" class="headerlink" title="parkNanos(long nanos)"></a>parkNanos(long nanos)</h4><p>与park()的不同仅在于会在nanos时间之后自动返回。</p><h4 id="parkUntil-Object-blocker-long-deadline"><a href="#parkUntil-Object-blocker-long-deadline" class="headerlink" title="parkUntil(Object blocker, long deadline)"></a>parkUntil(Object blocker, long deadline)</h4><p>在指定的时间内阻塞线程。deadline单位是ms，表示从1970到未来某个时刻的总毫秒数。</p><h4 id="unpark-Thread-thread"><a href="#unpark-Thread-thread" class="headerlink" title="unpark(Thread thread)"></a>unpark(Thread thread)</h4><p>调用该方法后，如果线程没有持有与LockSupport关联的许可证，则使shi线程持有。如果线程已经因park()而挂起，则唤醒线程。若unpark()调用前未调用过park()，那么由于线程持有许可证，再次调用park()后线程不会挂起并失去许可证。</p><p>注意：park()方法不会释放锁，ConditionObject的await()会释放锁，并且该await()方法挂起线程就是使用park()实现的。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称抽象队列同步器(AbstractQueuedSynchronizer)，它是实现JDK层面锁的基础组件，locks包ReentrantLock和ReentrantReadWriteLock均由AQS实现，同时CountDownLatch与Semaphore也是由AQS实现。</p><h4 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="AQS_UML.png" alt=""></p><p>由该图可知AQS继承自AbstractOwnableSynchronizer，并有内部类ConditionObject和Node。AQS的核心是<strong>state变量</strong>与<strong>队列</strong>，它的所有实现类都是围绕着对此二者的操作来进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>AQS是一个FIFO的双向队列，该队列用于<strong>存放竞争资源失败的线程</strong>，队列元素为Node。Node中的thread变量用来存放进入AQS队列的线程，<strong>SHARED</strong>用于<strong>标记线程是获取共享资源时失败而放入AQS队列</strong>的，<strong>EXCLUSIVE</strong>则用于<strong>标记线程是获取独占资源时失败而放入AQS队列的</strong>，<strong>waitStatus</strong>记录<strong>线程等待状态</strong>，可以取如下值：</p><ol><li><strong>SIGNAL=-1</strong>：线程需要被唤醒。</li><li><strong>CONDITION=-2</strong>：线程在条件队列(ConditionObject)中等待，而非AQS队列。</li><li><strong>CANCELLED=1</strong>：线程被取消了。</li><li><strong>PROPAGATE=-3</strong>：释放共享资源时需要通知其他节点。</li><li>0：线程新加入队列。</li></ol><h5 id="state变量"><a href="#state变量" class="headerlink" title="state变量"></a>state变量</h5><p>在AQS中维持了一个状态值state变量，<strong>AQS的不同实现中对state含义的定义均不同</strong>。JUC中的实现主要如下：</p><ol><li>ReentrantLock：state为0表示没有线程获取锁，大于1的整数表示线程获取锁的可重入次数。</li><li>ReentrantReadWriteLock：state的高16位表示读锁的的个数，低16位表示线程获取写锁的可重入次数。</li><li>Semaphore：state表示当前可用信号的个数。</li><li>CountDownLatch：state表示计数器当前的值。</li></ol><p>操作state的方式分为<strong>独占方式</strong>和<strong>共享方式</strong>，两种方式获取和释放资源使用的方法分别为：</p><ul><li>独占：void acquire(int arg);  void acquireInterruptibly(int arg);  boolean release(int arg)。</li><li>共享：void acquireShared(int arg);  void acquireSharedInterruptibly(int arg);  boolean release(int arg)。</li></ul><p>在上述方法中调用了一系列<strong>需要实现类自己实现的模板方法</strong>，一共有以下五个：</p><p><img src="template_method.png" alt=""></p><h4 id="锁的底层支持"><a href="#锁的底层支持" class="headerlink" title="锁的底层支持"></a>锁的底层支持</h4><h5 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h5><p>该抽象类中定义了一个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><p>表示<strong>独占模式下当前占有锁和资源的线程</strong>。</p><h5 id="独占锁-ReentrantLock与WriteLock"><a href="#独占锁-ReentrantLock与WriteLock" class="headerlink" title="独占锁-ReentrantLock与WriteLock"></a>独占锁-ReentrantLock与WriteLock</h5><p>对于AQS独占锁，当多个线程同时调用lock.lock()获取锁，只有一个线程获取到锁，其他线程会被转换为Node节点插入到lock锁对应的AQS队列中，并做自旋CAS尝试获取锁，尝试失败后阻塞。“自旋CAS/阻塞”的操作在acquireQueued()和doAcquire*()系列方法中实现。</p><p>线程通过调用acquire(int arg)获取独占资源，<strong>void acquire(int arg)源码</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire()尝试CAS修改state值获取锁，若成功则表达式<code>!tryAcquire(arg)</code>为false，&amp;&amp;后的表达式无需继续执行，方法直接结束；若失败，则addWaiter()将当前线程封装为类型为NODE.EXCLUSIVE的Node节点插入AQS队列末尾，acquireQueued()方法中节点自旋CAS尝试获取锁，失败则阻塞。</p><p><strong>addWaiter方法源码</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//判断尾节点是否为null</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//通过CAS完成“tail = node”操作</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果tail为null, 说明当前节点为AQS队列第一个节点，再调用enq入AQS队列</span></span><br><span class="line">    <span class="comment">//或CAS设置tail失败，调用enq方法重新入队</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>enq方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//tail为空则设置当前节点为头(尾)节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//addWaiter中CAS设置tail失败，说明有其他线程竞争进入AQS队列</span></span><br><span class="line">                <span class="comment">//由for循环知，该方法会不断自旋直到当前节点入队成功</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>acquireQueued方法源码</strong>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//只有当前节点是队列中第二个节点时才重新tryAcquire</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">//满足一定条件则阻塞当前线程，停止自旋</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//获取前驱节点的等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//只有当前驱节点等待状态为SIGNAL时才能阻塞当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//取消前驱节点，跳过</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">            <span class="comment">//设置前驱节点的等待状态为SIGNAL，下一次当前节点线程就会阻塞，说明只会自旋一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//shouldParkAfterFailedAcquire返回true，阻塞当前线程，停止自旋，被唤醒后继续执行for循环</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来讲release方法，该方法释放独占方式获取的锁和资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">//释放成功并且头节点不为空，头节点等待状态不为0</span></span><br><span class="line">            <span class="comment">//则唤醒后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="共享锁-ReadLock"><a href="#共享锁-ReadLock" class="headerlink" title="共享锁-ReadLock"></a>共享锁-ReadLock</h5><p>线程通过调用acquireShared方法获取共享资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知，共享方式与独占方式实现类似。tryAcquireShared成功则直接返回，失败则入AQS阻塞队列尾部，自旋一次后阻塞挂起自己。releaseShared源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>释放锁成功则调用doReleaseShared唤醒阻塞队列的<strong>所有</strong>线程。</p><h4 id="条件变量ConditionObejct"><a href="#条件变量ConditionObejct" class="headerlink" title="条件变量ConditionObejct"></a>条件变量ConditionObejct</h4><p>ConditionObject实现了Condition接口，是AQS的内部类，其含义是<strong>条件变量</strong>，用于<strong>结合锁实现同步</strong>。</p><p>ConditionObject通过AQS锁对象的newCondition()创建(该方法是Lock接口的方法，需要实现类实现)，它可以直接访问AQS对象内部的变量，比如state值和队列。<strong>每个ConditionObject对应一个条件队列</strong>（单向链表队列），用于<strong>存放调用await()方法后被阻塞的线程</strong>，而signal()/signalAll()方法用于唤醒条件队列中阻塞的线程并将节点加入AQS队列。条件队列的队头、尾分别为firstWaiter和lastWaiter。</p><p>与synchronized内置锁不同，synchronized只能与一个共享变量的wait()或notify()方法实现同步，而AQS实现的<strong>一个锁可以创建多个ConditionObject</strong>。与wait()和notify()类似，<strong>调用条件变量的await()和signal()之前，必须先获取条件变量对应的锁</strong>，否则也会抛出IllegalMonitorStateException。条件变量使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"begin wait"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">"end wait"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"begin signal"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(<span class="string">"end signal"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin wait</span><br><span class="line">begin signal</span><br><span class="line">end signal</span><br><span class="line">end wait</span><br></pre></td></tr></table></figure><p>注意，<strong>await()方法会释放锁</strong>，而<strong>signal()方法不会释放锁</strong>，<strong>必须手动调用锁对象的unlock()方法</strong>释放锁。await()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//创建类型为Node.CONDITION的节点并加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放当前线程的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode =</span><br><span class="line">             checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//线程被唤醒后在AQS队列中，自旋CAS尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用await()后，在内部会构造一个类型为Node.CONDITION的节点并插入条件队列末尾，之后当前线程会释放锁（修改state的值），然后通过LockSupport阻塞当前线程。另一个线程调用signal()后，<strong>条件队列队头节点出队放入AQS队列的队尾，然后唤醒线程</strong>，该线程继续执行await()方法中<code>LockSupport.park(this)</code>之后的代码，调用acquireQueued()方法<strong>自旋CAS尝试获取锁</strong>。</p><p>最后总结如下图：一个锁对应一个AQS队列，对应多个条件变量，每个条件变量有自己的一个条件队列。</p><p><img src="AQS.png" alt=""></p><h3 id="ReentrantLock详解"><a href="#ReentrantLock详解" class="headerlink" title="ReentrantLock详解"></a>ReentrantLock详解</h3><h4 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ReentrantLock_UML.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法可知，默认是创建非公平锁。</p><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><h5 id="void-lock-方法"><a href="#void-lock-方法" class="headerlink" title="void lock()方法"></a>void lock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.lock();&#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁成功则设置当前线程为独占线程，失败则调用AQS的acquire方法</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非公平锁的体现：如果state为0，不考虑是否有前驱节点，直接CAS获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="comment">//state不为0，但是当前线程是独占线程，则仅仅+1</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;acquire(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//公平锁体现：先检测是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="void-lockInterruptibly-方法"><a href="#void-lockInterruptibly-方法" class="headerlink" title="void lockInterruptibly()方法"></a>void lockInterruptibly()方法</h5><p>该方法对中断进行响应，也即当前线程调用该方法时，如果其他线程调用了当前线程的interrupt方法，则当前线程会抛出InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;sync.acquireInterruptibly(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="boolean-tryLock-方法"><a href="#boolean-tryLock-方法" class="headerlink" title="boolean tryLock()方法"></a>boolean tryLock()方法</h5><p>尝试获取锁。若该方法失败当前线程不会入AQS队列，也不会阻塞。</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><h5 id="void-unlock-方法"><a href="#void-unlock-方法" class="headerlink" title="void unlock()方法"></a>void unlock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock详解"><a href="#ReentrantReadWriteLock详解" class="headerlink" title="ReentrantReadWriteLock详解"></a>ReentrantReadWriteLock详解</h3><p>ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，来满足实际中写少读多的场景。</p><h4 id="类图结构-2"><a href="#类图结构-2" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ReentrantReadWriteLock_UML.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法可知，默认创建非公平锁。</p><p>读写锁的内部维护了一个<em>ReadLock</em>和一个<em>WriteLock</em>，它们依赖继承自AQS的Sync实现具体功能。读写锁使用state的高16位表示读状态，也即读锁线程个数；低16位表示写锁的可重入次数。Sync类源码表现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;<span class="comment">//偏移值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//低16位为0，第17位为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁线程最大个数65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//低15位为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号右移16位，低16位变为原高16位值，原高16位填0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位与运算使高17位为0，低15位不变</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，通过<strong>无符号右移</strong>获取读锁线程个数，通过<strong>与掩码按位与</strong>获取写锁可重入次数。</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><h5 id="下面只介绍tryAcquire方法"><a href="#下面只介绍tryAcquire方法" class="headerlink" title="下面只介绍tryAcquire方法"></a>下面只介绍tryAcquire方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);<span class="comment">//获取写锁可重入次数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;<span class="comment">//说明读锁或写锁已被某线程获取</span></span><br><span class="line">        <span class="comment">//w=0说明有线程获取了读锁，w!=0并且当前线程不是写锁拥有者则返回</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//说明当前线程获取了写锁，判断可重入次数是否超过最大值</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">         setState(c + acquires);<span class="comment">//state+1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//c=0则根据writerShouldBlock的返回值判断是否执行CAS获取写锁</span></span><br><span class="line">     <span class="keyword">if</span> (writerShouldBlock() ||!compareAndSetState(c, c + acquires))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     setExclusiveOwnerThread(current);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于writerShouldBlock，非公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//判断是否有前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：ReentrantReadWriteLock在采用非公平锁并且在读多写少的情况下，容易导致写线程饥饿。可以使用公平锁或者采用<em>StampedLock</em>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h3&gt;&lt;p&gt;锁相关类关系图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;java-thread-x-juc-ov
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC之原子包</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/</id>
    <published>2020-09-19T11:56:16.000Z</published>
    <updated>2020-09-27T02:52:28.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare-And-Swap）"></a>CAS（Compare-And-Swap）</h4><p>比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，<strong>只有当 V 的值等于旧值A，才将 V 的值更新为 B</strong>。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。<strong>CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性</strong>，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。</p><h4 id="CAS使用示例：AtomicInteger"><a href="#CAS使用示例：AtomicInteger" class="headerlink" title="CAS使用示例：AtomicInteger"></a>CAS使用示例：AtomicInteger</h4><p>java.util.concurrent.atomic包中的整数原子类AtomicInteger，其中的修改变量值的方法都采用了Unsafe类的CAS方法。以下代码使用了AtomicInteger执行了自增的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add0</span><span class="params">()</span></span>&#123;count.incrementAndGet();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">()</span></span>&#123;count.getAndIncrement();&#125;</span><br></pre></td></tr></table></figure><p>以下代码是AtomicInteger中上述两个自增方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们均调用了Unsafe类的getAndAddInt()，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数的含义分别是：var1指示对象的起始内存地址，var2指示该字段相对对象内存地址的偏移，var1和var2决定了对象在内存中的位置。var4指示需要加的值，此处为1。</p><p>通过 getIntVolatile(var1, var2) 得到对象的旧值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5(即没有被改变)，那么就更新内存地址为 var1+var2 的变量为 var5+var4。其中 compareAndSwapInt() 方法在Unsafe类中是native方法。我们注意到该方法在while循环中不断执行，对应的逻辑就是<strong>“如果发生冲突则不断尝试执行CAS操作”，这就是基于冲突检测的乐观并发策略</strong>。</p><p>最后需要注意的是，getAndAddInt()方法返回了var5，该值是<strong>旧值</strong>。其实add0和add1方法的执行效果是一样的，都是整数原子对象的值+1，由于incrementAndGet()和getAndIncrement()的返回值是整型，而前者的返回值比后者大1，因此容易误会。<strong>注意整数原子对象的值+1与它们的返回值无关，它的值是通过CAS操作直接修改的！</strong></p><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？</p><p>如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类AtomicStampedReference。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。</p><h5 id="若自旋时间过长则开销大"><a href="#若自旋时间过长则开销大" class="headerlink" title="若自旋时间过长则开销大"></a>若自旋时间过长则开销大</h5><p>如果自旋CAS长时间不成功，那么它会一直占用CPU资源。</p><h5 id="只能保证单个共享变量的原子操作"><a href="#只能保证单个共享变量的原子操作" class="headerlink" title="只能保证单个共享变量的原子操作"></a>只能保证单个共享变量的原子操作</h5><p>如果要保证对多个共享变量操作的原子性，可以将多个共享变量放入AtomicReference对象中，来保证原子性。</p><h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><p>JDK中的rt.jar中sun.misc包中的<em>Unsafe</em>类提供了硬件级别的原子性操作，<em>Unsafe</em>类中的方法绝大部分都是native方法，它们使用JNI访问本地C++实现库。</p><p>Unsafe类主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。因此JDK开发组限制了开发人员通过一般方式使用Unsafe类，比如如下代码会报异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priavte <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure><p>J.U.C中原子类获取Unsafe对象就是如此，Unsafe类提供静态方法getUnsafe()返回Unsafe对象，但是如果<strong>在用户程序中这样写就会报异常</strong>。原因在于getUnsafe()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取调用该方法的类的Class对象</span></span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">//判断是不是BootstrapClassLoader加载的该类</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.misc包下的VM类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSystemDomainLoader</span><span class="params">(ClassLoader var0)</span></span>&#123;<span class="keyword">return</span> var0 == <span class="keyword">null</span>;&#125;</span><br></pre></td></tr></table></figure><p>显然由于用户类是由AppClassLoader加载的，因此会报异常。</p><p>要想使用Unsafe类，可以使用反射来获取unsafe对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Field field = Unsafe.class.getDeclaredField("thUnsafe");</span><br><span class="line">    </span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Unsafe</em>类总体功能如下：</p><p><img src="java-thread-x-atomicinteger-unsafe.png" alt=""></p><p>其中原子操作只支持如下三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure><p>其余关于CAS的常用方法有：getAndAddInt, getAndAddLong, getAndSetInt, getAndSetLong, getAndSetObject。</p><h3 id="原子包"><a href="#原子包" class="headerlink" title="原子包"></a>原子包</h3><p>原子包即java.util.concurrent.atomic包，它包含了一系列的原子性操作类，这些类都是使用非阻塞算法CAS实现的。一共有如下类：</p><p><img src="juc_atomic.png" alt=""></p><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>依旧以AtomicInteger为例，其余原子类原理类似。</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>public final int get()：获取当前值<br>public final int getAndSet(int newValue)：获取当前值，并设置新值<br>public final int getAndIncrement()：获取当前值，并自增<br>public final int getAndDecrement()：获取当前值，并自减<br>public final int getAndAdd(int delta)：获取当前值，并加上预期的值<br>void lazySet(int newValue): 最终会设置成newValue, 使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>以下为部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于获取value字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加detla</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知：使用volatile修饰变量，保证了变量的可见性与有序性；使用CAS操作变量，保证了操作的原子性。因此最终效果与使用synchronized一致。</p><h4 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h4><ul><li><p>AtomicBoolean</p></li><li><p>AtomicInteger</p></li><li><p>AtomicLong</p></li></ul><p>上述三个原子类类似。</p><h4 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h4><p>使更新数组的某个元素满足原子性</p><ul><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li></ul><h4 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h4><ul><li>AtomicReference: 原子更新引用类型。</li><li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReference: 原子更新带有标记位的引用类型。</li></ul><h4 id="原子更新Field"><a href="#原子更新Field" class="headerlink" title="原子更新Field"></a>原子更新Field</h4><ul><li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater: 原子更新引用类型字段的更新器。</li></ul><p>这三个类均为抽象类，使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:</p><ul><li>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第二步，更新类的字段必须使用public volatile修饰。</li></ul><h4 id="JDK8新增的原子操作类LongAdder和DoubleAdder"><a href="#JDK8新增的原子操作类LongAdder和DoubleAdder" class="headerlink" title="JDK8新增的原子操作类LongAdder和DoubleAdder"></a>JDK8新增的原子操作类LongAdder和DoubleAdder</h4><p>使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，那么就会由大量线程因为不断自旋而浪费CPU资源。因此JDK8新增了LongAdder用于克服在高并发下使用AtomicLong的缺点，提升性能。</p><p>如图所示，使用AtomicLong时，是多个线程同时竞争同一个原子变量：</p><p><img src="AtomicLong.png" alt=""></p><p>而使用LongAdder时，则为：</p><p><img src="LongAdder.png" alt=""></p><p>LongAdder维护了一个Cell数组，每个Cell里有一个初始值为0L的long型变量，这样在同等并发量的情况下，争夺单个变量更新操作的线程减少。并且如果多个线程争夺同一个Cell原子变量失败了，它并不是在当前Cell变量上一直自旋CAS重试，而是尝试在其他Cell的变量上进行CAS，这个改变增加了当前线程重试CAS成功的可能性。最后，<strong>在获取LongAdder当前值时，把所有Cell变量的value累加再加上base返回</strong>。</p><p>Cell数组默认是null，只有在高并发的情况下才会创建它。在并发量少的时候所有的累加操作都是对base变量进行的，此时与AtomicLong类似。</p><p>Cell类使用了<code>@sun.misc.Contended</code>修饰进行字节填充，这是因为数组元素的内存地址连续，为了避免伪共享。</p><p>总结：LongAdder在AtomicLong的基础上<strong>将单个变量的更新压力分散到各Cell</strong>，在<strong>低并发的时候通过对base的直接更新可以很好的保障与AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。</strong><br><strong>缺点是LongAdder在求和的时候如果有并发更新，可能导致统计的数据有误差</strong>。</p><p>DoubleAdder与LongAdder类似。</p><h4 id="LongAccmulator和DoubleAccumulator"><a href="#LongAccmulator和DoubleAccumulator" class="headerlink" title="LongAccmulator和DoubleAccumulator"></a>LongAccmulator和DoubleAccumulator</h4><p>LongAdder可以看作是LongAccumulator的一个特例。LongAccumulator的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongAccumulator</span><span class="params">(LongBinaryOperator accumulatorFunction, <span class="keyword">long</span> identity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.function = accumulatorFunction;</span><br><span class="line">    base = <span class="keyword">this</span>.identity = identity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LongBinaryOperator</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据两个参数计算并返回一个值，具体的运算由用户自定义</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用LongAdder其实就相当于如下使用LongAccumulator:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(<span class="keyword">new</span> LongBinaryOperator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>LongAccumulator可以<strong>自定义双目运算规则</strong>（<strong>applyAsLong()的返回值就是要更新的值</strong>。在LongAdder中该值就是<code>base+x</code>，<code>x</code>为其add方法的参数），并且可以<strong>指定base的初始值</strong>，而LongAdder只能默认base为0。</p><h4 id="如何实现AtomicByte-AtomicFloat-AtomicDouble"><a href="#如何实现AtomicByte-AtomicFloat-AtomicDouble" class="headerlink" title="如何实现AtomicByte/AtomicFloat/AtomicDouble?"></a>如何实现AtomicByte/AtomicFloat/AtomicDouble?</h4><p>查看atomic包文档描述，结尾处写道：Additionally, classes are provided only for those types that are commonly useful in intended applications. For example, there is no atomic class for representing <code>byte</code>. In those infrequent cases where you would like to do so, you can use an <code>AtomicInteger</code> to hold <code>byte</code> values, and cast appropriately. You can also hold floats using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#floatToRawIntBits-float-" target="_blank" rel="noopener"><code>Float.floatToRawIntBits(float)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#intBitsToFloat-int-" target="_blank" rel="noopener"><code>Float.intBitsToFloat(int)</code></a> conversions, and doubles using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#doubleToRawLongBits-double-" target="_blank" rel="noopener"><code>Double.doubleToRawLongBits(double)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#longBitsToDouble-long-" target="_blank" rel="noopener"><code>Double.longBitsToDouble(long)</code></a> conversions.</p><p>由文档描述可知，使用Float和Double的方法转换并包装AtomicInteger即可。</p><p>参考：</p><p>《Java并发编程之美》</p><p>《深入理解Java虚拟机》</p><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAS操作&quot;&gt;&lt;a href=&quot;#CAS操作&quot; class=&quot;headerlink&quot; title=&quot;CAS操作&quot;&gt;&lt;/a&gt;CAS操作&lt;/h3&gt;&lt;h4 id=&quot;CAS（Compare-And-Swap）&quot;&gt;&lt;a href=&quot;#CAS（Compare-And-Swap
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC概述</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E6%A6%82%E8%BF%B0/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E6%A6%82%E8%BF%B0/</id>
    <published>2020-09-19T10:05:19.000Z</published>
    <updated>2020-09-27T02:40:50.098Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p><img src="java-thread-x-juc-overview-1.png" alt=""></p><h3 id="原子包"><a href="#原子包" class="headerlink" title="原子包"></a>原子包</h3><h4 id="基础类型"><a href="#基础类型" class="headerlink" title="基础类型"></a>基础类型</h4><p>AtomicBoolean，AtomicInteger，AtomicLong</p><h4 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h4><p>AtomicIntegerArray，AtomicLongArray，AtomicReferenceArray</p><h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>AtomicReference，AtomicMarkableReference，AtomicStampedReference</p><h4 id="FieldUpdater"><a href="#FieldUpdater" class="headerlink" title="FieldUpdater"></a>FieldUpdater</h4><p>AtomicIntegerFieldUpdater, AtomicLongFieldUpdater，AtomicReferenceFieldUpdate</p><h4 id="Adder和Accumulator"><a href="#Adder和Accumulator" class="headerlink" title="Adder和Accumulator"></a>Adder和Accumulator</h4><p>LongAdder, DoubleAdder, LongAccmulator, DoubleAccumulator</p><h3 id="锁和工具类"><a href="#锁和工具类" class="headerlink" title="锁和工具类"></a>锁和工具类</h3><p><img src="java-thread-x-juc-overview-lock.png" alt=""></p><h3 id="并发集合"><a href="#并发集合" class="headerlink" title="并发集合"></a>并发集合</h3><p><img src="java_collections_overview.png" alt=""></p><h3 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h3><p><img src="java-thread-x-juc-executors-1.png" alt=""></p><h3 id="多线程开发的良好习惯"><a href="#多线程开发的良好习惯" class="headerlink" title="多线程开发的良好习惯"></a>多线程开发的良好习惯</h3><ul><li>给线程起个有意义的名字，这样可以方便找 Bug。</li><li>缩小同步范围，从而减少锁争用。例如对于 synchronized，应该尽量使用同步块而不是同步方法。</li><li>多用同步工具少用 wait() 和 notify()。首先，CountDownLatch, CyclicBarrier, Semaphore 和 Exchanger 这些同步类简化了编码操作，而用 wait() 和 notify() 很难实现复杂控制流；其次，这些同步类是由最好的企业编写和维护，在后续的 JDK 中还会不断优化和完善。</li><li>使用 BlockingQueue 实现生产者消费者问题。</li><li>多用并发集合少用同步集合，例如应该使用 ConcurrentHashMap 而不是 Hashtable。</li><li>使用本地变量和不可变类来保证线程安全。</li><li>使用线程池而不是直接创建线程，这是因为创建线程代价很高，线程池可以有效地利用有限的线程来启动任务。</li></ul><p>图片来源均为：</p><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/thread/java-thread-x-juc-overview.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;java-thread-x-juc-overview-1.png&quot; al
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>ThreadLocal源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/ThreadLocal%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-18T07:16:56.000Z</published>
    <updated>2020-10-16T01:23:02.783Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><p>ThreadLocal提供了线程本地变量，也即如果在类中创建了一个ThreadLocal变量，那么<strong>每个访问该变量的线程都会在线程中创建该变量的副本</strong>。<strong>ThreadLocal 实例通常是类中的 private static 字段，它们希望将状态与某一个线程(例如，用户 ID 或事务 ID)相关联</strong>。从JMM的角度来看，主内存中并不会存储实值（无法在类中通过set方法或构造器赋初值），而线程中所有通过threadLocal引用的操作实际上都是操作线程自身工作内存中的副本，而非主内存中的ThreadLocal对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//以下三个变量均存于主内存中</span></span><br><span class="line">    <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> String stringA = <span class="keyword">new</span> String(<span class="string">"stringA"</span>);</span><br><span class="line"></span><br><span class="line">    String stringB = <span class="keyword">new</span> String(<span class="string">"stringB"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//主线程threadLocal值设置为threadLocalString, 实际上设置主线程工作内存中副本的值</span></span><br><span class="line">        threadLocal.set(<span class="string">"threadLocalString"</span>);</span><br><span class="line">        Test test = <span class="keyword">new</span> Test();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//子线程修改三个值</span></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            threadLocal.set(<span class="string">"1"</span>);</span><br><span class="line">            stringA = <span class="string">"2"</span>;</span><br><span class="line">            test.stringB = <span class="string">"3"</span>;</span><br><span class="line">            <span class="comment">//子线程工作内存读取的值</span></span><br><span class="line">            System.out.println(threadLocal.get());</span><br><span class="line">            System.out.println(stringA);</span><br><span class="line">            System.out.println(test.stringB);</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程工作内存中读取的值</span></span><br><span class="line">        System.out.println(threadLocal.get());</span><br><span class="line">        System.out.println(stringA);</span><br><span class="line">        System.out.println(test.stringB);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出结果为：</p><p>1<br>2<br>3<br>threadLocalString<br>2<br>3</p><p>由结果可知，<strong>类<em>ThreadLocal</em>变量不会像普通类实例变量和类静态变量那样，将线程中修改的值同步回主内存</strong>。</p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><p>首先来看ThreadLocal中的set()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">        map.set(<span class="keyword">this</span>, value);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        createMap(t, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol><li><p><code>Thread t = Thread.currentThread();</code>：获取当前线程对象；</p></li><li><p><code>ThreadLocalMap map = getMap(t);</code> ：获取当前线程对象的ThreadLocalMap。</p><p>查看源码发现这是一个定制化的哈希表，其key为ThreadLocal对象引用，value就是我们设置的值。getMap()方法与<strong>Thread类的threadLocals变量</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal成员方法</span></span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Thread类成员变量</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p>Thread中threadLocals被设计成map结构，那么显然一个线程可以关联多个ThreadLocal变量。</p></li><li><p><code>if-else</code>：如果当前线程的threadLocals不为空，则以当前ThreadLocal对象为key设置键值对。否则调用createMap()方法创建哈希表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">    t.threadLocals = </span><br><span class="line">        <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ol><p>再来看get()和remove()方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Thread t = Thread.currentThread();</span><br><span class="line">    ThreadLocalMap map = getMap(t);</span><br><span class="line">    <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">            T result = (T)e.value;</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> setInitialValue();<span class="comment">//若map为空则初始化并返回</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     T value = initialValue();</span><br><span class="line">     Thread t = Thread.currentThread();</span><br><span class="line">     ThreadLocalMap map = getMap(t);</span><br><span class="line">     <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">         map.set(<span class="keyword">this</span>, value);</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">         createMap(t, value);</span><br><span class="line">     <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般创建ThreadLocal时会重写该方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">    <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">        <span class="comment">//由于Entry继承自WeakReference,该方法最终调用Reference的clear()方法清除对象引用</span></span><br><span class="line">        m.remove(<span class="keyword">this</span>);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>总结：每个线程内部都有一个threadLocals成员变量，该变量类型为定制化的哈希表结构，其key为ThreadLocal的this引用，value为我们设置的值。每个线程的本地变量存放在自己工作内存中的threadLocals中。ThreadLocal就是一个工具类，它提供的方法就是为了Thread中的threadLocals而服务。</p><p>——————————————待补充———————————————————————-</p><h3 id="ThreadLocal造成内存泄漏"><a href="#ThreadLocal造成内存泄漏" class="headerlink" title="ThreadLocal造成内存泄漏"></a>ThreadLocal造成内存泄漏</h3><p>由于ThreadLocalMap的生命周期跟Thread一样长，如果没有手动删除Entry对象的引用就会导致内存泄漏。</p><h3 id="ThreadLocal使用场景"><a href="#ThreadLocal使用场景" class="headerlink" title="ThreadLocal使用场景"></a>ThreadLocal使用场景</h3><h4 id="数据库链接管理"><a href="#数据库链接管理" class="headerlink" title="数据库链接管理"></a>数据库链接管理</h4><p>使用ThreadLocal对象把Connection绑定到线程，使得线程中只有一个能控制事务的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.utils;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.SQLException;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 连接的工具类，从数据源中获取一个连接，并实现和线程的绑定</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConnectionUtils</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setDataSource</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = dataSource;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> ThreadLocal&lt;Connection&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;Connection&gt;()&#123;</span><br><span class="line">        <span class="comment">//若初次调用threadLocal.get()时线程的ThreadLocalMap为空，则初始化</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> Connection <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> dataSource.getConnection();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SQLException throwables) &#123;</span><br><span class="line">                throwables.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取当前线程上的连接</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">getThreadConnection</span><span class="params">()</span></span>&#123; </span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span></span>&#123;</span><br><span class="line">        threadLocal.remove();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Session管理"><a href="#Session管理" class="headerlink" title="Session管理"></a>Session管理</h4><p><a href="https://www.zhihu.com/search?type=content&amp;q=ThreadLocal" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=ThreadLocal</a></p><h3 id="InheritableThreadLocal"><a href="#InheritableThreadLocal" class="headerlink" title="InheritableThreadLocal"></a>InheritableThreadLocal</h3><p>InheritableThreadLocal继承自ThreadLocal，它可以让子线程访问在父线程中设置的本地变量。</p><h4 id="源码剖析-1"><a href="#源码剖析-1" class="headerlink" title="源码剖析"></a>源码剖析</h4><h4 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;基本使用&quot;&gt;&lt;a href=&quot;#基本使用&quot; class=&quot;headerlink&quot; title=&quot;基本使用&quot;&gt;&lt;/a&gt;基本使用&lt;/h3&gt;&lt;p&gt;ThreadLocal提供了线程本地变量，也即如果在类中创建了一个ThreadLocal变量，那么&lt;strong&gt;每个访问该
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java并发基础总结</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%B9%B6%E5%8F%91%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</id>
    <published>2020-09-13T09:07:19.000Z</published>
    <updated>2020-09-19T10:58:52.127Z</updated>
    
    <content type="html"><![CDATA[<h3 id="线程的实现"><a href="#线程的实现" class="headerlink" title="线程的实现"></a>线程的实现</h3><p>Thread类的所有关键方法都是声明为native的，也即Java线程的实现本质是使用平台的实现手段。</p><p>JDK1.2后，线程模型替换为基于操作系统原生线程模型来实现。</p><h3 id="Java线程优先级"><a href="#Java线程优先级" class="headerlink" title="Java线程优先级"></a>Java线程优先级</h3><p>Java一共设置了10个级别的线程优先级，在两个线程同时处于Ready状态时，优先级高的线程更容易被系统选择执行。</p><p>Java的线程优先级是通过映射到系统的原生线程上实现的，因此线程调度最终取决于操作系统，并且操作系统的优先级并不能与Java的优先级一一对应。例如Solaris中有2^32种优先级，Windows只有7种。Windows平台的JDK中使用了除THREAD_PRIORITY_IDLE之外的其余6种线程优先级，对应关系如下表：</p><div class="table-container"><table><thead><tr><th>Java线程优先级</th><th>Window线程优先级</th></tr></thead><tbody><tr><td>1（Thread.MIN_PRIORITY）</td><td>THREAD_PRIORITY_LOWEST</td></tr><tr><td>2</td><td>THREAD_PRIORITY_LOWEST</td></tr><tr><td>3</td><td>THREAD_PRIORITY_BELOW_NORMAL</td></tr><tr><td>4</td><td>THREAD_PRIORITY_BELOW_NORMAL</td></tr><tr><td>5（Thread.NORM_PRIORITY）</td><td>THREAD_PRIORITY_NORMAL</td></tr><tr><td>6</td><td>THREAD_PRIORITY_ABOVE_NORMAL</td></tr><tr><td>7</td><td>THREAD_PRIORITY_ABOVE_NORMAL</td></tr><tr><td>8</td><td>THREAD_PRIORITY_HIGHEST</td></tr><tr><td>9</td><td>THREAD_PRIORITY_HIGHEST</td></tr><tr><td>10（Thread.MAX_PRIORITY）</td><td>THREAD_PRIORITY_CRITICAL</td></tr></tbody></table></div><h3 id="状态转换"><a href="#状态转换" class="headerlink" title="状态转换"></a>状态转换</h3><p>Java线程状态转换图如下：</p><p><img src="Java_Thread_State.png" alt=""></p><ul><li><p>New：创建后尚未启动。</p></li><li><p>Runnable：包括了操作系统线程状态中的Ready和Runnning。</p></li><li><p>Waiting（无限期等待）：处于该状态的线程要等待被其他线程显式地唤醒。</p><p><img src="Waiting.png" alt=""></p></li><li><p>Timed Waiting（限期等待）：无需等待其它线程显式地唤醒，在一定时间之后会被系统自动唤醒。</p><p><img src="Timed_Waiting.png" alt=""></p></li><li><p>Blocked：等待获取一个排它锁。阻塞和等待的区别在于，<strong>阻塞是被动</strong>的，而<strong>等待线程是主动进入</strong>的。</p></li></ul><h3 id="使用线程"><a href="#使用线程" class="headerlink" title="使用线程"></a>使用线程</h3><p>有以下三种使用线程的方法，其中实现 Runnable 和 Callable 接口的类只能当做一个可以在线程中运行的任务，因此最后还需要通过 Thread 来调用。可以理解为任务是通过线程驱动从而执行的。</p><h4 id="继承Thread"><a href="#继承Thread" class="headerlink" title="继承Thread"></a>继承Thread</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest</span></span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用start()后该线程进入就绪态。</p><h4 id="实现Runnable接口"><a href="#实现Runnable接口" class="headerlink" title="实现Runnable接口"></a>实现Runnable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    MyRunnable instance = <span class="keyword">new</span> MyRunnable();</span><br><span class="line">    Thread thread = <span class="keyword">new</span> Thread(instance);</span><br><span class="line">    thread.start();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="实现Callable接口"><a href="#实现Callable接口" class="headerlink" title="实现Callable接口"></a>实现Callable接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyCallable</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">Integer</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">call</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> ExecutionException, InterruptedException </span>&#123;</span><br><span class="line">    FutureTask&lt;Integer&gt; ft = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> MyCallable());</span><br><span class="line">    <span class="keyword">new</span> Thread(ft).start();</span><br><span class="line">    System.out.println(ft.get());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用FutureTask任务有返回值。</p><h4 id="实现接口与继承Thread选择？"><a href="#实现接口与继承Thread选择？" class="headerlink" title="实现接口与继承Thread选择？"></a>实现接口与继承Thread选择？</h4><p>最好选择接口。</p><ol><li><strong>Java类不支持多继承</strong>，如果继承了Thread类就不能再继承其他类。而<strong>接口则可以多继承与多实现</strong>。</li><li>继承Thread，<strong>任务与线程代码没有分离</strong>，耦合度高，不符合软件工程“高内聚低耦合”的原则。</li><li><strong>继承Thread整个类开销过大</strong>。</li></ol><h3 id="线程之间的协作"><a href="#线程之间的协作" class="headerlink" title="线程之间的协作"></a>线程之间的协作</h3><h4 id="wait-notify-notifyAll"><a href="#wait-notify-notifyAll" class="headerlink" title="wait()/notify()/notifyAll()"></a>wait()/notify()/notifyAll()</h4><p>以上三个方法均属于Object类而非Thread。</p><p><strong>当一个线程调用一个共享变量的wait()方法时，该线程必须事先获取该共享变量的监视器锁</strong>，否则调用时会抛出IllegalMonitorStateException异常。调用wait()方法后，该线程会释放共享变量的监视器锁，然后挂起。以下事情可以唤醒该线程：</p><ol><li>其他线程获取锁后执行任务完毕后，调用该共享变量的notify()或notifyAll()方法并且释放锁。如果有多个线程在等待，notify()会随机唤醒一个，而notifyAll()则唤醒所有，然后由这些线程来竞争监视器锁，这些线程会依次得到锁并释放锁。</li><li>其他线程调用该线程的interrupt()方法，该线程抛出InterruptedException异常返回。</li></ol><p>一个线程获取共享变量的监视器锁有两种方式：</p><ol><li><p><strong>执行同步块代码，使用该共享变量作为参数</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(<span class="comment">/*共享变量*/</span>)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>调用该共享变量的同步方法</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ol><p>注意，一个线程可以从挂起态变为运行态，即使其他线程没有唤醒或中断该线程或这该线程等待超时，即所谓<strong>虚假唤醒</strong>。可以通过循环来防止虚假唤醒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obj)&#123;</span><br><span class="line">    <span class="keyword">while</span>(<span class="comment">/*条件不满足则一直等待*/</span>)&#123;</span><br><span class="line">        obj.wait();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以生产者消费者为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//生产线程部分代码，异常在方法外处理</span></span><br><span class="line"><span class="keyword">synchronized</span>(queue)&#123;</span><br><span class="line">    <span class="comment">//队列满则不需要再生产</span></span><br><span class="line">    <span class="keyword">while</span>(queue.size() == MAX_SIZE)&#123;</span><br><span class="line">        queue.wait();<span class="comment">//挂起并释放queue的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue.add(e);</span><br><span class="line">    queue.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//消费线程部分代码，异常在方法外处理</span></span><br><span class="line"><span class="keyword">synchronized</span>(queue)&#123;</span><br><span class="line">    <span class="comment">//队列空则不能消费</span></span><br><span class="line">    <span class="keyword">while</span>(queue.size() == <span class="number">0</span>)&#123;</span><br><span class="line">        queue.wait();<span class="comment">//挂起并释放queue的锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    queue.take();</span><br><span class="line">    queue.notifyAll();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关于调用wait()后释放锁，如果该线程持有多个对象的锁，那么调用了谁的wait，就只释放它的锁，并不会释放其他共享对象的锁。</p><h4 id="await-signal-signalAll"><a href="#await-signal-signalAll" class="headerlink" title="await()/signal()/signalAll()"></a>await()/signal()/signalAll()</h4><p>J.U.C包中提供了 Condition 类来实现线程之间的协调，可以在 Condition 上调用 await() 方法使线程等待，其它线程调用 signal() 或 signalAll() 方法唤醒等待的线程。</p><h4 id="join"><a href="#join" class="headerlink" title="join()"></a>join()</h4><p>在线程A中调用线程B的join() 方法，线程A阻塞，直到线程B执行完毕。</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt()"></a>interrupt()</h4><p>通过调用一个线程的 interrupt() 来中断该线程，如果该线程处于阻塞、限期等待或者无限期等待状态，那么就会抛出 InterruptedException，从而提前结束该线程。但是不能中断 I/O 阻塞和 synchronized 锁阻塞。</p><h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><h4 id="interrupt-1"><a href="#interrupt-1" class="headerlink" title="interrupt()"></a>interrupt()</h4><p>线程A运行时，线程B可以调用A的interrupt()方法来设置A的中断标志为true并立即返回。<strong>此时线程A实际并没有被中断，它会继续往下执行</strong>。<strong>但是如果A因为调用了wait()系列方法、join()方法、或者sleep()方法而被挂起，此时B若调用A的interrupt()方法，A会在调用这些方法的地方抛出InterruptedException异常而返回。</strong></p><h4 id="interrupted-isInterrupted"><a href="#interrupted-isInterrupted" class="headerlink" title="interrupted()/isInterrupted()"></a>interrupted()/isInterrupted()</h4><p>如果一个线程的 run() 方法执行一个无限循环，并且没有执行 sleep() 等会抛出 InterruptedException 的操作，那么调用线程的 interrupt() 方法就无法使线程提前结束。</p><p>但是调用 interrupt() 方法会设置线程的中断标记，此时调用 interrupted() 方法会返回 true。因此可以在循环体中使用 interrupted() 方法来判断线程是否处于中断状态，从而提前结束线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptExample</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span> (!Thread.interrupted()) &#123;</span><br><span class="line">                <span class="comment">// ..</span></span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"Thread end"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">        thread.interrupt();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看interrupted源码，发现其返回的是<strong>当前线程的中断标志</strong>，并且返回后将中断标志重置为false。这里需要注意的是假如在main方法中有这样一句: <code>threadA.interrupted()</code>，此时返回的<strong>不是threadA的中断标志而是主线程（main方法所在线程）的</strong>。而上述代码while循环中则返回的是<code>MyThread</code>的中断标志。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure><p>而要获取某个具体线程对象的中断标志，则应该用isInterrupted()方法。</p><h3 id="Thread其他常见方法"><a href="#Thread其他常见方法" class="headerlink" title="Thread其他常见方法"></a>Thread其他常见方法</h3><h4 id="join-1"><a href="#join-1" class="headerlink" title="join()"></a>join()</h4><p>项目中经常会遇到“等待其他几个线程执行完毕后才能继续往下执行”的场景，比如多个线程加载资源，需要等待多个线程全部加载完毕再汇总处理。Thread的join()则可以满足该场景的需求。</p><p>join()的作用：在线程A中调用线程B的join() 方法，线程A进入waiting状态，直到线程B执行完毕。</p><h4 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h4><p>sleep(long millis)是Thread类的static native方法，单位是毫秒。调用<code>Thread.sleep(1000)</code>并不会释放锁，进入<strong>timed waiting状态</strong>，1000毫秒过后该线程自动唤醒进入就绪态等待CPU调度。</p><h4 id="yield"><a href="#yield" class="headerlink" title="yield()"></a>yield()</h4><p>Thread类的静态方法。当一个线程调用yield方法时，实际就是在暗示线程调度器当前线程请求让出自己的CPU使用，但是线程调度器可以无条件忽略该暗示。</p><p>如果当前线程成功让出CPU使用权，会进入<strong>就绪态</strong>，甚至可能发生刚让出CPU使用权就又被调度到运行态的情况。</p><p>该方法可用于调试或测试时复现并发竞争条件导致的问题。</p><h4 id="setDaemon-Boolean-boolean"><a href="#setDaemon-Boolean-boolean" class="headerlink" title="setDaemon(Boolean boolean)"></a>setDaemon(Boolean boolean)</h4><p>Java中线程分为<strong>daemon（守护）线程</strong>和<strong>user线程</strong>两类，其中守护线程是程序运行时在后台提供服务的线程，不属于程序中不可或缺的部分，比如垃圾回收线程就是守护线程，而main方法所在的线程则是主线程。</p><p>当所有用户线程结束时，程序也就终止，同时会杀死所有守护线程。</p><p>通过在线程调用start()之前<code>myThread.setDaemon(true);</code>来设置该线程为守护线程。</p><p>总结：如果希望主线程结束后JVM进程马上结束，就将子线程设置为守护线程。</p><h4 id="面试：wait-与sleep-区别？"><a href="#面试：wait-与sleep-区别？" class="headerlink" title="面试：wait()与sleep()区别？"></a>面试：wait()与sleep()区别？</h4><ol><li>wait()是Object的方法，sleep()是Thread的方法。</li><li>wait()会释放锁，sleep()不会。</li></ol><h3 id="线程死锁"><a href="#线程死锁" class="headerlink" title="线程死锁"></a>线程死锁</h3><h4 id="死锁产生必备四条件"><a href="#死锁产生必备四条件" class="headerlink" title="死锁产生必备四条件"></a>死锁产生必备四条件</h4><ul><li><strong>互斥</strong>： 线程获取到的资源只能自己使用，其他请求该资源的线程只能等待。</li><li><strong>请求并持有</strong>：线程请求被其他线程占有资源的同时，并不释放已经持有的资源。</li><li><strong>不可剥夺</strong>：线程获取到的资源只能由线程使用完后自己释放。</li><li><strong>环路</strong>：线程-资源形成闭环。</li></ul><h4 id="避免死锁"><a href="#避免死锁" class="headerlink" title="避免死锁"></a>避免死锁</h4><p>只要破坏死锁产生必备的四个条件之一就可以避免死锁，但是目前只能通过<strong>避免形成环路</strong>来完成，也即可以使用<strong>资源申请的有序性原则</strong>。</p><h3 id="synchronized关键字"><a href="#synchronized关键字" class="headerlink" title="synchronized关键字"></a>synchronized关键字</h3><ul><li><p>同步代码块：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">A</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(obj)&#123;&#125;<span class="comment">//锁对象是obj</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>)&#123;&#125;<span class="comment">//锁对象是A的实例对象</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span>(A<span class="class">.<span class="keyword">class</span>)</span>&#123;&#125;<span class="comment">//锁对象是类Class对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>同步方法：锁对象是实例对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>静态同步方法：锁对象是类Class对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">func</span><span class="params">()</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>volatile虽然保证了<strong>可见性</strong>和<strong>有序性</strong>，但是并不保证原子性，通过Java内存模型与Java规范的内存间交互操作我们知道，volatile关键字不满足原子性的原因就是，虽然其通过{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}满足了可见性，但是<u><strong>只要{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不是原子的，那么一个线程对一个变量的操作就不是原子的</strong></u>。比如多线程计时器程序：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)&#123;</span><br><span class="line">            <span class="keyword">new</span> Thread(() -&gt; &#123;<span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++) count++;&#125;).start();</span><br><span class="line">        &#125;</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        System.out.println(count);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用volatile修饰count，显然在一个线程对一个变量进行{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}操作的时候，其他线程也可以进行这两个操作，这就导致了count的值最终一定会小于60000。而如果对内部for循环加synchronized块，那么它可以通过lock和unlock操作保证同步块中变量的修改一定满足{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不被其他线程打断。</p><h4 id="volatile的使用场景"><a href="#volatile的使用场景" class="headerlink" title="volatile的使用场景"></a>volatile的使用场景</h4><p>使用条件：<strong>写入变量值不依赖当前值时</strong>。因为如果依赖当前值，则必须保证{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}满足原子性。</p><p>常见场景：</p><ul><li><p>状态标志</p></li><li><p>一次性安全发布(one-time safe publication)</p></li><li><p>独立观察(independent observation)</p></li><li><p>volatile bean</p></li><li><p>开销较低的读-写锁策略</p></li><li><p>双重检查(double-checked)</p></li></ul><p>参考列表：</p><p>《Java并发编程之美》</p><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/thread/java-thread-x-thread-basic.html</a></p><p><a href="https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91" target="_blank" rel="noopener">https://cyc2018.github.io/CS-Notes/#/notes/Java%20%E5%B9%B6%E5%8F%91</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;线程的实现&quot;&gt;&lt;a href=&quot;#线程的实现&quot; class=&quot;headerlink&quot; title=&quot;线程的实现&quot;&gt;&lt;/a&gt;线程的实现&lt;/h3&gt;&lt;p&gt;Thread类的所有关键方法都是声明为native的，也即Java线程的实现本质是使用平台的实现手段。&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>线程安全与锁优化</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96/</id>
    <published>2020-09-12T12:39:28.000Z</published>
    <updated>2020-09-21T12:11:40.100Z</updated>
    
    <content type="html"><![CDATA[<h2 id="线程安全"><a href="#线程安全" class="headerlink" title="线程安全"></a>线程安全</h2><h3 id="Java中的线程安全"><a href="#Java中的线程安全" class="headerlink" title="Java中的线程安全"></a>Java中的线程安全</h3><p>线程安全不是一个非真即假的命题，可以<strong>将共享数据按照安全程度的强弱顺序分成以下五类</strong>: 不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。</p><h4 id="不可变"><a href="#不可变" class="headerlink" title="不可变"></a>不可变</h4><p>不可变的对象一定是线程安全的，因此不需要再采取任何的线程安全保障措施。</p><p>不可变的类型：</p><ul><li>final修饰的基本数据类型</li><li>String</li><li>枚举类型</li><li>java.lang.Number的部分子类，如 Long 和 Double 等数值包装类型，BigInteger 和 BigDecimal 等大数据类型。但同为 Number 的原子类 AtomicInteger 和 AtomicLong 则是可变的。</li></ul><h4 id="绝对线程安全"><a href="#绝对线程安全" class="headerlink" title="绝对线程安全*"></a>绝对线程安全*</h4><p>不管运行环境如何，调用者都不需要任何额外的同步措施。Java API中标注自己是线程安全的类，大多都不是绝对的线程安全，经常需要其他的同步措施。</p><h4 id="相对线程安全"><a href="#相对线程安全" class="headerlink" title="相对线程安全"></a>相对线程安全</h4><p>相对的线程安全才是我们通常意义上所讲的线程安全，它需要保证对这个对象是线程安全的，但是对于一些特定顺序的连续调用，就可能需要在调用端使用额外的同步手段。Java中大部分都属于这种类型，例如Vector、HashTable、Collections的synchronizedCollection()方法包装的集合等。</p><h4 id="线程兼容"><a href="#线程兼容" class="headerlink" title="线程兼容"></a>线程兼容</h4><p>线程兼容是指对象本身并不是线程安全的，但是可以通过在调用端正确地使用同步手段来保证对象在并发环境中可以安全地使用，我们平常说一个类不是线程安全的，绝大多数时候指的是这一种情况。Java API 中大部分的类都是属于线程兼容的，如与前面的 Vector 和 HashTable 相对应的集合类 ArrayList 和 HashMap 等。</p><h4 id="线程对立"><a href="#线程对立" class="headerlink" title="线程对立*"></a>线程对立*</h4><p>线程对立是指无论调用端是否采取了同步措施，都无法在多线程环境中并发使用的代码。</p><h3 id="线程安全-1"><a href="#线程安全-1" class="headerlink" title="线程安全"></a>线程安全</h3><h4 id="互斥同步"><a href="#互斥同步" class="headerlink" title="互斥同步"></a>互斥同步</h4><ul><li><strong>同步</strong>：多个线程并发访问共享数据时，保证共享数据在同一个时刻只被一个线程使用。</li><li><strong>互斥</strong>：互斥是实现同步的手段，主要有<strong>临界区</strong>、<strong>互斥量</strong>、<strong>信号量</strong>等方式。互斥是方法，同步是目的。</li><li>Java中实现同步的方式有synchronized关键字和J.U.C包的ReentrantLock。前者表现为原生语法层面的互斥锁，后者表现为API层面的互斥锁（lock()、unlock()配合try/finally语句来完成）。ReentrantLock增加了一些高级功能，主要有：<ol><li>等待可中断：当持有锁的线程长期不释放锁的时候，等待的线程可选择放弃等待改为处理其他事情。</li><li>公平锁：指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁。ReentrantLock默认非公平，但可在构造方法中指定为true。</li><li>锁可以绑定多个条件：指一个ReentrantLock对象可以同时绑定多个Condition对象。</li></ol></li></ul><h4 id="非阻塞同步"><a href="#非阻塞同步" class="headerlink" title="非阻塞同步"></a>非阻塞同步</h4><p>互斥同步最主要的问题就是线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。</p><p><strong>互斥同步</strong>属于一种<strong>悲观</strong>的并发策略，总是认为只要不去做正确的同步措施，那就肯定会出现问题。无论共享数据是否真的会出现竞争，它都要进行加锁（这里讨论的是概念模型，实际上虚拟机会优化掉很大一部分不必要的加锁）、用户态核心态转换、维护锁计数器和检查是否有被阻塞的线程需要唤醒等操作。</p><p>随着硬件指令集的发展，我们可以使用<strong>基于冲突检测的乐观并发策略</strong>：先进行操作，如果没有其它线程争用共享数据，那操作就成功了，否则采取补偿措施（不断地重试，直到成功为止）。<strong>这种乐观的并发策略的许多实现都不需要将线程阻塞</strong>，因此<strong>这种同步操作称为非阻塞同步</strong>。</p><h5 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare-And-Swap）"></a>CAS（Compare-And-Swap）</h5><p>比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，<strong>只有当 V 的值等于旧值A，才将 V 的值更新为 B</strong>。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。<strong>CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性</strong>，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。</p><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？</p><p>如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类<em>AtomicStampedReference</em>。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。</p><h4 id="无同步方案"><a href="#无同步方案" class="headerlink" title="无同步方案"></a>无同步方案</h4><p>如果一个方法本就不涉及共享数据，那么它天生就是线程安全的。</p><h5 id="可重入代码"><a href="#可重入代码" class="headerlink" title="可重入代码"></a>可重入代码</h5><p>可重入代码一定是线程安全的。</p><p>这种代码也叫做纯代码（Pure Code），可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用它本身），而在控制权返回后，原来的程序不会出现任何错误。</p><p>可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源、用到的状态量都由参数中传入、不调用非可重入的方法等。</p><h5 id="线程本地存储"><a href="#线程本地存储" class="headerlink" title="线程本地存储"></a>线程本地存储</h5><p>可以使用 <em>java.lang.ThreadLocal</em> 类来实现线程本地存储功能。详解参照“<em>ThreadLocal</em>源码剖析”。</p><h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>此处指JVM对synchronized的优化。</p><h4 id="自旋锁与自适应自旋"><a href="#自旋锁与自适应自旋" class="headerlink" title="自旋锁与自适应自旋"></a>自旋锁与自适应自旋</h4><p>互斥同步进入阻塞状态的开销都很大，应该尽量避免。在许多应用中，共享数据的锁定状态只会持续很短的一段时间。自旋锁的思想是<strong>让一个线程在请求一个共享数据的锁时执行忙循环</strong>（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。</p><p>自旋锁虽然能避免进入阻塞状态从而减少开销，但是它需要进行忙循环操作<strong>占用 CPU 时间</strong>，它<strong>只适用于共享数据的锁定状态很短的场景</strong>。</p><p>在 JDK 1.6 中引入了<strong>自适应的自旋锁</strong>。自适应<strong>意味着自旋的次数不再固定了，而是由前一次在同一个锁上的自旋次数及锁的拥有者的状态来决定。</strong></p><h4 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h4><p>虚拟机在JIT编译器运行时，对一些代码上要求同步，但是被检测出不可能存在共享数据竞争的锁进行消除。</p><p>锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断在一段代码中，堆上的所有数据都不会逃逸出去而被其他线程访问到，那就可以把它们当作栈上数据对待。</p><h4 id="锁粗化"><a href="#锁粗化" class="headerlink" title="锁粗化"></a>锁粗化</h4><p>如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁的范围扩展（粗化）到整个操作序列的外部。</p><h4 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h4><p>JDK 1.6 引入了偏向锁和轻量级锁，从而让锁拥有了四个状态：无锁状态（unlocked）、偏向锁状态（biasble）、轻量级锁状态（lightweight locked）和重量级锁状态（inflated）。</p><p><strong>轻量级锁是相对于传统的重量级锁（synchronized）而言，它使用 CAS 操作来避免重量级锁使用互斥量的开销。</strong></p><h4 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h4><p>偏向锁也是JDK1.6引入的一项锁优化，它的目的是消除数据在无竞争情况下的同步原语，甚至CAS也不需要。</p><p><strong>偏向锁偏向于第一个获得它的线程</strong>，在接下来的执行过程中，<strong>如果该锁没有被其他线程获取，那么第一个线程访问同步块时则永远不需要同步</strong>。当其他线程获取该锁后，则结束偏向状态。</p><p>参考：</p><p>《深入理解Java虚拟机》 周志明</p><p>《Java并发编程之美》</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;线程安全&quot;&gt;&lt;a href=&quot;#线程安全&quot; class=&quot;headerlink&quot; title=&quot;线程安全&quot;&gt;&lt;/a&gt;线程安全&lt;/h2&gt;&lt;h3 id=&quot;Java中的线程安全&quot;&gt;&lt;a href=&quot;#Java中的线程安全&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>Java内存模型</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/Java%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-09-12T12:39:07.000Z</published>
    <updated>2020-09-22T09:22:40.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java指令重排序"><a href="#Java指令重排序" class="headerlink" title="Java指令重排序"></a>Java指令重排序</h3><p>Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依赖性的指令重排序。但是指令重排在多线程程序中可能会出问题。</p><h3 id="主内存与工作内存"><a href="#主内存与工作内存" class="headerlink" title="主内存与工作内存"></a>主内存与工作内存</h3><p>Java虚拟机规范中试图定义一种Java内存模型来屏蔽掉各种硬件和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。（C/C++直接使用物理硬件和操作系统的内存模型，因此可能会由于平台差异导致同一份代码无法正常运行。）</p><p>JMM规定了所有的变量都存储在主内存中。注意：</p><ol><li><strong>此处的变量不包括局部变量与方法参数</strong>，<strong>因为它们是线程私有的</strong>。</li><li><strong>此处的主内存与硬件的主内存不同</strong>，<strong>此处仅是JVM内存的一部分</strong>。</li></ol><p>每条线程还有自己的工作内存，线程的工作内存中<strong>保存了被该线程使用到的变量的主内存拷贝副本</strong>（如果是对象，不会拷贝整个对象，只会拷贝某些字段值）。</p><p>线程对变量的所有操作都必须在工作内存中进行，而不能直接读写主内存中的变量，不同线程之间也无法访问对方的工作内存。JMM示意图如下：</p><p><img src="JMM_Model.png" alt=""></p><p>这与硬件的缓存访问操作很相似：</p><p><img src="CPU_Cache.png" alt=""></p><h3 id="内存间交互操作"><a href="#内存间交互操作" class="headerlink" title="内存间交互操作"></a>内存间交互操作</h3><p>JMM定义了8种操作来完成主内存和工作内存之间的交互，<strong>这些操作是原子的、不可再分的</strong>。</p><p><img src="JMM_Operation.png" alt=""></p><ul><li>lock: 作用于主内存，把一个变量标识为一条线程独占。</li><li>unlock: 作用于主内存，把一个锁定状态的变量释放。</li><li>read: 把一个变量的值从主内存传输到工作内存。</li><li>load: 把read操作得到的值放入工作内存的变量副本中。</li><li>use: 把工作内存变量的值传递给执行引擎。每当虚拟机遇到一个需要使用到变量的值的字节码指令时会执行此操作。</li><li>assign:  把执行引擎接收到的值赋给工作内存的变量。</li><li>store: 把工作内存的一个变量值传输到主内存。</li><li>write: 把store传的值放入主内存的变量中。</li></ul><h3 id="内存模型三大特征"><a href="#内存模型三大特征" class="headerlink" title="内存模型三大特征"></a>内存模型三大特征</h3><p>Java内存模型是围绕着并发过程中如何处理原子性、可见性和有序性这3个特征来建立的。</p><h4 id="原子性"><a href="#原子性" class="headerlink" title="原子性"></a>原子性</h4><p>原子性的含义理解：一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行。</p><p>由JMM直接保证的原子性变量操作包括read/load/use/assign/store/write。</p><p>如果应用场景需要一个更大范围的原子性保证，JMM还提供了lock和unlock来满足这种需求，对应的更高层次的字节码指令为monitorenter和monitorexit隐式使用这两个操作，反应到代码中就是synchronized关键字的使用，也即synchronized块的操作也具有原子性。也即<code>lock-&gt;{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}-&gt;unlock</code>保证了<code>{}</code>中一连串操作具有原子性。而volatile关键字不满足原子性的原因就是，虽然其通过{assign-&gt;store-&gt;write}和{read-&gt;load-&gt;use}满足了可见性，但是<u><strong>只要{read-&gt;load-&gt;use-&gt;assign-&gt;store-&gt;write}不是原子的，那么一个线程对一个变量的操作就不是原子的</strong></u>。</p><p>synchronized关键字经过编译后，会在同步块前后分别形成monitorenter和moniterexit两个字节码指令，这两个字节码指令都需要一个reference类型的参数来指明锁对象（monitorenter含义：获得对象的锁；monitorexit含义：释放对象的锁），比如同步块的this/某个对象，或者synchronized方法对应的实例对象，以及静态synchronized方法对应的类Class对象。</p><p>Tip: 通过<code>javap</code>反编译发现，临界区代码后有两个monitorexit字节码指令，是因为如果出现异常退出也需要释放锁。</p><h4 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h4><p>可见性是指：当一个线程修改了共享变量的值，其他线程能够立即得知这个修改。</p><p>JMM如何实现可见性？</p><p>答：volatile，在变量<strong>修改后</strong>将新值<strong>同步回主内存</strong>{assign-&gt;store-&gt;write}，变量<strong>使用前从主内存刷新到工作内存</strong>{read-&gt;load-&gt;use}。</p><p>Java哪些关键字可以保证可见性？</p><ul><li>volatile</li><li>synchronized: 对一个变量执行<strong>lock操作</strong>后，<strong>从主内存刷新到工作内存</strong>{lock-&gt;read-&gt;load-&gt;use}；对一个变量执行<strong>unlock操作</strong>之前，必须先把变量值<strong>同步回主内存</strong>{assign-&gt;store-&gt;write-&gt;unlock}。</li><li>final: 被 final 修饰的字段在构造器中一旦初始化完成，那么其它线程就能看见 final 字段的值。</li></ul><h4 id="有序性"><a href="#有序性" class="headerlink" title="有序性"></a>有序性</h4><p>有序性是指：在本线程内观察，所有操作都是有序的。在一个线程观察另一个线程，所有操作都是无序的，无序是因为发生了<strong>指令重排序</strong>以及<strong>工作内存与主内存同步有延迟</strong>。在 Java 内存模型中，允许<strong>编译器和处理器对指令进行重排序</strong>，重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。</p><p>volatile 关键字通过<strong>添加内存屏障的方式来禁止指令重排</strong>，即重排序时不能把后面的指令放到内存屏障之前。</p><p>也可以通过 synchronized 来保证有序性，它保证每个时刻只有一个线程执行同步代码（也即<strong>锁的作用</strong>），相当于是让线程顺序执行同步代码。</p><h3 id="先行发生原则（Happens-Before规则）"><a href="#先行发生原则（Happens-Before规则）" class="headerlink" title="先行发生原则（Happens-Before规则）"></a>先行发生原则（Happens-Before规则）</h3><p>先行发生是JMM中定义的两项操作之间的偏序关系，如果说操作A先行发生于操作B，其含义是：B发生之前，A产生的影响能被B观察到。“影响”包括修改了内存中共享变量的、发送了消息、调用了方法等。</p><p>JMM中一些天然的先行发生关系如下：</p><h4 id="程序次序规则（Program-Order-Rule）"><a href="#程序次序规则（Program-Order-Rule）" class="headerlink" title="程序次序规则（Program Order Rule）"></a>程序次序规则（Program Order Rule）</h4><p>在一个线程内，在程序前面的操作先行发生于后面的操作。</p><h4 id="管程锁定规则（Monitor-Lock-Rule）"><a href="#管程锁定规则（Monitor-Lock-Rule）" class="headerlink" title="管程锁定规则（Monitor Lock Rule）"></a>管程锁定规则（Monitor Lock Rule）</h4><p>一个 unlock 操作先行发生于后面对同一个锁的 lock 操作。</p><h4 id="volatile变量规则（Volatile-Variable-Rule）"><a href="#volatile变量规则（Volatile-Variable-Rule）" class="headerlink" title="volatile变量规则（Volatile Variable Rule）"></a>volatile变量规则（Volatile Variable Rule）</h4><p>对一个 volatile 变量的写操作先行发生于后面对这个变量的读操作。</p><h4 id="线程启动规则（Thread-Start-Rule）"><a href="#线程启动规则（Thread-Start-Rule）" class="headerlink" title="线程启动规则（Thread Start Rule）"></a>线程启动规则（Thread Start Rule）</h4><p>Thread 对象的 start() 方法调用先行发生于此线程的每一个动作。</p><h4 id="线程加入规则（Thread-Join-Rule）"><a href="#线程加入规则（Thread-Join-Rule）" class="headerlink" title="线程加入规则（Thread Join Rule）"></a>线程加入规则（Thread Join Rule）</h4><p>Thread 对象的结束先行发生于 join() 方法返回。</p><h4 id="线程中断规则（Thread-Interruption-Rule）"><a href="#线程中断规则（Thread-Interruption-Rule）" class="headerlink" title="线程中断规则（Thread Interruption Rule）"></a>线程中断规则（Thread Interruption Rule）</h4><p>对线程 interrupt() 方法的调用先行发生于被中断线程的代码检测到中断事件的发生，可以通过 interrupted() 方法检测到是否有中断发生。</p><h4 id="对象终结规则（Finalizer-Rule）"><a href="#对象终结规则（Finalizer-Rule）" class="headerlink" title="对象终结规则（Finalizer Rule）"></a>对象终结规则（Finalizer Rule）</h4><p>一个对象的初始化完成（构造函数执行结束）先行发生于它的 finalize() 方法的开始。</p><h4 id="传递性（Transitivity）"><a href="#传递性（Transitivity）" class="headerlink" title="传递性（Transitivity）"></a>传递性（Transitivity）</h4><p>如果操作 A 先行发生于操作 B，操作 B 先行发生于操作 C，那么操作 A 先行发生于操作 C。</p><h3 id="伪共享"><a href="#伪共享" class="headerlink" title="伪共享"></a>伪共享</h3><h4 id="缓存一致性（Cache-Coherence）"><a href="#缓存一致性（Cache-Coherence）" class="headerlink" title="缓存一致性（Cache Coherence）"></a>缓存一致性（Cache Coherence）</h4><p>在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存，如图所示：</p><p><img src="CPU_Cache.png" alt=""></p><p>当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那么在同步数据回主内存时该以谁的缓存数据为准呢？为了解决一致性问题，需要处理器访问缓存时都遵循一些协议，也即<strong>缓存一致性协议</strong>，在读写时根据协议来操作，这类协议有MSI，MESI，MOSI等等。</p><h4 id="局部性原理"><a href="#局部性原理" class="headerlink" title="局部性原理"></a>局部性原理</h4><p>局部性原理: CPU访问存储器时，无论是存取指令还是存取数据，所访问的存储单元都趋于聚集在一个较小的连续区域中。</p><p>时间局部性：如果一个信息项正在被访问，那么在近期它很可能还会被再次访问。</p><p>空间局部性：在最近的将来将用到的信息很可能与现在正在使用的信息在空间地址上是临近的。</p><h4 id="伪共享-1"><a href="#伪共享-1" class="headerlink" title="伪共享"></a>伪共享</h4><p>伪共享：多线程下访问同一个Cache行中的多个不同变量时产生。</p><p>在Cache内部是按行存储的，其中每一行称为一个Cache行。Cache行是与主内存进行数据交换的单位，其大小一般为2的幂次数字节。</p><p>当CPU访问某个变量时，首先会检查CPUCache内是否有该变量，如果有则直接读取，否则就向下级缓存找，直到主内存。然后将找到的变量所在内存区域的一个Cache行大小的内存复制到Cache中。由于存放到Cache行的是内存块而不是单个变量，所以可能会把多个变量存放到一个Cache行中。</p><p>由程序运行的局部性原理可知，程序会把变量所在内存中大小为Cache行的内存（地址连续的内存）放入CPUCache中。<strong>当多个线程同时写入Cache行中不同的变量时</strong>，由于缓存一致性协议，此时只能有一个线程操作Cache行，所以相比将每个变量放到一个Cache行，性能会有所下降，这就是<strong>伪共享</strong>。以下图为例：</p><p><img src="CPU_Cache.jpg" alt=""></p><p>上图中变量x,y所在的内存区域同时被复制到了<strong>CPU1和CPU2的Cache行</strong>以及<strong>二级缓存</strong>中，当线程1使用CPU1对x进行更新时，首先修改CPU1Cache1变量x所在的缓存行，<strong>此时由于缓存一致性协议，CPU2中变量x对应的缓存行失效</strong>，那么线程2在写入变量y时就只能从二级缓存查找了。</p><p>在创建数组时，数组里的多个元素就会被放入同一个缓存行，对于单线程程序而言，如果顺序访问数组中的元素，就会充分利用程序运行的局部性原则，从而加速了程序的运行。</p><h4 id="避免伪共享"><a href="#避免伪共享" class="headerlink" title="避免伪共享"></a>避免伪共享</h4><p>jdk1.8之前一般通过<strong>字节填充</strong>的方式来避免伪共享，也就是创建一个变量时使用无关字段填充该变量所在的缓存行，这样就避免了将多个变量存放在同一个缓存行中。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1, p2, p3, p4, p5, p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>CPU-Z</code>查看发现我的电脑CPU一级缓存行大小为64Byte，由于一个长整型变量占8Byte，那么以上代码变量总共占了56个Byte，其中6个变量48Byte为填充字节，而类对象的字节码的对象头占用8Byte，所以一个FilledLong对象实际会占用64Byte。</p><p><strong>jdk1.8提供了一个sun.misc.Contended注解来解决伪共享问题</strong>。将上面的代码修改如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，默认情况下，<code>@Contended</code>注解只用于Java核心类，比如rt包下的类。如果用户类路径下的类需要使用该注解，则需要添加JVM参数：<code>-XX:-RestrictContended</code>，填充的宽度默认为128，自定义宽度则可以设置<code>-XX:ContendedPaddingWidth</code>。</p><p>参考：《深入理解Java虚拟机》 周志明</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java指令重排序&quot;&gt;&lt;a href=&quot;#Java指令重排序&quot; class=&quot;headerlink&quot; title=&quot;Java指令重排序&quot;&gt;&lt;/a&gt;Java指令重排序&lt;/h3&gt;&lt;p&gt;Java内存模型允许编译器和处理器对指令重排序以提高运行性能，并且只会对不存在数据依
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>数据结构复习</title>
    <link href="http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/"/>
    <id>http://thmasterplan.cn/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%A4%8D%E4%B9%A0/</id>
    <published>2020-09-10T03:05:44.000Z</published>
    <updated>2020-09-10T06:50:15.337Z</updated>
    
    <content type="html"><![CDATA[<h2 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h2><p><img src="alg-overview-x.png" alt=""></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><ul><li>优点：存取速度快。</li><li>缺点：a.事先必须知道数组的长度。b.需要大块连续的内存块。c.插入删除元素的效率低</li><li>Java中主要类似的实现为<em>ArrayList</em>，其他一些容器底层也几乎都会用数组存储数据。</li></ul><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>优点：插入删除元素快；无空间限制。</li><li>缺点：查找存取慢。</li><li>分类：单向链表；双向链表；循环链表</li><li>Java中主要类似的实现为<em>LinkedList</em>，其他一些容器底层也会用到链表。</li></ul><h3 id="哈希表"><a href="#哈希表" class="headerlink" title="哈希表"></a>哈希表</h3><ul><li>详情见<em>HashMap</em>源码剖析。</li></ul><h3 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h3><ul><li>栈：LIFO</li><li>队列：FIFO</li><li>Java中推荐使用<em>ArrayDeque</em>。</li></ul><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><h5 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h5><p>最多有两棵子树的树。</p><p><img src="alg-tree-3.png" alt=""></p><h5 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h5><p>二叉树中所有非叶子节点的度都是2，且叶子节点都在同一层次上。</p><p><img src="alg-tree-5.png" alt=""></p><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>如果一个二叉树与满二叉树前m个节点的结构相同，这样的二叉树被称为完全二叉树。</p><p><img src="alg-tree-6.png" alt=""></p><h4 id="二叉搜索树（BST）"><a href="#二叉搜索树（BST）" class="headerlink" title="二叉搜索树（BST）"></a>二叉搜索树（BST）</h4><p>二叉查找树(Binary Search Tree)是指一棵空树或者具有下列性质的二叉树:</p><ul><li><p>若任意节点的左子树不空，则左子树上所有结点的值均小于它的根结点的值；</p></li><li><p>任意节点的右子树不空，则右子树上所有结点的值均大于它的根结点的值；</p></li><li>任意节点的左、右子树也分别为二叉查找树。</li><li>没有键值相等的节点。</li></ul><h4 id="平衡二叉树（AVL）"><a href="#平衡二叉树（AVL）" class="headerlink" title="平衡二叉树（AVL）"></a>平衡二叉树（AVL）</h4><p>平衡二叉树是指一棵空树或者它的左右两个子树的高度差绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。并且它满足二叉查找树的性质。</p><h4 id="红黑树（R-B-Tree）"><a href="#红黑树（R-B-Tree）" class="headerlink" title="红黑树（R-B Tree）"></a>红黑树（R-B Tree）</h4><h4 id="B树"><a href="#B树" class="headerlink" title="B树"></a>B树</h4><p>B树是一种平衡多路查找树。</p><h4 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h4><h4 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B*树"></a>B*树</h4><h4 id="R树"><a href="#R树" class="headerlink" title="R树"></a>R树</h4><h4 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h4><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><ul><li>定义</li><li>相关概念</li><li>类型<ul><li>无向图</li><li>有向图</li><li>完全图</li></ul></li></ul><h4 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h4><ul><li>邻接矩阵表示法</li><li>邻接表表示法</li></ul><h4 id="BFS和DFS"><a href="#BFS和DFS" class="headerlink" title="BFS和DFS"></a>BFS和DFS</h4><h4 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h4><ul><li>相关概念</li><li>Kruskal算法</li><li>Prim算法</li></ul><h4 id="最短路径算法"><a href="#最短路径算法" class="headerlink" title="最短路径算法"></a>最短路径算法</h4><ul><li>Dijkstra算法</li><li>Floyd算法</li></ul><h4 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h4><h4 id="AOE网与关键路径"><a href="#AOE网与关键路径" class="headerlink" title="AOE网与关键路径"></a>AOE网与关键路径</h4><h2 id="Blog推荐"><a href="#Blog推荐" class="headerlink" title="Blog推荐"></a>Blog推荐</h2><ul><li>基础：<a href="https://www.cnblogs.com/skywang12345/p/3603935.html" target="_blank" rel="noopener">https://www.cnblogs.com/skywang12345/p/3603935.html</a></li><li>进阶：<a href="https://blog.csdn.net/v_JULY_v/article/list/3" target="_blank" rel="noopener">https://blog.csdn.net/v_JULY_v/article/list/3</a></li></ul><p>参考：<a href="https://www.pdai.tech/md/algorithm/alg-basic-overview.html" target="_blank" rel="noopener">https://www.pdai.tech/md/algorithm/alg-basic-overview.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;alg-overview-x.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h2 
      
    
    </summary>
    
    
      <category term="数据结构与算法" scheme="http://thmasterplan.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="http://thmasterplan.cn/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-09T07:13:05.000Z</published>
    <updated>2020-09-27T02:53:40.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedHashMap是HashMap的一个子类，<strong>保存了键值对的插入顺序</strong>，在用Iterator遍历LinkedHashMap时，先得到的键值对肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><h2 id="LinkedHashMap的实现"><a href="#LinkedHashMap的实现" class="headerlink" title="LinkedHashMap的实现"></a>LinkedHashMap的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><img src="LinkedHashMap.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">HashMap</span>.<span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        Entry&lt;K,V&gt; before, after;</span><br><span class="line">        Entry(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, value, next);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>节点Entry<K, V>继承自HashMap.Node<K, V>，包含前置指针和后置指针。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双向链表的头指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; head;</span><br><span class="line"><span class="comment">//双向链表的尾指针</span></span><br><span class="line"><span class="keyword">transient</span> LinkedHashMap.Entry&lt;K,V&gt; tail;</span><br><span class="line"><span class="comment">//为false维护的是插入顺序；为true则是维护访问顺序。</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">boolean</span> accessOrder;</span><br></pre></td></tr></table></figure><p>由此可见LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了一个变量用于维护插入顺序或者访问顺序。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span></span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(initialCapacity);</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>();</span><br><span class="line">    accessOrder = <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity,<span class="keyword">float</span> loadFactor, <span class="keyword">boolean</span> accessOrder)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">super</span>(initialCapacity, loadFactor);</span><br><span class="line">     <span class="keyword">this</span>.accessOrder = accessOrder;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法知LinkedHashMap默认维护的是插入顺序。</p><h3 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h3><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">if</span> ((e = getNode(hash(key), key)) == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder)</span><br><span class="line">        afterNodeAccess(e);</span><br><span class="line">    <span class="keyword">return</span> e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">afterNodeAccess</span><span class="params">(Node&lt;K,V&gt; e)</span> </span>&#123; <span class="comment">// move node to last</span></span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last;</span><br><span class="line">    <span class="keyword">if</span> (accessOrder &amp;&amp; (last = tail) != e) &#123;</span><br><span class="line">        LinkedHashMap.Entry&lt;K,V&gt; p =    </span><br><span class="line">            (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after;</span><br><span class="line">        p.after = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>)</span><br><span class="line">            head = a;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            b.after = a;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>)</span><br><span class="line">            a.before = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            last = b;</span><br><span class="line">        <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">            head = p;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            p.before = last;</span><br><span class="line">            last.after = p;</span><br><span class="line">         &#125;</span><br><span class="line">         tail = p;</span><br><span class="line">         ++modCount;<span class="comment">//get也会导致结构性更改</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由get方法可知，accessOrder为true，也即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get方法都会将当前节点移动至链表尾部。<strong>保证链表尾部是最近访问的节点，那么链表首部就是最近最久未使用的节点。</strong></p><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>查看源码发现LinkedHashMap并没有重写put方法，但是重写了newNode方法，因此put会调用重写的newNode方法。并且发现put方法最后调用了afterNodeAccess方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node&lt;K,V&gt; <span class="title">newNode</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; e)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; p =</span><br><span class="line">    <span class="keyword">new</span> LinkedHashMap.Entry&lt;K,V&gt;(hash, key, value, e);</span><br><span class="line">    linkNodeLast(p);<span class="comment">//新建节点连接于链表尾部</span></span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// link at the end of list</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">linkNodeLast</span><span class="params">(LinkedHashMap.Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    LinkedHashMap.Entry&lt;K,V&gt; last = tail;</span><br><span class="line">    tail = p;</span><br><span class="line">    <span class="keyword">if</span> (last == <span class="keyword">null</span>)</span><br><span class="line">        head = p;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        p.before = last;</span><br><span class="line">        last.after = p;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="removeEldestEntry"><a href="#removeEldestEntry" class="headerlink" title="removeEldestEntry()"></a>removeEldestEntry()</h4><p>重写该方法可以删除最久未被使用的元素。</p><h4 id="afterNodeInsertion"><a href="#afterNodeInsertion" class="headerlink" title="afterNodeInsertion()"></a>afterNodeInsertion()</h4><p>新增时判断是否需要删除最久未被使用的元素。</p><p>开启accessOrder的情况和最后这两个方法主要用于实现LRU缓存。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ol><li>LinkedHashMap相对于HashMap增加了双向链表的结构，并且增设了变量accessOrder用于维护插入顺序或者访问顺序。</li><li>accessOrder为true，即LinkedHashMap维护的是LRU(最近最少访问)顺序时，每次调用get/put都会将当前节点移动至链表尾部。注意这意味着get也会导致modCount变化，迭代器会快速失败。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedHashMap是HashMap的一个子类，&lt;strong&gt;保存了键值对的插入顺序&lt;/strong&gt;，在用Iterator遍历Li
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-09T05:10:49.000Z</published>
    <updated>2020-09-27T02:38:11.979Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Map接口主要实现类有四个：HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图：</p><p><img src="Map.jpg" alt=""></p><p>其中HashMap根据key的hashCode计算得到的哈希值存储数据，因此在访问数据时直接根据hash函数计算就可以得到数据在数组中的位置，访问速度很快，但是遍历顺序却是不确定的。</p><p><strong>HashMap最多只允许一个节点的key为null，允许多个节点的value为null。</strong></p><p>HashMap非线程安全。若要满足线程安全，可以使用<code>Collections.synchronizedMap</code>方法使HashMap具有线程安全的能力，或者直接使用ConcurrentHashMap。</p><h2 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a>HashMap的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><img src="hashmap18_struc.png" alt=""></p><p>如上图所示，HashMap使用<strong>链地址法</strong>来解决冲突问题。jdk8后HashMap使用<strong>数组+链表/红黑树</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">//final修饰，key不可变，否则根据hash函数计算所得的索引位置就变了</span></span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap成员变量的含义"><a href="#HashMap成员变量的含义" class="headerlink" title="HashMap成员变量的含义"></a>HashMap成员变量的含义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组默认初始容量16.数组容量必须是2的幂，定位索引时采用&amp;运算效率高。</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当链表节点个数 &gt;= 8时，转换为红黑树，访问的时间复杂度由O(N)降为O(logN)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当红黑树节点个数 &lt; 6时，退化为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     * 只有当数组容量&gt;=64时，bin中的链表才会转换为红黑树；</span></span><br><span class="line"><span class="comment">     * 否则就算链表节点个数&gt;=8，也不会树化，而是对数组进行扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等于capacity * load factor, 当哈希表中有threshold个bin有节点时，进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//记录HashMap发生结构性更改的次数，用于实现迭代器fail-fast机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子,如果内存空间充足，可以在构造HashMap时适当减小负载因子和增大初  始容量，以此来提高HashMap效率；</span></span><br><span class="line"><span class="comment">//相反，如果内存空间紧张而对时间效率要求不高，则可以适当调大负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总节点个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于entrySet()方法返回所有键值对</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><h3 id="哈希方法"><a href="#哈希方法" class="headerlink" title="哈希方法"></a>哈希方法</h3><p>哈希函数用于确定节点在数组中的索引位置，其数学形式为<code>index = hash(key)</code>。jdk1.8实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知，hash函数的返回值并不是数组索引，因为数组长度并没有参与运算。实际上，获取索引的最后一步操作在获取节点的方法中实现，比如getNode()方法中的代码片段<code>tab[(n - 1) &amp; hash]</code>，tab就是哈希数组，n为数组长度。</p><p>以上代码可分为三步：</p><ol><li><code>h = key.hashCode()</code>  <strong>取key的hashCode值</strong>。</li><li><code>hash = h ^ (h &gt;&gt;&gt; 16)</code> 无符号右移16bit(左边补0), <strong>高位运算</strong>。<u>高16位异或运算结果为hashCode原来的值，低16位运算结果则是hashCode值的高16位和低16位异或所得。这么做可以<strong>在数组table的length比较小的时候，也能保证考虑到高低Bit都参与到Hash的计算中</strong>，同时不会有太大的开销，并且减小了冲突的可能。</u></li><li><p><code>index = (n - 1) &amp; hash</code> <strong>相当于求模运算</strong>，但是效率比<code>%</code>更高。因为数组的大小永远是2的幂，所以<code>n - 1</code>是<code>011..11</code>（32位）的形式，任何非负整数（且 &lt;= n-1）和它按位<code>&amp;</code>都会等于其本身。</p><p>举个例子：</p></li></ol><p><img src="hash_computing_ex.jpg" alt=""></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建指定初始容量和负载因子的HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建指定初始容量和默认负载因子的HashMap  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，构造方法中并没有创建哈希数组，初始化数组操作是通过resize()方法完成，而resize()方法是在放入键值对的时候才进行调用（初始化或者扩容2倍），比如putVal()方法。</p><p>构造方法中调用了tableSizeFor()来获取大于指定容量的最小的2的幂（在ArrayDeque中已分析），其源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;<span class="comment">//从左往右依次运算</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        </span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;<span class="comment">//旧数组容量</span></span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;<span class="comment">//旧扩容阈值</span></span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;<span class="comment">//扩容前数组大小如果已经达到最大(2^30)了</span></span><br><span class="line">                threshold = Integer.MAX_VALUE;<span class="comment">//修改阈值为int的最大值(2^31-1)，这样以后就不会扩容了</span></span><br><span class="line">                <span class="keyword">return</span> oldTab;<span class="comment">//直接返回旧数组不再扩容</span></span><br><span class="line">            &#125;<span class="comment">//扩容两倍并检验是否超过最大容量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// 阈值同样翻倍</span></span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">//oldCap为0但是oldThr&gt;0，这是因为构造方法中并没有创建哈希数组，但是却通过tableSizeFor()为threshold赋了值</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//对应上面代码的第二种情形，计算新的threshold</span></span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;<span class="comment">//创建新hash数组并赋值</span></span><br><span class="line">     </span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//以下代码块将每个bin都复制到新的数组中</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;<span class="comment">//释放引用，避免内存泄漏</span></span><br><span class="line">                    </span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)<span class="comment">//转为红黑树操作</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">//将该链表的冲突节点重新计算索引分配‘原索引’和‘原索引+oldCap’处</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        </span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//原索引</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="comment">//e.hash与oldCap按位与只有两种结果，要么为0，要么为oldCap，因为oldCap的二进制形式为0...01000..0</span></span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;<span class="comment">//原索引+oldCap</span></span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//原索引放到bin</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//原索引+oldCap放到bin</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由注释知，resize()方法用于初始化哈希数组或者扩容2倍。注意，<strong>扩容后元素的位置要么是在原位置，要么是在原位置再移动单倍容量位移的位置。</strong></p><h3 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h3><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><p>该方法的流程图如下：</p><p><img src="HashMap_putVal.jpg" alt=""></p><ol><li>判断table是否为空，空则调用resize()创建数组</li><li>计算index，并判断该处是否为null，为null则直接创建节点，并转向6。</li><li>不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value</li><li>不一致则判断该链为红黑树。</li><li>该链为链表则遍历，遍历过程判断链表长度&gt;=8转红黑树处理；不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value</li><li>添加节点后判断是否超过阈值threshold，是则扩容</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent, <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; </span><br><span class="line">        Node&lt;K,V&gt; p;</span><br><span class="line">        <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//1.判断table是否为空，空则调用resize()创建数组</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//2.计算index，并判断该处是否为null</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//为null则直接创建节点，并转向6</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          </span><br><span class="line">            Node&lt;K,V&gt; e; </span><br><span class="line">            K k;</span><br><span class="line">            <span class="comment">//3.不为null则判断首个元素的key是否和传入的key一致，一致则直接覆盖value</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//4.判断该链为红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="comment">//5.该链为链表则遍历</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//5.1 判断，链表长度&gt;=8转红黑树处理</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//5.2 不转红黑树则进行链表插入，判断，key已经存在则直接覆盖value</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    </span><br><span class="line">                    p = e;    </span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;<span class="comment">//覆盖value</span></span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    </span><br><span class="line">        ++modCount; </span><br><span class="line">        <span class="comment">//6.添加节点后判断是否超过阈值threshold，是则扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="其他常用方法："><a href="#其他常用方法：" class="headerlink" title="其他常用方法："></a>其他常用方法：</h4><ul><li><code>size()</code>：获取总节点个数</li><li><code>isEmpty()</code>：判断是否为空</li><li><code>containsKey()</code>：判断是否包含指定key</li><li><code>get()</code>：获取指定key节点的value</li><li><code>remove()</code>：移除指定key的节点</li><li><code>keySet()</code>：获取包含所有key的Set</li><li><code>entrySet()</code>：获取包含所有节点的Set</li></ul><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><ul><li>扩容特别耗性能，所以在使用HashMap的时候，估算map的大小，初始化的时候给一个大致的数值，避免map进行频繁的扩容。</li><li>负载因子可以修改，也可以大于1，但是建议不要轻易修改，除非情况非常特殊。</li><li>HashMap是线程不安全的，不要在并发的环境中同时操作HashMap，建议使用ConcurrentHashMap。</li><li>JDK1.8引入红黑树大程度优化了HashMap的性能。</li></ul><p>参考：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p><p>​            <a href="http://irfen.me/java1-8-hashmap/" target="_blank" rel="noopener">http://irfen.me/java1-8-hashmap/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Map接口主要实现类有四个：HashMap、Hashtable、LinkedHashMap和TreeMap，类继承关系如下图：&lt;/p&gt;
&lt;p
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
