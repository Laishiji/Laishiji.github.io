<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2020-11-09T14:32:51.207Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>(一)秒杀项目优化之定制化Tomcat配置</title>
    <link href="http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E4%B8%80-%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AE%9A%E5%88%B6%E5%8C%96Tomcat%E9%85%8D%E7%BD%AE/"/>
    <id>http://thmasterplan.cn/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/%E4%B8%80-%E7%A7%92%E6%9D%80%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96%E4%B9%8B%E5%AE%9A%E5%88%B6%E5%8C%96Tomcat%E9%85%8D%E7%BD%AE/</id>
    <published>2020-11-09T14:21:23.000Z</published>
    <updated>2020-11-09T14:32:51.207Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://github.com/Laishiji/miaosha" target="_blank" rel="noopener">项目地址</a>.</p><h2 id="云端部署"><a href="#云端部署" class="headerlink" title="云端部署"></a>云端部署</h2><h3 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h3><ol><li><code>yum -y install java</code></li><li><code>yum -y install java-1.8.0-openjdk-devel.x86_64</code></li></ol><h3 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h3><h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ol><li><code>yum install -y mysql*</code></li><li><code>yum install -y mariadb-server</code></li></ol><h4 id="启动服务"><a href="#启动服务" class="headerlink" title="启动服务"></a>启动服务</h4><p><code>systemctl start mariadb.service</code></p><h4 id="开机启动"><a href="#开机启动" class="headerlink" title="开机启动"></a>开机启动</h4><p><code>systemctl enable mariadb.service</code></p><h4 id="查看端口"><a href="#查看端口" class="headerlink" title="查看端口"></a>查看端口</h4><p><code>netstat -anp | grep 3306</code></p><h4 id="登录"><a href="#登录" class="headerlink" title="登录"></a>登录</h4><ol><li>初始化MySQL用户名和密码：<code>mysql -u USERNAME password PASSWORD</code></li><li>登录：<code>mysql -u USERNAME -p</code></li></ol><h3 id="备份本地数据库到云端"><a href="#备份本地数据库到云端" class="headerlink" title="备份本地数据库到云端"></a>备份本地数据库到云端</h3><h4 id="本地备份"><a href="#本地备份" class="headerlink" title="本地备份"></a>本地备份</h4><p>使用<code>mysqldump</code>命令根据已有数据库创建SQL文件：<code>mysqldump -u USERNAME --databases 数据库名 -p &gt; /路径/miaosha.sql</code>。</p><h4 id="上传"><a href="#上传" class="headerlink" title="上传"></a>上传</h4><p>使用scp命令上传SQL文件到云端tmp目录下：<code>scp /路径/miaosha.sql USERNAME@IP:/tmp</code></p><h4 id="云端恢复"><a href="#云端恢复" class="headerlink" title="云端恢复"></a>云端恢复</h4><p>重定向IO即可：<code>mysql -u USERNAME -p &lt; ../tmp/miaosha.sql</code>。</p><h3 id="本地应用程序打包部署到云端"><a href="#本地应用程序打包部署到云端" class="headerlink" title="本地应用程序打包部署到云端"></a>本地应用程序打包部署到云端</h3><ol><li><code>mvn clean package</code>或直接IDE右侧运行maven命令，target目录中生成Spring Boot的jar包。</li><li>scp命令上传到云端。</li><li>防火墙添加端口：<code>firewall-cmd --zone=public --add-port=8080/tcp --permanent</code></li><li>更新防火墙规则：<code>firewall-cmd --reload</code></li><li>新建配置文件appication.properties，该配置文件优先级大于项目中的。</li><li>运行：<code>java -jar miaosha.jar --spring.config.addtion-location=/var/www/miaosha/application.properties</code></li></ol><p>编写deploy脚本部署：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup java -Xms400m -Xmx400m -XX:NewSize=200m -XX:MaxNewSize=200m -jar miaosha.jar --spring.config.addtion-location=/var/www/miaosha/application.properties</span><br></pre></td></tr></table></figure><h2 id="性能压测"><a href="#性能压测" class="headerlink" title="性能压测"></a>性能压测</h2><p>使用JMeter进行性能压测，测试环境：1核2g内存。简单入门：</p><ol><li><p>创建线程组</p></li><li><p>添加取样器：HTTP请求。（一定要勾选KeepAlive，此处指HTTP的connection选项而非TCP的keepAlive机制，TCP的keepAlive机制用于检测死连接，HTTP的则是为了在一个TCP连接发送多个HTTP请求）</p><p><img src="JMeterHttp.png" alt=""></p></li><li><p>添加监听器：察看结果树</p></li><li><p>添加监听器：聚合报告</p></li></ol><p>聚合报告列表的含义：</p><p><img src="JMeter.png" alt=""></p><ul><li>样本：表示进行了20次请求</li><li>平均值：平均响应时间，单位ms</li><li>中位数：中位数响应时间，单位ms</li><li>百分位：百分之多少的请求的响应时间</li><li>吞吐量：TPS, Throughput Percent Second</li></ul><p>查看Tomcat默认维护的线程池中线程数量：</p><ol><li>获取SpringBoot程序pid：<code>ps -ef | grep miaosha</code></li><li>计算线程数量：<code>pstree -p 4073 | wc -l</code>，结果为28</li></ol><h2 id="性能初步调优-定制化内嵌Tomcat配置"><a href="#性能初步调优-定制化内嵌Tomcat配置" class="headerlink" title="性能初步调优-定制化内嵌Tomcat配置"></a>性能初步调优-定制化内嵌Tomcat配置</h2><p><strong>压测</strong>：调整线程组线程数为5000，Ramp-Up时间为15秒，循环次数100，查看服务器线程数量，结果为218，压测结果显示有大量请求被拒绝。压测过程可使用<code>top -H</code>查看实时的进程动态。</p><p><strong>压测</strong>：调整线程组线程数为1000，Ramp-Up时间为15秒，循环次数50，查看服务器线程数量，结果为218，压测结果显示已经没有请求被拒绝。压测过程可使用<code>top -H</code>查看实时的进程动态。</p><p><img src="JMeter0.png" alt=""></p><h3 id="修改全局配置文件"><a href="#修改全局配置文件" class="headerlink" title="修改全局配置文件"></a>修改全局配置文件</h3><p>通过查看<strong>spring-configuration-metadata.json</strong>，查看Spring Boot内嵌Tomcat的默认配置，主要有以下几点：</p><ul><li><strong>server.tomcat.accept-count</strong>：Maximum queue length for incoming connection requests when all possible request processing threads are in use. 等待队列长度，默认为100</li><li><strong>server.tomcat.max-connections</strong>：最大可被连接数，默认8192</li><li><strong>server.tomcat.max-threads</strong>：最大工作线程数，默认200</li><li><strong>server.tomcat.min-spare-threads</strong>：最小工作线程数，默认10</li></ul><p>由此得知，默认配置下连接超过8192后出现拒绝连接情况；默认配置下，触发的请求超过最大工作线程数200+最大等待队列长度100后即300，拒绝处理。</p><p>在application.properties中配置以上参数以覆盖默认设置，</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">server.tomcat.accept-count</span>=<span class="string">1000</span></span><br><span class="line"><span class="meta">server.tomcat.max-threads</span>=<span class="string">400</span></span><br><span class="line"><span class="meta">server.tomcat.min-spare-threads</span>=<span class="string">100</span></span><br></pre></td></tr></table></figure><p>一般来说4核8g内存最大线程数设置为800较为合理。杀掉进程重新部署后计算常驻线程数为118。</p><p><strong>再次压测</strong>：调整线程组线程数为1000，循环次数50，查看服务器线程数量，发现已经变为418，压测结果如下图：</p><p><img src="JMeter1.png" alt=""></p><p>由图可知，修改tomcat默认配置之后已经压测结果已经有所提升，但是单机TPS依旧只有309，响应时间依旧很长。</p><p>在实际开发中，以上四个参数需要视单个服务器具体的CPU和内存配置进行压测后才能得出最优配置。</p><h3 id="修改源码"><a href="#修改源码" class="headerlink" title="修改源码"></a>修改源码</h3><p>使用<code>WebServerFactoryCustomizer&lt;ConfigurableServletWebServerFactory&gt;</code>类定制化内嵌Tomcat配置：</p><ul><li><p><strong>keepAliveTimeOut</strong>：多少毫秒后若客户端无请求则断开本次TCP连接。</p></li><li><p><strong>maxKeepAliveRequests</strong>：一次TCP连接支持多少个HTTP请求后断开失效。</p></li></ul><p>这两个设置可以避免DDOS攻击，以及在用户长时间不发请求时节省服务器资源。代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 当Spring容器内没有TomcatEmbeddedServletContainerFactory这个bean时，会加载此bean到容器</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebServerConfiguration</span> <span class="keyword">implements</span> <span class="title">WebServerFactoryCustomizer</span>&lt;<span class="title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 使用对应工厂类提供给我们的接口定制化Tomcat</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> factory</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(ConfigurableServletWebServerFactory factory)</span> </span>&#123;</span><br><span class="line">        ((TomcatServletWebServerFactory)factory).addConnectorCustomizers(<span class="keyword">new</span> TomcatConnectorCustomizer() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">customize</span><span class="params">(Connector connector)</span> </span>&#123;</span><br><span class="line">                Http11NioProtocol protocol = (Http11NioProtocol) connector.getProtocolHandler();</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定制化keepAliveTimeOut,30s内没有请求则服务端断开TCP连接</span></span><br><span class="line">                protocol.setKeepAliveTimeout(<span class="number">30000</span>);</span><br><span class="line"></span><br><span class="line">                <span class="comment">//定制化maxKeepAliveRequests</span></span><br><span class="line">                protocol.setMaxKeepAliveRequests(<span class="number">10000</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="MySQL的QPS问题"><a href="#MySQL的QPS问题" class="headerlink" title="MySQL的QPS问题"></a>MySQL的QPS问题</h2><ul><li>主键查询：千万级别数据用时1-10ms；</li><li>唯一索引查询：千万级别数据用时10-100ms;</li><li>非唯一索引查询：千万级别数据用时100-1000ms；</li><li>无索引的普通字段查询：百万条数据用时1000ms+，全表扫描，不可接受。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://github.com/Laishiji/miaosha&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;项目地址&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id=&quot;云端部署&quot;&gt;&lt;a href=&quot;#云端部署&quot; class=&quot;headerlin
      
    
    </summary>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/categories/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
    
      <category term="项目优化" scheme="http://thmasterplan.cn/tags/%E9%A1%B9%E7%9B%AE%E4%BC%98%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>常用设计模式</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%B8%B8%E7%94%A8%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</id>
    <published>2020-11-03T08:41:33.000Z</published>
    <updated>2020-11-07T05:50:36.543Z</updated>
    
    <content type="html"><![CDATA[<p><strong>学习设计模式时，应当关注该模式“可以解决什么问题”。</strong></p><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>软件工程中，设计模式（design pattern）是对软件设计中普遍存在（反复出现） 的各种问题，所提出的解决方案。这个术语是由Erich Gamma等人在1990年代从建筑设计领域引入到计算机科学的。</p><h2 id="设计模式的目的"><a href="#设计模式的目的" class="headerlink" title="设计模式的目的"></a>设计模式的目的</h2><p>编写软件过程中，程序员面临着来自耦合性，内聚性以及可维护性，可扩展性，重用性，灵活性等多方面的挑战，设计模式是为了让程序(软件)具有更好的：</p><ul><li>代码重用性 (即：相同功能的代码，不用多次编写) </li><li>可读性 (即：编程规范性, 便于其他程序员的阅读和理解) </li><li>可扩展性 (即：当需要增加新的功能时，非常的方便，称为可维护) </li><li>可靠性 (即：当我们增加新的功能后，对原来的功能没有影响) </li><li>使程序呈现高内聚，低耦合的特性</li></ul><h1 id="UML复习"><a href="#UML复习" class="headerlink" title="UML复习"></a>UML复习</h1><h2 id="类图"><a href="#类图" class="headerlink" title="类图"></a>类图</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><p>UML中的类图用于表示类、接口、实例之间相互的静态关系。如图：</p><p><img src="uml_class.png" alt=""></p><p>该图中实线空心三角箭头表示继承关系。<strong>下划线</strong>表示这是一个<strong>静态</strong>字段或<strong>静态</strong>方法，<strong>斜体</strong>表示这是一个<strong>抽象</strong>类或<strong>抽象</strong>方法。</p><h3 id="接口与实现"><a href="#接口与实现" class="headerlink" title="接口与实现"></a>接口与实现</h3><p><img src="uml_interface.png" alt=""></p><p>该图中虚线空心三角箭头表示实现关系。接口会在类图中使用<code>&lt;&lt;interface&gt;&gt;</code>表明。</p><h3 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h3><p><img src="uml_aggregation.png" alt=""></p><p>聚合是一种“持有”关系，比如Basket类中持有多个Fruit实例。实际上关联、聚合、组合都是一种持有关系，依赖则属于“半持有”的关系，它们的区别如下：</p><p><a href="https://www.cnblogs.com/xrq730/p/5533019.html" target="_blank" rel="noopener">UML中：关联、聚合、组合、依赖的区别</a>.</p><h3 id="可见性"><a href="#可见性" class="headerlink" title="可见性"></a>可见性</h3><p><img src="visualbility.png" alt=""></p><p>该图标识了方法和字段的可见性：</p><ul><li>“+”表示public</li><li>“-“表示private</li><li>“#”表示protect</li><li>“~”表示包可见</li></ul><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><p>UML的时序图用于表示程序在工作时其内部方法的调用顺序，以及事件的发生顺序。例：</p><p><img src="uml_sequence.png" alt=""></p><p>时序图上方的长方形表示类的实例，长方形向下延伸的虚线表示时间的流逝。黑色实线箭头表示方法调用，虚线箭头表示方法返回。</p><h1 id="创建型模式"><a href="#创建型模式" class="headerlink" title="创建型模式"></a>创建型模式</h1><h2 id="单例（Singleton）"><a href="#单例（Singleton）" class="headerlink" title="单例（Singleton）"></a>单例（Singleton）</h2><p><strong>作为对象的创建模式，单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例。这个类称为单例类。</strong></p><p>单例模式的使用场景：需要频繁进行创建和销毁的对象、创建对象耗时过多或耗费资源过多（重量级对象）但又经常用到的对象、工具类对象、频繁访问数据库或文件的对象。例如：Spring中bean对象的创建默认就是singleton。</p><h3 id="饿汉式（立即加载）"><a href="#饿汉式（立即加载）" class="headerlink" title="饿汉式（立即加载）"></a>饿汉式（立即加载）</h3><h4 id="静态常量"><a href="#静态常量" class="headerlink" title="静态常量"></a>静态常量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticFinal</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticFinal</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态常量，创建类实例，连接-准备阶段赋值</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticFinal INSTANCE = <span class="keyword">new</span> StaticFinal();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticFinal <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticFinal staticFinal = StaticFinal.getInstance();</span><br><span class="line">        StaticFinal staticFinal1 = StaticFinal.getInstance();</span><br><span class="line">        System.out.println(staticFinal == staticFinal1); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>优点：类加载（static final变量在连接-准备阶段赋值）时就完成了对象的实例化，避免了线程同步问题。</li><li>缺点：如果从始至终没有用到该实例，会造成内存浪费。</li></ul><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticBlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticBlock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态常量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticBlock INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.静态代码块中，初始化阶段赋值</span></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        INSTANCE = <span class="keyword">new</span> StaticBlock();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//4.公有静态方法，获取实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticBlock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        StaticBlock staticBlock = StaticBlock.getInstance();<span class="comment">//调用类的静态方法-&gt;类初始化-&gt;静态代码块中创建实例</span></span><br><span class="line">        StaticBlock staticBlock1 = StaticBlock.getInstance();</span><br><span class="line">        System.out.println(staticBlock == staticBlock1); <span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优缺点同上。</p><h3 id="懒汉式（延迟加载）"><a href="#懒汉式（延迟加载）" class="headerlink" title="懒汉式（延迟加载）"></a>懒汉式（延迟加载）</h3><h4 id="线程不安全"><a href="#线程不安全" class="headerlink" title="线程不安全"></a>线程不安全</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NoSync</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">NoSync</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> NoSync instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> NoSync <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> NoSync();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：延迟加载，调用getInstance方法时才创建对象，不会出现浪费内存的情况。</p><p>缺点：不能保证线程安全。在多线程情况下，一个线程进入if(instance == null)判断语句块，还未来得及往下执行，另一个线程也正在判断该语句，此时便会产生多个实例。</p><p>实际开发中，不能使用该方式。</p><h4 id="线程不安全-同步代码块"><a href="#线程不安全-同步代码块" class="headerlink" title="线程不安全-同步代码块"></a>线程不安全-同步代码块</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncBlock</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncBlock</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncBlock instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SyncBlock <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="comment">//3.1.同步操作在条件判断之后</span></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (SyncBlock<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                instance = <span class="keyword">new</span> SyncBlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不能保证线程安全，原因同上。</p><h4 id="线程安全-同步方法"><a href="#线程安全-同步方法" class="headerlink" title="线程安全-同步方法"></a>线程安全-同步方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SyncMethod</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">SyncMethod</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SyncMethod instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态同步方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> SyncMethod <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)</span><br><span class="line">            instance = <span class="keyword">new</span> SyncMethod();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>优点：延迟加载，保证了线程安全。</p><p>缺点：效率低。实例化只需要执行一次就够了，但是以后每个线程每次调用getInstance都要进行同步加锁。</p><p>实际开发中，不推荐该方式。</p><h3 id="双重检查（Double-Check）"><a href="#双重检查（Double-Check）" class="headerlink" title="双重检查（Double Check）"></a>双重检查（Double Check）</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoubleCheck</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">DoubleCheck</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态volatile变量</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> DoubleCheck instance;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时才创建实例</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> DoubleCheck <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (DoubleCheck<span class="class">.<span class="keyword">class</span>)</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>) instance = <span class="keyword">new</span> DoubleCheck();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>双重检查是”线程不安全-同步代码块“与”线程安全-同步方法“的改进，volatile修饰变量保证可见性，即使有多个线程同时进行”第一个条件判断“，在同步代码块中也有第二个条件判断保证只会创建一个实例。同时解决了使用同步方法效率低的问题，因为线程多次调用getInstance只是第一次有同步加锁操作。</p><p>实际开发中，推荐使用。</p><h3 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StaticInnerClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">//1.构造方法私有化，其他类不能new</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">StaticInnerClass</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//2.私有静态内部类</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Instance</span></span>&#123;</span><br><span class="line">        <span class="comment">//2.1.私有静态常量，创建对象</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> StaticInnerClass INSTANCE = <span class="keyword">new</span> StaticInnerClass();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//3.公有静态方法，调用该方法时调用内部类的静态常量，</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> StaticInnerClass <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Instance.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于外部类加载时不会同时加载内部类，因此只有再调用getInstance方法时才会加载内部类，并在内部类类加载阶段的连接-准备阶段赋值。</p><p>该方式是对饿汉式的改进，既能避免线程同步问题，又能做到延迟加载，避免内存的浪费。</p><p>实际开发中，推荐使用。</p><h3 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumSingleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EnumSingleton enumSingleton = EnumSingleton.INSTANCE;</span><br><span class="line">        EnumSingleton enumSingleton1 = EnumSingleton.INSTANCE;</span><br><span class="line">        System.out.println(enumSingleton == enumSingleton1);<span class="comment">//true</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>最简单最推荐的方式</strong>。该方式不仅能避免线程同步问题，还能防止反序列化重新创建新的对象。</p><h2 id="简单工厂（Simple-Factory）"><a href="#简单工厂（Simple-Factory）" class="headerlink" title="简单工厂（Simple Factory）"></a>简单工厂（Simple Factory）</h2><p><strong>简单工厂模式是类的创建模式，又叫做静态工厂方法（Static Factory Method）模式。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。</strong></p><p><strong>场景</strong>：假设现在我们要实现一个登录功能，需要满足多种登录方式，那么自然的方式就是建立一个各种登录方式都适用的接口，使用的时候再判断具体创建哪种登录方式的实现类。如图：</p><p><img src="simple_factory_0.png" alt=""></p><p>源代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String telPhone , String password)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DomainLogin</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String telPhone, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PasswordLogin</span> <span class="keyword">implements</span> <span class="title">Login</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">verify</span><span class="params">(String telPhone, String password)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 业务逻辑</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们还需要一个工厂类LoginFactory，根据调用者不同的要求，创建出不同的登录对象并返回。而如果碰到不合法的要求，会返回一个Runtime异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFactory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Login <span class="title">getLogin</span><span class="params">(String loginType)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"password"</span>.equals(loginType))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> PasswordLogin();</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"passcode"</span>.equals(loginType))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> DomainLogin();</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"没有找到登录类型"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟servlet接收前端请求，由工厂获取具体登录类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String loginType = <span class="string">"password"</span>;</span><br><span class="line">        String telPhone = <span class="string">"13799990808"</span>;</span><br><span class="line">        String password = <span class="string">"password"</span>;</span><br><span class="line">        Login login = LoginFactory.getLogin(loginType);</span><br><span class="line">        <span class="keyword">boolean</span> bool = login.verify(telPhone, password);</span><br><span class="line">        <span class="keyword">if</span> (bool) &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 业务逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 业务逻辑</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>简单工厂模式的结构如下图：</p><p><img src="simple_factory_1.png" alt=""></p><p>优点：模式的核心是工厂类。这个类含有必要的逻辑判断，可以决定在什么时候创建哪一个登录验证类的实例，而<strong>调用者则可以免除直接创建对象的责任</strong>。<strong>简单工厂模式通过这种做法实现了对责任的分割，当系统引入新的登录方式的时候无需修改调用者</strong>。</p><p>缺点：工厂类集中了所以的创建逻辑，当有复杂的多层次等级结构时，所有的业务逻辑都在这个工厂类中实现。什么时候它不能工作了，整个系统都会受到影响。</p><p>转载自：<a href="https://www.cnblogs.com/java-my-life/archive/2012/03/22/2412308.html" target="_blank" rel="noopener">java_my_life</a>.</p><h2 id="工厂方法（Factory-Method）"><a href="#工厂方法（Factory-Method）" class="headerlink" title="工厂方法（Factory Method）"></a>工厂方法（Factory Method）</h2><p>工厂方法模式：定义一个<strong>创建产品对象的工厂接口</strong>，<strong>将实际创建工作推迟到工厂子类中</strong>。</p><p><strong>场景</strong>：某财务系统需要支持对数据库中的员工薪资进行导出，并且支持多种格式如：HTML、PDF等，每种格式导出的文件结构不同，比如有标准结构和财务需要的结构两种。</p><p>如果使用简单工厂模式，则工厂类必定过于臃肿。因为简单工厂模式只有一个工厂类，它需要处理所有的创建的逻辑。假如以上需求支持n种导出的格式以及2种导出的结构，那工厂类则需要<code>2*n</code>个if else语句来创建<code>2*n</code>种不同的类型。如果日后需求不断增加，则后果不堪设想。</p><p>这时候就需要工厂方法模式来处理以上需求。在工厂方法模式中，核心的工厂类不再负责所有的对象的创建，而是将具体创建的工作交给子类去做。这个核心类则摇身一变，成为了一个抽象工厂角色，仅负责给出具体工厂子类必须实现的接口，而不接触哪一个类应当被实例化这种细节。</p><p><strong>这种进一步抽象化的结果，使这种工厂方法模式可以用来允许系统在不修改具体工厂角色的情况下引进新的产品，引进一个新的产品则再创建一个新的工厂即可</strong>。这一特点无疑使得工厂方法模式具有超过简单工厂模式的优越性。下面就针对以上需求设计UML图：</p><p><img src="factory_method_1.png" alt=""></p><p>从上图可以看出，这个使用工厂方法模式的系统涉及到以下角色：</p><ul><li><strong>抽象工厂（ExportFactory）角色</strong>：担任这个角色的是工厂方法模式的核心，任何在模式中创建对象的工厂类必须实现这个接口。在实际的系统中，这个角色也常常使用抽象类实现。</li><li><strong>具体工厂（ExportHtmlFactory、ExportPdfFactory）角色</strong>：担任这个角色的是实现了抽象工厂接口的具体Java类。具体工厂角色含有与业务密切相关的逻辑，并且受到使用者的调用以创建导出类（如：ExportStandardHtmlFile）。假如我们新增了一个需求：导出CSV格式，则只需要新建一个实现ExportFactory接口的ExportCsvFactory工厂类即可。</li><li><strong>抽象导出（ExportFile）角色</strong>：具体工厂角色所创建对象的超类，也就是所有导出类的共同父类或共同拥有的接口。在实际的系统中，这个角色也常常使用抽象类实现。</li><li><strong>具体导出（ExportStandardHtmlFile等）角色</strong>：这个角色实现了抽象导出（ExportFile）角色所声明的接口，具体工厂角色所创建的每一个对象都是某个具体导出角色的实例。</li></ul><p><a href="https://github.com/Laishiji/designpattern/tree/main/factorymethod" target="_blank" rel="noopener">源代码参见GitHub</a>.</p><p>简单工厂模式可以看作是工厂方法模式的特例，设想如果非常确定一个系统只需要一个具体工厂类，那么不妨把抽象工厂类合并到具体工厂类中去。由于只有一个具体工厂类，所以不妨将工厂方法改为静态方法，这时候就得到了简单工厂模式。</p><p>转载自：<a href="https://www.cnblogs.com/java-my-life/archive/2012/03/25/2416227.html" target="_blank" rel="noopener">java_my_life</a>.</p><h2 id="抽象工厂（Abstract-Factory）"><a href="#抽象工厂（Abstract-Factory）" class="headerlink" title="抽象工厂（Abstract Factory）"></a>抽象工厂（Abstract Factory）</h2><p><strong>工厂方法模式中一个工厂类只能生产一种抽象产品类</strong>，比如上面的例子每一个具体工厂只能生产导出文件对象，<strong>而抽象工厂模式中一个具体工厂可以生产多种产品</strong>。还是以上面的场景为例，假设现在我们新增一个需求：该财务系统不仅要实现导出薪资文件功能，还要实现导入财务报表功能，假设财务报表有HTML和PDF两种格式，该怎么做？</p><ol><li>我们只需要将ExportFactory接口与ExportHtmlFactory、ExportPdfFactory实现类改名为Factory接口与HtmlFactory、PdfFactory，然后在接口与实现类种添加getImportFile方法；</li><li>创建ImportFile接口与对应的ImportHtmlFile、ImportPdfFile实现类；</li><li>在工厂类的getImportFile方法中创建ImportHtmlFile、ImportPdfFile实现类对象。</li></ol><p><a href="https://github.com/Laishiji/designpattern/tree/main/abstractfactory/src/main/java" target="_blank" rel="noopener">源代码参考GitHub</a>.</p><p>以下是一个更容易理解的例子：</p><ul><li><p>简单工厂模式：现有一个鼠标工厂，专业生产鼠标，给参数0，生产戴尔鼠标，给参数1，生产惠普鼠标。</p><p><img src="simplefac.jpg" alt=""></p></li><li><p>工厂方法模式：将简单工厂模式的方法中的判断逻辑抽取出来成为工作子类，实现解耦。</p><p><img src="facmethod.jpg" alt=""></p><p>当新增需求比如该鼠标工厂接了联想的订单，只需要新增一个LenovoMouseFactory即可，如果使用简单工厂模式的话则需要修改工厂类的代码，不符合开闭原则。</p></li><li><p>抽象工厂：假设我们的鼠标工厂越发红火，拓展了业务，不再只生产鼠标，同时还生产键盘等其他PC外设，那么我们只需要在原有的工厂中新增产品线即可。</p><p><img src="absfactory.jpg" alt=""></p></li></ul><h2 id="原型（Prototype）"><a href="#原型（Prototype）" class="headerlink" title="原型（Prototype）"></a>原型（Prototype）</h2><p>原型模式：<strong>通过给出一个原型对象来指明所有创建的对象的类型，然后用复制这个原型对象的办法创建出更多同类型的对象。</strong></p><p>Object类提供了一个clone()方法，该方法可以将一个对象复制一份，但是需要实现了clone方法的Java类必须实现接口Cloneable，此时在另一个类中就可以通过调用该Java类的clone方法获取克隆对象了（浅拷贝）。我们可以使用该特性实现原型模式。</p><p>关于深拷贝与浅拷贝：</p><h3 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h3><ul><li><p>B对A的浅拷贝：创建新对象B，将A的字段值复制到B。</p><ol><li>如果该<strong>字段值是</strong>对对象（例如，存储器地址）的<strong>引用</strong>，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。</li><li>如果该<strong>字段值是基本数据类型</strong>，则复制值。</li></ol></li><li><p>Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法， then <code>A B = (A) new A().clone();</code></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    C object;</span><br><span class="line">    A(<span class="keyword">int</span> val, C obj)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.object = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A aObj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> C(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        A bObj = (A) aObj.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如上代码中，如果bObj修改了引用类型C object中b的值为10，那么对象aObj中引用类型C object中b的值也是10，因为浅拷贝只是拷贝了aObj中object的引用（地址）给bObj。</p></li></ul><h3 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h3><ul><li>B对A的深拷贝：创建新对象B，对于A的引用类型字段，在B中创建该引用类型对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。</li><li>要实现深拷贝，不仅A需要实现Cloneable接口并重写clone方法，A中的引用类型C也需要实现Cloneable接口并重写clone方法。</li><li>深拷贝也可通过对象序列化的方式实现ByteArrayInputStream、ByteArrayOutputStream、ObjectInputStream、ObjectOutputStream。</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">    C(<span class="keyword">int</span> a, <span class="keyword">int</span> b)&#123;</span><br><span class="line">        <span class="keyword">this</span>.a = a;</span><br><span class="line">        <span class="keyword">this</span>.b = b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span> <span class="keyword">throws</span> CloneNotSupportedException </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">super</span>.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> <span class="keyword">implements</span> <span class="title">Cloneable</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> val;</span><br><span class="line">    C object;</span><br><span class="line">    A(<span class="keyword">int</span> val, C obj)&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">        <span class="keyword">this</span>.object = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">clone</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            A a = (A) <span class="keyword">super</span>.clone();</span><br><span class="line">            a.object = (C) object.clone();</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;<span class="keyword">catch</span>(CloneNotSupportedException e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        A aObj = <span class="keyword">new</span> A(<span class="number">1</span>, <span class="keyword">new</span> C(<span class="number">2</span>,<span class="number">3</span>));</span><br><span class="line">        A bObj = (A) aObj.clone();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring中原型模式的应用：当指定bean的scope为prototype时，表示bean对象的创建是多例的，每次调用getBean方法都会复制一份。（深拷贝）</p><h1 id="结构型模式"><a href="#结构型模式" class="headerlink" title="结构型模式"></a>结构型模式</h1><h2 id="适配器（Adapter）"><a href="#适配器（Adapter）" class="headerlink" title="适配器（Adapter）"></a>适配器（Adapter）</h2><p><strong>适配器模式将某个类的接口转换为客户端期望的另一个接口表示</strong>（现实生活中的转接头，充电头都是适配器），主要目的是解决兼容性问题，让原本因接口不匹配不能一起工作的两个类可以协同工作。</p><p>从用户的角度来看，用户是看不到被适配者目标的，感觉只是和适配器接口交互。</p><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>实现方式：<strong>Adapter类（适配器类）通过：继承src类（被适配类），实现dst接口（目标接口），完成src到dst的适配。</strong></p><p><strong>场景</strong>：以电源适配器为例，我们需要将220V（被适配类）的电压转换为5V（目标接口）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被适配类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Voltage220V</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出220V的电压</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output220V</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="number">220</span>;</span><br><span class="line">        <span class="keyword">return</span> src;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类继承自被适配类，实现目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">extends</span> <span class="title">Voltage220V</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = <span class="keyword">super</span>.output220V();</span><br><span class="line">        <span class="keyword">int</span> dst = src / <span class="number">44</span>;<span class="comment">//模拟变压操作</span></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟使用5V电压充电的手机</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Phone</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">charge</span><span class="params">(Voltage5V voltage5V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> voltage = voltage5V.output5V();</span><br><span class="line">        <span class="keyword">if</span>(voltage == <span class="number">5</span>)</span><br><span class="line">            System.out.println(<span class="string">"充电中..."</span>);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(voltage &gt; <span class="number">5</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"电压过高，不能充电！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charge(<span class="keyword">new</span> VoltageAdapter());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>实现方式：<strong>Adapter类（适配器类）通过：持有src类（被适配类）的实例，实现dst接口（目标接口），完成src到dst的适配。</strong></p><p>根据“组合/聚合复用原则”，在系统中尽量使用<strong>聚合关系来替代继承关系</strong>，对象适配器模式是对类适配器的改进。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 适配器类持有被适配类对象，实现目标接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VoltageAdapter</span> <span class="keyword">implements</span> <span class="title">Voltage5V</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    Voltage220V voltage220V;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">VoltageAdapter</span><span class="params">(Voltage220V voltage220V)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.voltage220V = voltage220V;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">output5V</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> src = voltage220V.output220V();</span><br><span class="line">        <span class="keyword">int</span> dst = src / <span class="number">44</span>;<span class="comment">//模拟变压操作</span></span><br><span class="line">        <span class="keyword">return</span> dst;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Phone phone = <span class="keyword">new</span> Phone();</span><br><span class="line">        phone.charge(<span class="keyword">new</span> VoltageAdapter(<span class="keyword">new</span> Voltage220V()));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="接口适配器"><a href="#接口适配器" class="headerlink" title="接口适配器"></a>接口适配器</h3><p>又叫<strong>默认适配器模式，</strong>适用情景：使用者只想使用一个接口的部分方法，此时我们就需要一个默认适配器。</p><p>当不需要全部实现接口提供的方法时，可先设计一个抽象类适配器，并为该接口中每个方法提供一个默认实现（空方法），那么该抽象类的子类可有选择地覆盖父类的某些方法来实现需求。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ALotOfMethod</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">DefaultAdapter</span> <span class="keyword">implements</span> <span class="title">ALotOfMethod</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m0</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m2</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        DefaultAdapter defaultAdapter = <span class="keyword">new</span> DefaultAdapter()&#123;</span><br><span class="line">            <span class="comment">//该匿名内部类是抽象类DefaultAdapter的子类</span></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">m1</span><span class="params">()</span></span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"只使用m1方法"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        defaultAdapter.m1();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Spring MVC中的HandlerAdapter就使用了适配器模式：</p><p><img src="spring_adapter.png" alt=""></p><p>HandlerAdapter的实现子类使得每一种Controller都有对应的适配器实现类。</p><h2 id="装饰器（Decorator）"><a href="#装饰器（Decorator）" class="headerlink" title="装饰器（Decorator）"></a>装饰器（Decorator）</h2><p><strong>装饰模式又名包装(Wrapper)模式。装饰模式以对客户端透明的方式动态扩展对象的功能，是继承关系的一个替代方案。</strong></p><p>装饰模式的类图：</p><p><img src="decorator.png" alt=""></p><p>在装饰模式中的角色有：</p><ul><li><strong>抽象构件(Component)角色：</strong>给出一个抽象接口，以规范准备接收增强功能的对象。</li><li><strong>具体构件(ConcreteComponent)角色：</strong>定义一个将要接收增强的类。</li><li><strong>装饰(Decorator)角色：</strong>持有一个抽象构建角色，并通过构造器注入具体构件角色。</li><li><strong>具体装饰(ConcreteDecorator)角色：</strong>负责给构件对象附加增强功能。</li></ul><p>比如我们在实际开发中自定义异常处理功能：</p><p>抽象构件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">CommonError</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span></span>; <span class="comment">//获取错误码</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMessage</span><span class="params">()</span></span>; <span class="comment">//获取错误消息</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMessage</span><span class="params">(String errorMessage)</span></span>;<span class="comment">//设置错误消息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体装饰器角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BusinessException</span> <span class="keyword">extends</span> <span class="title">Exception</span> <span class="keyword">implements</span> <span class="title">CommonError</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> CommonError commonError;<span class="comment">//持有抽象构建角色</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError)</span></span>&#123;<span class="comment">//构造器注入具体构件</span></span><br><span class="line">        <span class="keyword">super</span>();<span class="comment">//Throwable初始化</span></span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">BusinessException</span><span class="params">(CommonError commonError,String errorMessage)</span></span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.commonError = commonError;</span><br><span class="line">        <span class="keyword">this</span>.commonError.setErrorMessage(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorCode();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> commonError.getErrorMessage();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMessage</span><span class="params">(String errorMessage)</span> </span>&#123;</span><br><span class="line">        commonError.setErrorMessage(errorMessage);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>具体构件角色：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> EnumBusinessError implements CommonError&#123;</span><br><span class="line"></span><br><span class="line">    PARAMETER_VALIDATION_ERROR(<span class="number">10001</span>,<span class="string">"参数不合法"</span>),</span><br><span class="line">    UNKNOWN_ERROR(<span class="number">10002</span>,<span class="string">"未知错误"</span>),</span><br><span class="line"></span><br><span class="line">    USER_NOT_EXIST_ERROR(<span class="number">20001</span>,<span class="string">"用户不存在"</span>),</span><br><span class="line">    USER_LOGIN_FAIL(<span class="number">20002</span>, <span class="string">"用户手机号或密码不正确"</span>),</span><br><span class="line">    USER_NOT_LOGIN(<span class="number">20003</span>, <span class="string">"用户未登录"</span>),</span><br><span class="line"></span><br><span class="line">    STOCK_NOT_ENOUGH(<span class="number">30001</span>, <span class="string">"库存不足"</span>),</span><br><span class="line">    ;<span class="comment">//具体构件的枚举对象，用于注入具体装饰角色的构造器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> errorCode;</span><br><span class="line">    <span class="keyword">private</span> String errorMessage;</span><br><span class="line"></span><br><span class="line">    EnumBusinessError(<span class="keyword">int</span> errorCode, String errorMessage)&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorCode = errorCode;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getErrorCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorCode;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getErrorMessage</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setErrorMessage</span><span class="params">(String errorMessage)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.errorMessage = errorMessage;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Test：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="string">"不满足判断条件则抛出异常"</span>.equals(<span class="string">"a"</span>))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BusinessException(EnumBusinessError.PARAMETER_VALIDATION_ERROR);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰模式在JDK中的应用有I/O标准库的设计，以InputStream为例：</p><p><img src="decorator_JDK_IO.png" alt=""></p><p>上图中：</p><ul><li><strong>抽象构件(Component)角色：</strong>由InputStream扮演。这是一个抽象类，为各种子类型提供统一的接口。</li><li><strong>具体构件(ConcreteComponent)角色：</strong>由ByteArrayInputStream、FileInputStream、PipedInputStream、StringBufferInputStream等类扮演。它们实现了抽象构件角色所规定的接口。</li><li><strong>抽象装饰(Decorator)角色：</strong>由FilterInputStream扮演。它实现了InputStream所规定的接口。</li><li><strong>具体装饰(ConcreteDecorator)角色：</strong>由几个类扮演，分别是BufferedInputStream、DataInputStream以及两个不常用到的类LineNumberInputStream、PushbackInputStream。</li></ul><h2 id="代理（Proxy）"><a href="#代理（Proxy）" class="headerlink" title="代理（Proxy）"></a>代理（Proxy）</h2><p>参见：<a href="https://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/">JDK动态代理</a>.</p><p>代理模式与装饰模式在代码实现形式上几乎是一致的，区别只在于抽象层面我们分别赋予它们的含义。</p><h1 id="行为模式"><a href="#行为模式" class="headerlink" title="行为模式"></a>行为模式</h1><h2 id="模板方法（Template-Method）"><a href="#模板方法（Template-Method）" class="headerlink" title="模板方法（Template Method）"></a>模板方法（Template Method）</h2><p>模板方法模式：<strong>准备一个抽象类，将部分逻辑以具体方法以及具体构造函数的形式实现，然后声明一些抽象方法来迫使子类实现剩余的逻辑</strong>。不同的子类可以以不同的方式实现这些抽象方法，从而对剩余的逻辑有不同的实现。这就是模板方法模式的用意。</p><p>JDK中对模板方法模式最经典的应用就是J.U.C包中的AbstractQueuedSynchronizer类了。参考<a href="https://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/#AQS">JUC之锁</a>。</p><p>模板方法模式的类图如下：</p><p><img src="template_method.png" alt=""></p><p>这里涉及到两个角色：</p><p><strong>抽象模板(Abstract Template)角色有如下责任：</strong></p><ul><li>定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。</li><li>定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。</li></ul><p><strong>具体模板(Concrete Template)角色又如下责任：</strong></p><ul><li>实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。</li><li>每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。</li></ul><h2 id="策略（Strategy）"><a href="#策略（Strategy）" class="headerlink" title="策略（Strategy）"></a>策略（Strategy）</h2><p>策略模式：<strong>针对一组算法，将每一个算法封装到具有共同接口的独立的类中，从而使得它们可以相互替换。</strong></p><p>策略模式类图：</p><p><img src="strategy.png" alt=""></p><p>这个模式涉及到三个角色：</p><ul><li><strong>环境(Context)角色：</strong>持有一个Strategy的引用。</li><li><strong>抽象策略(Strategy)角色：</strong>这是一个抽象角色，通常由一个接口或抽象类实现。此角色给出所有的具体策略类所需的接口。</li><li><strong>具体策略(ConcreteStrategy)角色：</strong>包装了相关的算法或行为。</li></ul><p><strong>在客户端通过控制反转创建具体策略角色的前提下，策略模式使得客户端可以配置式地随时插入算法（新建一个ConcreteStrategy类）或更换算法。</strong></p><p><strong>场景</strong>：假设现在要设计一个贩卖各类书籍的电子商务网站的购物车系统。一个最简单的情况就是把所有货品的单价乘上数量，但是实际情况肯定比这要复杂。比如，本网站可能对所有的高级会员提供每本20%的促销折扣；对中级会员提供每本10%的促销折扣；对初级会员没有折扣。</p><p>根据描述，折扣是根据以下的几个算法中的一个进行的：</p><ul><li><p>算法一：对初级会员没有折扣。</p></li><li><p>算法二：对中级会员提供10%的促销折扣。</p></li><li><p>算法三：对高级会员提供20%的促销折扣。</p></li></ul><p><img src="strategy2.png" alt=""></p><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 计算图书的价格</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> booksPrice    图书的原价</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span>    计算出打折后的价格</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PrimaryMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对于初级会员的没有折扣"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IntermediateMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对于中级会员的折扣为10%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.9</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdvancedMemberStrategy</span> <span class="keyword">implements</span> <span class="title">MemberStrategy</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">double</span> <span class="title">calcPrice</span><span class="params">(<span class="keyword">double</span> booksPrice)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"对于高级会员的折扣为20%"</span>);</span><br><span class="line">        <span class="keyword">return</span> booksPrice * <span class="number">0.8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//选择并创建需要使用的策略对象</span></span><br><span class="line">        MemberStrategy strategy = <span class="keyword">new</span> AdvancedMemberStrategy();</span><br><span class="line">        <span class="comment">//创建环境</span></span><br><span class="line">        Price price = <span class="keyword">new</span> Price(strategy);</span><br><span class="line">        <span class="comment">//计算价格</span></span><br><span class="line">        <span class="keyword">double</span> quote = price.quote(<span class="number">300</span>);</span><br><span class="line">        System.out.println(<span class="string">"图书的最终价格为："</span> + quote);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>转载自：<a href="https://www.cnblogs.com/java-my-life/archive/2012/05/10/2491891.html" target="_blank" rel="noopener">java_my_life</a>.</p><h2 id="观察者（Observer）"><a href="#观察者（Observer）" class="headerlink" title="观察者（Observer）"></a>观察者（Observer）</h2><p>观察者模式：<strong>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。这个主题对象在状态上发生变化时，会通知所有观察者对象，使它们能够自动更新自己。</strong></p><p>一个软件系统常常要求在某一个对象的状态发生变化的时候，某些其他的对象做出相应的改变。观察者模式是满足这一要求的各种设计方案中最重要的一种。</p><p>观察者模式类图如下：</p><p><img src="observer.png" alt=""></p><p>观察者模式所涉及的角色有：</p><ul><li><p><strong>抽象主题(Subject)角色：</strong>抽象主题角色把所有对观察者对象的引用保存在一个集合（比如ArrayList对象）里，每个主题都可以有任何数量的观察者。抽象主题提供可以增加和删除观察者对象的方法，抽象主题角色又叫做抽象被观察者(Observable)角色。</p></li><li><p><strong>具体主题(ConcreteSubject)角色：</strong>具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色又叫做具体被观察者(Concrete Observable)角色。</p></li><li><p><strong>抽象观察者(Observer)角色：</strong>为所有的具体观察者定义一个接口，在得到主题的通知时更新自己，这个接口叫做更新接口。</p></li><li><p><strong>具体观察者(ConcreteObserver)角色：</strong>存储与主题的状态自恰的状态。具体观察者角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。如果需要，具体观察者角色可以保持一个指向具体主题对象的引用。</p></li></ul><p>代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subject</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用来保存注册的观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> List&lt;Observer&gt; list = <span class="keyword">new</span> ArrayList&lt;Observer&gt;();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 注册观察者对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer    观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">attach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        list.add(observer);</span><br><span class="line">        System.out.println(<span class="string">"Attached an observer"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 删除观察者对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> observer    观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">detach</span><span class="params">(Observer observer)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        list.remove(observer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知所有注册的观察者对象</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">nodifyObservers</span><span class="params">(String newState)</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(Observer observer : list)&#123;</span><br><span class="line">            observer.update(newState);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 更新接口</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> state    更新的状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String state)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteObserver</span> <span class="keyword">implements</span> <span class="title">Observer</span></span>&#123;</span><br><span class="line">    <span class="comment">//观察者的状态</span></span><br><span class="line">    <span class="keyword">private</span> String observerState;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(String state)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 更新观察者的状态，使其与目标的状态保持一致</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        observerState = state;</span><br><span class="line">        System.out.println(<span class="string">"状态为："</span>+observerState);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteSubject</span> <span class="keyword">extends</span> <span class="title">Subject</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String state;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getState</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> state;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">change</span><span class="params">(String newState)</span></span>&#123;</span><br><span class="line">        state = newState;</span><br><span class="line">        System.out.println(<span class="string">"主题状态为："</span> + state);</span><br><span class="line">        <span class="comment">//状态发生改变，通知各个观察者</span></span><br><span class="line">        <span class="keyword">this</span>.nodifyObservers(state);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcreteSubject subject = <span class="keyword">new</span> ConcreteSubject();</span><br><span class="line">        Observer observer = <span class="keyword">new</span> ConcreteObserver();</span><br><span class="line">        subject.attach(observer);</span><br><span class="line">        subject.change(<span class="string">"new State"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>拉模型与推模型</strong></p><p>在观察者模式中，又分为推模型和拉模型两种方式。</p><ul><li>推模型：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。</li><li>拉模型：主题对象在通知观察者时，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，<strong>会把主题对象自身的引用通过update()方法传递给观察者</strong>，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。</li></ul><p>很显然上述的代码示例是推模型。</p><p><strong>JAVA提供的对观察者模式的支持</strong></p><p>　在JAVA语言的java.util库里面，提供了一个<code>Observable</code>类以及一个<code>Observer</code>接口，构成JAVA语言对观察者模式的支持。</p><p><strong>Observer接口</strong></p><p>这个接口只定义了一个方法，即update()方法，当被观察者对象的状态发生变化时，被观察者对象的notifyObservers()方法就会调用这一方法。</p><p>所有的观察者类都需要实现该接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(Observable o, Object arg)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>Observable类</strong></p><p><strong>被观察者类（主题类）都是java.util.Observable类的子类</strong>。java.util.Observable提供公开的方法支持观察者对象，这些方法中有两个对Observable的子类非常重要：一个是<code>setChanged()</code>，另一个是<code>notifyObservers()</code>。第一方法setChanged()被调用之后会设置一个内部标记变量，代表被观察者对象的状态发生了变化。第二个是notifyObservers()，这个方法被调用时，会调用所有登记过的观察者对象的update()方法，使这些观察者对象可以更新自己。</p><h2 id="责任链（Chain-Of-Responsibility）"><a href="#责任链（Chain-Of-Responsibility）" class="headerlink" title="责任链（Chain Of Responsibility）"></a>责任链（Chain Of Responsibility）</h2><p>责任链模式：<strong>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。</strong></p><p>UML类图：</p><p><img src="chain_of_responsibility.png" alt=""></p><p>责任链模式涉及到的角色如下所示：</p><ul><li><p><strong>抽象处理者(Handler)角色：</strong>定义出一个处理请求的接口。如果需要，接口可以定义出一个方法以设定和返回对下家的引用。这个角色通常由一个Java抽象类或者Java接口实现。上图中Handler类的聚合关系给出了具体子类对下家的引用，抽象方法handleRequest()规范了子类处理请求的操作。</p></li><li><p><strong>具体处理者(ConcreteHandler)角色：</strong>具体处理者接到请求后，可以选择将请求处理掉，或者将请求传给下家。由于具体处理者持有对下家的引用，因此，如果需要，具体处理者可以访问下家。</p></li></ul><p><strong>场景</strong>：公司申请聚餐费用的管理。</p><p>​        申请聚餐费用的大致流程一般是：由申请人先填写申请单，然后交给领导审批，如果申请批准下来，领导会通知申请人审批通过，然后申请人去财务领取费用，如果没有批准下来，领导会通知申请人审批未通过，此事也就此作罢。</p><p>　　不同级别的领导，对于审批的额度是不一样的，比如，项目经理只能审批500元以内的申请；部门经理能审批1000元以内的申请；而总经理可以审核任意额度的申请。</p><p>　　也就是说，当某人提出聚餐费用申请的请求后，该请求会经由项目经理、部门经理、总经理之中的某一位领导来进行相应的处理，但是提出申请的人并不知道最终会由谁来处理他的请求，一般申请人是把自己的申请提交给项目经理，或许最后是由总经理来处理他的请求。</p><p>​        可以使用责任链模式来实现上述功能：当某人提出聚餐费用申请的请求后，该请求会在 <strong>项目经理—〉部门经理—〉总经理</strong> 这样一条领导处理链上进行传递，发出请求的人并不知道谁会来处理他的请求，每个领导会根据自己的职责范围，来判断是处理请求还是把请求交给更高级别的领导，只要有领导处理了，传递就结束了。</p><p>类图如下：</p><p><img src="chain_of_responsibility2.png" alt=""></p><p><a href="https://github.com/Laishiji/designpattern/tree/main/chainofresponsibility/src/main/java" target="_blank" rel="noopener">源代码参考GitHub</a>.</p><p>Spring MVC中的HandlerExecutionChain就使用到了责任链模式。</p><h1 id="Spring中的设计模式总结"><a href="#Spring中的设计模式总结" class="headerlink" title="Spring中的设计模式总结"></a>Spring中的设计模式总结</h1><p>待补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;学习设计模式时，应当关注该模式“可以解决什么问题”。&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h1&gt;&lt;p&gt;软件工程中，设计模式（design p
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="设计模式" scheme="http://thmasterplan.cn/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringBoot/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringBoot/</id>
    <published>2020-10-28T01:26:07.000Z</published>
    <updated>2020-11-01T15:39:54.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>SpringBoot使用一个全局的配置文件，文件名是固定的application。有两种格式的配置文件：</p><ul><li>property：application.properties</li><li>yaml：application.yml</li></ul><p>该配置文件用于修改SpringBoot自动配置的默认值。SpringBoot会扫描以下位置的全局配置文件，优先级从高到低如下：<code>项目根目录/config/</code>， <code>项目根目录/</code>，<code>resources/config/</code>，  <code>resources/</code>，高优先级的配置会覆盖低优先级的配置，所有的配置会形成互补配置。Spring Boot还支持多种外部配置方式。</p><h3 id="YAML"><a href="#YAML" class="headerlink" title="YAML"></a>YAML</h3><ul><li><p><code>属性: 值</code>表示一对键值对，冒号后的<strong>空格是必须的</strong>。</p></li><li><p>使用空格的缩进表示层级关系，只要是左对齐的一列属性都是同一层级的。</p></li><li><p>属性和值大小写敏感。</p></li><li><p>值的类型可以有：</p><ul><li><p>基本数据类型与字符串：可以不使用单引号或双引号。</p></li><li><p>对象，Map。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写法1</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line"> <span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="comment">#写法2</span></span><br><span class="line"><span class="attr">user:</span> <span class="string">&#123;name:</span> <span class="string">zhangsan,</span> <span class="attr">age:</span> <span class="number">18</span><span class="string">&#125;</span></span><br></pre></td></tr></table></figure></li><li><p>数组, Set, List。例如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#写法1</span></span><br><span class="line"><span class="attr">array:</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">a</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">b</span></span><br><span class="line"> <span class="bullet">-</span> <span class="string">c</span></span><br><span class="line"><span class="comment">#写法2</span></span><br><span class="line"><span class="attr">array:</span> <span class="string">[a,</span> <span class="string">b,</span> <span class="string">c]</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><p>注意：YAML不支持使用注解<code>@PropertySource</code>导入配置。</p><h3 id="获取配置文件中的值"><a href="#获取配置文件中的值" class="headerlink" title="获取配置文件中的值"></a>获取配置文件中的值</h3><p>YAML文件：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">age:</span> <span class="number">20</span></span><br><span class="line"><span class="attr">name:</span> <span class="string">zhangsan</span></span><br><span class="line"><span class="attr">user:</span></span><br><span class="line">  <span class="attr">name:</span> <span class="string">zhaosi</span></span><br><span class="line">  <span class="attr">age:</span> <span class="number">24</span></span><br></pre></td></tr></table></figure><p>实体类User：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootTest</span><span class="comment">//指定入口类或测试环境</span></span><br><span class="line"><span class="meta">@RunWith</span>(SpringRunner<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">YamlTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;age&#125;"</span>)<span class="comment">//自动注入</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;name&#125;"</span>)<span class="comment">//自动注入</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getProperty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(name+<span class="string">":"</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">getUser</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(user.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong><code>@ConfigurationProperties</code>注解</strong>：把同类配置信息自动封装成一个实体类，其属性prefix指定配置文件配置项的前缀。</p><p>另一种使用<code>@ConfigurationProperties</code>该注解的方式是，不需要在实体类上注解<code>@Component和@ConfigurationProperties</code>，而是在配置类使用<code>@Bean</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix=<span class="string">"user"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUserBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> User();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>导入配置文件处理器，配置文件值绑定时就会有提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p><code>@ConfigurationProperties</code>只能用于SpringBoot的全局配置文件application，而<code>@PropertySource</code>可以用于加载指定的配置文件，但是后者不支持yaml格式。</p><p><code>@Value</code>只能用于基本数据类型的注入，且支持<code>#{SpEL}</code>表达式。</p><p><code>@ImportReSource</code>：用于加载Spring的XML配置文件。SpringBoot不推荐使用这种方式，而是使用全注解的方式，即创建配置类。</p><h3 id="配置文件占位符"><a href="#配置文件占位符" class="headerlink" title="配置文件占位符"></a>配置文件占位符</h3><h4 id="RandomValuePropertySource"><a href="#RandomValuePropertySource" class="headerlink" title="RandomValuePropertySource"></a>RandomValuePropertySource</h4><p>可以在配置文件中使用该类的随机数。使用方式：<code>${random.value}</code>, <code>${random.uuid}</code>, <code>${random.int}</code>, <code>${random.long}</code>, <code>${random.int(10)}</code>,<code>${random.(10,100)}</code>。</p><h4 id="属性配置占位符"><a href="#属性配置占位符" class="headerlink" title="属性配置占位符"></a>属性配置占位符</h4><p>可以在配置文件中引用前面配置过的属性，例如：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">app.name</span>=<span class="string">MyApp</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name&#125; is a Spring Boot App.</span></span><br><span class="line"><span class="comment">#或者如果前面没有配置，也可配置默认值</span></span><br><span class="line"><span class="meta">app.description</span>=<span class="string">$&#123;app.name: DefaultAppName&#125; is a Spring Boot App.</span></span><br></pre></td></tr></table></figure><h3 id="配置多环境"><a href="#配置多环境" class="headerlink" title="配置多环境"></a>配置多环境</h3><p>在实际项目的开发过程中，经常需要配置多个环境（比如开发环境和生产环境），以便不同的环境使用不同配置参数。</p><h4 id="多配置文件方式"><a href="#多配置文件方式" class="headerlink" title="多配置文件方式"></a>多配置文件方式</h4><p>在resources目录下创建三个配置文件：</p><p>application-dev.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8080</span></span><br><span class="line"> <span class="attr">tomcat:</span> </span><br><span class="line">  <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">development</span></span><br></pre></td></tr></table></figure><p>application-prod.yml：</p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8888</span></span><br><span class="line"> <span class="attr">tomcat:</span> </span><br><span class="line">  <span class="attr">uri-encoding:</span> <span class="string">UTF-8</span></span><br><span class="line"><span class="attr">env:</span></span><br><span class="line"> <span class="attr">name:</span> <span class="string">produce</span></span><br></pre></td></tr></table></figure><p>application.yml： </p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">development</span> <span class="comment">#指定当前活动的配置文件为application-dev.yml</span></span><br></pre></td></tr></table></figure><p>properties格式同理：<code>spring.profiles.active=development</code></p><h4 id="文档块方式"><a href="#文档块方式" class="headerlink" title="文档块方式"></a>文档块方式</h4><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8080</span> <span class="comment">#默认为8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span></span><br><span class="line">  <span class="attr">active:</span> <span class="string">dev</span> <span class="comment">#激活dev则使用8081</span></span><br><span class="line"></span><br><span class="line"><span class="meta">---</span></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span> <span class="string">dev</span></span><br><span class="line"> </span><br><span class="line"><span class="meta">---</span></span><br><span class="line"></span><br><span class="line"><span class="attr">server:</span></span><br><span class="line"> <span class="attr">port:</span> <span class="number">8082</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"> <span class="attr">profiles:</span> <span class="string">prod</span></span><br></pre></td></tr></table></figure><h4 id="命令行方式"><a href="#命令行方式" class="headerlink" title="命令行方式"></a>命令行方式</h4><p>加入选项<code>--spring.profiles.active=prod</code>即可。</p><h3 id="自动装配原理"><a href="#自动装配原理" class="headerlink" title="自动装配原理"></a>自动装配原理</h3><p>application配置文件可以配置哪些属性？参照<a href="https://docs.spring.io/spring-boot/docs/2.1.17.RELEASE/reference/html/common-application-properties.html" target="_blank" rel="noopener">官方文档</a>。</p><p>———————————————————-待补充———————————————————-</p><h2 id="日志"><a href="#日志" class="headerlink" title="日志"></a>日志</h2><p>SLF4J(Simple Logging Facade for Java)：抽象层日志框架。</p><p>LogBack：具体的日志框架实现。</p><p><code>spring-boot-starter-logging</code>采用了SLF4J + LogBack实现日志功能，<strong>我们在开发的时候应该使用抽象层框架SLF4J，而LogBack的实现则是用于配置</strong>，这是<a href="https://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/#D%EF%BC%9A%E4%BE%9D%E8%B5%96%E5%80%92%E7%BD%AE%E5%8E%9F%E5%88%99%EF%BC%88Dependency-Inversion-Principle%EF%BC%89">依赖倒置原则</a>与<a href="https://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/#L%EF%BC%9A%E9%87%8C%E6%B0%8F%E6%9B%BF%E6%8D%A2%E5%8E%9F%E5%88%99%EF%BC%88Liskov-Substitution-Principle%EF%BC%89">里氏替换原则</a>的体现。</p><p>当我们引入其他依赖时，该依赖使用的日志框架可能与Spring Boot的实现方案不同，比如可能是JUL，log4j, log4j2等等。为了统一日志框架，SLF4J提供了常见日志框架实现的转换方案。我们唯一要做的就是<strong>在引入其他依赖时，排除掉其使用的日志框架</strong>即可，以此来避免SLF4J提供的转换jar包与之冲突。比如，Spring使用的就是commons-logging日志框架，在引入spring-core时，我们需要如此做：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">exclusions</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;<span class="name">exclusion</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-logging<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">         <span class="tag">&lt;/<span class="name">exclusion</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">exclusions</span>&gt;</span></span><br><span class="line"> <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="SLF4J的使用"><a href="#SLF4J的使用" class="headerlink" title="SLF4J的使用"></a>SLF4J的使用</h3><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//日志记录器   </span></span><br><span class="line">Logger logger = LoggerFactory.getLogger(getClass());</span><br><span class="line"></span><br><span class="line"><span class="comment">//日志级别</span></span><br><span class="line"><span class="comment">//由低到高：trace &lt; debug &lt; info &lt; warn &lt; error</span></span><br><span class="line">logger.trace(<span class="string">"trace..."</span>);</span><br><span class="line">logger.debug(<span class="string">"debug..."</span>);</span><br><span class="line">logger.info(<span class="string">"info..."</span>);</span><br><span class="line">logger.warn(<span class="string">"warn..."</span>);</span><br><span class="line">logger.error(<span class="string">"error..."</span>);</span><br></pre></td></tr></table></figure><p>Spring Boot默认使用info级别及以上的日志级别，所以trace和debug日志信息是不会输出到控制台的。我们可以在<code>application</code>配置文件中调整日志级别：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">logging.level.com.example</span>=<span class="string">trace</span></span><br></pre></td></tr></table></figure><p>以上配置的含义是：<code>com.example</code>包下的所有代码日志级别调整为trace及以上。</p><h4 id="常见日志配置"><a href="#常见日志配置" class="headerlink" title="常见日志配置"></a>常见日志配置</h4><p>如果我们不指定日志输出文件和路径，日志只会在控制台中输出。</p><p>在<code>application</code>配置文件中：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#默认生成日志文件到当前项目根目录下</span></span><br><span class="line"><span class="meta">logging.file</span>=<span class="string">mylog.log</span></span><br><span class="line"><span class="comment">#也可指定路径</span></span><br><span class="line"><span class="meta">logging.file</span>=<span class="string">G:/mylog.log</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#或者在当前磁盘下生成a目录，a目录下生成b目录，b目录下默认生成spring.log日志文件</span></span><br><span class="line"><span class="meta">logging.path</span>=<span class="string">/a/b</span></span><br><span class="line"><span class="comment">#                                                            [从左显示的]  </span></span><br><span class="line"><span class="comment">#指定控制台输出的日志格式   [           时间          ]  [ 线程名 ][字符宽度][最长50个字符] [日志消息与换行符]</span></span><br><span class="line"><span class="meta">logging.pattern.console</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;50&#125; - %msg%n</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#指定文件中日志输出的格式</span></span><br><span class="line"><span class="meta">logging.pattern.file</span>=<span class="string">%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; *** [%thread] *** %-5level *** %logger&#123;50&#125; ： %msg%n</span></span><br></pre></td></tr></table></figure><p>我们也可在resources下放入各个日志框架自己的配置文件，Spring Boot就不会使用默认配置了。</p><div class="table-container"><table><thead><tr><th>Logging System</th><th>Customization</th></tr></thead><tbody><tr><td>Logback</td><td><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td>Log4j2</td><td><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td>JDK (Java Util Logging)</td><td><code>logging.properties</code></td></tr></tbody></table></div><h4 id="切换日志框架"><a href="#切换日志框架" class="headerlink" title="切换日志框架"></a>切换日志框架</h4><p>假设要替换为log4j：</p><ol><li>在pom.xml中选中<code>spring-boot-starter-logging</code>，右键Diagrams打开依赖树；</li><li>选中logback-classic，右键Exclude; </li><li>选中log4j-over-slf4j，右键Exclude，也即删除SLF4J的覆盖方案；</li><li>导入SLF4J对log4j的适配方案依赖<code>slf4j-log4j12</code>。</li></ol><h2 id="JSR-303-–-Bean-Validation"><a href="#JSR-303-–-Bean-Validation" class="headerlink" title="JSR 303 – Bean Validation"></a>JSR 303 – Bean Validation</h2><p>JSR是Java Specification Requests的缩写，意思是Java 规范提案。是指向JCP(Java Community Process)提出新增一个标准化技术规范的正式请求。任何人都可以提交JSR，以向Java平台增添新的API和服务。JSR已成为Java界的一个重要标准。<a href="https://jcp.org/en/jsr/detail?id=303" target="_blank" rel="noopener">JSR - 303</a> 为 JavaBean 验证定义了相应的元数据模型和 API。</p><p>在任何时候，当你要处理一个应用程序的业务逻辑，数据校验是你必须要考虑和面对的事情。应用程序必须通过某种手段来确保输入进来的数据从语义上来讲是正确的。在通常的情况下，应用程序是分层的，不同的层由不同的开发人员来完成。很多时候同样的数据验证逻辑会出现在不同的层，这样就会导致代码冗余和一些管理的问题，比如说语义的一致性等。为了避免这样的情况发生，最好是将验证逻辑与相应的域模型进行绑定。</p><p>Hibernate Validator 是 Bean Validation 的参考实现 。 Hibernate Validator 提供了 JSR 303 规范中所有内置 constraint 的实现，除此之外还有一些附加的 constraint。</p><h3 id="Bean-Validation中的constraint"><a href="#Bean-Validation中的constraint" class="headerlink" title="Bean Validation中的constraint"></a>Bean Validation中的constraint</h3><div class="table-container"><table><thead><tr><th style="text-align:left"><strong>Constraint</strong></th><th style="text-align:left"><strong>被注解的属性：</strong></th></tr></thead><tbody><tr><td style="text-align:left"><code>@Valid</code></td><td style="text-align:left">是一个对象，需要检查此对象的所有字段值（级联验证）</td></tr><tr><td style="text-align:left"><code>@Null</code></td><td style="text-align:left">必须为 <code>null</code></td></tr><tr><td style="text-align:left"><strong><code>@NotNull</code></strong></td><td style="text-align:left"><strong>必须不为 <code>null</code></strong></td></tr><tr><td style="text-align:left"><code>@AssertTrue</code></td><td style="text-align:left">必须为 <code>true</code></td></tr><tr><td style="text-align:left"><code>@AssertFalse</code></td><td style="text-align:left">必须为 <code>false</code></td></tr><tr><td style="text-align:left"><code>@Min(value)</code></td><td style="text-align:left">必须是一个数字，其最小值为value</td></tr><tr><td style="text-align:left"><code>@Max(value)</code></td><td style="text-align:left">必须是一个数字，其最大值为value</td></tr><tr><td style="text-align:left"><code>@DecimalMin(value)</code></td><td style="text-align:left">必须是一个数字，其最小值为value</td></tr><tr><td style="text-align:left"><code>@DecimalMax(value)</code></td><td style="text-align:left">必须是一个数字，其最大值为value</td></tr><tr><td style="text-align:left"><code>@Size(max, min)</code></td><td style="text-align:left">大小必须在指定的范围内</td></tr><tr><td style="text-align:left"><code>@Digits (integer, fraction)</code></td><td style="text-align:left">必须是一个数字，其值必须在可接受的范围内</td></tr><tr><td style="text-align:left"><code>@Past</code></td><td style="text-align:left">必须是一个过去的日期</td></tr><tr><td style="text-align:left"><code>@Future</code></td><td style="text-align:left">必须是一个将来的日期</td></tr><tr><td style="text-align:left"><code>@Pattern(value)</code></td><td style="text-align:left">必须符合指定的正则表达式</td></tr></tbody></table></div><h3 id="Hibernate-Validator-附加的-constraint"><a href="#Hibernate-Validator-附加的-constraint" class="headerlink" title="Hibernate Validator 附加的 constraint"></a>Hibernate Validator 附加的 constraint</h3><div class="table-container"><table><thead><tr><th><strong>Constraint</strong></th><th><strong>被注解的属性：</strong></th></tr></thead><tbody><tr><td><code>@Email</code></td><td>必须是电子邮箱地址</td></tr><tr><td><code>@Length(min=, max=)</code></td><td>必须是字符串，其大小必须在指定的范围内</td></tr><tr><td><strong><code>@NotEmpty</code></strong></td><td><strong>若是字符串，则必须不为null；若是集合，则集合size &gt; 0</strong></td></tr><tr><td><code>@Range(min=, max=)</code></td><td>必须在合适的范围内</td></tr><tr><td><strong><code>@NotBlank</code></strong></td><td><strong>必须是字符串，且trim()后的length &gt; 0</strong></td></tr><tr><td><code>@URL</code></td><td>必须是字符串，且是一个有效的url</td></tr><tr><td><code>@CreditCardNumber</code></td><td>必须是字符串，且是合法的银行卡/信用卡</td></tr><tr><td><code>@ScriptAssert</code></td><td>要有JSR 223 - Java Scripting API的实现</td></tr><tr><td><code>@SafeHtml</code></td><td>classpath中要有jsoup包</td></tr></tbody></table></div><p>随着Hibernate Validator版本的迭代，也更新了一些其他的constraint，可在IDEA右侧工具栏的Bean Validation中查看。</p><h3 id="使用Hibernate-Validator"><a href="#使用Hibernate-Validator" class="headerlink" title="使用Hibernate Validator"></a>使用Hibernate Validator</h3><p>可以写一个统一的校验类，然后在service层或controller层中调用校验类的校验方法。若有参数不合法，则可使用自定义的异常类抛出参数不合法的异常信息。<a href="https://github.com/Laishiji/miaosha/tree/main/src/main/java/com/laishiji/miaosha/validator" target="_blank" rel="noopener">参考</a></p><h3 id="自定义constraint"><a href="#自定义constraint" class="headerlink" title="自定义constraint"></a>自定义constraint</h3><ol><li>自定义注解，参考Hibernate实现的注解。</li><li>自定义validator实现<code>ConstraintValidator</code>接口，并实现isValid方法。</li><li>将自定义validator赋值给<code>@Constraint</code>的validateBy属性。</li></ol><p>示例：自定义constraint, 校验参数必须是3的倍数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;ElementType.Field&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Constraint</span>(validateBy = &#123;MultipleOfThreeForInteger<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> @<span class="title">interface</span> <span class="title">MultipleOfThree</span></span>&#123;</span><br><span class="line">    <span class="function">String <span class="title">message</span><span class="params">()</span> <span class="keyword">default</span> "必须是3的倍数"</span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;?&gt;[] groups() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Payload&gt;[] payload() <span class="keyword">default</span> &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> MultipleOfThreeForInteger implements ConstraintValidator&lt;MultipleOfThree, Integer&gt;&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initialize</span><span class="params">(MultipleOfThree constraintAnnotation)</span></span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(Integer value, ConstraintValidatorContext context)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value % <span class="number">3</span> == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>至此，<code>@MultipleOfThree</code>就可以用于参数验证了。</p><h2 id="Thymeleaf模板引擎"><a href="#Thymeleaf模板引擎" class="headerlink" title="Thymeleaf模板引擎"></a>Thymeleaf模板引擎</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;配置&quot;&gt;&lt;a href=&quot;#配置&quot; class=&quot;headerlink&quot; title=&quot;配置&quot;&gt;&lt;/a&gt;配置&lt;/h2&gt;&lt;p&gt;SpringBoot使用一个全局的配置文件，文件名是固定的application。有两种格式的配置文件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;prop
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="SpringBoot" scheme="http://thmasterplan.cn/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>IDEA使用技巧</title>
    <link href="http://thmasterplan.cn/Others/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <id>http://thmasterplan.cn/Others/IDEA%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</id>
    <published>2020-10-25T07:25:43.000Z</published>
    <updated>2020-11-08T13:56:37.659Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Lombok插件"><a href="#Lombok插件" class="headerlink" title="Lombok插件"></a>Lombok插件</h2><p>使用该插件可以在编辑器中简化冗长的代码，尤其是POJO类。使用Lombok需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>Lombok使用注解来开启相应的功能：</p><ul><li><code>@Data</code>：自动生成Getter/Setter/toString/equals/hashCode方法，以及不带参数的构造方法。</li><li><code>@NonNull</code>：帮助处理NPE异常。</li><li><code>@CleanUp</code>：自动管理资源，不用再在finally中添加资源的close方法。</li><li><code>@Setter/@Getter</code>：自动生成Setter/Getter方法。</li><li><code>@ToString</code>：自动生成toString方法。</li><li><code>@EqualsAndHashCode</code>：从对象的字段中重写hashCode和equals方法。</li><li><code>@NoArgsConstructor/RequiredArgsConstructor/@AllArgsConstructor</code>：自动生成构造方法。</li><li><code>@Value</code>：用于注解final类。</li><li><code>@Builder</code>：产生复杂的构建器API类。</li><li><code>SneakyThrows</code>：用于异常处理。</li><li><code>@Synchronized</code>：同步方法的转化。</li><li><code>@Log</code>：支持使用各种日志对象。</li></ul><h2 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h2><p>修改快捷键：File -&gt; Settings -&gt; Keymap.</p><ul><li>自动代码补全：<code>Ctrl+Shift+Space</code>。</li><li><strong>查看类的源码</strong>：在光标所在的类名上<code>Ctrl+B</code>。</li><li><strong>搜索类并查看源码</strong>：<code>Ctrl+N</code>。</li><li>自动生成setter/getter/构造器等：<code>Alt+Insert</code>。</li><li>提示方法参数列表：<code>Ctrl+P</code>。</li><li><strong>快速修复错误：<code>Alt+Enter</code>。（超常用，比如导入光标所在类的包）</strong></li><li>提交修改到新版本（Git）：<code>Ctrl+K</code>。</li></ul><h2 id="自定义高复用代码块"><a href="#自定义高复用代码块" class="headerlink" title="自定义高复用代码块"></a>自定义高复用代码块</h2><p>File -&gt; Settings -&gt; Editor -&gt; Live Templates -&gt; 右键<code>+</code>，Abbreviation代表添加缩写语句。IDEA内置常用的高复用代码块如下：</p><ul><li><code>psvm</code>/<code>main</code>：生成<code>public static void main(String[] args) {}</code></li><li><code>sout/soutp</code>：生成<code>System.out.println();</code>，区别是后者光标在<code>;</code>后面。</li><li><code>fori</code>：生成<code>for (int i = 0; i &lt; ; i++) {}</code></li><li><code>foreach</code>：<code>for (:) {}</code></li><li><code>psf/psfi/psfs</code>：<code>public static final</code>/<code>public static final int</code>/<code>public static final String</code></li><li><code>prsf</code>：<code>private static final</code></li><li><code>ifn</code>：<code>if ( == null) {}</code></li></ul><h2 id="设置代码模板"><a href="#设置代码模板" class="headerlink" title="设置代码模板"></a>设置代码模板</h2><p>File -&gt; Settings -&gt; Editor -&gt; File and Code Template.</p><p>Includes中可以添加注释信息，之后每一个新生成的Java类头部都会生成该注释。</p><h2 id="Debug"><a href="#Debug" class="headerlink" title="Debug"></a>Debug</h2><p>调试栏的按钮用处如下表：</p><div class="table-container"><table><thead><tr><th>按钮</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td><img src="Show_Execution_Point.jpg" alt=""></td><td style="text-align:left">(Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可<strong>跳转到当前代码执行的行</strong></td></tr><tr><td><img src="step_over.jpg" alt=""></td><td style="text-align:left">(F8)：步过，<strong>一行一行地往下走，如果这一行上有方法不会进入方法</strong>。</td></tr><tr><td><img src="step_into.jpg" alt=""></td><td style="text-align:left">(F7)：步入。如果当前行有方法，可以进入方法内部，一般用于进入<strong>自定义方法</strong>内，不会进入官方类库的方法。</td></tr><tr><td><img src="force_step_into.jpg" alt=""></td><td style="text-align:left">(Alt + Shift + F7)：强制步入，<strong>能进入任何方法</strong>，查看底层源码的时候可以用这个进入官方类库的方法。</td></tr><tr><td><img src="step_out.jpg" alt=""></td><td style="text-align:left">(Shift + F8)：步出，从步入的方法内<strong>退出到方法调用处</strong>，此时方法已执行完毕，只是还没有完成赋值。</td></tr><tr><td><img src="drop_frame.jpg" alt=""></td><td style="text-align:left">回退断点。</td></tr><tr><td><img src="run_to_cursor.jpg" alt=""></td><td style="text-align:left">(Alt + F9)：<strong>运行到光标处</strong>，你可以将光标定位到你需要查看的那一行，然后使用这个功能，代码会运行至光标行，而不需要打断点。</td></tr><tr><td><img src="evaluate_expression.jpg" alt=""></td><td style="text-align:left">(Alt + F8)：计算表达式。可以输入对象调用其set方法设置值，而不用修改源码或重新请求。</td></tr><tr><td><img src="resume.JPG" alt=""></td><td style="text-align:left">跳转到下一个断点处。</td></tr><tr><td><img src="view_breakpoints.JPG" alt=""></td><td style="text-align:left">查看并设置所有断点信息。</td></tr><tr><td><img src="mute_breakpoints.JPG" alt=""></td><td style="text-align:left">禁止所有断点。</td></tr><tr><td><img src="thread_dump.JPG" alt=""></td><td style="text-align:left">获取线程的运行状态、标识和调用的堆栈信息。</td></tr></tbody></table></div><h3 id="条件断点"><a href="#条件断点" class="headerlink" title="条件断点"></a>条件断点</h3><p>右键单击断点处即可设置条件断点，通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p><img src="condition_breakpoint.jpg" alt=""></p><p>多线程调试时，需要调整断点挂起级别为Thread。</p><p><img src="multi_thread_debug.jpg" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Lombok插件&quot;&gt;&lt;a href=&quot;#Lombok插件&quot; class=&quot;headerlink&quot; title=&quot;Lombok插件&quot;&gt;&lt;/a&gt;Lombok插件&lt;/h2&gt;&lt;p&gt;使用该插件可以在编辑器中简化冗长的代码，尤其是POJO类。使用Lombok需要添加依赖：&lt;/
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Git</title>
    <link href="http://thmasterplan.cn/Others/Git/"/>
    <id>http://thmasterplan.cn/Others/Git/</id>
    <published>2020-10-25T06:33:13.000Z</published>
    <updated>2020-10-26T13:48:31.110Z</updated>
    
    <content type="html"><![CDATA[<h3 id="版本控制"><a href="#版本控制" class="headerlink" title="版本控制"></a>版本控制</h3><p>版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便<strong>查看更改历史记录</strong>，<strong>备份以便恢复以前的版本</strong>的软件工程技术。最重要的是可以实现<strong>跨区域多人协同开发</strong>。</p><h4 id="本地版本控制系统"><a href="#本地版本控制系统" class="headerlink" title="本地版本控制系统"></a>本地版本控制系统</h4><p>最流行的是<strong>RCS</strong>。</p><p>记录文件每次的更新，可以对每个版本做一个快照，或是记录补丁文件（补丁指文件修订前后的变化），适合个人用。</p><p><img src="local.png" alt=""></p><h4 id="集中化版本控制系统"><a href="#集中化版本控制系统" class="headerlink" title="集中化版本控制系统"></a>集中化版本控制系统</h4><p>最流行的是<strong>SVN</strong>。</p><p>所有的版本数据都保存在服务器上，用户在服务器上同步更新或上传自己的修改。用户的本地只有自己以前所同步的版本，如果不连网的话，用户就看不到历史版本，也无法切换版本验证问题，或在不同分支工作。</p><p>管理员也可以轻松掌控每个开发者的权限，并且管理一个 CVCS 要远比在各个客户端上维护本地数据库来得轻松容易。</p><p>缺点是服务器的单点故障。如果宕机一小时，那么在这一小时内，谁都无法提交更新，也就无法协同工作。 如果中心数据库所在的磁盘发生损坏，又没有做恰当备份，毫无疑问你将丢失所有数据——包括项目的整个变更历史，只剩下人们在各自机器上保留的单独快照。 本地版本控制系统也存在类似问题，只要整个项目的历史记录被保存在单一位置，就有丢失所有历史更新记录的风险。当然可以在服务端进行主从备份。</p><p><img src="centralized.png" alt=""></p><h4 id="分布式版本控制系统"><a href="#分布式版本控制系统" class="headerlink" title="分布式版本控制系统"></a>分布式版本控制系统</h4><p>最流行的是<strong>Git</strong>。</p><p>客户端拥有代码仓库的完整镜像，包括完整的历史记录。这么一来，任何一处协同工作用的服务器发生故障，事后都可以用任何一个镜像出来的本地仓库恢复。 因为每一次的克隆操作，实际上都是一次对代码仓库的完整备份。</p><p>对于数据权限敏感性高的公司来说不适用。</p><p><img src="distributed.png" alt=""></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p>使用<code>git config</code>命令查看所有的配置选项。其中：</p><ul><li><p>查看系统配置：<code>git config --system -l</code>，其配置文件所在：<code>安装路径\Git\etc\gitconfig</code>。</p></li><li><p>查看用户配置：<code>git config --global -l</code> ，其配置文件所在：<code>C:\Users\用户名\.gitconfig</code>。</p></li><li><p>设置用户名与邮箱（必要）：每次提交都会用到该用户标识。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">"zhangsan"</span></span><br><span class="line">git config --global user.email <span class="string">"1234@126.com"</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="Git的原理"><a href="#Git的原理" class="headerlink" title="Git的原理"></a>Git的原理</h3><h4 id="Git三大区域"><a href="#Git三大区域" class="headerlink" title="Git三大区域"></a>Git三大区域</h4><ul><li>工作区：存放项目代码的地方。</li><li>暂存区：暂存区，用于临时存放你的改动，事实上它只是一个文件，保存即将提交到文件列表信息。</li><li>本地版本库：仓库区（或本地仓库），就是安全存放数据的位置，这里面有你提交到所有版本的数据，每提交一次修改就会有一个新的版本。其中HEAD指向最新放入仓库的版本。</li></ul><p>三大区域与远程库交互的图示如下：</p><p><img src="git.png" alt=""></p><h4 id="实体、引用与索引"><a href="#实体、引用与索引" class="headerlink" title="实体、引用与索引"></a>实体、引用与索引</h4><h5 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h5><ul><li><p>提交到本地仓库中的所有文件，包括每个提交的说明信息，目录结构等都会转换成实体。</p></li><li><p>所有实体均存在于.git/objects/目录中。</p></li><li><p>git中每一个实体以一个40字符长度的十六进制字符串来唯一标识。</p></li><li>git中包括四种类型的实体：<ul><li>blob：文件内容。</li><li>tree：文件名与目录结构。</li><li>commit：提交的作者、日期与说明等。</li><li>tag：指向某提交对象的引用。</li></ul></li></ul><h5 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h5><ul><li><p>Git 中，<strong>一个分支（branch）、远程分支（remote branch）或一个标签（tag）仅是指向一个实体的一个指针</strong>，这里的实体通常是一个commit实体。这些引用以文本文件的形式存储在目录 .git/refs/ 中。</p></li><li><p>Git 有一种特殊的引用，称为符号引用。它并不直接指向一个实体，而是指向另一个引用。比如，.git/HEAD就是一个符号引用。它指向你正在工作的当前分支的最新版本，初始为main分支。</p></li></ul><h5 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h5><ul><li>索引是一个暂存区，以二进制文件的形式存储为文件 .git/index 中。当<code>git add</code> 一个文件，git 将该文件的信息添加到索引中；当<code>git commit</code>时，git 仅提交索引文件中列出的文件到 git 本地仓库。</li></ul><p>实体、引用与索引的关系如图：</p><p><img src="entity_ref_index.png" alt=""></p><h3 id="Git项目搭建"><a href="#Git项目搭建" class="headerlink" title="Git项目搭建"></a>Git项目搭建</h3><h4 id="本地新建"><a href="#本地新建" class="headerlink" title="本地新建"></a>本地新建</h4><ol><li>在项目根目录下：<code>git init</code>，就会生成.git目录。</li><li>本地生成SSH公钥：<code>ssh-keygen rsa</code>命令生成公钥，生成目录为用户目录下的<code>.ssh</code>文件夹，拷贝公钥<code>id_rsa.pub</code>的文本到github/gitee/gitlab对应处，即可无需密码登录。</li><li><code>git branch -M main</code>：重命名默认分支名master为主分支main。</li><li>在项目根目录下：<code>git remote add origin [远程仓库地址]</code>，给远程仓库地址命名为origin，方便后续使用。远程仓库地址SSH方式示例：<code>git@github.com:Github用户名/项目名.git</code>。</li><li>在项目根目录下：<code>git push -u origin main</code>，将main分支push到远程仓库。</li></ol><h4 id="远程克隆"><a href="#远程克隆" class="headerlink" title="远程克隆"></a>远程克隆</h4><ul><li>在本地没有项目的情况下初次克隆：<code>git clone [url]</code>。</li><li>在本地已有项目的情况下：<code>git pull origin main</code>。</li></ul><h3 id="Git文件操作"><a href="#Git文件操作" class="headerlink" title="Git文件操作"></a>Git文件操作</h3><h4 id="文件的四种状态"><a href="#文件的四种状态" class="headerlink" title="文件的四种状态"></a>文件的四种状态</h4><p>版本控制就是对文件的版本控制，要对文件进行修改、提交等操作，首先要知道文件当前在什么状态。</p><p>使用<code>git status</code>查看文件状态。</p><ul><li>Untracked：未跟踪，此文件在文件夹中，但并没有加入到git库，不参与版本控制。</li><li>Staged：暂存状态。</li><li>Committed：文件已经提交到本地仓库。</li><li>Modified： 工作目录中文件若已修改，通过<code>git add</code>可进入暂存staged状态，<code>git commit</code>提交修改到本地仓库；也可使用<code>git checkout</code>丢弃修改，即从仓库中取出之前的版本覆盖当前修改。</li></ul><p>git状态转换如图所示：</p><p><img src="git_file_state.png" alt=""></p><h4 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h4><ul><li><code>git add .</code>：添加当前目录所有文件到暂存区。</li><li><code>git commit -m &quot;提交信息&quot;</code>：提交。</li></ul><h4 id="忽略文件"><a href="#忽略文件" class="headerlink" title="忽略文件"></a>忽略文件</h4><p>有些时候我们不想把某些文件纳入版本控制中，比如数据库文件，临时文件，设计文件等</p><p>在主目录下建立<code>.gitignore</code>文件(IDEA项目会自动生成)，此文件有如下规则：</p><ul><li>空行或以<code>#</code>开始的行将会被忽略。</li><li>可以使用Linux通配符。例如：<code>*</code>代表任意多个字符，<code>?</code>代表一个字符，<code>[abc]</code>代表可选字符范围，<code>{string1,string2,...}</code>代表可选的字符串等。</li><li>如果名称的最前面有一个感叹号<code>!</code>，表示例外规则，将不被忽略。</li></ul><p>例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#为注释</span><br><span class="line">*.txt        #忽略所有 .txt结尾的文件,这样的话上传就不会被选中！</span><br><span class="line">!lib.txt     #但lib.txt除外</span><br><span class="line">&#x2F;temp        #忽略temp同级目录其他文件和目录，不忽略temp目录</span><br><span class="line">build&#x2F;       #忽略build&#x2F;目录下的所有文件</span><br><span class="line">doc&#x2F;*.txt    #会忽略 doc&#x2F;notes.txt 但不包括 doc&#x2F;server&#x2F;arch.txt</span><br></pre></td></tr></table></figure><h3 id="Git分支"><a href="#Git分支" class="headerlink" title="Git分支"></a>Git分支</h3><p><strong>每个分支有多个版本，每提交一次修改就会有一个新的版本</strong>，HEAD指向当前分支的最新版本。</p><p>Git默认创建分支master，使用<code>git branch</code>查看当前所有分支。</p><p><strong>在商业项目开发中，不会轻易在主分支上操作，而是建立一个开发用的分支，最后将成熟的代码添加到主分支上。</strong></p><ul><li>创建新分支：<code>git branch 分支名</code>。新分支与当前分支指向同一个提交点（版本），切换到新分支后的提交才是新分支独有的。</li><li>切换到另一个分支：<code>git checkout 分支名</code>。</li><li>查看分支提交日志：<code>git log --oneline</code>或<code>git log</code>。</li></ul><h4 id="分支合并"><a href="#分支合并" class="headerlink" title="分支合并"></a>分支合并</h4><ul><li><p><strong>快速合并：</strong></p><ol><li><p>假设某时刻在main分支，<code>git branch dev</code>创建dev分支，<code>git checkout dev</code>切换到dev分支，此时main和dev都指向最新的同一个版本，如图所示：</p><p><img src="fast_merge_1.jpg" alt=""></p></li><li><p>添加某个文件test，<code>git add test</code>-&gt;<code>git commit -m &quot;test merge&quot;</code>提交形成新版本后，dev指向了新版本而main还在前一个版本，如何让main分支与dev合并呢？如图所示：</p><p><img src="fast_merge_2.jpg" alt=""></p></li><li><p><code>git checkout main</code>先切回main分支，然后<code>git merge dev</code>，此时Git的实际操作是将main指针指向dev指向的同一个版本实体，因此称为快速合并。 </p><p><img src="fast_merge.jpg" alt=""></p></li></ol></li></ul><p>快速合并前提：一个分支没有变化，另一个分支有新版本的情况。如果两个分支都有修改则不适用。</p><ul><li><p><strong>三方合并：</strong></p><p>适用于两个分支都有新版本的情况。</p><ol><li>假设某时刻在main分支，<code>git branch dev</code>创建dev分支，<code>git checkout dev</code>切换到dev分支，此时main和dev都指向最新的同一个版本；</li><li>添加某个文件test，<code>git add test</code>-&gt;<code>git commit -m &quot;test merge&quot;</code>提交形成新版本，dev指向了新版本；</li><li><code>git checkout main</code>切换回main分支，修改某个文件，提交形成新版本，main指向了新版本；</li><li><code>git merge dev</code>，创建新版本，该版本是main分支的修改版本与dev修改版本的合并，main指针指向该新版本，dev则不变，依旧指向其修改的那个版本。</li></ol></li><li><p><strong>合并冲突：</strong>两个分支都对以前相同版本的某个文件进行了修改，如何合并呢？</p><p>Git会将两个分支的修改都保留下，由用户协商进行保留。</p></li></ul><h3 id="Idea集成Git"><a href="#Idea集成Git" class="headerlink" title="Idea集成Git"></a>Idea集成Git</h3><p>IDEA在顶部菜单栏VCS选项下集成了版本控制功能，选择<code>Import into Version Control</code>，选择<code>Create Git Repository</code>即可。</p><p>项目目录中，红色表示该文件状态为Untracked，蓝色表示文件被修改（Modified），否则则是被忽略。</p><p>VCS-&gt;Git-&gt;Push-&gt;Define remote设置远程仓库URL，即可push本地仓库到云端。</p><p><img src="idea_git.png" alt=""></p><h4 id="克隆云端项目到IDEA"><a href="#克隆云端项目到IDEA" class="headerlink" title="克隆云端项目到IDEA"></a>克隆云端项目到IDEA</h4><p>VCS-&gt;Checkout from Version Control-&gt;Git，填入URL</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;版本控制&quot;&gt;&lt;a href=&quot;#版本控制&quot; class=&quot;headerlink&quot; title=&quot;版本控制&quot;&gt;&lt;/a&gt;版本控制&lt;/h3&gt;&lt;p&gt;版本控制（Revision control）是一种在开发的过程中用于管理我们对文件、目录或工程等内容的修改历史，方便&lt;str
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Git" scheme="http://thmasterplan.cn/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>MyBatis</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/MyBatis/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/MyBatis/</id>
    <published>2020-10-21T04:12:46.000Z</published>
    <updated>2020-10-28T13:15:52.508Z</updated>
    
    <content type="html"><![CDATA[<h2 id="全局配置文件"><a href="#全局配置文件" class="headerlink" title="全局配置文件"></a>全局配置文件</h2><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><h3 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE configuration</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Config 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-config.dtd"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="properties标签（不常用）"><a href="#properties标签（不常用）" class="headerlink" title="properties标签（不常用）"></a>properties标签（不常用）</h3><p>使用该标签可引入外部properties配置文件的内容，或在子标签property中进行配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">"org/mybatis/example/config.properties"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"dev_user"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"F2Fa3!33TYyg"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><p>设置好的属性可以在整个配置文件中用来替换需要动态配置的属性值。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="settings标签"><a href="#settings标签" class="headerlink" title="settings标签"></a>settings标签</h3><div class="table-container"><table><thead><tr><th style="text-align:left">设置名</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">cacheEnabled</td><td style="text-align:left">全局性地开启或关闭所有映射器配置文件中已配置的任何缓存。</td></tr><tr><td style="text-align:left">lazyLoadingEnabled</td><td style="text-align:left">延迟加载的全局开关。当开启时，所有关联对象都会延迟加载。 特定关联关系中可通过设置 <code>fetchType</code> 属性来覆盖该项的开关状态。</td></tr><tr><td style="text-align:left">aggressiveLazyLoading</td><td style="text-align:left">开启时，任一方法的调用都会加载该对象的所有延迟加载属性。 否则，每个延迟加载属性会按需加载（参考 <code>lazyLoadTriggerMethods</code>)。</td></tr><tr><td style="text-align:left">multipleResultSetsEnabled</td><td style="text-align:left">是否允许单个语句返回多结果集（需要数据库驱动支持）。</td></tr><tr><td style="text-align:left">useColumnLabel</td><td style="text-align:left">使用列标签代替列名。实际表现依赖于数据库驱动，具体可参考数据库驱动的相关文档，或通过对比测试来观察。</td></tr><tr><td style="text-align:left">useGeneratedKeys</td><td style="text-align:left">允许 JDBC 支持自动生成主键，需要数据库驱动支持。如果设置为 true，将强制使用自动生成主键。尽管一些数据库驱动不支持此特性，但仍可正常工作（如 Derby）。</td></tr><tr><td style="text-align:left">autoMappingBehavior</td><td style="text-align:left">指定 MyBatis 应如何自动映射列到字段或属性。 NONE 表示关闭自动映射；PARTIAL 只会自动映射没有定义嵌套结果映射的字段。 FULL 会自动映射任何复杂的结果集（无论是否嵌套）。</td></tr><tr><td style="text-align:left">autoMappingUnknownColumnBehavior</td><td style="text-align:left">指定发现自动映射目标未知列（或未知属性类型）的行为。<code>NONE</code>: 不做任何反应<code>WARNING</code>: 输出警告日志（<code>&#39;org.apache.ibatis.session.AutoMappingUnknownColumnBehavior&#39;</code> 的日志等级必须设置为 <code>WARN</code>）<code>FAILING</code>: 映射失败 (抛出 <code>SqlSessionException</code>)</td></tr><tr><td style="text-align:left">defaultExecutorType</td><td style="text-align:left">配置默认的执行器。SIMPLE 就是普通的执行器；REUSE 执行器会重用预处理语句（PreparedStatement）； BATCH 执行器不仅重用语句还会执行批量更新。</td></tr><tr><td style="text-align:left">defaultStatementTimeout</td><td style="text-align:left">设置超时时间，它决定数据库驱动等待数据库响应的秒数。</td></tr><tr><td style="text-align:left">defaultFetchSize</td><td style="text-align:left">为驱动的结果集获取数量（fetchSize）设置一个建议值。此参数只可以在查询设置中被覆盖。</td></tr><tr><td style="text-align:left">defaultResultSetType</td><td style="text-align:left">指定语句默认的滚动策略。（新增于 3.5.2）</td></tr><tr><td style="text-align:left">safeRowBoundsEnabled</td><td style="text-align:left">是否允许在嵌套语句中使用分页（RowBounds）。如果允许使用则设置为 false。</td></tr><tr><td style="text-align:left">safeResultHandlerEnabled</td><td style="text-align:left">是否允许在嵌套语句中使用结果处理器（ResultHandler）。如果允许使用则设置为 false。</td></tr><tr><td style="text-align:left">mapUnderscoreToCamelCase</td><td style="text-align:left">是否开启驼峰命名自动映射，即从经典数据库列名 A_COLUMN 映射到经典 Java 属性名 aColumn。</td></tr><tr><td style="text-align:left">localCacheScope</td><td style="text-align:left">MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</td></tr><tr><td style="text-align:left">jdbcTypeForNull</td><td style="text-align:left">当没有为参数指定特定的 JDBC 类型时，空值的默认 JDBC 类型。 某些数据库驱动需要指定列的 JDBC 类型，多数情况直接用一般类型即可，比如 NULL、VARCHAR 或 OTHER。</td></tr><tr><td style="text-align:left">lazyLoadTriggerMethods</td><td style="text-align:left">指定对象的哪些方法触发一次延迟加载。</td></tr><tr><td style="text-align:left">defaultScriptingLanguage</td><td style="text-align:left">指定动态 SQL 生成使用的默认脚本语言。</td></tr><tr><td style="text-align:left">defaultEnumTypeHandler</td><td style="text-align:left">指定 Enum 使用的默认 <code>TypeHandler</code> 。（新增于 3.4.5）</td></tr><tr><td style="text-align:left">callSettersOnNulls</td><td style="text-align:left">指定当结果集中值为 null 的时候是否调用映射对象的 setter（map 对象时为 put）方法，这在依赖于 Map.keySet() 或 null 值进行初始化时比较有用。注意基本类型（int、boolean 等）是不能设置成 null 的。</td></tr><tr><td style="text-align:left">returnInstanceForEmptyRow</td><td style="text-align:left">当返回行的所有列都是空时，MyBatis默认返回 <code>null</code>。 当开启这个设置时，MyBatis会返回一个空实例。 请注意，它也适用于嵌套的结果集（如集合或关联）。（新增于 3.4.2）</td></tr><tr><td style="text-align:left">logPrefix</td><td style="text-align:left">指定 MyBatis 增加到日志名称的前缀。</td></tr><tr><td style="text-align:left">logImpl</td><td style="text-align:left">指定 MyBatis 所用日志的具体实现，未指定时将自动查找。</td></tr><tr><td style="text-align:left">proxyFactory</td><td style="text-align:left">指定 Mybatis 创建可延迟加载对象所用到的代理工具。</td></tr><tr><td style="text-align:left">vfsImpl</td><td style="text-align:left">指定 VFS 的实现</td></tr><tr><td style="text-align:left">useActualParamName</td><td style="text-align:left">允许使用方法签名中的名称作为语句参数名称。 为了使用该特性，你的项目必须采用 Java 8 编译，并且加上 <code>-parameters</code> 选项。（新增于 3.4.1）</td></tr><tr><td style="text-align:left">configurationFactory</td><td style="text-align:left">指定一个提供 <code>Configuration</code> 实例的类。 这个被返回的 Configuration 实例用来加载被反序列化对象的延迟加载属性值。 这个类必须包含一个签名为<code>static Configuration getConfiguration()</code> 的方法。（新增于 3.2.3）</td></tr><tr><td style="text-align:left">shrinkWhitespacesInSql</td><td style="text-align:left">从SQL中删除多余的空格字符。请注意，这也会影响SQL中的文字字符串。 (新增于 3.5.5)</td></tr><tr><td style="text-align:left">defaultSqlProviderType</td><td style="text-align:left">Specifies an sql provider class that holds provider method (Since 3.5.6). This class apply to the <code>type</code>(or <code>value</code>) attribute on sql provider annotation(e.g. <code>@SelectProvider</code>), when these attribute was omitted.</td></tr></tbody></table></div><p>使用示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadingEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"multipleResultSetsEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useColumnLabel"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"useGeneratedKeys"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingBehavior"</span> <span class="attr">value</span>=<span class="string">"PARTIAL"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"autoMappingUnknownColumnBehavior"</span> <span class="attr">value</span>=<span class="string">"WARNING"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultExecutorType"</span> <span class="attr">value</span>=<span class="string">"SIMPLE"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultStatementTimeout"</span> <span class="attr">value</span>=<span class="string">"25"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"defaultFetchSize"</span> <span class="attr">value</span>=<span class="string">"100"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"safeRowBoundsEnabled"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"mapUnderscoreToCamelCase"</span> <span class="attr">value</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"localCacheScope"</span> <span class="attr">value</span>=<span class="string">"SESSION"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"jdbcTypeForNull"</span> <span class="attr">value</span>=<span class="string">"OTHER"</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"lazyLoadTriggerMethods"</span> <span class="attr">value</span>=<span class="string">"equals,clone,hashCode,toString"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="typeAliases标签"><a href="#typeAliases标签" class="headerlink" title="typeAliases标签"></a>typeAliases标签</h3><p> 为Java的全类名设置缩短的别名：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeAlias</span> <span class="attr">alias</span>=<span class="string">"Author"</span> <span class="attr">type</span>=<span class="string">"domain.blog.Author"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><p>也可以指定一个包名(批量设置别名)，MyBatis 会在包名下面搜索需要的 Java Bean。每一个在包 <code>domain.blog</code> 中的 Java Bean，在没有注解的情况下，会使用 Bean 的首字母小写的非限定类名来作为它的别名。 比如 <code>domain.blog.Author</code> 的别名为 <code>author</code>；若有注解，则别名为其注解值：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"domain.blog"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Alias</span>(<span class="string">"author"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Author</span> </span>&#123;</span><br><span class="line">   <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：我们设置的别名不能与MyBatis的<strong>内置别名</strong>（见文档）冲突。</p><h3 id="typeHandlers标签"><a href="#typeHandlers标签" class="headerlink" title="typeHandlers标签"></a>typeHandlers标签</h3><p>MyBatis在设置PreparedStatement中的参数或从结果集取出一个值时， 都会用类型处理器将获取到的值以合适的方式转换成 Java 类型。在<a href="https://mybatis.org/mybatis-3/zh/configuration.html#typeHandlers" target="_blank" rel="noopener">官方文档</a>中描述了一些默认的类型处理器。</p><p>我们可以重写已有的类型处理器或自己创建类型处理器来处理不支持的或非标准的类型：实现 <code>org.apache.ibatis.type.TypeHandler</code>接口， 或继承 <code>org.apache.ibatis.type.BaseTypeHandler</code>， 并且可以（可选地）将它映射到一个 JDBC 类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MappedJdbcTypes</span>(JdbcType.VARCHAR)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExampleTypeHandler</span> <span class="keyword">extends</span> <span class="title">BaseTypeHandler</span>&lt;<span class="title">String</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setNonNullParameter</span><span class="params">(PreparedStatement ps, <span class="keyword">int</span> i, String parameter, JdbcType jdbcType)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    ps.setString(i, parameter);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, String columnName)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnName);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(ResultSet rs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> rs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> String <span class="title">getNullableResult</span><span class="params">(CallableStatement cs, <span class="keyword">int</span> columnIndex)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> cs.getString(columnIndex);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- mybatis-config.xml --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">typeHandlers</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">typeHandler</span> <span class="attr">handler</span>=<span class="string">"org.mybatis.example.ExampleTypeHandler"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">typeHandlers</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用上述的类型处理器将会覆盖默认的处理 Java String 类型的属性以及 VARCHAR 类型的参数和结果的类型处理器。</p><h3 id="enviroments标签"><a href="#enviroments标签" class="headerlink" title="enviroments标签"></a>enviroments标签</h3><p>MyBatis 可以配置成适应多种环境，这种机制有助于将 SQL 映射应用于多种数据库之中， 现实情况下有多种理由需要这么做。例如，开发、测试和生产环境需要有不同的配置；或者想在具有相同 Schema 的多个生产数据库中使用相同的 SQL 映射。例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">"development"</span>&gt;</span> <span class="tag">&lt;<span class="name">！--指定默认使用哪种环境</span> <span class="attr">--</span>&gt;</span></span><br><span class="line">   <span class="comment">&lt;!--测试使用的环境--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"test"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">           .....</span><br><span class="line">       <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environment</span>&gt;</span> </span><br><span class="line">    </span><br><span class="line">   <span class="comment">&lt;!--开发使用的环境--&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">"development"</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">"JDBC"</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">"POOLED"</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driver"</span> <span class="attr">value</span>=<span class="string">"$&#123;driver&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;url&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;username&#125;"</span>/&gt;</span></span><br><span class="line">       <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;password&#125;"</span>/&gt;</span></span><br><span class="line">     <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不过，<strong>尽管可以配置多个环境，但每个 SqlSessionFactory 实例只能选择一种环境。</strong>所以，需要连接N个数据库，就需要创建N个SqlSessionFactory实例，<strong>每个数据库对应一个SqlSessionFactory</strong>。</p><h4 id="事务管理器（transactionManager）"><a href="#事务管理器（transactionManager）" class="headerlink" title="事务管理器（transactionManager）"></a>事务管理器（transactionManager）</h4><p>在 MyBatis 中有两种类型的事务管理器（也就是 type=”[JDBC|MANAGED]”）。如果使用 Spring + MyBatis，则没有必要配置事务管理器，因为 <strong>Spring 模块会使用自带的管理器来覆盖MyBatis的配置</strong>。</p><h4 id="数据源（DataSource）"><a href="#数据源（DataSource）" class="headerlink" title="数据源（DataSource）"></a>数据源（DataSource）</h4><p>dataSource 元素使用标准的 JDBC 数据源接口来配置 JDBC 连接对象的资源。有三种内建的数据源类型（也就是 type=”[UNPOOLED|POOLED|JNDI]”）:</p><ul><li><p>UNPOOLED：不使用连接池，每次请求时打开和关闭连接。</p></li><li><p>POOLED：使用连接池。该别名对应的类为PooledDataSourceFactory，其构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PooledDataSourceFactory</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.dataSource = <span class="keyword">new</span> PooledDataSource();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>常用属性见<a href="https://mybatis.org/mybatis-3/zh/configuration.html#environments" target="_blank" rel="noopener">官方文档</a>。</p></li></ul><ul><li>JNDI：这个数据源实现是为了能在如 EJB 或应用服务器这类容器中使用，容器可以集中或在外部配置数据源，然后放置一个 JNDI 上下文的数据源引用。</li></ul><p>使用自定义数据源：实现接口<code>org.apache.ibatis.datasource.DataSourceFactory</code>或者继承<code>org.apache.ibatis.datasource.unpooled.UnpooledDataSourceFactory</code>，dataSource标签的type属性指定实现类的全类名。</p><h3 id="databaseIdProvider标签"><a href="#databaseIdProvider标签" class="headerlink" title="databaseIdProvider标签"></a>databaseIdProvider标签</h3><p> 为支持多厂商特性，MyBatis 可以根据不同的数据库厂商执行不同的语句。示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--DB_VENDOR：VendorDatabaseIdProvider的别名，其作用是得到数据库厂商的标识--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">databaseIdProvider</span> <span class="attr">type</span>=<span class="string">"DB_VENDOR"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--为不同的数据库厂商取别名--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"MySQL"</span> <span class="attr">value</span>=<span class="string">"mysql"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"SQL Server"</span> <span class="attr">value</span>=<span class="string">"sqlserver"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"Oracle"</span> <span class="attr">value</span>=<span class="string">"oracle"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"DB2"</span> <span class="attr">value</span>=<span class="string">"db2"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">databaseIdProvider</span>&gt;</span></span><br></pre></td></tr></table></figure><p>同时在映射文件具体的SQL语句配置中指定数据库厂商别名(databaseId属性)：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span> <span class="attr">databaseId</span>=<span class="string">"mysql"</span>&gt;</span></span><br><span class="line">         select id, last_name lastName, gender,email from user where id = #&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="mappers标签"><a href="#mappers标签" class="headerlink" title="mappers标签"></a>mappers标签</h3><p>该标签告诉MyBatis去哪里找映射文件。</p><h4 id="mapper子标签"><a href="#mapper子标签" class="headerlink" title="mapper子标签"></a>mapper子标签</h4><p>有如下属性：</p><ul><li>resource：引用相对类路径下的映射文件。</li><li>url：引用网络或磁盘路径下的映射文件。</li><li>class：使用DAO接口的全类名。（注解配置）</li></ul><h4 id="package子标签"><a href="#package子标签" class="headerlink" title="package子标签"></a>package子标签</h4><p>name属性指定DAO所在的包名：将包内的所有DAO接口实现全部注册为映射器（所谓映射器就是dao接口的代理对象）。(注解配置)</p><h3 id="plugins标签"><a href="#plugins标签" class="headerlink" title="plugins标签"></a>plugins标签</h3><p>MyBatis 允许我们在映射语句执行过程中的某一点进行拦截调用（动态代理）。默认情况下，MyBatis 允许使用插件来拦截的方法有：</p><ul><li>Executor ：update, query, flushStatements, commit, rollback, getTransaction, close, isClosed.</li><li>ParameterHandler ：getParameterObject, setParameters.</li><li>ResultSetHandler ：handleResultSets, handleOutputParameters.</li><li>StatementHandler ：prepare, parameterize, batch, update, query.</li></ul><h3 id="objectFactory标签"><a href="#objectFactory标签" class="headerlink" title="objectFactory标签"></a>objectFactory标签</h3><p>每次 MyBatis <strong>创建结果对象的新实例时</strong>，它都会使用一个对象工厂（ObjectFactory）实例来完成实例化工作。具体使用参见文档。</p><p>使用场景：比如在学校系统中，学生除了有基础信息，我们还想临时添加一个总成绩的属性用来表示最近一次成绩总分。这个时候我们就可以通过自定义ObjectFactory来实现了。在创建好对象后在去查询数据进行填充。</p><h2 id="映射文件"><a href="#映射文件" class="headerlink" title="映射文件"></a>映射文件</h2><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><h3 id="约束-1"><a href="#约束-1" class="headerlink" title="约束"></a>约束</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">  PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">  "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br></pre></td></tr></table></figure><h3 id="select-insert-update和delete标签"><a href="#select-insert-update和delete标签" class="headerlink" title="select, insert, update和delete标签"></a>select, insert, update和delete标签</h3><p><a href="https://github.com/Laishiji/FrameworkLearningDemo/tree/main/MyBatisDemo" target="_blank" rel="noopener">CRUD Demo</a>。mapper.xml示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--增--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">        insert into user(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用useGeneratedKeys和keyProperty属性获取自增长ID并将其封装给pojo对应的成员变量id，这两个属性仅适用于insert和update标签</span></span><br><span class="line"><span class="comment">    &lt;insert id="addUser" useGeneratedKeys="true" keyProperty="id"&gt;</span></span><br><span class="line"><span class="comment">        insert into user(last_name, gender, email) values(#&#123;lastName&#125;, #&#123;gender&#125;, #&#123;email&#125;)</span></span><br><span class="line"><span class="comment">    &lt;/insert&gt;</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--删--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">delete</span> <span class="attr">id</span>=<span class="string">"deleteUserById"</span>&gt;</span></span><br><span class="line">        delete from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">delete</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--改--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">        update user set last_name=#&#123;lastName&#125;, gender=#&#123;gender&#125;, email=#&#123;email&#125; where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">&lt;!--查--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">         select id, last_name, gender,email from user where id = #&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>测试方法示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testCRUD</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    InputStream inputStream = Resources.getResourceAsStream(<span class="string">"MyBatisConfig.xml"</span>);</span><br><span class="line"></span><br><span class="line">    SqlSessionFactory sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line">    <span class="comment">//sqlSessionFactory.openSession(true);表示自动提交</span></span><br><span class="line">    SqlSession openSession = sqlSessionFactory.openSession();<span class="comment">//需要手动提交</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        IUserMapper userMapper = openSession.getMapper(IUserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//增</span></span><br><span class="line">        <span class="comment">//userMapper.addUser(new User(null, "张三", "abd@gmail.com", "男"));</span></span><br><span class="line">        <span class="comment">//删</span></span><br><span class="line">        <span class="comment">//userMapper.deleteUserById(5);</span></span><br><span class="line">        <span class="comment">//改</span></span><br><span class="line">        <span class="comment">//userMapper.updateUser(new User(1, "Tom", "abcdefg@126.com","男"));</span></span><br><span class="line">        <span class="comment">//查</span></span><br><span class="line">        System.out.println(userMapper.getUserById(<span class="number">2</span>));</span><br><span class="line">        <span class="comment">//手动提交</span></span><br><span class="line">        openSession.commit();</span><br><span class="line">    &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">        openSession.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>另外，MyBatis允许增删改的DAO接口方法定义以下类型返回值（不需要在mapper.xml中定义返回属性）：Integer/Long/Boolean/void。</p><h3 id="sql标签"><a href="#sql标签" class="headerlink" title="sql标签"></a>sql标签</h3><p>用于<strong>定义可重用的sql片段</strong>，方便后面引用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">sql</span> <span class="attr">id</span>=<span class="string">"insertColumn"</span>&gt;</span></span><br><span class="line">    id,last_name,email,gender</span><br><span class="line"><span class="tag">&lt;/<span class="name">sql</span>&gt;</span></span><br></pre></td></tr></table></figure><p>引用：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">    insert into user(</span><br><span class="line">    <span class="tag">&lt;<span class="name">include</span> <span class="attr">refid</span>=<span class="string">"insertColumn"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line">    ) values</span><br><span class="line">    .....</span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="DAO接口方法参数值与SQL语句字段值的传递"><a href="#DAO接口方法参数值与SQL语句字段值的传递" class="headerlink" title="DAO接口方法参数值与SQL语句字段值的传递"></a>DAO接口方法参数值与SQL语句字段值的传递</h3><ul><li>dao接口方法只有一个参数：#{参数名}直接取出参数的值。</li><li><p>dao接口方法有多个参数：</p><ul><li>默认情况下：多个参数会被MyBatis封装成一个map，其key是MyBatis指定的固定形式：param1, param2, …paramN；value才是传入的参数值。SQL语句通过固定形式#{param1}, #{param2}, …取值。</li><li>我们也可以明确指定key的值：在DAO接口方法参数列表的每一个参数前使用<code>Param(&quot;key&quot;)</code>注解 。</li><li>若多个参数正好是POJO的成员变量，则直接传入POJO。</li><li>也可以传入一个Map，然后在SQL语句中使用#{key}来取值。</li></ul></li><li><p>示例：</p><ul><li><p>接口方法：<code>public User getUser(@Param(&quot;id&quot;)Integer id, String lastName);</code></p><p>SQL语句取值：id==&gt;#{id}/#{param1}, lastName==&gt;#{param2}</p></li><li><p>接口方法：<code>public User getUser(Integer id, User user);</code></p><p>SQL语句取值：id==&gt;#{param1}, lastName==&gt;#{param2.lastName}</p></li><li><p>接口方法：<code>public User getUser(List&lt;Integer&gt; ids);</code></p><p>SQL语句取值（固定形式）：#{list[0]}, #{list[1]}…</p><p>注意：若参数列表是集合类型或数组，取值都是固定形式。比如#{list[0]}, #{array[0]}。</p></li></ul></li><li><p>SQL语句中也可使用<code>${key}</code>取值，它与<code>#{key}</code>的区别是：前者取值后直接赋值给SQL语句对应字段，后者是以预编译（PreparedStatement）的形式将参数设置到SQL语句中。<code>${key}</code>的使用场景是：SQL不支持占位符的地方（非字段）使用。</p></li><li><code>#{}</code>使用时可以指定一些规则：jdbcType, javaType等，参见文档。</li></ul><h3 id="结果映射-ORM"><a href="#结果映射-ORM" class="headerlink" title="结果映射(ORM)"></a>结果映射(ORM)</h3><h4 id="自动映射"><a href="#自动映射" class="headerlink" title="自动映射"></a>自动映射</h4><p>全局配置中setting标签有一个属性autoMappingBehavior，其值默认为PARTIAL，开启自动映射的功能，唯一的要求是表的列名和POJO成员变量名一致。另外，可以通过设置mapUnderscoreToCamelCase=true来使数据库字段命名规范中的A_COLUMN自动映射为Java中的驼峰命名法aColumn。</p><p>以下是一些自动映射的例子：</p><ul><li><p>DAO接口方法返回POJO类或List</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByLastNameLike</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByLastNameLike"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from user where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DAO接口方法返回单条记录的Map，key是字段名，值是记录对应的值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;String, Object&gt; <span class="title">getUserByIdReturnMap</span><span class="params">(Integer id)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByIdReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"map"</span>&gt;</span></span><br><span class="line">    select * from user where id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>DAO接口方法返回多条记录的Map，key是记录的主键，值是POJO。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@MapKey</span>(<span class="string">"id"</span>)<span class="comment">//该注解用于指定key</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Map&lt;Integer, User&gt; <span class="title">getUserByLastNameLikeReturnMap</span><span class="params">(String lastName)</span></span>;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByLastNameLikeReturnMap"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">    select * from user where last_name like #&#123;lastName&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="自定义结果集映射-resultMap"><a href="#自定义结果集映射-resultMap" class="headerlink" title="自定义结果集映射: resultMap"></a>自定义结果集映射: resultMap</h4><p>resultMap属性和resultMap标签用于自定义结果集映射规则，resultMap和resultType属性只能选择一个使用。mapper.xml示例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义某个POJO类的封装规则</span></span><br><span class="line"><span class="comment">        type: 自定义规则的POJO全类名</span></span><br><span class="line"><span class="comment">        id: 用于引用</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span> <span class="attr">id</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--指定主键列的封装规则</span></span><br><span class="line"><span class="comment">            column: 指定哪一列</span></span><br><span class="line"><span class="comment">            property: 指定对应的POJO类成员变量</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">&lt;!--定义普通列的封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--其他不指定的列会自动封装，建议都指定--&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>使用场景示例：</p><ol><li><p>查询User的同时查询其对应的Department。<a href="https://github.com/Laishiji/FrameworkLearningDemo/tree/main/MyBatisDemoWithResultMap" target="_blank" rel="noopener">demo</a></p><p>IUserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--自定义User类的封装规则1, 使用级联属性的方式--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"myMap"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下是Department的映射,使用级联属性的方式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"department.id"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"department.departmentName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义User类的封装规则2, 使用association标签--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"myMap2"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--以下是Department的映射，使用association标签</span></span><br><span class="line"><span class="comment">            property: 指定User中哪个属性是联结的对象</span></span><br><span class="line"><span class="comment">            javaType: 指定该属性对象的类型</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span> <span class="attr">javaType</span>=<span class="string">"org.example.pojo.Department"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"dept_id"</span> <span class="attr">property</span>=<span class="string">"id"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserAndDept"</span> <span class="attr">resultMap</span>=<span class="string">"myMap2"</span>&gt;</span></span><br><span class="line">          select u.id, u.last_name, u.gender, u.email, u.dept_id, d.dept_name</span><br><span class="line">        from user u , dept d where u.dept_id=d.id and u.id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--自定义User类的封装规则3, 使用association进行分步查询</span></span><br><span class="line"><span class="comment">        1.使用User的id查询User所有信息</span></span><br><span class="line"><span class="comment">        2.根据返回信息中的dept_id值去dept表查询Department信息</span></span><br><span class="line"><span class="comment">        3.将Department信息设置到User中</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"myMap3"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"id"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--select属性：表明当前User的属性department是通过getDepartmentById方法查询得到</span></span><br><span class="line"><span class="comment">            column属性：将dept_id列的值作为参数传递给getDepartmentById方法</span></span><br><span class="line"><span class="comment">                       当column要传递多个参数时，可使用&#123;key1=column1,key2=column2..&#125;</span></span><br><span class="line"><span class="comment">                       的形式。</span></span><br><span class="line"><span class="comment">             --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">"department"</span></span></span><br><span class="line"><span class="tag">                     <span class="attr">select</span>=<span class="string">"org.example.dao.IDepartmentMapper.getDepartmentById"</span></span></span><br><span class="line"><span class="tag">        <span class="attr">column</span>=<span class="string">"dept_id"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserById"</span> <span class="attr">resultMap</span>=<span class="string">"myMap3"</span>&gt;</span></span><br><span class="line">        select * from user where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用分步查询的好处是，可以使用延迟加载，我们只在需要查询部门信息的时候再去查询它，大大提升了效率。</span></span><br><span class="line"><span class="comment">        实现延迟加载：只需要再分步查询的基础上在全局配置文件的setting中设置lazyLoadingEnabled为true，</span></span><br><span class="line"><span class="comment">        aggressiveLazyLoading为false即可；或者在association/collection标签中配置fetchType="lazy"。</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><p>IDepartmentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE mapper</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-3-mapper.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IDepartmentMapper"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentById"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.Department"</span>&gt;</span></span><br><span class="line">        select  id, dept_name departmentName from dept where id=#&#123;id&#125;</span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在Department中添加成员变量<code>List&lt;User&gt; users</code>，查询一个Department时查询对应的users。<a href="https://github.com/Laishiji/FrameworkLearningDemo/tree/main/MyBatisDemoWithResultMap2" target="_blank" rel="noopener">demo</a></p><p>IDepartmentMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">resultMap</span> <span class="attr">id</span>=<span class="string">"MyDeptMap"</span> <span class="attr">type</span>=<span class="string">"org.example.pojo.Department"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"did"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"dept_name"</span> <span class="attr">property</span>=<span class="string">"departmentName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--collection标签定义关联集合类型的属性的封装规则</span></span><br><span class="line"><span class="comment">        property: 指定集合类型的成员变量</span></span><br><span class="line"><span class="comment">        ofType: 指定集合内元素类型</span></span><br><span class="line"><span class="comment">        select: 用于分步查询，参考association</span></span><br><span class="line"><span class="comment">    --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">collection</span> <span class="attr">property</span>=<span class="string">"users"</span> <span class="attr">ofType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--定义集合中元素的封装规则--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">"uid"</span> <span class="attr">property</span>=<span class="string">"id"</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"last_name"</span> <span class="attr">property</span>=<span class="string">"lastName"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"email"</span> <span class="attr">property</span>=<span class="string">"email"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">"gender"</span> <span class="attr">property</span>=<span class="string">"gender"</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">collection</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">resultMap</span>&gt;</span></span><br><span class="line">   </span><br><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getDepartmentById2"</span> <span class="attr">resultMap</span>=<span class="string">"MyDeptMap"</span>&gt;</span></span><br><span class="line">     select d.id did, d.dept_name, u.id uid, u.last_name, u.email, u.gender</span><br><span class="line">     from dept d left join user u</span><br><span class="line">     on d.id=u.dept_id where d.id=#&#123;id&#125;</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><p>discriminator鉴别器：resultMap子标签，使用该标签可<strong>根据某列（column）的值改变封装行为</strong>。例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--某列字段的类型--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">discriminator</span> <span class="attr">javaType</span>=<span class="string">"String"</span> <span class="attr">column</span>"<span class="attr">gender</span>"&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"女"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span> &gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">association</span> <span class="attr">property</span>=<span class="string">""</span> <span class="attr">select</span>=<span class="string">""</span> <span class="attr">column</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">association</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">case</span> <span class="attr">value</span>=<span class="string">"男"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">id</span> <span class="attr">column</span>=<span class="string">""</span> <span class="attr">property</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">column</span>=<span class="string">""</span> <span class="attr">property</span>=<span class="string">""</span>&gt;</span><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">        ......</span><br><span class="line">    <span class="tag">&lt;/<span class="name">case</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">discriminator</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="动态SQL"><a href="#动态SQL" class="headerlink" title="动态SQL"></a>动态SQL</h2><p><a href="https://mybatis.org/mybatis-3/zh/dynamic-sql.html" target="_blank" rel="noopener">MyBatis官方文档</a></p><h3 id="if标签"><a href="#if标签" class="headerlink" title="if标签"></a>if标签</h3><p>用于动态拼接SQL语句。</p><p>test属性：值为判断表达式（OGNL），从DAO接口方法参数列表中取值进行判断。特殊符号需要转义<code>&quot; -&gt; &amp;quot;</code>, <code>&#39; -&gt; &amp;apos;</code>, <code>&amp; -&gt; &amp;amp;</code>, <code>&lt; -&gt; &amp;lt;</code>, <code>&gt; -&gt; &amp;gt;</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"org.example.dao.IUserMapper"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionIf"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null and lastName.trim()!=''"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!--多余的and--&gt;</span>and last_name like #&#123;lastName&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email!=''"</span>&gt;</span></span><br><span class="line">                and email=#&#123;email&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender=='男' or gender=='女'"</span>&gt;</span></span><br><span class="line">                and gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userMapper.getUserByConditionIf(<span class="keyword">new</span> User(<span class="keyword">null</span>, <span class="string">"Tom"</span>, <span class="string">"abcdefg@126.com"</span>, <span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><p>对于调用方法参数中第一个条件为null的情况，可以使用where标签消除第一个and关键字，避免SQL语句错误。</p><h3 id="trim标签"><a href="#trim标签" class="headerlink" title="trim标签"></a>trim标签</h3><p>属性：</p><ul><li>prefix：给trim标签中拼接后的字符串添加一个前缀。</li><li>prefixOverrides：去掉trim标签中拼接后的字符串前面多余的字符。</li><li>suffix：给trim标签中拼接后的字符串添加一个后缀。</li><li>suffixOverrides：去掉trim标签中拼接后的字符串后面多余的字符。</li></ul><p>例如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionTrim"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">trim</span> <span class="attr">prefix</span>=<span class="string">"where"</span> <span class="attr">suffixOverrides</span>=<span class="string">"and"</span>&gt;</span></span><br><span class="line">             <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span></span><br><span class="line">                id=#&#123;id&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null and lastName.trim()!=''"</span>&gt;</span></span><br><span class="line">               last_name like #&#123;lastName&#125; and</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null and email!=''"</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125; and <span class="comment">&lt;!--多余的and--&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender=='男' or gender=='女'"</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125; </span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span>           </span><br><span class="line">        <span class="tag">&lt;/<span class="name">trim</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;User&gt; list = userMapper.getUserByConditionTrim(<span class="keyword">new</span> User(<span class="number">1</span>, <span class="string">"Tom"</span>, <span class="string">"abcdefg@126.com"</span>, <span class="keyword">null</span>));</span><br></pre></td></tr></table></figure><h3 id="choose标签"><a href="#choose标签" class="headerlink" title="choose标签"></a>choose标签</h3><p>分支选择，类似于switch-case。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionChoose"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">        select * from user</span><br><span class="line">        <span class="tag">&lt;<span class="name">where</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">choose</span>&gt;</span><span class="comment">&lt;!--switch--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"id!=null"</span>&gt;</span> <span class="comment">&lt;!--case--&gt;</span></span><br><span class="line">                    id=#&#123;id&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">when</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">                    last_name like #&#123;lastName&#125;</span><br><span class="line">                <span class="tag">&lt;/<span class="name">when</span>&gt;</span></span><br><span class="line">                <span class="comment">&lt;!--前面的条件都不满足则--&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">otherwise</span>&gt;</span></span><br><span class="line">                    1=1</span><br><span class="line">                <span class="tag">&lt;/<span class="name">otherwise</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">choose</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">where</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="set标签"><a href="#set标签" class="headerlink" title="set标签"></a>set标签</h3><p>用于update的SQL语句，去除多余的<code>,</code>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">update</span> <span class="attr">id</span>=<span class="string">"updateUser"</span>&gt;</span></span><br><span class="line">    update user</span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"lastName!=null"</span>&gt;</span></span><br><span class="line">                last_name=#&#123;lastName&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"email!=null"</span>&gt;</span></span><br><span class="line">                email=#&#123;email&#125;,</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">if</span> <span class="attr">test</span>=<span class="string">"gender!=null"</span>&gt;</span></span><br><span class="line">                gender=#&#123;gender&#125;</span><br><span class="line">            <span class="tag">&lt;/<span class="name">if</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">update</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="foreach标签"><a href="#foreach标签" class="headerlink" title="foreach标签"></a>foreach标签</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">id</span>=<span class="string">"getUserByConditionForeach"</span> <span class="attr">resultType</span>=<span class="string">"org.example.pojo.User"</span>&gt;</span></span><br><span class="line">  select * from user where id in</span><br><span class="line">  <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"item_id"</span> <span class="attr">index</span>=<span class="string">"index"</span> <span class="attr">collection</span>=<span class="string">"ids"</span> <span class="attr">open</span>=<span class="string">"("</span> <span class="attr">separator</span>=<span class="string">","</span> <span class="attr">close</span>=<span class="string">")"</span>&gt;</span></span><br><span class="line">        #&#123;item_id&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserByConditionForeach</span><span class="params">(@Param(<span class="string">"ids"</span>)</span>List&lt;Integer&gt; idList)</span>;</span><br></pre></td></tr></table></figure><p>可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是key，item 是value。</p><p>foreach标签也常用于<strong>批量insert操作</strong>。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">insert</span> <span class="attr">id</span>=<span class="string">"addUsers"</span>&gt;</span></span><br><span class="line">    insert into user(last_name, email, gender) values</span><br><span class="line">    <span class="tag">&lt;<span class="name">foreach</span> <span class="attr">item</span>=<span class="string">"user"</span> <span class="attr">collection</span>=<span class="string">"users"</span> <span class="attr">separator</span>=<span class="string">","</span>&gt;</span></span><br><span class="line">        (#&#123;user.lastName&#125;, #&#123;user.email&#125;, #&#123;user.gender&#125;)</span><br><span class="line">    <span class="tag">&lt;/<span class="name">foreach</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">insert</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addUsers</span><span class="params">(@Param(<span class="string">"users"</span>)</span>List&lt;User&gt; users)</span>;</span><br></pre></td></tr></table></figure><h3 id="script"><a href="#script" class="headerlink" title="script"></a>script</h3><p>注解方式配置dao接口方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Update</span>(&#123;<span class="string">"&lt;script&gt;"</span>,</span><br><span class="line">     <span class="string">"update Author"</span>,</span><br><span class="line">     <span class="string">"  &lt;set&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='username != null'&gt;username=#&#123;username&#125;,&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='password != null'&gt;password=#&#123;password&#125;,&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='email != null'&gt;email=#&#123;email&#125;,&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"    &lt;if test='bio != null'&gt;bio=#&#123;bio&#125;&lt;/if&gt;"</span>,</span><br><span class="line">     <span class="string">"  &lt;/set&gt;"</span>,</span><br><span class="line">     <span class="string">"where id=#&#123;id&#125;"</span>,</span><br><span class="line">     <span class="string">"&lt;/script&gt;"</span>&#125;)</span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">updateAuthorValues</span><span class="params">(Author author)</span></span>;</span><br></pre></td></tr></table></figure><h3 id="bind标签"><a href="#bind标签" class="headerlink" title="bind标签"></a>bind标签</h3><p>该标签可以将OGNL表达式的值绑定到一个变量中，方便后面引用该变量的值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bind</span> <span class="attr">name</span>=<span class="string">"变量名"</span> <span class="attr">value</span>=<span class="string">"OGNL表达式"</span>&gt;</span><span class="tag">&lt;/<span class="name">bind</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h2><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html#cache" target="_blank" rel="noopener">MyBatis官方文档</a></p><p>Mybatis 的缓存是针对SQL语句查询的优化，极大地提升了查询效率。实际开发中使用Redis实现缓存。</p><p>MyBatis默认定义了两级缓存：</p><ul><li>默认情况下，只开启了一级缓存（SqlSession级别，也称本地缓存）。</li><li>二级缓存需要手动开启和配置（基于命名空间，全局缓存）。</li><li>为了提高扩展性，MyBatis定义了缓存接口Cache，我们可以通过实现Cache接口来自定义二级缓存。MyBatis中的缓存就是一个HashMap。</li></ul><h3 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h3><p>与数据库同一次会话期间查询到的数据会放在本地缓存中，下次获取相同的数据时（需要SqlSession, mapper方法和参数，SQL语句都相同）直接从缓存中获取。</p><p>两次相同的查询之间若执行了增删改操作，清除缓存。</p><p>可以使用openSession.clearCache()方法清除一级缓存。</p><h3 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h3><p>一个namespace对应一个二级缓存。<strong>一个会话查询一条数据，该数据会被放在当前会话的一级缓存中。若会话关闭，则一级缓存数据会被保存到二级缓存中</strong>，<u><strong>新的会话查询数据会先参照二级缓存</strong></u>。二级缓存的使用：在映射文件中添加<code>&lt;cache/&gt;</code>即可，<strong>缓存只作用于该映射文件下的SQL语句</strong>，该标签有如下属性：</p><ul><li>eviction：缓存的清除策略。有如下取值：<ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用：当<strong>系统将要发生OOM异常时</strong>，软引用指向的对象才被真正回收。</li><li><code>WEAK</code> – 弱引用：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。</li></ul></li><li>flushInterval：缓存刷新间隔，即多长时间清空一次缓存，单位ms。默认不清空。</li><li>size：缓存引用数目。默认1024。</li><li>readOnly：是否只读。默认false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化，POJO类需要实现Serializable接口）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</li><li>type：自定义缓存的全类名。</li></ul><p><code>&lt;cache/&gt;</code>标签的效果默认如下：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><h3 id="缓存相关配置"><a href="#缓存相关配置" class="headerlink" title="缓存相关配置"></a>缓存相关配置</h3><ul><li>全局配置文件：<code>&lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;&gt;</code>, 默认开启二级缓存。一级缓存默认开启无法关闭。</li><li>全局配置文件：<code>&lt;setting name=&quot;localCacheScope&quot; value=&quot;SESSION&quot;&gt;</code>。MyBatis 利用本地缓存机制（Local Cache）防止循环引用和加速重复的嵌套查询。 默认值为 SESSION，会缓存一个会话中执行的所有查询。 若设置值为 STATEMENT，本地缓存将仅用于执行语句，对相同 SqlSession 的不同查询将不会进行缓存。</li><li>select标签的属性useCache，默认为true，为false则关闭二级缓存。</li><li>insert, update, delete标签的属性flushCache, 默认为true，即增删改后默认清除一级缓存和二级缓存。</li></ul><h2 id="逆向工程"><a href="#逆向工程" class="headerlink" title="逆向工程"></a>逆向工程</h2><p><a href="http://mybatis.org/generator/" target="_blank" rel="noopener">mybatis generator doc</a>.</p><p>使用mybatis generator根据数据库表自动生成POJO类，DAO接口以及映射文件。</p><p>注意：生成的只包含单表查询，多表联查需要自行编写。</p><p>使用步骤：</p><ol><li><p>导入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.generator<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-generator-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>与pom.xml同级目录下编写myBatisGenerator.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE generatorConfiguration</span></span><br><span class="line"><span class="meta">        PUBLIC "-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN"</span></span><br><span class="line"><span class="meta">        "http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--使用逆向工程生成数据库对应表的POJO类、DAO接口和映射文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generatorConfiguration</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context</span> <span class="attr">id</span>=<span class="string">"DB2Tables"</span> <span class="attr">targetRuntime</span>=<span class="string">"MyBatis3"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--不生成注释--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suppressAllComments"</span> <span class="attr">value</span>=<span class="string">"true"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">commentGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--配置数据库连接--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">jdbcConnection</span> <span class="attr">driverClass</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">connectionURL</span>=<span class="string">"jdbc:mysql://localhost:3306/ssm_crud?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">userId</span>=<span class="string">"root"</span></span></span><br><span class="line"><span class="tag">                        <span class="attr">password</span>=<span class="string">"admin"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">jdbcConnection</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaTypeResolver</span> &gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"forceBigDecimals"</span> <span class="attr">value</span>=<span class="string">"false"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaTypeResolver</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定POJO类生成位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaModelGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"org.example.bean"</span> <span class="attr">targetProject</span>=<span class="string">".\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"trimStrings"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaModelGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定SQL映射文件生成位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">sqlMapGenerator</span> <span class="attr">targetPackage</span>=<span class="string">"mapper"</span>  <span class="attr">targetProject</span>=<span class="string">".\src\main\resources"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">sqlMapGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定DAO接口生成位置--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">javaClientGenerator</span> <span class="attr">type</span>=<span class="string">"XMLMAPPER"</span> <span class="attr">targetPackage</span>=<span class="string">"org.example.dao"</span>  <span class="attr">targetProject</span>=<span class="string">".\src\main\java"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"enableSubPackages"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">javaClientGenerator</span>&gt;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">&lt;!--指定数据库每个表的生成策略--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"employee"</span> <span class="attr">domainObjectName</span>=<span class="string">"Employee"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">table</span> <span class="attr">tableName</span>=<span class="string">"department"</span> <span class="attr">domainObjectName</span>=<span class="string">"Department"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;/<span class="name">context</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">generatorConfiguration</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>创建<code>MBGTest.java</code>并运行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MBGTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        List&lt;String&gt; warnings = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">        <span class="keyword">boolean</span> overwrite = <span class="keyword">true</span>;</span><br><span class="line">        File configFile = <span class="keyword">new</span> File(<span class="string">"myBatisGenerator.xml"</span>);</span><br><span class="line">        ConfigurationParser cp = <span class="keyword">new</span> ConfigurationParser(warnings);</span><br><span class="line">        Configuration config = cp.parseConfiguration(configFile);</span><br><span class="line">        DefaultShellCallback callback = <span class="keyword">new</span> DefaultShellCallback(overwrite);</span><br><span class="line">        MyBatisGenerator myBatisGenerator = <span class="keyword">new</span> MyBatisGenerator(config, callback, warnings);</span><br><span class="line">        myBatisGenerator.generate(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><p>生成的类中包含XXXExample.java的，表示条件查询。条件查询使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要求：查询雇员名字中包含e字母并且性别为1</span></span><br><span class="line">EmployeeMapper mapper = openSession.getMapper(EmployeeMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">EmployeeExample example = <span class="keyword">new</span> EmployeeExample();</span><br><span class="line">Criteria criteria = example.createCriteria();<span class="comment">//Criteria对象封装查询的条件</span></span><br><span class="line">criteria.andLastNameLike(<span class="string">"%e%"</span>);</span><br><span class="line">criteria.andGenderEqualTo(<span class="string">"1"</span>);</span><br><span class="line">List&lt;Employee&gt; list = mapper.selectByExample(example);</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;全局配置文件&quot;&gt;&lt;a href=&quot;#全局配置文件&quot; class=&quot;headerlink&quot; title=&quot;全局配置文件&quot;&gt;&lt;/a&gt;全局配置文件&lt;/h2&gt;&lt;p&gt;&lt;a href=&quot;https://mybatis.org/mybatis-3/zh/configuratio
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="MyBatis" scheme="http://thmasterplan.cn/tags/MyBatis/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringMVC/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringMVC/</id>
    <published>2020-10-18T06:42:34.000Z</published>
    <updated>2020-11-09T04:22:17.727Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">SpringMVC Doc</a></p><h2 id="B-S三层架构与MVC模型"><a href="#B-S三层架构与MVC模型" class="headerlink" title="B/S三层架构与MVC模型"></a>B/S三层架构与MVC模型</h2><h3 id="三层架构"><a href="#三层架构" class="headerlink" title="三层架构"></a>三层架构</h3><ul><li>表现层：WEB层，用来和客户端进行数据交互。表现层一般会采用MVC的设计模型 。</li><li>业务层：处理公司具体的业务逻辑 。</li><li>持久层：用来操作数据库。</li></ul><h3 id="MVC模型"><a href="#MVC模型" class="headerlink" title="MVC模型"></a>MVC模型</h3><ul><li>MVC全名是Model View Controller 模型视图控制器，每个部分各司其职。 </li><li>Model：数据模型，JavaBean的类，用来进行数据封装。 </li><li>View：指JSP、HTML用来展示数据给用户。</li><li>Controller：用来接收用户的请求，整个流程的控制器。用来进行数据校验等。</li></ul><h2 id="环境搭建"><a href="#环境搭建" class="headerlink" title="环境搭建"></a>环境搭建</h2><ol><li><p>选择原型<code>maven-archetype-webapp</code>，创建工程。</p></li><li><p>补全工程目录结构如下：</p><p><img src="webproj_dirstructure.png" alt=""></p></li><li><p>导入maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.source</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.source</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.compiler.target</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">maven.compiler.target</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>5.2.5.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在<code>web.xml</code>中配置Servlet控制器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置tomcat服务器：</p><p><img src="serverdeploy.png" alt=""></p><p><img src="serverdeploy2.png" alt=""></p></li></ol><p>web路径：不以<code>/</code>开始的相对路径，以当前资源所在目录为基准；以<code>/</code>开始的相对路径，以服务器的路径（<a href="http://localhost:3306）为基准。可通过设置服务器路径到变量APP_PATH：">http://localhost:3306）为基准。可通过设置服务器路径到变量APP_PATH：</a></p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;% pageContext.setAttribute(<span class="string">"APP_PATH"</span>, request.getContextPath()); %&gt;</span><br></pre></td></tr></table></figure><p>然后通过<code>${APP_PATH}/某路径</code>来设置路径。</p><h2 id="简单案例"><a href="#简单案例" class="headerlink" title="简单案例"></a>简单案例</h2><h3 id="案例代码"><a href="#案例代码" class="headerlink" title="案例代码"></a>案例代码</h3><ol><li><p>配置DispatcherServlet(前端控制器)</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">web-app</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>Archetype Created Web Application<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--加载spring配置文件并创建IoC容器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:springmvc.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">     <span class="comment">&lt;!--Tomcat启动时加载DispatcherServlet--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line">  </span><br><span class="line">  <span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>dispatcherServlet<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span><span class="comment">&lt;!--拦截所有请求--&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置springmvc.xml </p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"org.example"</span>&gt;</span><span class="tag">&lt;/<span class="name">context:component-scan</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--创建视图解析器对象--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/pages/"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--开启SpringMVC框架注解的支持--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--使用该标签自动加载RequestMappingHandlerMapping和RequestMappingHandlerAdapter--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span>&gt;</span><span class="tag">&lt;/<span class="name">mvc:annotation-driven</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>编写index.jsp和HelloController控制器类</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>入门案例<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"hello"</span>&gt;</span>入门案例<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(path = <span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"hello world!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在WEB-INF目录下创建pages目录，编写success.jsp页面</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;<span class="name">h3</span>&gt;</span>Success!<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>启动Tomcat测试</p></li></ol><h3 id="简单案例的执行流程"><a href="#简单案例的执行流程" class="headerlink" title="简单案例的执行流程"></a>简单案例的执行流程</h3><ol><li>当启动Tomcat服务器的时候，因为配置了load-on-startup标签，所以会创建DispatcherServlet对象， 就会加载springmvc.xml配置文件。</li><li>开启了注解扫描，那么HelloController对象就会被创建，另外springmvc.xml中配置的InternalResourceViewResolver也会被创建，这两个对象进入IoC容器。</li><li>从index.jsp发送请求，请求会先到达DispatcherServlet核心控制器，根据配置@RequestMapping注解找到执行的具体方法。</li><li>根据执行方法的返回值，再根据配置的视图解析器，去指定的目录下查找指定名称的JSP文件 。</li><li>Tomcat服务器渲染页面，做出响应。</li></ol><h3 id="Spring-MVC九大组件"><a href="#Spring-MVC九大组件" class="headerlink" title="Spring MVC九大组件"></a>Spring MVC九大组件</h3><p><img src="springmvc_flow.jpg" alt=""></p><p>用户请求到达dispatcherServlet，它就相当于 mvc 模式中的 c，dispatcherServlet是整个流程控制的中心，由它调用其它组件处理用户的请求，dispatcherServlet 的存在降低了组件之间的耦合性。Handler即我们编写的Controller类，由 dispatcherServlet把用户请求转发到 Handler， Handler再对具体的用户请求进行处理。</p><h4 id="HandlerMapping"><a href="#HandlerMapping" class="headerlink" title="HandlerMapping"></a>HandlerMapping</h4><p>处理器映射器。HandlerMapping 负责根据用户请求URI找到 Handler 即处理器，SpringMVC 提供了不同的映射器实现不同的映射方式，例如：配置文件方式，实现接口方式，注解方式等。</p><h4 id="HandlerAdapters"><a href="#HandlerAdapters" class="headerlink" title="HandlerAdapters"></a>HandlerAdapters</h4><p>处理器适配器。通过 HandlerAdapter对处理器进行执行，这是适配器模式的应用，通过扩展适配器可以对更多类型的处理器进行执行。</p><h4 id="ViewResolver"><a href="#ViewResolver" class="headerlink" title="ViewResolver"></a>ViewResolver</h4><p>视图处理器。ViewResolver负责将处理结果生成 View 视图，ViewResolver 首先根据逻辑视图名解析成物理视图名，即具体的页面地址，再生成 View视图对象，最后对View进行渲染将处理结果通过页面展示给用户。</p><h4 id="HandlerExceptionResolver"><a href="#HandlerExceptionResolver" class="headerlink" title="HandlerExceptionResolver"></a>HandlerExceptionResolver</h4><p>异常处理器。</p><h4 id="MultipartResolver"><a href="#MultipartResolver" class="headerlink" title="MultipartResolver"></a>MultipartResolver</h4><p>文件处理器，用于处理上传的文件。</p><h4 id="LocaleResolver"><a href="#LocaleResolver" class="headerlink" title="LocaleResolver"></a>LocaleResolver</h4><p>当前环境处理器。这就相当于配置数据库的方言一样，有了这个就可以对不同区域的用户显示不同的结果。SpringMVC主要有两个地方用到了Locale：一是ViewResolver视图解析的时候；二是用到国际化资源或者主题的时候。</p><h4 id="ThemeResolver"><a href="#ThemeResolver" class="headerlink" title="ThemeResolver"></a>ThemeResolver</h4><p>主题处理器，用于解析主题。SpringMVC中一个主题对应一个properties文件，里面存放着跟当前主题相关的所有资源，如图片、css样式等。</p><h4 id="RequestToViewNameTranslator"><a href="#RequestToViewNameTranslator" class="headerlink" title="RequestToViewNameTranslator"></a>RequestToViewNameTranslator</h4><p>视图名称翻译器。有的Handler处理完后并没有设置View也没有设置ViewName，这时就需要从request获取ViewName了，如何从request中获取ViewName就是RequestToViewNameTranslator要做的事情了。</p><h4 id="FlashMapManager"><a href="#FlashMapManager" class="headerlink" title="FlashMapManager"></a>FlashMapManager</h4><p>参数传递管理器。用于管理FlashMap，FlashMap主要用在redirect重定向中传递参数。</p><h2 id="请求参数的绑定"><a href="#请求参数的绑定" class="headerlink" title="请求参数的绑定"></a>请求参数的绑定</h2><h3 id="基本数据类型与字符串对象的绑定"><a href="#基本数据类型与字符串对象的绑定" class="headerlink" title="基本数据类型与字符串对象的绑定"></a>基本数据类型与字符串对象的绑定</h3><p>要求前端页面的参数名称必须和控制器中方法的形参名称保持一致。(严格区分大小写)</p><p>前端页面代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="account/findAccount?accountId=10&amp;accountName=zhangsan"&gt;查询账户&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/findAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">findAccount</span><span class="params">(Integer accountId,String accountName)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"查询了账户"</span>+accountId+<span class="string">","</span>+accountName);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="POJO类及其关联类对象的绑定"><a href="#POJO类及其关联类对象的绑定" class="headerlink" title="POJO类及其关联类对象的绑定"></a>POJO类及其关联类对象的绑定</h3><p>要求表单中参数名称和 POJO 类的属性名称保持一致。并且控制器方法的参数类型是 POJO 类型。</p><p>POJO类代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line">    <span class="keyword">private</span> Address address;</span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Address</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String provinceName;</span><br><span class="line">    <span class="keyword">private</span> String cityName;</span><br><span class="line">    <span class="comment">//getters and setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"account/saveAccount"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    账户名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户省份：&lt;input type=<span class="string">"text"</span> name=<span class="string">"address.provinceName"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户城市：&lt;input type=<span class="string">"text"</span> name=<span class="string">"address.cityName"</span> &gt;&lt;br/&gt;</span><br><span class="line">            &lt;input type=<span class="string">"submit"</span> value=<span class="string">"保存"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/saveAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">saveAccount</span><span class="params">(Account account)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"保存了账户。。。。"</span>+account);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="集合类型对象的绑定"><a href="#集合类型对象的绑定" class="headerlink" title="集合类型对象的绑定"></a>集合类型对象的绑定</h3><ol><li>要求集合类型的请求参数必须在 POJO 中。在表单中请求参数名称要和 POJO 中集合属性名称相同。 给 List 集合中的元素赋值，使用下标。 给 Map 集合中的元素赋值，使用键值对。</li><li>接收的请求参数是 json 格式数据。需要借助注解@RequestParam或@RequestBody实现。</li></ol><p>pojo类包含集合类型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Account&gt; accounts;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,Account&gt; accountMap;</span><br><span class="line">    <span class="comment">//getters, setters and toString</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"account/updateAccount"</span> method=<span class="string">"post"</span>&gt;</span><br><span class="line">    用户名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span> &gt;&lt;br/&gt;</span><br><span class="line">    用户密码：&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span> &gt;&lt;br/&gt;</span><br><span class="line">    用户年龄：&lt;input type=<span class="string">"text"</span> name=<span class="string">"age"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">1</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[0].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">1</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[0].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">2</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[1].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">2</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accounts[1].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">3</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['one'].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">3</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['one'].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">4</span>名称：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['two'].name"</span> &gt;&lt;br/&gt;</span><br><span class="line">    账户<span class="number">4</span>金额：&lt;input type=<span class="string">"text"</span> name=<span class="string">"accountMap['two'].money"</span> &gt;&lt;br/&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> value=<span class="string">"保存"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/updateAccount"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">updateAccount</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"更新了账户。。。。"</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="请求参数中文乱码解决"><a href="#请求参数中文乱码解决" class="headerlink" title="请求参数中文乱码解决"></a>请求参数中文乱码解决</h3><h4 id="POST请求方式"><a href="#POST请求方式" class="headerlink" title="POST请求方式"></a>POST请求方式</h4><p>在web.xml中配置过滤器来转换请求数据的编码。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="tag">&lt;/<span class="name">filterclass</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 指定字符集 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>encoding<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--过滤所有请求--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>characterEncodingFilter<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 springmvc的配置文件中可以配置，静态资源不过滤：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- location 表示路径，mapping 表示文件，**表示该目录下的文件以及子目录的文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/css/"</span> <span class="attr">mapping</span>=<span class="string">"/css/**"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/images/"</span> <span class="attr">mapping</span>=<span class="string">"/images/**"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:resources</span> <span class="attr">location</span>=<span class="string">"/scripts/"</span> <span class="attr">mapping</span>=<span class="string">"/javascript/**"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h4 id="GET请求方式"><a href="#GET请求方式" class="headerlink" title="GET请求方式"></a>GET请求方式</h4><p>Tomacat 对 GET 和 POST 请求处理方式是不同的，GET 请求的编码问题，要改 Tomcat 的 server.xml 配置文件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">Connector</span> <span class="attr">connectionTimeout</span>=<span class="string">"20000"</span> <span class="attr">port</span>=<span class="string">"8080"</span> <span class="attr">protocol</span>=<span class="string">"HTTP/1.1"</span> <span class="attr">redirectPort</span>=<span class="string">"8443"</span></span></span><br><span class="line"><span class="tag"><span class="attr">useBodyEncodingForURI</span>=<span class="string">"true"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>如果遇到 ajax 请求仍然乱码，把 useBodyEncodingForURI=”true”改为 URIEncoding=”UTF-8”即可。</p><h3 id="自定义类型转换器"><a href="#自定义类型转换器" class="headerlink" title="自定义类型转换器"></a>自定义类型转换器</h3><p>表单提交的任何数据类型全部都是字符串类型，假如后台定义Integer类型，数据也可以封装上，说明 Spring框架内部会默认进行数据类型转换。</p><p>如果想自定义数据类型转换，可以实现Converter接口并重写convert方法。比如表单提交”2020/11/11”，Spring可以正常转换为Date类型，但是表单提交的是”2020-11-11”，这时就需要我们自定义类型转换器了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.text.DateFormat;</span><br><span class="line"><span class="keyword">import</span> java.text.SimpleDateFormat;</span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> org.springframework.core.convert.converter.Converter;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把字符串转换成日期的转换器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">StringToDateConverter</span> <span class="keyword">implements</span></span></span><br><span class="line"><span class="class">    <span class="title">Converter</span>&lt;<span class="title">String</span>, <span class="title">Date</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 进行类型转换的方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Date <span class="title">convert</span><span class="params">(String source)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(source == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"参数不能为空"</span>);</span><br><span class="line">           </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            DateFormat df = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"yyyy-MM-dd"</span>);</span><br><span class="line">            <span class="comment">// 解析字符串</span></span><br><span class="line">            Date date = df.parse(source);</span><br><span class="line">            <span class="keyword">return</span> date;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"类型转换错误"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在springmvc.xml中配置StringToDateConverter对象：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--创建类型转换器工厂--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"conversionService"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">class</span>=<span class="string">"org.springframework.context.support.ConversionServiceFactoryBean"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--给工厂注入一个新的类型转换器--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"converters"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!--创建自定义类型转换器--&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.itcast.utils.StringToDateConverter"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 开启Spring对MVC注解的支持 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:annotation-driven</span> <span class="attr">conversion-service</span>=<span class="string">"conversionService"</span>/&gt;</span></span><br></pre></td></tr></table></figure><h3 id="在控制器中使用原生的ServletAPI"><a href="#在控制器中使用原生的ServletAPI" class="headerlink" title="在控制器中使用原生的ServletAPI"></a>在控制器中使用原生的ServletAPI</h3><p>在控制器的方法参数中使用HttpServletRequest、HttpServletResponse、HttpSession等即可。</p><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><h3 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h3><ul><li>作用：是建立请求URL和处理方法之间的对应关系。</li><li>属性<ul><li>path/value: 指定请求路径的url</li><li>method: 指定该方法的请求方式（post,get…）</li><li>headers: 发送的请求中必须包含请求头</li><li>params: 限制请求参数的条件，它支持简单的表达式，要求请求参数的 key和value 必须和配置的一模一样。例如： params = {“accountName”}，表示请求参数必须有 accountName；params = {“moeny!100”}，表示请求参数中 money 不能是 100。</li></ul></li><li>RequestMapping注解可以作用在方法和类上：作用在类上，path属性表示第一级的访问目录；作用在方法上，path属性表示第二级的访问目录。</li></ul><h3 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h3><ul><li>作用：作用于参数。把请求中指定名称的参数给控制器中的形参赋值。</li><li><p>属性</p><ul><li>value/name: 请求参数中的名称。</li><li>required：请求参数中是否必须提供此参数。默认值：true。表示必须提供，如果不提供将报错。</li></ul></li><li><p>示例</p><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="springmvc/useRequestParam?name=test"&gt;requestParam 注解&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/useRequestParam"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">useRequestParam</span><span class="params">(@RequestParam(<span class="string">"name"</span>)</span>String username,</span></span><br><span class="line"><span class="function">                              @<span class="title">RequestParam</span><span class="params">(value=<span class="string">"age"</span>,required=<span class="keyword">false</span>)</span>Integer age)</span>&#123;</span><br><span class="line">    System.out.println(username+<span class="string">","</span>+age);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h3><ul><li>作用：作用于参数。用于获取请求体内容，并将其绑定到Bean上或者分别绑定到对应的变量上。直接使用得到是 key=value&amp;key=value…结构的数据。 get 请求方式不适用。</li><li>属性：required。是否必须有请求体。默认值是：true。当取值为 true 时，get 请求方式会报错。如果取值 为 false，get 请求得到的是 null。</li></ul><h3 id="PathVarible"><a href="#PathVarible" class="headerlink" title="@PathVarible"></a>@PathVarible</h3><ul><li><p>作用：作用于参数。用于绑定 url 中的占位符。例如：请求 url 中 /delete/{id}，这个{id}就是 url 占位符。 url 支持占位符是 spring3.0 之后加入的。是 springmvc 支持 rest 风格 URL 的一个重要标志。</p></li><li><p>属性</p><ul><li>value/name：指定url中占位符名称。</li><li>required：请求url中是否必须提供占位符。</li></ul></li><li><p>示例</p><p>jsp代码：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href="springmvc/usePathVariable/100"&gt;pathVariable 注解&lt;/a&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/usePathVariable/&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">usePathVariable</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Integer id)</span>&#123;</span><br><span class="line">    System.out.println(id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>RESTful编程风格</p><ul><li>HTTP 协议里，四个表示操作方式的动词：GET 、POST 、PUT、 DELETE。它们分别对应四种基本操作：GET 用来获取资源，POST 用来新建资源，PUT 用来更新资源，DELETE 用来 删除资源。</li><li><code>@RestController</code>：创建处理http请求的对象。Spring4之后加入的注解，原来在<code>@Controller</code>中返回json需要<code>@ResponseBody</code>来配合，如果直接用<code>@RestController</code>替代<code>@Controller</code>就不需要再配置<code>@ResponseBody</code>，默认返回json格式。</li><li>RESTful在SpringMVC里的应用：请求同一个Controller，<strong>具体到每个方法method上的路径path一样</strong>(不再是每个方法上都配置一个具体的路径来进行匹配)，但每个method请求方式不一样，根据GET、PUT、POST 和 DELETE的不同方式，匹配不同的method。</li><li>示例：</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="comment">// 省略setter和getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(value=<span class="string">"/users"</span>)     <span class="comment">// 通过这里配置使下面的映射都在/users下</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建线程安全的Map</span></span><br><span class="line">    <span class="keyword">static</span> Map&lt;Long, User&gt; users = Collections.synchronizedMap(<span class="keyword">new</span> HashMap&lt;Long, User&gt;());</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> List&lt;User&gt; <span class="title">getUserList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/"的GET请求，用来获取用户列表</span></span><br><span class="line">        <span class="comment">// 还可以通过@RequestParam从页面中传递参数来进行查询条件或者翻页信息的传递</span></span><br><span class="line">        List&lt;User&gt; r = <span class="keyword">new</span> ArrayList&lt;User&gt;(users.values());</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/"</span>, method=RequestMethod.POST)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">postUser</span><span class="params">(@ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/"的POST请求，用来创建User</span></span><br><span class="line">        <span class="comment">// 除了@ModelAttribute绑定参数之外，还可以通过@RequestParam从页面中传递参数</span></span><br><span class="line">        users.put(user.getId(), user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/&#123;id&#125;"的GET请求，用来获取url中id值的User信息</span></span><br><span class="line">        <span class="comment">// url中的id可通过@PathVariable绑定到函数的参数中</span></span><br><span class="line">        <span class="keyword">return</span> users.get(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.PUT)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">putUser</span><span class="params">(@PathVariable Long id, @ModelAttribute User user)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/&#123;id&#125;"的PUT请求，用来更新User信息</span></span><br><span class="line">        User u = users.get(id);</span><br><span class="line">        u.setName(user.getName());</span><br><span class="line">        u.setAge(user.getAge());</span><br><span class="line">        users.put(id, u);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value=<span class="string">"/&#123;id&#125;"</span>, method=RequestMethod.DELETE)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">deleteUser</span><span class="params">(@PathVariable Long id)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 处理"/users/&#123;id&#125;"的DELETE请求，用来删除User</span></span><br><span class="line">        users.remove(id);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>HiddenHttpMethodFilter</p><p>由于浏览器 form 表单只支持 GET 与 POST 请求，而 DELETE、PUT 等 method 并不支持，Spring3.0 添 加了该过滤器，可以将浏览器请求改为指定的请求方式，发送给我们的控制器方法，使得支持 GET、POST、PUT 与 DELETE 请求。</p></li></ul><h3 id="RequestHeader"><a href="#RequestHeader" class="headerlink" title="@RequestHeader"></a>@RequestHeader</h3><ul><li>作用：作用于参数。用于获取请求消息头。</li><li>属性：<ul><li>value：提供消息头名称。</li><li>required：是否必须有此消息头。</li></ul></li></ul><h3 id="CookieValue"><a href="#CookieValue" class="headerlink" title="@CookieValue"></a>@CookieValue</h3><ul><li>作用：作用于参数。用于把指定 cookie 名称的值传入控制器方法参数。</li><li>属性<ul><li>value：指定cookie名称。</li><li>required：是否必须有此cookie。</li></ul></li></ul><h3 id="ModelAttribute"><a href="#ModelAttribute" class="headerlink" title="@ModelAttribute"></a>@ModelAttribute</h3><ul><li><p>作用：该注解是 SpringMVC4.3 版本以后新加入的。它可以用于修饰方法和参数。</p><ul><li>修饰<strong>方法</strong>：<strong>当前方法会在控制器的每个方法执行之前先执行一次。</strong></li><li>修饰<strong>参数</strong>：获取指定的数据给参数赋值。</li></ul></li><li><p>属性：value/name。：用于获取数据的 key。key 可以是 POJO的属性名称，也可以是 map 结构的 key。</p></li><li><p>应用场景：当表单提交数据不是完整的实体类数据时，保证没有提交数据的字段使用数据库对象原来的数据。 例如： 我们在编辑一个用户时，用户有一个创建信息字段，该字段的值是不允许被修改的。在提交表单数据时肯定没有此字段的内容，一旦更新会把该字段内容置为 null，此时就可以使用此注解修饰方法解决问题。</p><ul><li><p>基于 Map 的应用场景示例 1：ModelAttribute 修饰方法带返回值</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 修改用户信息 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"springmvc/updateUser"</span> <span class="attr">method</span>=<span class="string">"post"</span>&gt;</span></span><br><span class="line">    用户名称：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span></span></span><br><span class="line"><span class="tag">                <span class="attr">name</span>=<span class="string">"username"</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    用户年龄：<span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">name</span>=<span class="string">"age"</span> &gt;</span><span class="tag">&lt;<span class="name">br</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"保存"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">showModel</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟去数据库查询并设置表单中没有的字段password</span></span><br><span class="line">    User abc = findUserByName(username);</span><br><span class="line">    System.out.println(<span class="string">"执行了 showModel 方法"</span>+abc);</span><br><span class="line">    <span class="keyword">return</span> abc;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> User <span class="title">findUserByName</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">    User user = <span class="keyword">new</span> User();</span><br><span class="line">    user.setUsername(username);</span><br><span class="line">    user.setAge(<span class="number">19</span>);</span><br><span class="line">    user.setPassword(<span class="string">"123456"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/updateUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"控制器中处理请求的方法：修改用户："</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>基于 Map 的应用场景示例 2：ModelAttribute 修饰方法不带返回值</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ModelAttribute</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">showModel</span><span class="params">(String username,Map&lt;String,User&gt; map)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//模拟去数据库查询并设置表单中没有的字段password</span></span><br><span class="line">    <span class="comment">//使用map来传递user对象</span></span><br><span class="line">    User user = findUserByName(username);</span><br><span class="line">    System.out.println(<span class="string">"执行了 showModel 方法"</span>+user);</span><br><span class="line">    map.put(<span class="string">"abc"</span>,user);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/updateUser"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testModelAttribute</span><span class="params">(@ModelAttribute(<span class="string">"abc"</span>)</span>User user) </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"控制器中处理请求的方法：修改用户："</span>+user);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="SessionAttributes"><a href="#SessionAttributes" class="headerlink" title="@SessionAttributes"></a>@SessionAttributes</h3><ul><li>作用：作用于类上。<code>@SessionAttributes</code> is used to store model attributes in the HTTP Servlet session between requests. </li><li><p>属性</p><ul><li>name/value：存入Session域的属性名称，可以存入多个。</li><li>types：指定存入的数据类型。</li></ul></li><li><p>示例</p><p>jsp代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testPut"</span>&gt;</span>存入 SessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testGet"</span>&gt;</span>取出 SessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"springmvc/testClean"</span>&gt;</span>清除 SessionAttribute<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">"sessionAttributeController"</span>)</span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/springmvc"</span>)</span><br><span class="line"><span class="meta">@SessionAttributes</span>(value =&#123;<span class="string">"username"</span>,<span class="string">"password"</span>&#125;,types=&#123;Integer<span class="class">.<span class="keyword">class</span>&#125;)</span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">class</span> <span class="title">SessionAttributeController</span> </span>&#123;</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 把数据存入Servlet session</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> model</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">* Model是spring提供的一个接口，该接口有一个实现类 ExtendedModelMap</span></span><br><span class="line"><span class="comment">* 该类继承了ModelMap，而 ModelMap就是LinkedHashMap子类</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testPut"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testPut</span><span class="params">(Model model)</span></span>&#123;</span><br><span class="line">    model.addAttribute(<span class="string">"username"</span>, <span class="string">"tom"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"password"</span>,<span class="string">"123456"</span>);</span><br><span class="line">    model.addAttribute(<span class="string">"age"</span>, <span class="number">31</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/testGet"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testGet</span><span class="params">(ModelMap model)</span></span>&#123;</span><br><span class="line">    System.out.println(model.get(<span class="string">"username"</span>)+<span class="string">";"</span>+model.get(<span class="string">"password"</span>)+<span class="string">";"</span>+model.get(<span class="string">"age"</span>));</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125; </span><br><span class="line"> <span class="meta">@RequestMapping</span>(<span class="string">"/testClean"</span>)</span><br><span class="line"> <span class="function"><span class="keyword">public</span> String <span class="title">complete</span><span class="params">(SessionStatus sessionStatus)</span></span>&#123;</span><br><span class="line">     sessionStatus.setComplete();</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line"> &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="CrossOrigin"><a href="#CrossOrigin" class="headerlink" title="@CrossOrigin"></a>@CrossOrigin</h3><p>当我们使用前后端分离的方式开发项目，前端使用<code>XMLHttpReques</code>，也即AJAX请求页面时，浏览器访问的URI与AJAX请求的URI（我们RequestMapping定义的虚拟地址）是不同的，因此请求会报错。</p><p>CORS是一个W3C标准，全称是”跨域资源共享”（Cross-origin resource sharing）。它允许浏览器向跨源服务器，发出<code>XMLHttpRequest</code>请求，从而克服了AJAX只能<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">同源</a>使用的限制。<strong>CORS需要浏览器和服务器同时支持</strong>。</p><h4 id="前端解决方案"><a href="#前端解决方案" class="headerlink" title="前端解决方案"></a><a href="https://zhuanlan.zhihu.com/p/50416743" target="_blank" rel="noopener">前端解决方案</a></h4><ol><li>JSONP</li><li>CORS【推荐】</li><li>HTML5 API：postMessage</li><li>Web Sockets</li></ol><h4 id="后端Spring-MVC解决方案"><a href="#后端Spring-MVC解决方案" class="headerlink" title="后端Spring MVC解决方案"></a><a href="https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.html#mvc-cors" target="_blank" rel="noopener">后端Spring MVC解决方案</a></h4><ol><li>细粒度方式，仅限于类或方法：<code>@CrossOrigin</code><ul><li>跨域：<code>@CrossOrigin(origins = {&quot;*&quot;},allowedHeaders = &quot;*&quot;)</code></li><li>跨域传递Cookie：<code>@CrossOrigin(origins = {&quot;*&quot;},allowCredentials = &quot;true&quot;,allowedHeaders = &quot;*&quot;)</code></li></ul></li><li>全局配置：Java类+注解配置，或XML配置。</li><li>过滤器方式：使用内置的<code>CorsFilter</code>。</li></ol><h2 id="控制器方法返回值类型与结果视图"><a href="#控制器方法返回值类型与结果视图" class="headerlink" title="控制器方法返回值类型与结果视图"></a>控制器方法返回值类型与结果视图</h2><h3 id="返回字符串"><a href="#返回字符串" class="headerlink" title="返回字符串"></a>返回字符串</h3><p>控制器方法返回字符串可以指定逻辑视图名，通过视图解析器解析为物理视图地址。例如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定逻辑视图名，经过视图解析器解析为物理路径：/WEB-INF/pages/success.jsp</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testReturnString"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testReturnString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AccountController的testReturnString 方法执行了。。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回类型为void"><a href="#返回类型为void" class="headerlink" title="返回类型为void"></a>返回类型为void</h3><p>使用Servlet的request和response对象返回页面：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testReturnVoid</span><span class="params">(HttpServletRequest request,HttpServletResponse response)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">    <span class="comment">//使用request跳转</span></span><br><span class="line">    request.getRequestDispatcher(<span class="string">"/WEB-INF/pages/success.jsp"</span>).forward(request, response);</span><br><span class="line">    <span class="comment">//使用response重定向</span></span><br><span class="line">    response.sendRedirect(<span class="string">"index.jsp"</span>);</span><br><span class="line">    <span class="comment">//使用response指定响应结果,例如JSON数据</span></span><br><span class="line">    response.setCharacterEncoding(<span class="string">"utf-8"</span>);</span><br><span class="line">    response.setContentType(<span class="string">"application/json;charset=utf-8"</span>);</span><br><span class="line">    response.getWriter().write(<span class="string">"json 串"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="返回类型为ModelAndView"><a href="#返回类型为ModelAndView" class="headerlink" title="返回类型为ModelAndView"></a>返回类型为ModelAndView</h3><p>ModelAndView是SpringMVC的内置对象。通过该对象的addObject方法添加对象，setViewName方法设置逻辑视图名称，视图解析器会根据名称返回指定的页面。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testReturnModelAndView"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> ModelAndView <span class="title">testReturnModelAndView</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">    mv.addObject(<span class="string">"username"</span>, <span class="string">"张三"</span>);</span><br><span class="line">    mv.setViewName(<span class="string">"success"</span>);</span><br><span class="line">    <span class="keyword">return</span> mv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--success.jsp--&gt;</span><br><span class="line">&lt;%@ page language=<span class="string">"java"</span> contentType=<span class="string">"text/html; charset=UTF-8"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;!DOCTYPE html PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span> <span class="string">"http://www.w3.org/TR/html4/loose.dtd"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;meta http-equiv=<span class="string">"Content-Type"</span> content=<span class="string">"text/html; charset=UTF-8"</span>&gt;</span><br><span class="line">        &lt;title&gt;执行成功&lt;/title&gt;</span><br><span class="line">    &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        执行成功！</span><br><span class="line">        $&#123;requestScope.username&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><h3 id="转发与重定向"><a href="#转发与重定向" class="headerlink" title="转发与重定向"></a>转发与重定向</h3><h4 id="转发"><a href="#转发" class="headerlink" title="转发"></a>转发</h4><p>控制器方法在提供了 String 类型的返回值之后，默认就是请求转发。我们也可以写成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testForward"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testForward</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AccountController 的 testForward 方法执行了。。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"forward:/WEB-INF/pages/success.jsp"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>需要注意的是，如果用了formward则路径必须写成<strong>实际视图 url</strong>，不能写逻辑视图(不会交给视图解析器解析)。 它相当于“request.getRequestDispatcher(“url”).forward(request,response)”。使用请求转发，<strong>既可以转发到 jsp，也可以转发到其他的控制器方法</strong>。</p><h4 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/testRedirect"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">testRedirect</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"AccountController 的 testRedirect 方法执行了。。。。"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"redirect:testReturnModelAndView"</span>;<span class="comment">//重定向到另一个控制器方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它相当于“response.sendRedirect(url)”。需要注意的是，如果是重定向到 jsp 页面，则 jsp 页面不 能写在 WEB-INF 目录中，否则无法找到。</p><h3 id="ResponseBody响应JSON"><a href="#ResponseBody响应JSON" class="headerlink" title="@ResponseBody响应JSON"></a>@ResponseBody响应JSON</h3><p>该注解用于<strong>将控制器方法的返回值对象</strong>，通过HttpMessageConverter接口<strong>转换为指定格式的数据</strong>如json, xml等<strong>响应给客户端</strong>，而不再需要视图渲染。SpringMVC默认用MappingJacksonHttpMessageConverter对json数据进行转换，需要加入如下jackson的包：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-annotations<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp代码：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script type="text/javascript" src="$&#123;pageContext.request.contextPath&#125;/js/jquery.min.js"&gt;&lt;/script&gt;</span><br><span class="line">&lt;script type=<span class="string">"text/javascript"</span>&gt;</span><br><span class="line">    $(function()&#123;</span><br><span class="line">        $(<span class="string">"#testJson"</span>).click(function()&#123;</span><br><span class="line">            $.ajax(&#123;</span><br><span class="line">                type:<span class="string">"post"</span>,</span><br><span class="line">                url:<span class="string">"$&#123;pageContext.request.contextPath&#125;/testResponseJson"</span>,</span><br><span class="line">                contentType:<span class="string">"application/json;charset=utf-8"</span>,</span><br><span class="line">                data:<span class="string">'&#123;"id":1, "name":"test", "money":999.0&#125;'</span>,</span><br><span class="line">                dataType:<span class="string">"json"</span>,</span><br><span class="line">                success:function(data)&#123;</span><br><span class="line">                    alert(data);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;)</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;!-- 测试异步请求 --&gt;</span><br><span class="line">&lt;input type=<span class="string">"button"</span> value=<span class="string">"测试ajax, 请求json和响应json"</span> id=<span class="string">"testJson"</span>/&gt;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span>(<span class="string">"jsonController"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JsonController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/testResponseJson"</span>)</span><br><span class="line">    <span class="keyword">public</span> <span class="meta">@ResponseBody</span> <span class="function">Account <span class="title">testResponseJson</span><span class="params">(@RequestBody Account account)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"异步请求："</span>+account);</span><br><span class="line">        <span class="keyword">return</span> account;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h2><h3 id="本服务器文件上传"><a href="#本服务器文件上传" class="headerlink" title="本服务器文件上传"></a>本服务器文件上传</h3><p>前端页面form表单的enctype属性（表示<strong>表单请求正文的类型</strong>）的默认值是application/x-www-form-urlencoded，要实现文件上传必须将该属性的值设置为multipart/form-data，并且表单的method属性必须是POST，同时提供一个文件选择域<code>&lt;input type=&quot;file&quot;/&gt;</code>。</p><p>SpringMVC实现文件上传需要导入以下包，会用到commons-fileupload包的文件上传解析器，而该包依赖于commons-io：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-fileupload<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>commons-io<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>jsp页面：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;body&gt;</span><br><span class="line">   &lt;form action=<span class="string">"test/fileUpload"</span> method=<span class="string">"post"</span> enctype=<span class="string">"multipart/form-data"</span>&gt;</span><br><span class="line">       图片：&lt;input type=<span class="string">"file"</span> name=<span class="string">"uploadFile"</span>&gt;</span><br><span class="line">       &lt;input type=<span class="string">"submit"</span> value=<span class="string">"上传"</span>&gt;</span><br><span class="line">   &lt;/form&gt;</span><br><span class="line">&lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>控制器代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileUpload"</span>)</span><br><span class="line">    <span class="comment">//SpringMVC提供了MultipartFile类来接收上传文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFileUpload</span><span class="params">(MultipartFile uploadFile, HttpServletRequest request)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line"></span><br><span class="line">        String fileName = uploadFile.getOriginalFilename();</span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>).toUpperCase();</span><br><span class="line">        fileName = uuid + <span class="string">"_"</span> + fileName;</span><br><span class="line"></span><br><span class="line">        String path = request.getSession().getServletContext().getRealPath(<span class="string">"/uploads/"</span>);</span><br><span class="line">        File file = <span class="keyword">new</span> File(path);</span><br><span class="line">        <span class="keyword">if</span>(!file.exists()) file.mkdirs();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//transferTo(File file)方法写入文件到路径</span></span><br><span class="line">        uploadFile.transferTo(<span class="keyword">new</span> File(path,fileName));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置文件上传解析器 --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 注意id的值是固定的--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"multipartResolver"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">class</span>=<span class="string">"org.springframework.web.multipart.commons.CommonsMultipartResolver"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 设置上传文件的最大尺寸为 5MB --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"maxUploadSize"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">value</span>&gt;</span>5242880<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="跨服务器文件上传"><a href="#跨服务器文件上传" class="headerlink" title="跨服务器文件上传"></a>跨服务器文件上传</h3><p>在实际开发中，会有很多处理不同功能的服务器。例如： 应用服务器：负责部署应用。数据库服务器：运行数据库。缓存和消息服务器：负责处理大并发访问的缓存和消息。文件服务器：负责存储用户上传文件的服务器。 (注意：此处说的不是服务器集群）此时我们就需要将用户上传的文件从应用服务器上传到文件服务器。</p><p>导入依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.sun.jersey<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jersey-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.18.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>控制器代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"/test"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FileUploadController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/fileUpload"</span>)</span><br><span class="line">    <span class="comment">//SpringMVC提供了MultipartFile类来接收上传文件</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">testFileUpload</span><span class="params">(MultipartFile uploadFile)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        String path = <span class="string">"文件服务器的存储路径/"</span>;</span><br><span class="line"></span><br><span class="line">        String fileName = uploadFile.getOriginalFilename();</span><br><span class="line">        String uuid = UUID.randomUUID().toString().replace(<span class="string">"-"</span>,<span class="string">""</span>).toUpperCase();</span><br><span class="line">        fileName = uuid + <span class="string">"_"</span> + fileName;</span><br><span class="line">        <span class="comment">//创建客户端对象</span></span><br><span class="line">        Client client = Client.create();</span><br><span class="line">        <span class="comment">//和文件服务器连接</span></span><br><span class="line">        WebResource webResource = client.resource(path+fileName);</span><br><span class="line">        <span class="comment">//上传</span></span><br><span class="line">        webResource.put(uploadFile.getBytes());</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h2><p>一旦产生异常则向上抛出，持久层DAO -&gt; 业务层Service -&gt; 表现层Controlller  ，最终由SpringMVC的DispatherServlet匹配异常处理器组件进行处理。</p><h3 id="自定义异常类"><a href="#自定义异常类" class="headerlink" title="自定义异常类"></a>自定义异常类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyException</span> <span class="keyword">extends</span> <span class="title">Exception</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Stirng message;</span><br><span class="line">    <span class="comment">//构造器.setter and getter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Controller方法中抛出该自定义异常，由我们定义的异常处理器捕获并处理。</p><h3 id="自定义异常处理器并配置"><a href="#自定义异常处理器并配置" class="headerlink" title="自定义异常处理器并配置"></a>自定义异常处理器并配置</h3><p>自定义异常处理器需要实现HandlerExceptionResolver接口，该接口提供了<code>resolveException(Exception, Hanlder)</code>方法的一个实现，方法会返回一个<code>ModelAndView</code>。</p><p>另外，我们也可以使用框架已有的异常处理器实现类<code>SimpleMappingExceptionResolver</code>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyExceptionResolver</span> <span class="keyword">implements</span> <span class="title">HandlerExceptionResolver</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ModelAndView <span class="title">resolveException</span><span class="params">(HttpServletRequest httpServletRequest, HttpServletResponse httpServletResponse, Object o, Exception e)</span></span>&#123;</span><br><span class="line">        ModelAndView mv = <span class="keyword">new</span> ModelAndView();</span><br><span class="line">        mv.addObject(<span class="string">"errorMsg"</span>, ex.getMessage());</span><br><span class="line">        mv.setViewName(<span class="string">"error"</span>);<span class="comment">//返回error.jsp</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"myExceptionResolver"</span> <span class="attr">class</span>=<span class="string">"org.example.exception.MyExceptionResolver"</span>&gt;</span> <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="ExceptionHandler"><a href="#ExceptionHandler" class="headerlink" title="@ExceptionHandler"></a>@ExceptionHandler</h3><p><code>HandlerExceptionResolver</code>接口以及<code>SimpleMappingExceptionResolver</code>解析器类的实现使得你能<strong>声明式地将异常映射到特定的视图</strong>上，还可以在异常被转发（forward）到对应的视图前使用Java代码做些判断和逻辑。不过在一些场景，<strong>特别是依靠<code>@ResponseBody</code>返回响应而非依赖视图解析机制的场景</strong>（比如Restful风格）下，<strong>直接设置响应的状态码并将客户端需要的错误信息直接写回响应体</strong>中，可能是更方便的方法。</p><p>如果<code>@ExceptionHandler</code>方法是在控制器内部定义的，那么它会<strong>接收并处理由控制器（或其任何子类）中的<code>@RequestMapping</code>方法抛出的异常。</strong></p><p>此外，<code>@ExceptionHandler</code>注解还可以接受一个异常类型的数组作为参数值。若抛出了已在列表中声明的异常，那么相应的<code>@ExceptionHandler</code>方法将会被调用。如果没有给注解任何参数值，那么默认处理的异常类型将是方法参数所声明的那些异常。</p><p><code>@ExceptionHandler</code>方法的返回值可以是<code>String</code>类型——这种情况下会被解析为视图名——可以是<code>ModelAndView</code>类型的对象，也可以是<code>ResponseEntity</code>。或者你还可以在方法上添加<code>@ResponseBody</code>注解以使用消息转换器会转换信息为特定类型的数据，然后把它们写回到响应流中。<a href="https://github.com/Laishiji/miaosha/blob/main/src/main/java/com/laishiji/miaosha/controller/CommonController.java" target="_blank" rel="noopener">例如</a>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ExceptionHandler</span>(Exception<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseStatus</span>(<span class="title">HttpStatus</span>.<span class="title">OK</span>)</span></span><br><span class="line"><span class="class">@<span class="title">ResponseBody</span></span></span><br><span class="line"><span class="class"><span class="title">public</span> <span class="title">Object</span> <span class="title">handlerException</span>(<span class="title">HttpServletRequest</span> <span class="title">request</span>, <span class="title">Exception</span> <span class="title">e</span>)</span>&#123;</span><br><span class="line">    <span class="comment">//直接返回e或者businessException的话, json中会包含很多虚拟机栈跟踪信息,</span></span><br><span class="line">    <span class="comment">//因此使用map取出错误状态码和错误信息即可</span></span><br><span class="line">    Map&lt;String, Object&gt; responseData = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">if</span>(e <span class="keyword">instanceof</span> BusinessException)&#123;</span><br><span class="line">        BusinessException businessException = (BusinessException)e;</span><br><span class="line"></span><br><span class="line">        responseData.put(<span class="string">"errorCode"</span>, businessException.getErrorCode());</span><br><span class="line">        responseData.put(<span class="string">"errorMessage"</span>, businessException.getErrorMessage());</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        responseData.put(<span class="string">"errorCode"</span>, EnumBusinessError.UNKNOWN_ERROR.getErrorCode());</span><br><span class="line">        responseData.put(<span class="string">"errorMessage"</span>, EnumBusinessError.UNKNOWN_ERROR.getErrorMessage());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//归一化处理，返回通用对象</span></span><br><span class="line">    <span class="keyword">return</span> CommonReturnType.create(responseData, <span class="string">"fail"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>Spring MVC的处理器拦截器类似于Servlet的过滤 Filter，用于对处理器进行预处理和后处理。它们的区别是：过滤器在 url-pattern中配置了/*之后，可以对所有要访问的资源拦截。 拦截器只会拦截访问的控制器方法，如果访问的是 jsp，html,css,image 或者js是不会进行拦截的。</p><p>我们也可以定义拦截器链，在访问被拦截的方法时，拦截器链 中的拦截器会按照定义的顺序执行。</p><p>拦截器是AOP思想的具体应用，由动态代理实现。要自定义拦截器，需要实现HandlerInterceptor接口。</p><h3 id="自定义拦截器"><a href="#自定义拦截器" class="headerlink" title="自定义拦截器"></a>自定义拦截器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span></span>&#123;</span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * controller方法执行前，进行拦截的方法</span></span><br><span class="line"><span class="comment">    * return true放行</span></span><br><span class="line"><span class="comment">    * return false拦截</span></span><br><span class="line"><span class="comment">    * 可以使用转发或者重定向直接跳转到指定的页面。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Object handler)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"拦截器执行了..."</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>springmvc.xml中配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置拦截器 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mvc:interceptors</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法进行拦截 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mvc:mapping</span> <span class="attr">path</span>=<span class="string">"/user/*"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 哪些方法不进行拦截 &lt;mvc:exclude-mapping path=""/&gt;--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 注册拦截器对象 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"cn.itcast.demo1.MyInterceptor"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mvc:interceptor</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mvc:interceptors</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="HandlerInterceptor接口方法"><a href="#HandlerInterceptor接口方法" class="headerlink" title="HandlerInterceptor接口方法"></a>HandlerInterceptor接口方法</h3><h3 id="preHandle"><a href="#preHandle" class="headerlink" title="preHandle"></a>preHandle</h3><p>控制器方法执行前拦截的方法。</p><ul><li>可以使用request或者response跳转到指定的页面 。</li><li>return true放行，执行下一个拦截器，如果没有拦截器，执行controller中的方法。</li><li>return false不放行，不会执行controller中的方法。</li></ul><h3 id="postHandle"><a href="#postHandle" class="headerlink" title="postHandle"></a>postHandle</h3><p>控制器方法执行后执行的方法，在JSP视图执行前。</p><ul><li>可以使用request或者response跳转到指定的页面。</li><li>如果指定了跳转的页面，那么controller方法跳转的页面将不会显示。</li></ul><h3 id="afterCompletion"><a href="#afterCompletion" class="headerlink" title="afterCompletion"></a>afterCompletion</h3><p>最后执行的方法，JSP视图执行后执行。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://docs.spring.io/spring-framework/docs/5.2.5.RELEASE/spring-framework-reference/web.html#mvc&quot; target=&quot;_blank&quot; rel=&quot;noopene
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring事务处理</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Spring%E4%BA%8B%E5%8A%A1%E5%A4%84%E7%90%86/</id>
    <published>2020-10-17T01:55:38.000Z</published>
    <updated>2020-10-19T11:00:19.551Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了业务层的事务处理解决方案。</p><p>Spring为我们提供了一组事务控制的接口，在<code>spring-tx</code>jar包中。</p><p>Spring的事务控制基于AOP，可以通过编程和配置两种方式实现。主要使用配置的方式。</p><h3 id="Spring事务控制的API"><a href="#Spring事务控制的API" class="headerlink" title="Spring事务控制的API"></a>Spring事务控制的API</h3><h4 id="PlatFormTransactionManager"><a href="#PlatFormTransactionManager" class="headerlink" title="PlatFormTransactionManager"></a>PlatFormTransactionManager</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PlatformTransactionManager</span> <span class="keyword">extends</span> <span class="title">TransactionManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取事务状态</span></span><br><span class="line">    <span class="function">TransactionStatus <span class="title">getTransaction</span><span class="params">(@Nullable TransactionDefinition var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//提交事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">commit</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//回滚事务</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">rollback</span><span class="params">(TransactionStatus var1)</span> <span class="keyword">throws</span> TransactionException</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="DataSourceTransactionManager"><a href="#DataSourceTransactionManager" class="headerlink" title="DataSourceTransactionManager"></a>DataSourceTransactionManager</h4><p>真正管理事务的对象。该类继承自PlatFormTransactionManager的抽象实现类AbstractPlatformTransactionManager。</p><h4 id="TransactionDefinition"><a href="#TransactionDefinition" class="headerlink" title="TransactionDefinition"></a>TransactionDefinition</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">TransactionDefinition</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果当前没有事务，则新建一个事务，如果已经存在一个事务，则加入到这个事务中。默认值</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRED = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//支持当前事务，如果当前没有事务，则以非事务方式运行</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_SUPPORTS = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//使用当前的事务，若当前没有事务，则抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_MANDATORY = <span class="number">2</span>;</span><br><span class="line">    <span class="comment">//新建事务，如果当前在事务中，把当前事务挂起</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_REQUIRES_NEW = <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//以非事务方式执行操作，如果当前存在事务，把当前事务挂起</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NOT_SUPPORTED = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//以非事务方式运行，若当前存在事务，抛出异常</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NEVER = <span class="number">5</span>;</span><br><span class="line">    <span class="comment">//若当前存在事务，则在嵌套事务内执行。若当前没有事务，则执行REQUIRED类似的操作。</span></span><br><span class="line">    <span class="keyword">int</span> PROPAGATION_NESTED = <span class="number">6</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> ISOLATION_DEFAULT = -<span class="number">1</span>;<span class="comment">//默认使用数据库的事务隔离级别，归属下别某一种</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_UNCOMMITTED = <span class="number">1</span>;<span class="comment">//可以读取未提交数据</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_READ_COMMITTED = <span class="number">2</span>;<span class="comment">//只能读取已提交数据，解决脏读问题（Oracle默认级别）</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_REPEATABLE_READ = <span class="number">4</span>;<span class="comment">//是否读取其他事务提交修改后的数据，解决不可重复读问题</span></span><br><span class="line">    <span class="keyword">int</span> ISOLATION_SERIALIZABLE = <span class="number">8</span>;<span class="comment">//是否读取其他事务提交添加后的数据，解决幻影读问题</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> TIMEOUT_DEFAULT = -<span class="number">1</span>;<span class="comment">//默认没有超时时间，正数时单位为秒</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//获取事务传播行为</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getPropagationBehavior</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取事务隔离级别，默认使用数据库的事务隔离级别</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getIsolationLevel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取事务超时时间</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">int</span> <span class="title">getTimeout</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//事务是否只读，建议查询时设置为只读。</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> <span class="keyword">boolean</span> <span class="title">isReadOnly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取事务名称</span></span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    <span class="function"><span class="keyword">default</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取默认的事务定义信息对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> TransactionDefinition <span class="title">withDefaults</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> StaticTransactionDefinition.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="TransactionStatus"><a href="#TransactionStatus" class="headerlink" title="TransactionStatus"></a>TransactionStatus</h4><p>该接口描述了某个时间点上事务对象的状态信息，包含6个具体的操作。</p><ul><li>void flush()：刷新事务。</li><li>boolean hasSavepoint()：是否存在存储点。</li><li>boolean isCompleted()：事务是否完成。</li><li>boolean isNewTransaction()：是否是新的事务。</li><li>boolean isRollbackOnly()：事务是否回滚。</li><li>void setRollbackOnly()：设置事务回滚。</li></ul><h3 id="Spring声明式事务控制"><a href="#Spring声明式事务控制" class="headerlink" title="Spring声明式事务控制"></a>Spring声明式事务控制</h3><h4 id="XML配置实现"><a href="#XML配置实现" class="headerlink" title="XML配置实现"></a>XML配置实现</h4><p><a href="https://github.com/Laishiji/SpringLearningDemo/tree/master/SpringTransactionDemo" target="_blank" rel="noopener">案例代码</a>。配置步骤如下：</p><ol><li><p>导入命名空间和约束：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务管理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--需要先配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务的通知：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置AOP中通用的切入点表达式：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--配置切入点表达式--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>建立事务通知和切入点表达式的关系：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:pointcut</span> <span class="attr">id</span>=<span class="string">"pt"</span> <span class="attr">expression</span>=<span class="string">"execution(* com.itheima.service.impl.*.*(..))"</span>/&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--建立事务通知和切入点表达式的关系--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">aop:advisor</span> <span class="attr">advice-ref</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">pointcut-ref</span>=<span class="string">"pt"</span>&gt;</span><span class="tag">&lt;/<span class="name">aop:advisor</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>在事务通知标签内配置事务的属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:advice</span> <span class="attr">id</span>=<span class="string">"transactionInterceptor"</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--5.配置事务的属性</span></span><br><span class="line"><span class="comment">                isolation: 指定事务隔离级别。默认DEFAULT,表示使用数据库默认事务隔离级别</span></span><br><span class="line"><span class="comment">                propagation: 指定事务的传播行为。默认值是REQUIRED,增删改的选择。查询可选用SUPPORTS</span></span><br><span class="line"><span class="comment">                read-only: 指定事务是否只读。只有查询才能设置为true</span></span><br><span class="line"><span class="comment">                rollback-for: 指定一个异常，产生该异常时，事务回滚；产生其他异常时，事务不回滚。不指定则任何异常都回滚。</span></span><br><span class="line"><span class="comment">                no-rollback-for: 指定一个异常，产生该异常时，事务不回滚；产生其他异常时，事务回滚。不指定则任何异常都回滚。</span></span><br><span class="line"><span class="comment">                timeout:指定超时时间，默认没有</span></span><br><span class="line"><span class="comment">        --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"*"</span> <span class="attr">propagation</span>=<span class="string">"REQUIRED"</span> <span class="attr">read-only</span>=<span class="string">"false"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tx:method</span> <span class="attr">name</span>=<span class="string">"find*"</span> <span class="attr">propagation</span>=<span class="string">"SUPPORTS"</span> <span class="attr">read-only</span>=<span class="string">"true"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:method</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tx:attributes</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tx:advice</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><h4 id="注解配置实现"><a href="#注解配置实现" class="headerlink" title="注解配置实现"></a>注解配置实现</h4><p><a href="https://github.com/Laishiji/SpringLearningDemo/tree/master/SpringTransactionAnnotationDemo" target="_blank" rel="noopener">案例代码</a>。配置步骤如下：</p><ol><li><p>导入命名空间和约束：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:aop</span>=<span class="string">"http://www.springframework.org/schema/aop"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:tx</span>=<span class="string">"http://www.springframework.org/schema/tx"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/tx</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/tx/spring-tx.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/aop</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/aop/spring-aop.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></li><li><p>配置事务管理器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"transactionManager"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DataSourceTransactionManager"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--需要先配置数据源--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>纯注解方式则创建配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 创建事务管理器配置类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TransactionConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"transactionManager"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> PlatformTransactionManager <span class="title">createTransactionManager</span><span class="params">(DataSource dataSource)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DataSourceTransactionManager(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>开启Spring对注解事务的支持：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">tx:annotation-driven</span> <span class="attr">transaction-manager</span>=<span class="string">"transactionManager"</span>&gt;</span><span class="tag">&lt;/<span class="name">tx:annotation-driven</span>&gt;</span></span><br></pre></td></tr></table></figure><p>纯注解方式在主配置类上使用<code>@EnableTransactionManagement</code>来开启。</p></li><li><p>在需要事务支持的地方使用<code>@Transactional</code>标记。比如业务层接口实现类上或者其方法（切入点方法）之上。</p></li></ol><h4 id="纯注解配置实现"><a href="#纯注解配置实现" class="headerlink" title="纯注解配置实现"></a>纯注解配置实现</h4><p><a href="https://github.com/Laishiji/SpringLearningDemo/tree/master/SpringTransactionAnnoDemo2" target="_blank" rel="noopener">案例代码</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;JavaEE体系进行分层开发，事务处理位于业务层，Spring提供了业务层的事务处理解决方案。&lt;/p&gt;
&lt;p&gt;Spring为我们提供了一组事
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring模板类JdbcTemplate</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Spring%E6%A8%A1%E6%9D%BF%E7%B1%BBJdbcTemplate/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/Spring%E6%A8%A1%E6%9D%BF%E7%B1%BBJdbcTemplate/</id>
    <published>2020-10-17T01:55:21.000Z</published>
    <updated>2020-10-19T11:00:01.846Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JdbcTemplate概述"><a href="#JdbcTemplate概述" class="headerlink" title="JdbcTemplate概述"></a>JdbcTemplate概述</h3><p>JdbcTemplate是对原始JDBC API的简单封装。除该模板类以外，Spring还提供了操作关系型数据库的HibernateTemplate，操作NoSQL数据库的RedisTemplate，操作消息队列的JmsTemplate。</p><p>Maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-tx<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.7.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>8.0.21<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="JdbcTemplate实现CRUD"><a href="#JdbcTemplate实现CRUD" class="headerlink" title="JdbcTemplate实现CRUD"></a>JdbcTemplate实现CRUD</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"jdbcTemplate"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.core.JdbcTemplate"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"dataSource"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"org.springframework.jdbc.datasource.DriverManagerDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClassName"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/test?useUnicode=true&amp;amp;characterEncoding=UTF-8&amp;amp;serverTimezone=UTC"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"root"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"admin"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Account</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Float money;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Integer <span class="title">getId</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setId</span><span class="params">(Integer id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.id = id;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Float <span class="title">getMoney</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMoney</span><span class="params">(Float money)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"Account&#123;"</span> +</span><br><span class="line">                <span class="string">"id="</span> + id +</span><br><span class="line">                <span class="string">", name='"</span> + name + <span class="string">'\''</span> +</span><br><span class="line">                <span class="string">", money="</span> + money +</span><br><span class="line">                <span class="string">'&#125;'</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcTemplateDemo</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ApplicationContext applicationContext = <span class="keyword">new</span> ClassPathXmlApplicationContext(<span class="string">"bean.xml"</span>);</span><br><span class="line">        JdbcTemplate jdbcTemplate =(JdbcTemplate) applicationContext.getBean(<span class="string">"jdbcTemplate"</span>);</span><br><span class="line">        <span class="comment">//CRUD操作</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="增加（Create）"><a href="#增加（Create）" class="headerlink" title="增加（Create）"></a>增加（Create）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"insert into account(name,money) values(?,?)"</span>,<span class="string">"bbb"</span>,<span class="number">1000</span>);</span><br></pre></td></tr></table></figure><h4 id="删除（Delete）"><a href="#删除（Delete）" class="headerlink" title="删除（Delete）"></a>删除（Delete）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"delete from account where id=?"</span>, <span class="number">7</span>);</span><br></pre></td></tr></table></figure><h4 id="更新（Update）"><a href="#更新（Update）" class="headerlink" title="更新（Update）"></a>更新（Update）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">jdbcTemplate.update(<span class="string">"update account set name=?,money=? where id=?"</span>, <span class="string">"aaa"</span>, <span class="number">1000</span>, <span class="number">1</span>);</span><br></pre></td></tr></table></figure><h4 id="检索（Retrieve）"><a href="#检索（Retrieve）" class="headerlink" title="检索（Retrieve）"></a>检索（Retrieve）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 定义Account的封装策略</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountRowMapper</span> <span class="keyword">implements</span> <span class="title">RowMapper</span>&lt;<span class="title">Account</span>&gt;</span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 将结果集的数据封装到Account中，然后Spring将Account加到List&lt;Account&gt;中</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> resultSet</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> i</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">         * <span class="doctag">@throws</span> SQLException</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Account <span class="title">mapRow</span><span class="params">(ResultSet resultSet, <span class="keyword">int</span> i)</span> <span class="keyword">throws</span> SQLException </span>&#123;</span><br><span class="line">            Account account = <span class="keyword">new</span> Account();</span><br><span class="line">            account.setId(resultSet.getInt(<span class="string">"id"</span>));</span><br><span class="line">            account.setName(resultSet.getString(<span class="string">"name"</span>));</span><br><span class="line">            account.setMoney(resultSet.getFloat(<span class="string">"money"</span>));</span><br><span class="line">            <span class="keyword">return</span> account;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">"select * from account where money &gt; ?"</span>,<span class="keyword">new</span> AccountRowMapper(),<span class="number">1000f</span>);</span><br></pre></td></tr></table></figure><p>实际使用中不需要自己实现RowMapper，可使用Spring提供的BeanPropertyRowMapper类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;Account&gt; accountList = jdbcTemplate.query(<span class="string">"select * from account where money &gt; ?"</span>,<span class="keyword">new</span> BeanPropertyRowMapper&lt;Account&gt;(Account<span class="class">.<span class="keyword">class</span>),1000<span class="title">f</span>)</span>;</span><br></pre></td></tr></table></figure><p>使用聚合函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Long count = jdbcTemplate.queryForObject(<span class="string">"select count(*) from account where money &gt; ?"</span>, Long<span class="class">.<span class="keyword">class</span>, 500<span class="title">f</span>)</span>;</span><br></pre></td></tr></table></figure><h3 id="JdbcDaoSupport"><a href="#JdbcDaoSupport" class="headerlink" title="JdbcDaoSupport"></a>JdbcDaoSupport</h3><p>使DAO类继承自JdbcDaoSupport，则DAO类不再需要在代码中注入数据源和JdbcTemplate变量，而是在代码中使用<code>super.getJdbcTemplate()</code>获取。这样写的好处是当有大量DAO时，可以减少重复代码，适用于XML配置的方式。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JdbcTemplate概述&quot;&gt;&lt;a href=&quot;#JdbcTemplate概述&quot; class=&quot;headerlink&quot; title=&quot;JdbcTemplate概述&quot;&gt;&lt;/a&gt;JdbcTemplate概述&lt;/h3&gt;&lt;p&gt;JdbcTemplate是对原始JDBC A
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>CGLib动态代理</title>
    <link href="http://thmasterplan.cn/JavaWeb/CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/CGLib%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2020-10-16T02:50:22.000Z</published>
    <updated>2020-10-16T11:34:07.902Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CGLib是一个强大、高性能的字节码生产类库，可以实现运行期动态扩展Java类和实现Java接口，Spring在运行期间通过 CGlib<strong>继承被代理类</strong>，重写父类的方法，实现AOP面向切面编程。</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>使用Enhancer类的create方法得到代理对象，该方法的参数列表：</p><ul><li>Class ：被代理类的class对象</li><li>Callback：用于提供增强的代码，一般写该接口的实现类MethodInterceptor</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Object cgLibProxy = Enhancer.create(XXX.getClass(), <span class="keyword">new</span> MethodInterceptor()&#123;</span><br><span class="line">    <span class="comment">//执行被代理类的任何方法都会经过该方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] args, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><h3 id="JDK与CGLib动态代理区别"><a href="#JDK与CGLib动态代理区别" class="headerlink" title="JDK与CGLib动态代理区别"></a>JDK与CGLib动态代理区别</h3><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><ul><li><p>JDK动态代理是面向接口，<strong>通过创建代理实现类实现</strong>，创建代理速度比CGLib快。</p></li><li><p><strong>CGLib动态代理是通过继承被代理类实现</strong>（如果被代理类被final关键字所修饰，那么会失败），创建代理没有JDK动态代理快，但是运行速度比JDK动态代理要快。</p></li></ul><h4 id="使用注意"><a href="#使用注意" class="headerlink" title="使用注意"></a>使用注意</h4><p>如果要被代理的对象是个实现类，那么Spring会使用JDK动态代理来完成操作（Spirng默认采用JDK动态代理实现机制）</p><p>如果被代理类不是实现类，Spring会强制使用CGLib来实现动态代理。</p><h4 id="Spring中如何选择代理机制？"><a href="#Spring中如何选择代理机制？" class="headerlink" title="Spring中如何选择代理机制？"></a>Spring中如何选择代理机制？</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">aop:config</span> <span class="attr">proxy-target-class</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">aop:config</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过配置Spring的中aop:config标签来显示的指定使用动态代理机制 proxy-target-class=true表示使用CGLib代理，如果为false就是默认使用JDK动态代理。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;CGLib是一个强大、高性能的字节码生产类库，可以实现运行期动态扩展Java类和实现Java接口，Spring在运行期间通过 CGlib&lt;s
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>开发原则</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E5%BC%80%E5%8F%91%E5%8E%9F%E5%88%99/</id>
    <published>2020-10-13T07:23:38.000Z</published>
    <updated>2020-11-03T13:29:38.408Z</updated>
    
    <content type="html"><![CDATA[<p>在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式， 不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。</p><p>面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有 <code>迪米特法则</code>和<code>合成复用原则</code>。</p><h3 id="S：单一职责原则（Single-Responsibility-Principle）"><a href="#S：单一职责原则（Single-Responsibility-Principle）" class="headerlink" title="S：单一职责原则（Single-Responsibility Principle）"></a>S：单一职责原则（Single-Responsibility Principle）</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p><strong>一个对象应该只包含单一的职责，并且该职责被完整地封装在一个类中</strong>。</p><h4 id="原则分析"><a href="#原则分析" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>一个<strong>类(或者大到模块，小到方法)</strong>承担的职责越多，它被复用的可能性越小；如果一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作。</li><li>类的职责主要包括两个方面: 数据职责和行为职责，数据职责通过其属性来体现，而行为职责通过其方法来体现。</li><li>单一职责原则是实现高内聚、低耦合的指导方针，在很多代码重构手法中都能找到它的存在，它是最简单但又最难运用的原则，需要设计人员发现类的不同职责并将其分离，而发现类的多重职责需要设计人员具有较强的分析设计能力和相关重构经验。</li></ul><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>单一职责原则提出了一个编写程序的标准，用“职责”或“变化原因”来衡量接口或类设计得是否合理，但是“职责”和“变化原因”都是没有具体标准的，一个类到底要负责那些职责? 这些职责怎么细化? 细化后是否都要有一个接口或类? 这些都需从实际的情况考虑。因项目而异，因环境而异。</p><p>例：SpringMVC 中Entity, DAO, Service, Controller, Util等的分离。</p><h3 id="O：开闭原则（Open-Closed-Principle）"><a href="#O：开闭原则（Open-Closed-Principle）" class="headerlink" title="O：开闭原则（Open - Closed Principle）"></a>O：开闭原则（Open - Closed Principle）</h3><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong>一个软件实体(如类、模块和函数)应该对扩展开放，对修改关闭</strong>。</p><h4 id="原则分析-1"><a href="#原则分析-1" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>当软件实体因需求要变化时, 尽量通过扩展已有软件实体，可以提供新的行为，以满足对软件的新的需求，而不是修改已有的代码，使变化中的软件有一定的适应性和灵活性 。已有软件模块，特别是最重要的抽象层模块不能再修改，这使变化中的软件系统有一定的稳定性和延续性。</li><li><strong>实现开闭原则的关键就是抽象化</strong>：<strong>在开闭原则中，不允许修改抽象类或者接口，允许扩展的是具体的实现类。</strong>抽象类和接口在开闭原则中扮演着极其重要的角色，既要预知可能变化的需求，又要预见所有可能已知的扩展，所以在这里”抽象化”是关键!</li><li>可变性的封闭原则：找到系统的可变因素，将它封装起来。 不要把可变因素放在多个类中，或者散落在程序的各个角落，应该将可变因素封装起来，并且切忌不要把所有的可变因素封装在一起，应该分块封装可变因素。</li></ul><h4 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h4><p>设计模式中模板方法模式和观察者模式都是开闭原则的极好体现。</p><h3 id="L：里氏替换原则（Liskov-Substitution-Principle）"><a href="#L：里氏替换原则（Liskov-Substitution-Principle）" class="headerlink" title="L：里氏替换原则（Liskov Substitution Principle）"></a>L：里氏替换原则（Liskov Substitution Principle）</h3><h4 id="定义-2"><a href="#定义-2" class="headerlink" title="定义"></a>定义</h4><p> <strong>所有引用父类的地方必须能透明地替换为其子类的对象</strong>。</p><h4 id="原则分析-2"><a href="#原则分析-2" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li><p>讲的是基类和子类的关系，只有这种关系存在时，里氏替换原则才存在。正方形是长方形是理解里氏替换原则的经典例子。</p></li><li><p>里氏替换原则可以<strong>通俗表述</strong>为： <strong>在软件中如果能够使用基类对象，那么一定能够使用其子类对象</strong>。把基类都替换成它的子类，程序将不会产生任何错误和异常，<strong>反之不成立</strong>，如果一个软件实体使用的是一个子类的话，那么它不一定能够使用基类。</p></li><li><p><strong>里氏替换原则是实现开闭原则的重要方式之一【抽象类和接口（不允许修改）看作基类，实现类（允许扩展）看作子类】，由于使用基类对象的地方都可以使用子类对象，因此<u>在程序中尽量使用基类类型来对对象进行定义，而在运行时再确定其子类类型，用子类对象来替换父类对象</u>。</strong></p></li></ul><h3 id="I：接口隔离原则（Interface-Segregation-Principle）"><a href="#I：接口隔离原则（Interface-Segregation-Principle）" class="headerlink" title="I：接口隔离原则（Interface Segregation Principle）"></a>I：接口隔离原则（Interface Segregation Principle）</h3><h4 id="定义-3"><a href="#定义-3" class="headerlink" title="定义"></a>定义</h4><p><strong>客户端不应该依赖那些它不需要的接口。</strong></p><p>另一种定义：<strong>一旦一个接口太大，则需要将它分割成一些更细小的接口</strong>，使用该接口的客户端仅需知道与之相关的方法即可。 注意，在该定义中的接口指的是方法。例如调用某个类的public方法。这个方法对外就是接口。</p><h4 id="原则分析-3"><a href="#原则分析-3" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>使用多个专门的接口，而不使用单一的总接口。</li><li><strong>使用接口隔离原则拆分接口时，首先必须满足单一职责原则</strong>，将一组相关的操作定义在一个接口中，且在满足高内聚的前提下，接口中的方法越少越好。</li></ul><h3 id="D：依赖倒置原则（Dependency-Inversion-Principle）"><a href="#D：依赖倒置原则（Dependency-Inversion-Principle）" class="headerlink" title="D：依赖倒置原则（Dependency-Inversion Principle）"></a>D：依赖倒置原则（Dependency-Inversion Principle）</h3><h4 id="定义-4"><a href="#定义-4" class="headerlink" title="定义"></a>定义</h4><p><strong>高层模块不应该依赖（使用）低层模块</strong>，<strong>它们都应该依赖抽象</strong>。抽象不应该依赖（使用）具体，具体应该依赖（使用）抽象。</p><h4 id="原则分析-4"><a href="#原则分析-4" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li><p><strong>如果说开闭原则是面向对象设计的目标，依赖倒置原则则是手段</strong>。</p></li><li><p>依赖倒置原则的中心思想是面向接口编程。</p></li><li><p>依赖倒置原则是里氏替换原则的补充。</p></li></ul><h4 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h4><p>依赖倒置原则的常用实现方式之一是在代码中使用抽象，而将具体类放在配置文件中。</p><p>例：Spring中的依赖注入。</p><h3 id="组合-聚合复用原则（Composite-Aggregate-Reuse-Principle）"><a href="#组合-聚合复用原则（Composite-Aggregate-Reuse-Principle）" class="headerlink" title="组合/聚合复用原则（Composite/Aggregate Reuse Principle）"></a>组合/聚合复用原则（Composite/Aggregate Reuse Principle）</h3><h4 id="定义-5"><a href="#定义-5" class="headerlink" title="定义"></a>定义</h4><p>尽量使用对象组合，而不是继承来达到复用的目的。</p><h4 id="原则分析-5"><a href="#原则分析-5" class="headerlink" title="原则分析"></a>原则分析</h4><ul><li>组合/聚合可以使系统更加灵活，类与类之间的耦合度降低，一个类的变化对其他类造成的影响相对较少，因此一般首选使用组合/聚合来实现复用。</li><li>其次才考虑继承，在使用继承时，需要严格遵循里氏代换原则，有效使用继承会有助于对问题的理解，降低复杂度，而滥用继承反而会增加系统构建和维护的难度以及系统的复杂度，因此需要慎重使用继承复用。</li></ul><h3 id="迪米特法则（Law-of-Demeter）"><a href="#迪米特法则（Law-of-Demeter）" class="headerlink" title="迪米特法则（Law of Demeter）"></a>迪米特法则（Law of Demeter）</h3><p>系统中的类尽量不要与其他类互相作用，以减少类之间的耦合度。又叫最少知识原则(Least Knowledge Principle)。</p><p>目标：实现高内聚、低耦合。</p><h4 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h4><p>设计模式Facade模式、Mediator模式。</p><h3 id="设计原则核心思想"><a href="#设计原则核心思想" class="headerlink" title="设计原则核心思想"></a>设计原则核心思想</h3><ol><li><p><strong>找出应用中可能需要变化之处</strong>，把它们独立出来，不要和那些不需要变化的代码混在一起。 </p></li><li><p><strong>针对接口编程</strong>，而不是针对实现编程。</p></li><li><p>为了交互对象之间的<strong>松耦合</strong>设计而努力。</p></li></ol><p>参考：<a href="https://www.pdai.tech/md/dev-spec/spec/dev-th-solid.html" target="_blank" rel="noopener">https://www.pdai.tech/md/dev-spec/spec/dev-th-solid.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;在软件开发中，前人对软件系统的设计和开发总结了一些原则和模式， 不管用什么语言做开发，都将对我们系统设计和开发提供指导意义。&lt;/p&gt;
&lt;p&gt;面向对象的基本原则(solid)是五个，但是在经常被提到的除了这五个之外还有 &lt;code&gt;迪米特法则&lt;/code&gt;和&lt;code&gt;合成复
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>软件开发过程模型</title>
    <link href="http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/"/>
    <id>http://thmasterplan.cn/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91%E8%BF%87%E7%A8%8B%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-10-13T07:23:02.000Z</published>
    <updated>2020-10-14T05:18:35.129Z</updated>
    
    <content type="html"><![CDATA[<h2 id="软件开发过程模型"><a href="#软件开发过程模型" class="headerlink" title="软件开发过程模型"></a>软件开发过程模型</h2><h3 id="瀑布模型（Waterfall-Model）"><a href="#瀑布模型（Waterfall-Model）" class="headerlink" title="瀑布模型（Waterfall Model）"></a>瀑布模型（Waterfall Model）</h3><p>瀑布模型（经典生命模型）提出了软件开发的系统化的、顺序的方法。其流程从用户需求规格说明开始，通过策划、建模、构建和部署过程，最终提供一个完整的软件并提供持续的技术支持。</p><p><img src="Waterfall.png" alt=""></p><h4 id="模型特点"><a href="#模型特点" class="headerlink" title="模型特点"></a>模型特点</h4><ul><li>必须等前一阶段的工作完成之后，才能开始后一段的工作。</li><li>每一阶段都必须完成规定的文档，没有交出合格的文档就是没有完成该阶段的任务。</li><li>前一阶段的输出文档就是后一阶段的输入文档，因此，只有前一阶段的输出文档正确，后一阶段的工作才能得到正确的结果。</li><li>每个阶段结束前都要对所完成的文档进行评审，以便及早发现问题，改正错误。事实上越是早期阶段犯下的错误，暴露出来的时间就越晚，排除故障改正错误所需付出的代价也越高。因此，及时审查，是保证软件质量，降低软件成本的重要措施。</li></ul><h4 id="模型优点"><a href="#模型优点" class="headerlink" title="模型优点"></a>模型优点</h4><ul><li>强调了开发的阶段性，各阶段具有顺序性和依赖性</li><li>强调早期调研和需求分析，推迟编码实现的观点</li><li>提供了一个模板，这个模板使得分析、设计、编码、测试和支持的方法可以在该模板下有一个共同的指导。</li></ul><h4 id="模型局限"><a href="#模型局限" class="headerlink" title="模型局限"></a>模型局限</h4><ul><li>瀑布模型是一种线性模型，要求项目严格按规程推进，必须等到所有开发工作全部完成以后才能获得可以交付的软件产品。不能对软件系统进行快速创建，对于一些急于交付的软件系统的开发很不方便。</li><li>瀑布模型适合于需求明确，且无大的需求变更的软件开发（编译系统、操作系统等）。而对于分析初期需求模糊的项目，瀑布模型也并不适合。</li></ul><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>适用于需求确定，无大的需求变更，工作能够采用线性的方式完成的软件。</p><h3 id="演化模型（Evolutionary-Model）"><a href="#演化模型（Evolutionary-Model）" class="headerlink" title="演化模型（Evolutionary Model）"></a>演化模型（Evolutionary Model）</h3><h4 id="快速原型（Rapid-Prototype）"><a href="#快速原型（Rapid-Prototype）" class="headerlink" title="快速原型（Rapid Prototype）"></a>快速原型（Rapid Prototype）</h4><p>软件开发过程中，开发初期很难得到一个完整的、准确的需求规格说明，开发者往往对要解决的应用问题模糊不清，以至于形成的需求规格说明常常是不完整的、不准确的，有时甚至是有歧义的。此外，在整个开发过程中，用户可能会产生新的要求，导致需求的变更。为了适应这种需求的不确定性和变化，于是出现了快速原型（Rapid Prototype）开发方法。</p><h5 id="模型特点-1"><a href="#模型特点-1" class="headerlink" title="模型特点"></a>模型特点</h5><ul><li><strong>快速原型是用来获取用户需求的，或是用来试探设计是否有效的。一旦需求或设计确定下来了，原型就将被抛弃。</strong>因此，快速原型要求快速构件、容易修改，以节约原型创建的成本、加快开发速度。</li><li>快速原型是暂时适用使用的，因此并不要求完整。它往往针对某个局部问题建立专门原型，如界面原型、工作流原型等。</li><li>快速原型不能贯穿软件的整个生命周期，它需要和其他的过程模型相结合才能产生作用。例如，在瀑布模型中应用快速原型，以解决瀑布模型在需求分析时期存在的不足。</li></ul><h5 id="模型优点-1"><a href="#模型优点-1" class="headerlink" title="模型优点"></a>模型优点</h5><ul><li>能渐进地启发客户提出新的要求或任务，促使开发人员和用户达成共识。</li><li>减少了开发风险，避免了因为需求不确定而在开发过程中浪费了大量的资源。</li></ul><h5 id="模型局限-1"><a href="#模型局限-1" class="headerlink" title="模型局限"></a>模型局限</h5><ul><li>没有考虑到软件的整体和长期的可维护性。</li><li>可能由于达不到质量要求而导致产品被抛弃，从而采用新的模型重新设计。</li></ul><h5 id="适用场景-1"><a href="#适用场景-1" class="headerlink" title="适用场景"></a>适用场景</h5><p>原型方法比较适用于用户需求不清、需求经常变化的情况。当系统规模不是很大也不太复杂时，采用该方法比较好。</p><h4 id="原型进化（-Prototype-Evolution）"><a href="#原型进化（-Prototype-Evolution）" class="headerlink" title="原型进化（ Prototype Evolution）"></a>原型进化（ Prototype Evolution）</h4><p>原型进化对开发过程的考虑是，针对有待开发的软件系统，先开发一个原型系统给用户使用，然后根据用户使用情况的意见反馈，对原型系统不断修改，使它逐步接近并最终到达开发目标。<strong>跟快速原型不同的是，快速原型在完成需求定义后将被抛弃，而原型进化所要创建的原型则是一个今后将要投入应用的系统</strong>，只是所创建的原型系统在功能、性能等方面还有许多不 足，还没有达到最终开发目标，需要不断改进。 原型进化的工作流程如图 2-3 所示。</p><p><img src="PrototypeEvolution.png" alt=""></p><p>从图中可以看到，它具有以下两个特点：</p><ul><li>原型进化模型将软件的需求细部定义、产品开发和有效性验证放在同一个工作进程中交替或并行运作。因此，在获得了软件需求框架以后，例如软件的基本功能被确定以后，就可以直接进入到对软件的开发中。</li><li>原型进化模型是通过不断发布新的软件版本而使软件逐步完善的，因此，这种开发模式特别<strong>适合于那些用户急需的软件产品开发</strong>。它能够快速地向用户交付可以投入实际运行的软件成果，并能够很好地适应软件用户对需求规格的变更。 原型进化模型能够适应软件需求的中途变更，但在应用的时候，以下问题需要得到足够的重视：<ol><li>原型进化模型虽说使开发进程加快了，但不能像瀑布模型那样提供明确的里程碑管理，随着开发过程中版本的快速更新，项目管理、软件配置管理会变得复杂起来，管理者难以把握开发进度。因此，<strong>对于大型软件项目，原型进化模型缺乏有效的管理规程</strong>。</li><li><strong>开发过程中软件版本的快速变更，还可能损伤软件的内部结构，使其缺乏整体性和稳定性</strong>。另外，用于反映软件版本变更的文档也有可能跟不上软件的变更速度。这些问题必将影响到今后软件的维护。</li></ol></li></ul><h3 id="增量模型（Incremental-Model）"><a href="#增量模型（Incremental-Model）" class="headerlink" title="增量模型（Incremental Model）"></a>增量模型（Incremental Model）</h3><p>增量模型融合了瀑布模型的基本成分和原型进化模型的迭代特征，它对软件过程的考虑是：在整体上按照瀑布模型的流程实施项目开发，以方便对项目的管理；但在软件的实际开发中，则<strong>将软件系统按功能分解为许多增减构件，并以构件为单位逐个地创建与交付</strong>，直到全部增量构件创建完成，并都被集成到系统之中交付用户使用。</p><p><img src="Incremental.jpg" alt=""></p><p><img src="Incremental.png" alt=""></p><h4 id="模型特点-2"><a href="#模型特点-2" class="headerlink" title="模型特点"></a>模型特点</h4><ul><li>当使用增量模型时，第一个增量往往是核心的产品。</li><li>客户对每个增量的使用和评估都作为下一个增量发布的新特性和功能。</li><li>该模型采用随着日程时间的进展而交错的线性序列，每一个线性序列产生软件的一个可发布的“增量”。</li></ul><h4 id="模型优点-2"><a href="#模型优点-2" class="headerlink" title="模型优点"></a>模型优点</h4><ul><li>第一个可交付版本所需要的成本和时间很少。</li><li>开发由增量表示的小系统所承担的风险不大。</li><li>由于很快发布了第一个版本，因此可以减少用户需求的变更。</li><li>运行增量投资，即在项目开始时，可以仅对一个或两个增量投资。</li></ul><h4 id="模型局限-2"><a href="#模型局限-2" class="headerlink" title="模型局限"></a>模型局限</h4><ul><li>管理发生的成本、进度和配置的复杂性可能会超出组织的能力。</li><li>如果没有对用户的变更要求进行规划，那么产生的出事增量可能会造成后来增量的不稳定。</li><li>如果需求不想早期思考的那样稳定和完整，那么一些增量就可能需要重新开发，重新发布。</li></ul><h4 id="适用场景-2"><a href="#适用场景-2" class="headerlink" title="适用场景"></a>适用场景</h4><p>项目在既定的商业要求期限之前不可能找到足够的开发人员的情况。</p><h3 id="螺旋模型（Spiral-Model）"><a href="#螺旋模型（Spiral-Model）" class="headerlink" title="螺旋模型（Spiral Model）"></a>螺旋模型（Spiral Model）</h3><p>对于复杂的大型软件，开发一个原型往往达不到要求。<strong>螺旋模型将瀑布模型和演化模型结合起来，加入了两种模型均忽略的风险分析</strong>，弥补了这两种模型的不足。</p><p><img src="Spiral.png" alt=""></p><p>螺旋线中的每个回路都被分成为四个步骤：</p><ol><li>制定计划：确定软件的目标，选定实施方案，明确项目开发的限制条件；</li><li>风险评估：分析所选的方案，识别风险，消除风险；</li><li>实施工程：实施软件开发，验证阶段性产品；</li><li>用户评估：评价开发工作，提出修正建议，建立下一个周期的开发计划。</li></ol><h4 id="模型特点-3"><a href="#模型特点-3" class="headerlink" title="模型特点"></a>模型特点</h4><ul><li>与瀑布模型相比，螺旋模型支持用户需求的动态变化，为用户参与软件开发的所有关键决策提供了方便。</li><li>使用螺旋模型进行软件开发，需要开发人员具有相当丰富的风险评估经验和专门知识。</li></ul><h4 id="模型优点-3"><a href="#模型优点-3" class="headerlink" title="模型优点"></a>模型优点</h4><ul><li>关注软件的重用。</li><li>关注早期错误的消除。</li><li>将质量目标放在首位。</li><li>将开发阶段与维护阶段结合在一起。</li></ul><h4 id="模型局限-3"><a href="#模型局限-3" class="headerlink" title="模型局限"></a>模型局限</h4><ul><li>开发人员需要有较强的风险评估的经验。</li><li>契约开发通常需要事先指定过程模型和发布产品。</li></ul><h4 id="适用场景-3"><a href="#适用场景-3" class="headerlink" title="适用场景"></a>适用场景</h4><p>螺旋模型强调风险分析，使得开发人员和用户对每个演化层出现的风险有所了解，从而做出应有的反应。因此，该模型适合用于庞大、复杂并且具有高风险的系统。</p><h3 id="喷泉模型（Water-Fountain-Model）"><a href="#喷泉模型（Water-Fountain-Model）" class="headerlink" title="喷泉模型（Water Fountain Model）"></a>喷泉模型（Water Fountain Model）</h3><p>喷泉模型是专门<strong>针对面向对象软件开发方法而提出</strong>的。该模型认为软件开发过程自下而上周期的各阶段是相互迭代和无间隙的特性。</p><p>无间隙指在各项活动之间无明显边界，如分析和设计活动之间没有明显的界限，由于对象概念的引入，表达分析、设计、实现等活动只用对象类和关系，从而可以较为容易地实现活动的迭代和无间隙，使其开发自然地包括复用。</p><p>在面向对象方法中，对象既是对现实问题中实体的抽象，也是构造软件系统的基本元素。 因此，建立对象模型在面向对象方法中，既可以用于分析，也可以用于设计，而且分析阶段所获得的对象框架模型可以无缝过渡到设计阶段，以作为软件实现的依据。</p><p><img src="WaterFountain.jpg" alt=""></p><p>开发步骤：</p><ol><li>第一阶段软件开发的目标可以是软件的基本功能；</li><li>第二阶段可以是在第一阶段建立的软件 的基础上，对软件进行进一步的完善，并实现软件的主要功能；</li><li>第三阶段则是在第二阶段的基 础上，对软件进行更加完整的开发，并以实现软件全部功能作为创建目标。 应该说，喷泉模型能够较有效地平衡软件系统的近期需求与远期规划，因此能够较好地满足用户在软件应用上的发展需要。</li></ol><h4 id="模型优点-4"><a href="#模型优点-4" class="headerlink" title="模型优点"></a>模型优点</h4><p>喷泉模型不像瀑布模型那样，需要分析活动结束后才开始设计活动，设计活动结束后才开始编码活动。该模型的各个阶段没有明显的界限，开发人员可以同步进行开发。其优点是可以提高软件项目开发效率，节省开发时间，适应于面向对象的软件开发过程。</p><h4 id="模型局限-4"><a href="#模型局限-4" class="headerlink" title="模型局限"></a>模型局限</h4><p>由于喷泉模型在各个开发阶段是重叠的，因此在开发过程中需要大量的开发人员，因此不利于项目的管理。此外这种模型要求严格管理文档，使得审核的难度加大，尤其是面对可能随时加入各种信息、需求与资料的情况。 </p><h3 id="基于构件的开发模型（Component-based-Development-Model）"><a href="#基于构件的开发模型（Component-based-Development-Model）" class="headerlink" title="基于构件的开发模型（Component-based Development Model）"></a>基于构件的开发模型（Component-based Development Model）</h3><p>基于构件的开发方法是指利用预先包装的构件来构造应用系统。构件可以是组织内部开发的构件，也可以是商品化成品构件。基于构件的开发模型具有许多螺旋模型的特点，它本质上是演化模型，需要以迭代方式构件软件。其不同之处在于，基于构件的开发模型<strong>采用预先打包的软件构件开发应用</strong>。</p><h2 id="具体开发流程参考"><a href="#具体开发流程参考" class="headerlink" title="具体开发流程参考"></a>具体开发流程参考</h2><p>类似于螺旋模型，结合了瀑布模型和演化模型。</p><p><img src="dev_workflow.png" alt=""></p><p>本文参考：</p><ol><li><a href="https://www.cnblogs.com/jojop/p/11801241.html" target="_blank" rel="noopener">https://www.cnblogs.com/jojop/p/11801241.html</a></li><li><a href="https://www.cnblogs.com/youcong/p/9498489.html" target="_blank" rel="noopener">https://www.cnblogs.com/youcong/p/9498489.html</a></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;软件开发过程模型&quot;&gt;&lt;a href=&quot;#软件开发过程模型&quot; class=&quot;headerlink&quot; title=&quot;软件开发过程模型&quot;&gt;&lt;/a&gt;软件开发过程模型&lt;/h2&gt;&lt;h3 id=&quot;瀑布模型（Waterfall-Model）&quot;&gt;&lt;a href=&quot;#瀑布模型（Wat
      
    
    </summary>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/categories/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
    
      <category term="软件工程" scheme="http://thmasterplan.cn/tags/%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴 Java 开发手册 v1.2.0</title>
    <link href="http://thmasterplan.cn/Others/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/"/>
    <id>http://thmasterplan.cn/Others/%E9%98%BF%E9%87%8C%E5%B7%B4%E5%B7%B4Java%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/</id>
    <published>2020-10-02T08:42:19.000Z</published>
    <updated>2020-11-08T01:34:17.248Z</updated>
    
    <content type="html"><![CDATA[<p>本文转载自：<a href="https://github.com/mysterin/alibaba-java-specification" target="_blank" rel="noopener">https://github.com/mysterin/alibaba-java-specification</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>《阿里巴巴 Java 开发手册》是阿里巴巴集团技术团队的集体经验总结，经历了多次大规模一线实战的检验及不断的完善，反馈给广大开发者。现代软件行业的高速发展对开发者的综合素质要求越来越高，因为不仅是编程知识点，其它维度的知识点也会影响到软件的最终交付质量。比如：数据库的表结构和索引设计缺陷可能带来软件上的架构缺陷或性能风险；工程结构混乱导致后续维护艰难；没有鉴权的漏洞代码易被黑客攻击等等。所以本手册以 Java 开发者为中心视角，划分为编程规约、异常日志、MySQL 数据库、工程结构、安全规约五大块，再根据内容特征，细分成若干二级子目录。根据约束力强弱及故障敏感性，规约依次分为强制、推荐、参考三大类。对于规约条目的延伸信息中，“说明”对内容做了引申和解释；“正例”提倡什么样的编码和实现方式；“反例”说明需要提防的雷区，以及真实的错误案例。  </p><p>本手册的愿景是码出高效、码出质量。代码的字里行间流淌的是软件生命中的血<br>液，质量的提升是尽可能少踩坑，杜绝踩重复的坑，切实提升质量意识。另外，现代<br>软件架构都需要协同开发完成，高效协作即降低协同成本，提升沟通效率，所谓无规<br>矩不成方圆，无规范不能协作。众所周知，制订交通法规表面上是要限制行车权，实<br>际上是保障公众的人身安全。试想如果没有限速，没有红绿灯，谁还敢上路行驶。对<br>软件来说，适当的规范和标准绝不是消灭代码内容的创造性、优雅性，而是限制过度<br>个性化，以一种普遍认可的统一方式一起做事，提升协作效率。  </p><p>《阿里巴巴 Java 开发手册》，开放包容地认真听取社区、博客、论坛的反馈，及时修正，保持与时俱进。请关注手册末页的“阿里技术”和“云栖社区”公众号获取最新版本。  </p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><!-- MarkdownTOC --><ul><li><a href="#%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83">编程规范</a><ul><li><a href="#%E5%91%BD%E5%90%8D%E9%A3%8E%E6%A0%BC">命名风格</a></li><li><a href="#%E5%B8%B8%E9%87%8F%E5%AE%9A%E4%B9%89">常量定义</a></li><li><a href="#%E4%BB%A3%E7%A0%81%E6%A0%BC%E5%BC%8F">代码格式</a></li><li><a href="#oop-%E8%A7%84%E7%BA%A6">OOP 规约</a></li><li><a href="#%E9%9B%86%E5%90%88%E5%A4%84%E7%90%86">集合处理</a></li><li><a href="#%E5%B9%B6%E5%8F%91%E5%A4%84%E7%90%86">并发处理</a></li><li><a href="#%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5">控制语句</a></li><li><a href="#%E6%B3%A8%E9%87%8A%E8%A7%84%E7%BA%A6">注释规约</a></li><li><a href="#%E5%85%B6%E4%BB%96">其他</a></li></ul></li><li><a href="#%E5%BC%82%E5%B8%B8%E6%97%A5%E5%BF%97">异常日志</a><ul><li><a href="#%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">异常处理</a></li><li><a href="#%E6%97%A5%E5%BF%97%E8%A7%84%E7%BA%A6">日志规约</a></li></ul></li><li><a href="#mysql-%E6%95%B0%E6%8D%AE%E5%BA%93">MYSQL 数据库</a><ul><li><a href="#%E5%BB%BA%E8%A1%A8%E8%A7%84%E7%BA%A6">建表规约</a></li><li><a href="#%E7%B4%A2%E5%BC%95%E8%A7%84%E7%BA%A6">索引规约</a></li><li><a href="#sql-%E8%AF%AD%E5%8F%A5">SQL 语句</a></li><li><a href="#orm-%E6%98%A0%E5%B0%84">ORM 映射</a></li></ul></li><li><a href="#%E5%B7%A5%E7%A8%8B%E7%BB%93%E6%9E%84">工程结构</a><ul><li><a href="#%E5%BA%94%E7%94%A8%E5%88%86%E5%B1%82">应用分层</a></li><li><a href="#%E4%BA%8C%E6%96%B9%E5%BA%93%E4%BE%9D%E8%B5%96">二方库依赖</a></li><li><a href="#%E6%9C%8D%E5%8A%A1%E5%99%A8">服务器</a></li></ul></li><li><a href="#%E5%AE%89%E5%85%A8%E8%A7%84%E7%BA%A6">安全规约</a></li><li><a href="#%E9%99%84-1%EF%BC%9A%E7%89%88%E6%9C%AC%E5%8E%86%E5%8F%B2">附 1：版本历史</a></li><li><a href="#%E9%99%84-2%EF%BC%9A%E6%9C%AC%E6%89%8B%E5%86%8C%E4%B8%93%E6%9C%89%E5%90%8D%E8%AF%8D">附 2：本手册专有名词</a></li></ul><!-- /MarkdownTOC --><h2 id="编程规范"><a href="#编程规范" class="headerlink" title="编程规范"></a>编程规范</h2><h4 id="命名风格"><a href="#命名风格" class="headerlink" title="命名风格"></a>命名风格</h4><ol><li><p>【强制】代码中的命名均不能以下划线或美元符号开始，也不能以下划线或美元符号结束。<br><strong>反例：</strong> <code>_name / __name / $Object / name_ / name$ / Object$</code></p></li><li><p>【强制】代码中的命名严禁使用拼音与英文混合的方式，更不允许直接使用中文的方式。说明：正确的英文拼写和语法可以让阅读者易于理解，避免歧义。注意，即使纯拼音命名方式也要避免采用。<br><strong>正例：</strong> <code>alibaba / taobao / youku / hangzhou</code> 等国际通用的名称，可视同英文。<br><strong>反例：</strong> <code>DaZhePromotion [打折] / getPingfenByName() [评分] / int 某变量 = 3</code></p></li><li><p>【强制】类名使用 <code>UpperCamelCase</code> 风格，必须遵从驼峰形式，但以下情形例外：<code>DO / BO / DTO / VO / AO</code><br><strong>正例：</strong> <code>MarcoPolo / UserDO / XmlService / TcpUdpDeal / TaPromotion</code><br><strong>反例：</strong> <code>macroPolo / UserDo / XMLService / TCPUDPDeal / TAPromotion</code></p></li><li><p>【强制】方法名、参数名、成员变量、局部变量都统一使用 <code>lowerCamelCase</code> 风格，必须遵从驼峰形式。<br><strong>正例：</strong> <code>localValue / getHttpMessage() / inputUserId</code></p></li><li><p>【强制】常量命名全部大写，单词间用下划线隔开，力求语义表达完整清楚，不要嫌名字长。<br><strong>正例：</strong> <code>MAX_STOCK_COUNT</code><br><strong>反例：</strong> <code>MAX_COUNT</code></p></li><li><p>【强制】抽象类命名使用 <code>Abstract</code> 或 <code>Base</code> 开头；异常类命名使用 <code>Exception</code> 结尾；测试类命名以它要测试的类的名称开始，以 <code>Test</code> 结尾。</p></li><li><p>【强制】中括号是数组类型的一部分，数组定义如下：<code>String[] args</code>。<br><strong>反例：</strong> 使用 <code>String args[]</code> 的方式来定义。</p></li><li><p>【强制】POJO 类中布尔类型的变量，都不要加 is，否则部分框架解析会引起序列化错误。<br><strong>反例：</strong> 定义为基本数据类型 <code>Boolean isDeleted</code>；的属性，它的方法也是 <code>isDeleted()</code>，RPC 框架在反向解析的时候，“以为”对应的属性名称是 <code>deleted</code>，导致属性获取不到，进而抛出异常。</p></li><li><p>【强制】包名统一使用小写，点分隔符之间有且仅有一个自然语义的英语单词。包名统一使用单数形式，但是类名如果有复数含义，类名可以使用复数形式。<br><strong>正例：</strong> 应用工具类包名为 <code>com.alibaba.open.util</code>、类名为 <code>MessageUtils</code>（此规则参考 spring 的框架结构）</p></li><li><p>【强制】杜绝完全不规范的缩写，避免望文不知义。<br><strong>反例：</strong> <code>AbstractClass</code> “缩写”命名成 <code>AbsClass</code>；<code>condition</code> “缩写”命名成 <code>condi</code>，此类随意缩写严重降低了代码的可阅读性。</p></li><li><p>【推荐】如果使用到了设计模式，建议在类名中体现出具体模式。<br><strong>说明：</strong> 将设计模式体现在名字中，有利于阅读者快速理解架构设计思想。<br><strong>正例：</strong>  </p><pre><code>public class OrderFactory;public class LoginProxy;public class ResourceObserver;</code></pre></li><li><p>【推荐】接口类中的方法和属性不要加任何修饰符号（<code>public</code> 也不要加），保持代码的简洁性，并加上有效的 Javadoc 注释。尽量不要在接口里定义变量，如果一定要定义变量，肯定是与接口方法相关，并且是整个应用的基础常量。<br><strong>正例：</strong> 接口方法签名：<code>void f();</code>  </p><pre><code>    接口基础常量表示：`String COMPANY = &quot;alibaba&quot;;`  </code></pre><p><strong>反例：</strong> 接口方法定义：<code>public abstract void f();</code><br><strong>说明：</strong> JDK8 中接口允许有默认实现，那么这个 <code>default</code> 方法，是对所有实现类都有价值的默认实现。</p></li><li><p>接口和实现类的命名有两套规则：<br>1） 【强制】对于 Service 和 DAO 类，基于 SOA 的理念，暴露出来的服务一定是接口，内部的实现类用 Impl 的后缀与接口区别。  </p><pre><code>**正例：** `CacheServiceImpl` 实现 `CacheService` 接口。  </code></pre><p>2） 【推荐】如果是形容能力的接口名称，取对应的形容词做接口名（通常是–able 的形式）。  </p><pre><code>**正例：** `AbstractTranslator` 实现 `Translatable`。</code></pre></li><li><p>【参考】枚举类名建议带上 Enum 后缀，枚举成员名称需要全大写，单词间用下划线隔开。<br><strong>说明：</strong> 枚举其实就是特殊的常量类，且构造方法被默认强制是私有。<br><strong>正例：</strong> 枚举名字：<code>DealStatusEnum</code>，成员名称：<code>SUCCESS / UNKOWN_REASON</code>。</p></li><li><p>【参考】各层命名规约：  </p><ol><li><code>Service/DAO</code> 层方法命名规约<br>1） 获取单个对象的方法用 <code>get</code> 做前缀。<br>2） 获取多个对象的方法用 <code>list</code> 做前缀。<br>3） 获取统计值的方法用 <code>count</code> 做前缀。<br>4） 插入的方法用 <code>save</code>（推荐）或 <code>insert</code> 做前缀。<br>5） 删除的方法用 <code>remove</code>（推荐）或 <code>delete</code> 做前缀。<br>6） 修改的方法用 <code>update</code> 做前缀。  </li><li>领域模型命名规约<br>1） 数据对象：<code>xxxDO</code>，<code>xxx</code> 即为数据表名。<br>2） 数据传输对象：<code>xxxDTO</code>，<code>xxx</code> 为业务领域相关的名称。<br>3） 展示对象：<code>xxxVO</code>，<code>xxx</code> 一般为网页名称。<br>4） <code>POJO</code> 是 <code>DO/DTO/BO/VO</code> 的统称，禁止命名成 <code>xxxPOJO</code>。</li></ol></li></ol><h4 id="常量定义"><a href="#常量定义" class="headerlink" title="常量定义"></a>常量定义</h4><ol><li><p>【强制】不允许任何魔法值（即未经定义的常量）直接出现在代码中。<br><strong>反例：</strong> </p><pre><code>String key = &quot;Id#taobao_&quot; + tradeId;  cache.put(key, value);</code></pre></li><li><p>【强制】long 或者 Long 初始赋值时，必须使用大写的 L，不能是小写的 l，小写容易跟数字 1 混淆，造成误解。<br>说明：<code>Long a = 2l;</code> 写的是数字的 21，还是 Long 型的 2?</p></li><li><p>【推荐】不要使用一个常量类维护所有常量，应该按常量功能进行归类，分开维护。如：缓存相关的常量放在类：CacheConsts 下；系统配置相关的常量放在类：ConfigConsts 下。<br><strong>说明：</strong> 大而全的常量类，非得使用查找功能才能定位到修改的常量，不利于理解和维护。</p></li><li><p>【推荐】常量的复用层次有五层：跨应用共享常量、应用内共享常量、子工程内共享常量、包内共享常量、类内共享常量。<br>1） 跨应用共享常量：放置在二方库中，通常是 <code>client.jar</code> 中的 <code>constant</code> 目录下。<br>2） 应用内共享常量：放置在一方库的 <code>modules</code> 中的 <code>constant</code> 目录下。  </p><pre><code>**反例：** 易懂变量也要统一定义成应用内共享常量，两位攻城师在两个类中分别定义了表示“是”的变量：      类 A 中：public static final String YES = &quot;yes&quot;;      类 B 中：public static final String YES = &quot;y&quot;;      A.YES.equals(B.YES)，预期是 true，但实际返回为 false，导致线上问题。  </code></pre><p>3） 子工程内部共享常量：即在当前子工程的 <code>constant</code> 目录下。<br>4） 包内共享常量：即在当前包下单独的 <code>constant</code> 目录下。<br>5） 类内共享常量：直接在类内部 <code>private static final</code> 定义。  </p></li><li><p>【推荐】如果变量值仅在一个范围内变化，且带有名称之外的延伸属性，定义为枚举类。下面正例中的数字就是延伸信息，表示星期几。<br><strong>正例：</strong> <code>public Enum { MONDAY(1), TUESDAY(2), WEDNESDAY(3), THURSDAY(4), FRIDAY(5), SATURDAY(6),SUNDAY(7);}</code></p></li></ol><h4 id="代码格式"><a href="#代码格式" class="headerlink" title="代码格式"></a>代码格式</h4><ol><li><p>【强制】大括号的使用约定。如果是大括号内为空，则简洁地写成{}即可，不需要换行；如果是非空代码块则：<br>1） 左大括号前不换行。<br>2） 左大括号后换行。<br>3） 右大括号前换行。<br>4） 右大括号后还有 else 等代码则不换行；表示终止的右大括号后必须换行。  </p></li><li><p>【强制】 左小括号和字符之间不出现空格；同样，右小括号和字符之间也不出现空格。详见<br>第 5 条下方正例提示。<br> <strong>反例：</strong> <code>if (空格 a == b 空格)</code></p></li><li><p>【强制】<code>if/for/while/switch/do</code> 等保留字与括号之间都必须加空格。</p></li><li><p>【强制】任何二目、三目运算符的左右两边都需要加一个空格。<br><strong>说明：</strong> 运算符包括赋值运算符=、逻辑运算符&amp;&amp;、加减乘除符号等。</p></li><li><p>【强制】缩进采用 4 个空格，禁止使用 tab 字符。<br><strong>说明：</strong> 如果使用 tab 缩进，必须设置 1 个 tab 为 4 个空格。IDEA 设置 tab 为 4 个空格时，请勿勾选 <code>Use tab character</code>；而在 eclipse 中，必须勾选 <code>insert spaces for tabs</code>。<br><strong>正例：</strong> （涉及 1-5 点）  </p><pre><code> public static void main(String[] args) {     // 缩进 4 个空格     String say = &quot;hello&quot;;     // 运算符的左右必须有一个空格     int flag = 0;     // 关键词 if 与括号之间必须有一个空格，括号内的 f 与左括号，0 与右括号不需要空格     if (flag == 0) {         System.out.println(say);     }     // 左大括号前加空格且不换行；左大括号后换行     if (flag == 1) {         System.out.println(&quot;world&quot;);     // 右大括号前换行，右大括号后有 else，不用换行     } else {         System.out.println(&quot;ok&quot;);     // 在右大括号后直接结束，则必须换行     } } </code></pre></li><li><p>【强制】单行字符数限制不超过 120 个，超出需要换行，换行时遵循如下原则：<br>1） 第二行相对第一行缩进 4 个空格，从第三行开始，不再继续缩进，参考示例。<br>2） 运算符与下文一起换行。<br>3） 方法调用的点符号与下文一起换行。<br>4） 在多个参数超长，在逗号后换行。<br>5） 在括号前不要换行，见反例。<br> <strong>正例：</strong> </p><pre><code> StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，换行缩进 4 个空格，并且方法前的点符号一起换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;)... .append(&quot;huang&quot;);</code></pre><p> <strong>反例：</strong> </p><pre><code> StringBuffer sb = new StringBuffer(); //超过 120 个字符的情况下，不要在括号前换行 sb.append(&quot;zi&quot;).append(&quot;xin&quot;)...append (&quot;huang&quot;); //参数很多的方法调用可能超过 120 个字符，不要在逗号前换行 method(args1, args2, args3, ... , argsX); </code></pre></li><li><p>【强制】方法参数在定义和传入时，多个参数逗号后边必须加空格。<br><strong>正例：</strong> 下例中实参的”a”,后边必须要有一个空格。<code>method(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;);</code></p></li><li><p>【强制】IDE 的 text file encoding 设置为 UTF-8; IDE 中文件的换行符使用 Unix 格式，不要使用 windows 格式。</p></li><li><p>【推荐】没有必要增加若干空格来使某一行的字符与上一行对应位置的字符对齐。<br><strong>正例：</strong> </p><pre><code>int a = 3;long b = 4L;float c = 5F;StringBuffer sb = new StringBuffer();</code></pre><p><strong>说明：</strong> 增加 sb 这个变量，如果需要对齐，则给 a、b、c 都要增加几个空格，在变量比较多的情况下，是一种累赘的事情。</p></li><li><p>【推荐】方法体内的执行语句组、变量的定义语句组、不同的业务逻辑之间或者不同的语义之间插入一个空行。相同业务逻辑和语义之间不需要插入空行。<br><strong>说明：</strong> 没有必要插入多个空行进行隔开。</p></li></ol><h4 id="OOP-规约"><a href="#OOP-规约" class="headerlink" title="OOP 规约"></a>OOP 规约</h4><ol><li><p>【强制】避免通过一个类的对象引用访问此类的静态变量或静态方法，无谓增加编译器解析成本，直接用类名来访问即可。</p></li><li><p>【强制】所有的覆写方法，必须加@Override 注解。<br><strong>说明：</strong> <code>getObject()</code> 与 <code>get0bject()</code> 的问题。一个是字母的 O，一个是数字的 0，加 <code>@Override</code>可以准确判断是否覆盖成功。另外，如果在抽象类中对方法签名进行修改，其实现类会马上编译报错。</p></li><li><p>【强制】相同参数类型，相同业务含义，才可以使用 Java 的可变参数，避免使用 <code>Object</code>。<br><strong>说明：</strong> 可变参数必须放置在参数列表的最后。（提倡同学们尽量不用可变参数编程）<br><strong>正例：</strong> <code>public User getUsers(String type, Integer... ids) {...}</code></p></li><li><p>【强制】外部正在调用或者二方库依赖的接口，不允许修改方法签名，避免对接口调用方产生影响。接口过时必须加 <code>@Deprecated</code> 注解，并清晰地说明采用的新接口或者新服务是什么。</p></li><li><p>【强制】不能使用过时的类或方法。<br><strong>说明：</strong> <code>java.net.URLDecoder</code> 中的方法 <code>decode(String encodeStr)</code> 这个方法已经过时，应该使用双参数 <code>decode(String source, String encode)</code>。接口提供方既然明确是过时接口，那么有义务同时提供新的接口；作为调用方来说，有义务去考证过时方法的新实现是什么。</p></li></ol><ol><li>【强制】<code>Object</code> 的 <code>equals</code> 方法容易抛空指针异常，应使用常量或确定有值的对象来调用<br><code>equals</code>。<br><strong>正例：</strong> <code>&quot;test&quot;.equals(object);</code><br><strong>反例：</strong> <code>object.equals(&quot;test&quot;);</code><br><strong>说明：</strong> 推荐使用 <code>java.util.Objects#equals</code> （JDK7 引入的工具类）</li></ol><ol><li><p>【强制】所有的相同类型的包装类对象之间值的比较，全部使用 <code>equals</code> 方法比较。<br>说明：对于 <code>Integer var = ?</code> 在-128 至 127 范围内的赋值，<code>Integer</code> 对象是在<br><code>IntegerCache.cache</code> 产生，会复用已有对象，这个区间内的 <code>Integer</code> 值可以直接使用 == 进行判断，但是这个区间之外的所有数据，都会在堆上产生，并不会复用已有对象，这是一个大坑，推荐使用 <code>equals</code> 方法进行判断。</p></li><li><p>关于基本数据类型与包装数据类型的使用标准如下：<br>1） 【强制】所有的 <code>POJO</code> 类属性必须使用包装数据类型。<br>2） 【强制】RPC 方法的返回值和参数必须使用包装数据类型。<br>3） 【推荐】所有的局部变量使用基本数据类型。<br><strong>说明：</strong> <code>POJO</code> 类属性没有初值是提醒使用者在需要使用时，必须自己显式地进行赋值，任何<br>NPE 问题，或者入库检查，都由使用者来保证。<br><strong>正例：</strong> 数据库的查询结果可能是 <code>null</code>，因为自动拆箱，用基本数据类型接收有 NPE 风险。<br><strong>反例：</strong> 比如显示成交总额涨跌情况，即正负 x%，x 为基本数据类型，调用的 RPC 服务，调用不成功时，返回的是默认值，页面显示：0%，这是不合理的，应该显示成中划线-。所以包装数据类型的 <code>null</code> 值，能够表示额外的信息，如：远程调用失败，异常退出。</p></li><li><p>【强制】定义 <code>DO/DTO/VO</code> 等 <code>POJO</code> 类时，不要设定任何属性默认值。<br><strong>反例：</strong> <code>POJO</code> 类的 <code>gmtCreate</code> 默认值为 <code>new Date()</code>;但是这个属性在数据提取时并没有置入具<br>体值，在更新其它字段时又附带更新了此字段，导致创建时间被修改成当前时间。</p></li><li><p>【强制】序列化类新增属性时，请不要修改 <code>serialVersionUID</code> 字段，避免反序列失败；如<br>果完全不兼容升级，避免反序列化混乱，那么请修改 <code>serialVersionUID</code> 值。<br><strong>说明：</strong> 注意 <code>serialVersionUID</code> 不一致会抛出序列化运行时异常。</p></li><li><p>【强制】构造方法里面禁止加入任何业务逻辑，如果有初始化逻辑，请放在 <code>init</code> 方法中。</p></li><li><p>【强制】<code>POJO</code> 类必须写 <code>toString</code> 方法。使用 IDE 的中工具：<code>source&gt; generate toString</code><br>时，如果继承了另一个 <code>POJO</code> 类，注意在前面加一下 <code>super.toString</code>。<br><strong>说明：</strong> 在方法执行抛出异常时，可以直接调用 <code>POJO</code> 的 <code>toString()</code>方法打印其属性值，便于排查问题。</p></li><li><p>【推荐】使用索引访问用 <code>String</code> 的 <code>split</code> 方法得到的数组时，需做最后一个分隔符后有无内容的检查，否则会有抛 <code>IndexOutOfBoundsException</code> 的风险。<br><strong>说明：</strong> </p><pre><code>String str = &quot;a,b,c,,&quot;;String[] ary = str.split(&quot;,&quot;);//预期大于 3，结果是 3System.out.println(ary.length);</code></pre></li><li><p>【推荐】当一个类有多个构造方法，或者多个同名方法，这些方法应该按顺序放置在一起，便于阅读。</p></li><li><p>【推荐】 类内方法定义顺序依次是：公有方法或保护方法 &gt; 私有方法 &gt; <code>getter/setter</code> 方法。<br><strong>说明：</strong> 公有方法是类的调用者和维护者最关心的方法，首屏展示最好；保护方法虽然只是子类关心，也可能是“模板设计模式”下的核心方法；而私有方法外部一般不需要特别关心，是一个黑盒实现；因为方法信息价值较低，所有 <code>Service</code> 和 <code>DAO</code> 的 <code>getter/setter</code> 方法放在类体最后。</p></li></ol><ol><li><p>【推荐】<code>setter</code> 方法中，参数名称与类成员变量名称一致，<code>this.成员名 = 参数名</code>。在 <code>getter/setter</code> 方法中，不要增加业务逻辑，增加排查问题的难度。<br><strong>反例：</strong> </p><pre><code>public Integer getData() {    if (true) {        return this.data + 100;    } else {        return this.data - 100;    }}</code></pre></li><li><p>【推荐】循环体内，字符串的连接方式，使用 <code>StringBuilder</code> 的 <code>append</code> 方法进行扩展。<br><strong>说明：</strong> 反编译出的字节码文件显示每次循环都会 <code>new</code> 出一个 <code>StringBuilder</code> 对象，然后进行 <code>append</code> 操作，最后通过 <code>toString</code> 方法返回 <code>String</code> 对象，造成内存资源浪费。<br><strong>反例：</strong> </p><pre><code>    String str = &quot;start&quot;;    for (int i = 0; i &lt; 100; i++) {        str = str + &quot;hello&quot;;    }</code></pre></li><li><p>【推荐】<code>final</code> 可以声明类、成员变量、方法、以及本地变量，下列情况使用 <code>final</code> 关键字：<br>1） 不允许被继承的类，如：<code>String</code> 类。<br>2） 不允许修改引用的域对象，如：<code>POJO</code> 类的域变量。<br>3） 不允许被重写的方法，如：<code>POJO</code> 类的 <code>setter</code> 方法。<br>4） 不允许运行过程中重新赋值的局部变量。<br>5） 避免上下文重复使用一个变量，使用 <code>final</code> 描述可以强制重新定义一个变量，方便更好地进行重构。  </p></li><li><p>【推荐】慎用 <code>Object</code> 的 <code>clone</code> 方法来拷贝对象。<br><strong>说明：</strong> 对象的 <code>clone</code> 方法默认是浅拷贝，若想实现深拷贝需要重写 <code>clone</code> 方法实现属性对象的拷贝。</p></li><li><p>【推荐】类成员与方法访问控制从严：<br>1） 如果不允许外部直接通过 <code>new</code> 来创建对象，那么构造方法必须是 <code>private。</code><br>2） 工具类不允许有 <code>public</code> 或 <code>default</code> 构造方法。<br>3） 类非 <code>static</code> 成员变量并且与子类共享，必须是 <code>protected</code>。<br>4） 类非 <code>static</code> 成员变量并且仅在本类使用，必须是 <code>private</code>。<br>5） 类 <code>static</code> 成员变量如果仅在本类使用，必须是 <code>private</code>。<br>6） 若是 <code>static</code> 成员变量，必须考虑是否为 <code>final</code>。<br>7） 类成员方法只供类内部调用，必须是 <code>private</code>。<br>8） 类成员方法只对继承类公开，那么限制为 <code>protected</code>。<br><strong>说明：</strong> 任何类、方法、参数、变量，严控访问范围。过于宽泛的访问范围，不利于模块解耦。<br>思考：如果是一个 <code>private</code> 的方法，想删除就删除，可是一个 <code>public</code> 的 <code>service</code> 方法，或者一个 <code>public</code> 的成员变量，删除一下，不得手心冒点汗吗？变量像自己的小孩，尽量在自己的视线内，变量作用域太大，如果无限制的到处跑，那么你会担心的。</p></li></ol><h4 id="集合处理"><a href="#集合处理" class="headerlink" title="集合处理"></a>集合处理</h4><ol><li><p>【强制】关于 <code>hashCode</code> 和 <code>equals</code> 的处理，遵循如下规则：<br>1） 只要重写 <code>equals</code>，就必须重写 <code>hashCode。</code><br>2） 因为 <code>Set</code> 存储的是不重复的对象，依据 <code>hashCode</code> 和 <code>equals</code> 进行判断，所以 <code>Set</code> 存储的对象必须重写这两个方法。<br>3） 如果自定义对象做为 <code>Map</code> 的键，那么必须重写 <code>hashCode</code> 和 <code>equals</code>。<br><strong>说明：</strong> <code>String</code> 重写了 <code>hashCode</code> 和 <code>equals</code> 方法，所以我们可以非常愉快地使用 <code>String</code> 对象作为 <code>key</code> 来使用。</p></li><li><p>【强制】<code>ArrayList</code> 的 <code>subList</code> 结果不可强转成 <code>ArrayList</code>，否则会抛出 <code>ClassCastException</code> 异常：<code>java.util.RandomAccessSubList cannot be cast to java.util.ArrayList</code> ;<br><strong>说明：</strong> <code>subList</code> 返回的是 <code>ArrayList</code> 的内部类 <code>SubList</code>，并不是 <code>ArrayList</code> ，而是<br><code>ArrayList</code> 的一个视图，对于 <code>SubList</code> 子列表的所有操作最终会反映到原列表上。</p></li><li><p>【强制】 在 <code>subList</code> 场景中，高度注意对原集合元素个数的修改，会导致子列表的遍历、增<br>加、删除均产生 <code>ConcurrentModificationException</code> 异常。</p></li><li><p>【强制】使用集合转数组的方法，必须使用集合的 <code>toArray(T[] array)</code>，传入的是类型完全一样的数组，大小就是 <code>list.size()</code>。<br><strong>说明：</strong> 使用 <code>toArray</code> 带参方法，入参分配的数组空间不够大时，<code>toArray</code> 方法内部将重新分配内存空间，并返回新数组地址；如果数组元素大于实际所需，下标为<code>[ list.size() ]</code>的数组元素将被置为 <code>null</code>，其它数组元素保持原值，因此最好将方法入参数组大小定义与集合元素个数一致。<br> <strong>正例：</strong> </p><pre><code> List&lt;String&gt; list = new ArrayList&lt;String&gt;(2); list.add(&quot;guan&quot;); list.add(&quot;bao&quot;); String[] array = new String[list.size()]; array = list.toArray(array);</code></pre><p> <strong>反例：</strong> 直接使用 <code>toArray</code> 无参方法存在问题，此方法返回值只能是 <code>Object[]</code>类，若强转其它类型数组将出现 <code>ClassCastException</code> 错误。</p></li><li><p>【强制】使用工具类 <code>Arrays.asList()</code>把数组转换成集合时，不能使用其修改集合相关的方<br>法，它的 <code>add/remove/clear</code> 方法会抛出 <code>UnsupportedOperationException</code> 异常。<br><strong>说明：</strong> <code>asList</code> 的返回对象是一个 <code>Arrays</code> 内部类，并没有实现集合的修改方法。<code>Arrays.asList</code> 体现的是适配器模式，只是转换接口，后台的数据仍是数组。</p><pre><code>  String[] str = new String[] { &quot;a&quot;, &quot;b&quot; };  List list = Arrays.asList(str);</code></pre><p> 第一种情况：<code>list.add(&quot;c&quot;);</code> 运行时异常。<br> 第二种情况：<code>str[0] = &quot;gujin&quot;;</code> 那么 list.get(0)也会随之修改。</p></li><li><p>【强制】泛型通配符 <code>&lt;? extends T&gt;</code> 来接收返回的数据，此写法的泛型集合不能使用 <code>add</code> 方法，而 <code>&lt;? super T&gt;</code> 不能使用 <code>get</code> 方法，做为接口调用赋值时易出错。<br><strong>说明：</strong> 扩展说一下 <code>PECS(Producer Extends Consumer Super)</code> 原则：1）频繁往外读取内容<br>的，适合用上界 <code>Extends</code>。2）经常往里插入的，适合用下界 <code>Super</code>。</p></li><li><p>【强制】不要在 <code>foreach</code> 循环里进行元素的 <code>remove/add</code> <code>操作。remove</code> 元素请使用 <code>Iterator</code> 方式，如果并发操作，需要对 <code>Iterator</code> 对象加锁。<br><strong>正例：</strong> </p><pre><code>Iterator&lt;String&gt; it = a.iterator();while (it.hasNext()) {    String temp = it.next();    if (删除元素的条件) {        it.remove();    }}</code></pre><p><strong>反例：</strong> </p><pre><code>List&lt;String&gt; a = new ArrayList&lt;String&gt;();a.add(&quot;1&quot;);a.add(&quot;2&quot;);for (String temp : a) {    if (&quot;1&quot;.equals(temp)) {        a.remove(temp);    }}</code></pre><p><strong>说明：</strong> 以上代码的执行结果肯定会出乎大家的意料，那么试一下把“1”换成“2”，会是同样的结果吗？</p></li><li><p>【强制】 在 JDK7 版本及以上，<code>Comparator</code> 要满足如下三个条件，不然 <code>Arrays.sort</code>，<code>Collections.sort</code> 会报 <code>IllegalArgumentException</code> 异常。<br><strong>说明：</strong><br>1） x，y 的比较结果和 y，x 的比较结果相反。<br>2） x&gt;y，y&gt;z，则 x&gt;z。<br>3） x=y，则 x，z 比较结果和 y，z 比较结果相同。<br><strong>反例：</strong> 下例中没有处理相等的情况，实际使用中可能会出现异常：</p><pre><code> new Comparator&lt;Student&gt;() {     @Override     public int compare(Student o1, Student o2) {         return o1.getId() &gt; o2.getId() ? 1 : -1;     } };</code></pre></li><li><p>【推荐】集合初始化时，指定集合初始值大小。<br><strong>说明：</strong> <code>HashMap</code> 使用 <code>HashMap(int initialCapacity)</code> 初始化，<br><strong>正例：</strong> <code>initialCapacity = (需要存储的元素个数 / 负载因子) + 1</code>。注意负载因子（即 loaderfactor）默认为 0.75，如果暂时无法确定初始值大小，请设置为 16。<br><strong>反例：</strong> <code>HashMap</code> 需要放置 1024 个元素，由于没有设置容量初始大小，随着元素不断增加，容量 7 次被迫扩大，resize 需要重建 hash 表，严重影响性能。</p></li><li><p>【推荐】使用 <code>entrySet</code> 遍历 <code>Map</code> 类集合 KV，而不是 <code>keySet</code> 方式进行遍历。<br><strong>说明：</strong> <code>keySet</code> 其实是遍历了 2 次，一次是转为 <code>Iterator</code> 对象，另一次是从 <code>hashMap</code> 中取出 <code>key</code> 所对应的 <code>value</code>。而 <code>entrySet</code> 只是遍历了一次就把 <code>key</code> 和 <code>value</code> 都放到了 <code>entry</code> 中，效率更高。如果是 JDK8，使用 <code>Map.foreach</code> 方法。<br><strong>正例：</strong> <code>values()</code> 返回的是 V 值集合，是一个 <code>list</code> 集合对象；<code>keySet()</code> 返回的是 K 值集合，是一个 <code>Set</code> 集合对象；<code>entrySet()</code> 返回的是 K-V 值组合集合。</p></li><li><p>【推荐】高度注意 Map 类集合 K/V 能不能存储 null 值的情况，如下表格：</p><p>| 集合类            | Key           | Value         | Super       | 说明       |<br>| :———————— | :—————— | :—————— | :————— | :————- |<br>| HashTable         | 不允许为 null | 不允许为 null | Dictionary  | 线程安全   |<br>| ConcurrentHashMap | 不允许为 null | 不允许为 null | AbstractMap | 分段锁技术 |<br>| TreeMap           | 不允许为 null | 允许为 null   | AbstractMap | 线程不安全 |<br>| HashMap           | 允许为 null   | 允许为 null   | AbstractMap | 线程不安全 |</p><p><strong>反例：</strong> 由于 <code>HashMap</code> 的干扰，很多人认为 <code>ConcurrentHashMap</code> 是可以置入 <code>null</code> 值，而事实上，存储 <code>null</code> 值时会抛出 NPE 异常。</p></li><li><p>【参考】合理利用好集合的有序性(sort)和稳定性(order)，避免集合的无序性(unsort)和不稳定性(unorder)带来的负面影响。<br><strong>说明：</strong> 有序性是指遍历的结果是按某种比较规则依次排列的。稳定性指集合每次遍历的元素次<br>序是一定的。如： <code>ArrayList</code> 是 order/unsort；<code>HashMap</code> 是 unorder/unsort；<code>TreeSet</code> 是 order/sort。</p></li><li><p>【参考】利用 <code>Set</code> 元素唯一的特性，可以快速对一个集合进行去重操作，避免使用 <code>List</code> 的 <code>contains</code> 方法进行遍历、对比、去重操作。</p></li></ol><h4 id="并发处理"><a href="#并发处理" class="headerlink" title="并发处理"></a>并发处理</h4><ol><li><p>【强制】获取单例对象需要保证线程安全，其中的方法也要保证线程安全。<br><strong>说明：</strong> 资源驱动类、工具类、单例工厂类都需要注意。</p></li><li><p>【强制】创建线程或线程池时请指定有意义的线程名称，方便出错时回溯。<br><strong>正例：</strong> </p><pre><code> public class TimerTaskThread extends Thread {     public TimerTaskThread() {         super.setName(&quot;TimerTaskThread&quot;); ...     } }</code></pre></li><li><p>【强制】线程资源必须通过线程池提供，不允许在应用中自行显式创建线程。<br><strong>说明：</strong> 使用线程池的好处是减少在创建和销毁线程上所花的时间以及系统资源的开销，解决资<br>源不足的问题。如果不使用线程池，有可能造成系统创建大量同类线程而导致消耗完内存或者“过度切换”的问题。</p></li><li><p>【强制】线程池不允许使用 Executors 去创建，而是通过 ThreadPoolExecutor 的方式，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。<br><strong>说明：</strong> <code>Executors</code> 返回的线程池对象的弊端如下：  </p><ol><li><code>FixedThreadPool</code> 和 <code>SingleThreadPool</code>:<br>允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。  </li><li><code>CachedThreadPool</code> 和 <code>ScheduledThreadPool</code>:<br>允许的创建线程数量为 <code>Integer.MAX_VALUE</code>，可能会创建大量的线程，从而导致 OOM。</li></ol></li><li><p>【强制】<code>SimpleDateFormat</code> 是线程不安全的类，一般不要定义为 <code>static</code> 变量，如果定义为 <code>static</code>，必须加锁，或者使用 <code>DateUtils</code> 工具类。<br><strong>正例：</strong> 注意线程安全，使用 <code>DateUtils</code>。亦推荐如下处理：</p><pre><code> private static final ThreadLocal&lt;DateFormat&gt; df = new ThreadLocal&lt;DateFormat&gt;() {     @Override     protected DateFormat initialValue() {         return new SimpleDateFormat(&quot;yyyy-MM-dd&quot;);     } };</code></pre><p> <strong>说明：</strong> 如果是 JDK8 的应用，可以使用 <code>Instant</code> 代替 <code>Date</code>，<code>LocalDateTime</code> 代替 <code>Calendar</code>，<code>DateTimeFormatter</code> 代替 <code>Simpledateformatter</code>，官方给出的解释：simple beautiful strong<br>immutable thread-safe。</p></li><li><p>【强制】高并发时，同步调用应该去考量锁的性能损耗。能用无锁数据结构，就不要用锁；能锁区块，就不要锁整个方法体；能用对象锁，就不要用类锁。<br><strong>说明：</strong> 尽可能使加锁的代码块工作量尽可能的小，避免在锁代码块中调用 RPC 方法。</p></li><li><p>【强制】对多个资源、数据库表、对象同时加锁时，需要保持一致的加锁顺序，否则可能会造成死锁。<br><strong>说明：</strong> 线程一需要对表 A、B、C 依次全部加锁后才可以进行更新操作，那么线程二的加锁顺序也必须是 A、B、C，否则可能出现死锁。</p></li><li><p>【强制】并发修改同一记录时，避免更新丢失，需要加锁。要么在应用层加锁，要么在缓存加锁，要么在数据库层使用乐观锁，使用 version 作为更新依据。<br><strong>说明：</strong> 如果每次访问冲突概率小于 20%，推荐使用乐观锁，否则使用悲观锁。乐观锁的重试次数不得小于 3 次。</p></li><li><p>【强制】多线程并行处理定时任务时，<code>Timer</code> 运行多个 <code>TimeTask</code> 时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 <code>ScheduledExecutorService</code> 则没有这个问题。</p></li><li><p>【推荐】使用 <code>CountDownLatch</code> 进行异步转同步操作，每个线程退出前必须调用 <code>countDown</code> 方法，线程执行代码注意 catch 异常，确保 <code>countDown</code> 方法可以执行，避免主线程无法执行至 <code>await</code> 方法，直到超时才返回结果。<br><strong>说明：</strong> 注意，子线程抛出异常堆栈，不能在主线程 try-catch 到。</p></li><li><p>【推荐】避免 <code>Random</code> 实例被多线程使用，虽然共享该实例是线程安全的，但会因竞争同一 seed 导致的性能下降。<br><strong>说明：</strong> <code>Random</code> 实例包括 <code>java.util.Random</code> 的实例或者 <code>Math.random()</code> 的方式。<br><strong>正例：</strong> 在 JDK7 之后，可以直接使用 API <code>ThreadLocalRandom</code>，而在 JDK7 之前，需要编码保证每个线程持有一个实例。</p></li><li><p>【推荐】在并发场景下，通过双重检查锁（double-checked locking）实现延迟初始化的优化问题隐患(可参考 The “Double-Checked Locking is Broken” Declaration)，推荐问题解决方案中较为简单一种（适用于 JDK5 及以上版本），将目标属性声明为 <code>volatile</code> 型。<br><strong>反例：</strong> </p><pre><code>class Foo {    private Helper helper = null;    public Helper getHelper() {        if (helper == null) synchronized(this) {            if (helper == null)                helper = new Helper();        }        return helper;    }    // other functions and members...}</code></pre></li><li><p>【参考】volatile 解决多线程内存不可见问题。对于一写多读，是可以解决变量同步问题，但是如果多写，同样无法解决线程安全问题。如果是 count++操作，使用如下类实现：<br><code>AtomicInteger count = new AtomicInteger(); count.addAndGet(1);</code> 如果是 JDK8，推荐使用 <code>LongAdder</code> 对象，比 <code>AtomicLong</code> 性能更好（减少乐观锁的重试次数）。</p></li><li><p>【参考】  在容量不够进行 resize 时由于高并发可能出现死链，导致 CPU 飙升，在开发过程中可以使用其它数据结构或加锁来规避此风险。</p></li><li><p>【参考】<code>ThreadLocal</code> 无法解决共享对象的更新问题，<code>ThreadLocal</code> 对象建议使用 <code>static</code> 修饰。这个变量是针对一个线程内所有操作共有的，所以设置为静态变量，所有此类实例共享此静态变量，也就是说在类第一次被使用时装载，只分配一块存储空间，所有此类的对象(只要是这个线程内定义的)都可以操控这个变量。</p></li></ol><h4 id="控制语句"><a href="#控制语句" class="headerlink" title="控制语句"></a>控制语句</h4><ol><li><p>【强制】在一个 <code>switch</code> 块内，每个 <code>case</code> 要么通过 <code>break/return</code> 等来终止，要么注释说明程序将继续执行到哪一个 <code>case</code> 为止；在一个 <code>switch</code> 块内，都必须包含一个 <code>default</code> 语句并且放在最后，即使它什么代码也没有。</p></li><li><p>【强制】在 if/else/for/while/do 语句中必须使用大括号。即使只有一行代码，避免使用单行的形式：if (condition) statements;</p></li><li><p>【推荐】表达异常的分支时，少用 if-else 方式，这种方式可以改写成：</p><pre><code>if (condition) { ... return obj;}// 接着写 else 的业务逻辑代码;</code></pre><p><strong>说明：</strong> 如果非得使用 if()…else if()…else…方式表达逻辑，【强制】避免后续代码维护困难，请勿超过 3 层。<br><strong>正例：</strong> 逻辑上超过 3 层的 if-else 代码可以使用卫语句，或者状态模式来实现。卫语句示例如下：</p><pre><code>public void today() {    if (isBusy()) {        System.out.println(“change time.”);        return;    }    if (isFree()) {        System.out.println(“go to travel.”);        return;    }    System.out.println(“stay at home to learn Alibaba Java Coding Guideline.”);    return;}</code></pre></li><li><p>【推荐】除常用方法（如 getXxx/isXxx）等外，不要在条件判断中执行其它复杂的语句，将复杂逻辑判断的结果赋值给一个有意义的布尔变量名，以提高可读性。<br><strong>说明：</strong> 很多 if 语句内的逻辑相当复杂，阅读者需要分析条件表达式的最终结果，才能明确什么样的条件执行什么样的语句，那么，如果阅读者分析逻辑表达式错误呢？<br> <strong>正例：</strong> </p><pre><code> //伪代码如下 final boolean existed = (file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...); if (existed) {  ... }</code></pre><p> <strong>反例：</strong> </p><pre><code> if ((file.open(fileName, &quot;w&quot;) != null) &amp;&amp; (...) || (...)) {  ... }</code></pre></li><li><p>【推荐】循环体中的语句要考量性能，以下操作尽量移至循环体外处理，如定义对象、变量、获取数据库连接，进行不必要的 try-catch 操作（这个 try-catch 是否可以移至循环体外）。</p></li><li><p>【推荐】接口入参保护，这种场景常见的是用于做批量操作的接口。</p></li><li><p>【参考】下列情形，需要进行参数校验：<br>1） 调用频次低的方法。<br>2） 执行时间开销很大的方法。此情形中，参数校验时间几乎可以忽略不计，但如果因为参<br>数错误导致中间执行回退，或者错误，那得不偿失。<br>3） 需要极高稳定性和可用性的方法。<br>4） 对外提供的开放接口，不管是 RPC/API/HTTP 接口。<br>5） 敏感权限入口。</p></li><li><p>【参考】下列情形，不需要进行参数校验：<br>1） 极有可能被循环调用的方法。但在方法说明里必须注明外部参数检查要求。<br>2） 底层调用频度比较高的方法。毕竟是像纯净水过滤的最后一道，参数错误不太可能到底<br>层才会暴露问题。一般 DAO 层与 Service 层都在同一个应用中，部署在同一台服务器中，所以 DAO 的参数校验，可以省略。<br>3） 被声明成 private 只会被自己代码所调用的方法，如果能够确定调用方法的代码传入参数已经做过检查或者肯定不会有问题，此时可以不校验参数。</p></li></ol><h4 id="注释规约"><a href="#注释规约" class="headerlink" title="注释规约"></a>注释规约</h4><ol><li><p>【强制】类、类属性、类方法的注释必须使用 Javadoc 规范，使用<code>/**内容*/格式，不得使用 //xxx 方式</code>。<br><strong>说明：</strong> 在 IDE 编辑窗口中，Javadoc 方式会提示相关注释，生成 Javadoc 可以正确输出相应注释；在 IDE 中，工程调用方法时，不进入方法即可悬浮提示方法、参数、返回值的意义，提高<br>阅读效率。</p></li><li><p>【强制】所有的抽象方法（包括接口中的方法）必须要用 Javadoc 注释、除了返回值、参数、异常说明外，还必须指出该方法做什么事情，实现什么功能。<br><strong>说明：</strong> 对子类的实现要求，或者调用注意事项，请一并说明。</p></li><li><p>【强制】所有的类都必须添加创建者和创建日期。</p></li><li><p>【强制】方法内部单行注释，在被注释语句上方另起一行，使用 //注释。方法内部多行注释使用/<em> </em>/注释，注意与代码对齐。</p></li><li><p>【强制】所有的枚举类型字段必须要有注释，说明每个数据项的用途。</p></li><li><p>【推荐】与其“半吊子”英文来注释，不如用中文注释把问题说清楚。专有名词与关键字保持英文原文即可。<br><strong>反例：</strong> “TCP 连接超时”解释成“传输控制协议连接超时”，理解反而费脑筋。</p></li><li><p>【推荐】代码修改的同时，注释也要进行相应的修改，尤其是参数、返回值、异常、核心逻辑等的修改。<br><strong>说明：</strong> 代码与注释更新不同步，就像路网与导航软件更新不同步一样，如果导航软件严重滞后，<br>就失去了导航的意义。</p></li><li><p>【参考】合理处理注释掉的代码。在上方详细说明，而不是简单的注释掉。如果无用，则删除。<br><strong>说明：</strong> 代码被注释掉有两种可能性：1）后续会恢复此段代码逻辑。2）永久不用。前者如果没<br>有备注信息，难以知晓注释动机。后者建议直接删掉（代码仓库保存了历史代码）。</p></li><li><p>【参考】对于注释的要求：第一、能够准确反应设计思想和代码逻辑；第二、能够描述业务含义，使别的程序员能够迅速了解到代码背后的信息。完全没有注释的大段代码对于阅读者形同天书，注释是给自己看的，即使隔很长时间，也能清晰理解当时的思路；注释也是给继任者看的，使其能够快速接替自己的工作。</p></li><li><p>【参考】好的命名、代码结构是自解释的，注释力求精简准确、表达到位。避免出现注释的一个极端：过多过滥的注释，代码的逻辑一旦修改，修改注释是相当大的负担。<br><strong>反例：</strong>  </p><pre><code>// put elephant into fridgeput(elephant, fridge);</code></pre><p>方法名 put，加上两个有意义的变量名 elephant 和 fridge，已经说明了这是在干什么，语义清晰的代码不需要额外的注释。</p></li><li><p>【参考】特殊注释标记，请注明标记人与标记时间。注意及时处理这些标记，通过标记扫描，经常清理此类标记。线上故障有时候就是来源于这些标记处的代码。<br>1） 待办事宜（TODO）:（ 标记人，标记时间，[预计处理时间]）表示需要实现，但目前还未实现的功能。这实际上是一个 Javadoc 的标签，目前的 Javadoc 还没有实现，但已经被广泛使用。只能应用于类，接口和方法（因为它是一个 Javadoc 标签）。<br>2） 错误，不能工作（FIXME）:（标记人，标记时间，[预计处理时间]）在注释中用 FIXME 标记某代码是错误的，而且不能工作，需要及时纠正的情况。</p></li></ol><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><ol><li><p>【强制】在使用正则表达式时，利用好其预编译功能，可以有效加快正则匹配速度。<br>说明：不要在方法体内定义：<code>Pattern pattern = Pattern.compile(规则);</code></p></li><li><p>【强制】<code>velocity</code> 调用 POJO 类的属性时，建议直接使用属性名取值即可，模板引擎会自动按规范调用 POJO 的 getXxx()，如果是 boolean 基本数据类型变量（boolean 命名不需要加 is前缀），会自动调用 isXxx()方法。<br><strong>说明：</strong> 注意如果是 Boolean 包装类对象，优先调用 getXxx()的方法。</p></li><li><p>【强制】后台输送给页面的变量必须加$!{var}——中间的感叹号。<br><strong>说明：</strong> 如果 <code>var=null</code> 或者不存在，那么${var}会直接显示在页面上。</p></li><li><p>【强制】注意 <code>Math.random()</code> 这个方法返回是 double 类型，注意取值的范围 0≤x&lt;1（能够取到零值，注意除零异常），如果想获取整数类型的随机数，不要将 x 放大 10 的若干倍然后取整，直接使用 Random 对象的 nextInt 或者 nextLong 方法。</p></li><li><p>【强制】获取当前毫秒数 <code>System.currentTimeMillis()</code>; 而不是 <code>new Date().getTime()</code>;<br><strong>说明：</strong> 如果想获取更加精确的纳秒级时间值，使用 System.nanoTime()的方式。在 JDK8 中，针对统计时间等场景，推荐使用 Instant 类。</p></li><li><p>【推荐】不要在视图模板中加入任何复杂的逻辑。<br><strong>说明：</strong> 根据 MVC 理论，视图的职责是展示，不要抢模型和控制器的活。</p></li><li><p>【推荐】任何数据结构的构造或初始化，都应指定大小，避免数据结构无限增长吃光内存。</p></li><li><p>【推荐】对于“明确停止使用的代码和配置”，如方法、变量、类、配置文件、动态配置属性等要坚决从程序中清理出去，避免造成过多垃圾。</p></li></ol><h2 id="异常日志"><a href="#异常日志" class="headerlink" title="异常日志"></a>异常日志</h2><h4 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h4><ol><li><p>【强制】Java 类库中定义的一类 RuntimeException 可以通过预先检查进行规避，而不应该通过 catch 来处理，比如： <code>IndexOutOfBoundsException</code> ， <code>NullPointerException</code> 等等。<br><strong>说明：</strong> 无法通过预检查的异常除外，如在解析一个外部传来的字符串形式数字时，通过 catch<br>NumberFormatException 来实现。<br><strong>正例：</strong> <code>if (obj != null) {...}</code><br><strong>反例：</strong> <code>try { obj.method() } catch (NullPointerException e) {...}</code>  </p></li><li><p>【强制】异常不要用来做流程控制，条件控制，因为异常的处理效率比条件分支低。</p></li><li><p>【强制】对大段代码进行 try-catch，这是不负责任的表现。catch 时请分清稳定代码和非稳定代码，稳定代码指的是无论如何不会出错的代码。对于非稳定代码的 catch 尽可能进行区分异常类型，再做对应的异常处理。</p></li><li><p>【强制】捕获异常是为了处理它，不要捕获了却什么都不处理而抛弃之，如果不想处理它，请将该异常抛给它的调用者。最外层的业务使用者，必须处理异常，将其转化为用户可以理解的内容。</p></li><li><p>【强制】有 try 块放到了事务代码中，catch 异常后，如果需要回滚事务，一定要注意手动回滚事务。</p></li><li><p>【强制】finally 块必须对资源对象、流对象进行关闭，有异常也要做 try-catch。<br><strong>说明：</strong> 如果 JDK7 及以上，可以使用 try-with-resources 方式。</p></li><li><p>【强制】不能在 finally 块中使用 return，finally 块中的 return 返回后方法结束执行，不会再执行 try 块中的 return 语句。</p></li><li><p>【强制】捕获异常与抛异常，必须是完全匹配，或者捕获异常是抛异常的父类。<br><strong>说明：</strong> 如果预期对方抛的是绣球，实际接到的是铅球，就会产生意外情况。</p></li><li><p>【推荐】方法的返回值可以为 null，不强制返回空集合，或者空对象等，必须添加注释充分说明什么情况下会返回 null 值。调用方需要进行 null 判断防止 NPE 问题。<br><strong>说明：</strong> 本手册明确防止 NPE 是调用者的责任。即使被调用方法返回空集合或者空对象，对调用者来说，也并非高枕无忧，必须考虑到远程调用失败、序列化失败、运行时异常等场景返回 null 的情况。</p></li><li><p>【推荐】防止 NPE，是程序员的基本修养，注意 NPE 产生的场景：<br>1）返回类型为基本数据类型，return 包装数据类型的对象时，自动拆箱有可能产生 NPE。  </p><pre><code>**反例：** `public int f() { return Integer 对象}`， 如果为 null，自动解箱抛 NPE。  </code></pre><p>2） 数据库的查询结果可能为 null。<br>3） 集合里的元素即使 isNotEmpty，取出的数据元素也可能为 null。<br>4） 远程调用返回对象时，一律要求进行空指针判断，防止 NPE。<br>5） 对于 Session 中获取的数据，建议 NPE 检查，避免空指针。<br>6） 级联调用 obj.getA().getB().getC()；一连串调用，易产生 NPE。<br><strong>正例：</strong> 使用 JDK8 的 Optional 类来防止 NPE 问题。</p></li><li><p>【推荐】定义时区分 unchecked / checked 异常，避免直接抛出 <code>new RuntimeException()</code>，更不允许抛出 Exception 或者 Throwable，应使用有业务含义的自定义异常。推荐业界已定义过的自定义异常，如：DAOException / ServiceException 等。</p></li><li><p>【参考】在代码中使用“抛异常”还是“返回错误码”，对于公司外的 http/api 开放接口必须使用“错误码”；而应用内部推荐异常抛出；跨应用间 RPC 调用优先考虑使用 Result 方式，封装 isSuccess()方法、“错误码”、“错误简短信息”。<br><strong>说明：</strong> 关于 RPC 方法返回方式使用 Result 方式的理由：<br>1）使用抛异常返回方式，调用方如果没有捕获到就会产生运行时错误。<br>2）如果不加栈信息，只是 new 自定义异常，加入自己的理解的 error message，对于调用端解决问题的帮助不会太多。如果加了栈信息，在频繁调用出错的情况下，数据序列化和传输的性能损耗也是问题。</p></li><li><p>【参考】避免出现重复的代码（Don’t Repeat Yourself），即 DRY 原则。<br><strong>说明：</strong> 随意复制和粘贴代码，必然会导致代码的重复，在以后需要修改时，需要修改所有的副本，容易遗漏。必要时抽取共性方法，或者抽象公共类，甚至是共用模块。<br><strong>正例：</strong> 一个类中有多个 public 方法，都需要进行数行相同的参数校验操作，这个时候请抽取：<br><code>private boolean checkParam(DTO dto) {...}</code></p></li></ol><h4 id="日志规约"><a href="#日志规约" class="headerlink" title="日志规约"></a>日志规约</h4><ol><li><p>【强制】应用中不可直接使用日志系统（Log4j、Logback）中的 API，而应依赖使用日志框架 SLF4J 中的 API，使用门面模式的日志框架，有利于维护和各个类的日志处理方式统一。</p><pre><code>import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger = LoggerFactory.getLogger(Abc.class);</code></pre></li><li><p>【强制】日志文件推荐至少保存 15 天，因为有些异常具备以“周”为频次发生的特点。</p></li><li><p>【强制】应用中的扩展日志（如打点、临时监控、访问日志等）命名方式：appName_logType_logName.log。logType:日志类型，推荐分类有 stats/desc/monitor/visit 等；logName:日志描述。这种命名的好处：通过文件名就可知道日志文件属于什么应用，什么类型，什么目的，也有利于归类查找。<br><strong>正例：</strong> mppserver 应用中单独监控时区转换异常，如： mppserver_monitor_timeZoneConvert.log<br><strong>说明：</strong> 推荐对日志进行分类，如将错误日志和业务日志分开存放，便于开发人员查看，也便于<br>通过日志对系统进行及时监控。</p></li><li><p>【强制】对 trace/debug/info 级别的日志输出，必须使用条件输出形式或者使用占位符的方<br>式。<br><strong>说明：</strong> logger.debug(“Processing trade with id: “ + id + “ symbol: “ + symbol);如果日志级别是 warn，上述日志不会打印，但是会执行字符串拼接操作，如果 symbol 是对象，会执行 toString() 方法，浪费了系统资源，执行了上述操作，最终日志却没有打印。<br> <strong>正例：</strong> （条件）</p><pre><code> if (logger.isDebugEnabled()) {     logger.debug(&quot;Processing trade with id: &quot; + id + &quot; symbol: &quot; + symbol); }</code></pre><p> <strong>正例：</strong> （占位符）</p><pre><code> logger.debug(&quot;Processing trade with id: {} symbol : {} &quot;, id, symbol);</code></pre></li><li><p>【强制】避免重复打印日志，浪费磁盘空间，务必在 log4j.xml 中设置 additivity=false。<br><strong>正例：</strong> <code>&lt;logger name=&quot;com.taobao.dubbo.config&quot; additivity=&quot;false&quot;&gt;</code></p></li><li><p>【强制】异常信息应该包括两类信息：案发现场信息和异常堆栈信息。如果不处理，那么通过关键字 throws 往上抛出。<br><strong>正例：</strong> logger.error(各类参数或者对象 toString + “_” + e.getMessage(), e);</p></li><li><p>【推荐】谨慎地记录日志。生产环境禁止输出 debug 日志；有选择地输出 info 日志；如果使用 warn 来记录刚上线时的业务行为信息，一定要注意日志输出量的问题，避免把服务器磁盘<br>撑爆，并记得及时删除这些观察日志。<br><strong>说明：</strong> 大量地输出无效日志，不利于系统性能提升，也不利于快速定位错误点。记录日志时请思考：这些日志真的有人看吗？看到这条日志你能做什么？能不能给问题排查带来好处？</p></li><li><p>【参考】可以使用 warn 日志级别来记录用户输入参数错误的情况，避免用户投诉时，无所适从。注意日志输出的级别，error 级别只记录系统逻辑出错、异常等重要的错误信息。如非必要，请不要在此场景打出 error 级别。</p></li></ol><h2 id="MYSQL-数据库"><a href="#MYSQL-数据库" class="headerlink" title="MYSQL 数据库"></a>MYSQL 数据库</h2><h4 id="建表规约"><a href="#建表规约" class="headerlink" title="建表规约"></a>建表规约</h4><ol><li><p>【强制】表达是与否概念的字段，必须使用 is_xxx 的方式命名，数据类型是 unsigned tinyint（ 1 表示是，0 表示否）。<br><strong>说明：</strong> 任何字段如果为非负数，必须是 unsigned。<br><strong>正例：</strong> 表达逻辑删除的字段名 is_deleted，1 表示删除，0 表示未删除。</p></li><li><p>【强制】表名、字段名必须使用小写字母或数字，禁止出现数字开头，禁止两个下划线中间只出现数字。数据库字段名的修改代价很大，因为无法进行预发布，所以字段名称需要慎重考虑。<br><strong>正例：</strong> getter_admin，task_config，level3_name<br><strong>反例：</strong> GetterAdmin，taskConfig，level_3_name</p></li><li><p>【强制】表名不使用复数名词。<br><strong>说明：</strong> 表名应该仅仅表示表里面的实体内容，不应该表示实体数量，对应于 DO 类名也是单数形式，符合表达习惯。</p></li><li><p>【强制】禁用保留字，如 desc、range、match、delayed 等，请参考 MySQL 官方保留字。</p></li><li><p>【强制】主键索引名为 pk_字段名；唯一索引名为 uk_字段名；普通索引名则为 idx_字段名。<br><strong>说明：</strong> pk_ 即 primary key；uk_ 即 unique key；idx_ 即 index 的简称。</p></li><li><p>【强制】小数类型为 decimal，禁止使用 float 和 double。<br><strong>说明：</strong> float 和 double 在存储的时候，存在精度损失的问题，很可能在值的比较时，得到不正确的结果。如果存储的数据范围超过 decimal 的范围，建议将数据拆成整数和小数分开存储。</p></li><li><p>【强制】如果存储的字符串长度几乎相等，使用 char 定长字符串类型。</p></li><li><p>【强制】varchar 是可变长字符串，不预先分配存储空间，长度不要超过 5000，如果存储长度大于此值，定义字段类型为 text，独立出来一张表，用主键来对应，避免影响其它字段索引效率。</p></li><li><p>【强制】表必备三字段：id, gmt_create, gmt_modified。<br><strong>说明：</strong> 其中 id 必为主键，类型为 unsigned bigint、单表时自增、步长为 1。gmt_create, gmt_modified 的类型均为 date_time 类型。</p></li><li><p>【推荐】表的命名最好是加上“业务名称_表的作用”。<br><strong>正例：</strong> tiger_task / tiger_reader / mpp_config</p></li><li><p>【推荐】库名与应用名称尽量一致。</p></li><li><p>【推荐】如果修改字段含义或对字段表示的状态追加时，需要及时更新字段注释。</p></li><li><p>【推荐】字段允许适当冗余，以提高查询性能，但必须考虑数据一致。冗余字段应遵循：<br>1）不是频繁修改的字段。<br>2）不是 varchar 超长字段，更不能是 text 字段。<br><strong>正例：</strong> 商品类目名称使用频率高，字段长度短，名称基本一成不变，可在相关联的表中冗余存<br>储类目名称，避免关联查询。</p></li><li><p>【推荐】单表行数超过 500 万行或者单表容量超过 2GB，才推荐进行分库分表。<br><strong>说明：</strong> 如果预计三年后的数据量根本达不到这个级别，请不要在创建表时就分库分表。</p></li><li><p>【参考】合适的字符存储长度，不但节约数据库表空间、节约索引存储，更重要的是提升检索速度。<br><strong>正例：</strong> 如下表，其中无符号值可以避免误存负数，且扩大了表示范围。</p><p>| 对象     | 年龄区间   | 类型              | 表示范围                       |<br>| :———- | :————- | :———————— | :——————————————- |<br>| 人       | 150 岁之内 | unsigned tinyint  | 无符号值：0 到 255             |<br>| 龟       | 数百岁     | unsigned smallint | 无符号值：0 到 65535           |<br>| 恐龙化石 | 数千万年   | unsigned int      | 无符号值：0 到约 42.9 亿       |<br>| 太阳     | 约 50 亿年 | unsigned bigint   | 无符号值：0 到约 10 的 19 次方 |</p></li></ol><h4 id="索引规约"><a href="#索引规约" class="headerlink" title="索引规约"></a>索引规约</h4><ol><li><p>【强制】业务上具有唯一特性的字段，即使是多个字段的组合，也必须建成唯一索引。<br>说明：不要以为唯一索引影响了 insert 速度，这个速度损耗可以忽略，但提高查找速度是明显的；另外，即使在应用层做了非常完善的校验控制，只要没有唯一索引，根据墨菲定律，必然有脏数据产生。</p></li><li><p>【强制】 超过三个表禁止 join。需要 join 的字段，数据类型必须绝对一致；多表关联查询时，保证被关联的字段需要有索引。<br><strong>说明：</strong> 即使双表 join 也要注意表索引、SQL 性能。</p></li><li><p>【强制】在 varchar 字段上建立索引时，必须指定索引长度，没必要对全字段建立索引，根据实际文本区分度决定索引长度即可。<br><strong>说明：</strong> 索引的长度与区分度是一对矛盾体，一般对字符串类型数据，长度为 20 的索引，区分度会高达 90%以上，可以使用 count(distinct left(列名, 索引长度))/count(*)的区分度来确定。</p></li><li><p>【强制】页面搜索严禁左模糊或者全模糊，如果需要请走搜索引擎来解决。<br><strong>说明：</strong> 索引文件具有 B-Tree 的最左前缀匹配特性，如果左边的值未确定，那么无法使用此索引。</p></li><li><p>【推荐】如果有 order by 的场景，请注意利用索引的有序性。order by 最后的字段是组合索引的一部分，并且放在索引组合顺序的最后，避免出现 file_sort 的情况，影响查询性能。<br><strong>正例：</strong> where a=? and b=? order by c; 索引：a_b_c<br><strong>反例：</strong> 索引中有范围查找，那么索引有序性无法利用，如：WHERE a&gt;10 ORDER BY b; 索引 a_b 无法排序。</p></li><li><p>【推荐】利用覆盖索引来进行查询操作，避免回表。<br><strong>说明：</strong> 如果一本书需要知道第 11 章是什么标题，会翻开第 11 章对应的那一页吗？目录浏览一下就好，这个目录就是起到覆盖索引的作用。<br><strong>正例：</strong> 能够建立索引的种类：主键索引、唯一索引、普通索引，而覆盖索引是一种查询的一种<br>效果，用 explain 的结果，extra 列会出现：using index。</p></li><li><p>【推荐】利用延迟关联或者子查询优化超多分页场景。<br><strong>说明：</strong> MySQL 并不是跳过 offset 行，而是取 offset+N 行，然后返回放弃前 offset 行，返回 N 行，那当 offset 特别大的时候，效率就非常的低下，要么控制返回的总页数，要么对超过特定阈值的页数进行 SQL 改写。<br><strong>正例：</strong> 先快速定位需要获取的 id 段，然后再关联：<br> SELECT a.* FROM 表 1 a, (select id from 表 1 where 条件 LIMIT 100000,20 ) b where a.id=b.id</p></li><li><p>【推荐】SQL 性能优化的目标：至少要达到 range 级别，要求是 ref 级别，如果可以是 consts 最好。<br><strong>说明：</strong>  </p><pre><code>1） consts 单表中最多只有一个匹配行（主键或者唯一索引），在优化阶段即可读取到数据。  2） ref 指的是使用普通的索引（normal index）。  3） range 对索引进行范围检索。  </code></pre><p><strong>反例：</strong> explain 表的结果，type=index，索引物理文件全扫描，速度非常慢，这个 index 级别比较 range 还低，与全表扫描是小巫见大巫。</p></li><li><p>【推荐】建组合索引的时候，区分度最高的在最左边。<br><strong>正例：</strong> 如果 where a=? and b=? ，a 列的几乎接近于唯一值，那么只需要单建 idx_a 索引即可。<br><strong>说明：</strong> 存在非等号和等号混合判断条件时，在建索引时，请把等号条件的列前置。如：where a&gt;?<br>and b=? 那么即使 a 的区分度更高，也必须把 b 放在索引的最前列。</p></li><li><p>【推荐】防止因字段类型不同造成的隐式转换，导致索引失效。</p></li><li><p>【参考】创建索引时避免有如下极端误解：<br>1）宁滥勿缺。误认为一个查询就需要建一个索引。<br>2）宁缺勿滥。误认为索引会消耗空间、严重拖慢更新和新增速度。<br>3）抵制惟一索引。误认为业务的惟一性一律需要在应用层通过“先查后插”方式解决。</p></li></ol><h4 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h4><ol><li><p>【强制】不要使用 count(列名)或 count(常量)来替代 count(<em>)，count(</em>)是 SQL92 定义的标准统计行数的语法，跟数据库无关，跟 NULL 和非 NULL 无关。<br><strong>说明：</strong> count(*)会统计值为 NULL 的行，而 count(列名)不会统计此列为 NULL 值的行。</p></li><li><p>【强制】count(distinct col) 计算该列除 NULL 之外的不重复行数，注意 count(distinct col1, col2) 如果其中一列全为 NULL，那么即使另一列有不同的值，也返回为 0。</p></li><li><p>【强制】当某一列的值全是 NULL 时，count(col)的返回结果为 0，但 sum(col)的返回结果为 NULL，因此使用 sum()时需注意 NPE 问题。<br><strong>正例：</strong> 可以使用如下方式来避免 sum 的 NPE 问题：SELECT IF(ISNULL(SUM(g)),0,SUM(g)) FROM table;</p></li><li><p>【强制】使用 ISNULL()来判断是否为 NULL 值。注意：NULL 与任何值的直接比较都为 NULL。<br><strong>说明：</strong><br> 1） NULL&lt;&gt;NULL 的返回结果是 NULL，而不是 false。<br> 2） NULL=NULL 的返回结果是 NULL，而不是 true。<br> 3） NULL&lt;&gt;1 的返回结果是 NULL，而不是 true。  </p></li><li><p>【强制】在代码中写分页查询逻辑时，若 count 为 0 应直接返回，避免执行后面的分页语句。</p></li><li><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。<br><strong>说明：</strong> （概念解释）学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，则为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群；级联更新是强阻塞，存在数据库更新风暴的风险；外键影响数据库的插入速度。</p></li><li><p>【强制】禁止使用存储过程，存储过程难以调试和扩展，更没有移植性。</p></li><li><p>【强制】数据订正时，删除和修改记录时，要先 select，避免出现误删除，确认无误才能执行更新语句。</p></li><li><p>【推荐】in 操作能避免则避免，若实在避免不了，需要仔细评估 in 后边的集合元素数量，控制在 1000 个之内。</p></li><li><p>【参考】如果有全球化需要，所有的字符存储与表示，均以 utf-8 编码，注意字符统计函数的区别。<br><strong>说明：</strong><br> SELECT LENGTH(“轻松工作”)； 返回为 12<br> SELECT CHARACTER_LENGTH(“轻松工作”)； 返回为 4<br> 如果要使用表情，那么使用 utfmb4 来进行存储，注意它与 utf-8 编码的区别。</p></li><li><p>【参考】TRUNCATE TABLE 比 DELETE 速度快，且使用的系统和事务日志资源少，但 TRUNCATE 无事务且不触发 trigger，有可能造成事故，故不建议在开发代码中使用此语句。<br><strong>说明：</strong> TRUNCATE TABLE 在功能上与不带 WHERE 子句的 DELETE 语句相同。</p></li></ol><h4 id="ORM-映射"><a href="#ORM-映射" class="headerlink" title="ORM 映射"></a>ORM 映射</h4><ol><li><p>【强制】在表查询中，一律不要使用 <em> 作为查询的字段列表，需要哪些字段必须明确写明。<br><em>*说明：</em></em> 1）增加查询分析器解析成本。2）增减字段容易与 resultMap 配置不一致。</p></li><li><p>【强制】POJO 类的布尔属性不能加 is，而数据库字段必须加 is_，要求在 resultMap 中进行字段与属性之间的映射。<br><strong>说明：</strong> 参见定义 POJO 类以及数据库字段定义规定，在<resultMap>中增加映射，是必须的。在 MyBatis Generator 生成的代码中，需要进行对应的修改。</p></li><li><p>【强制】不要用 resultClass 当返回参数，即使所有类属性名与数据库字段一一对应，也需要定义；反过来，每一个表也必然有一个与之对应。<br><strong>说明：</strong> 配置映射关系，使字段与 DO 类解耦，方便维护。</p></li><li><p>【强制】sql.xml 配置参数使用：#{}，#param# 不要使用${} 此种方式容易出现 SQL 注入。</p></li><li><p>【强制】iBATIS 自带的 queryForList(String statementName,int start,int size)不推荐使用。<br><strong>说明：</strong> 其实现方式是在数据库取到statementName对应的SQL语句的所有记录，再通过subList<br>取 start,size 的子集合。<br><strong>正例：</strong> </p><pre><code> Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;start&quot;, start); map.put(&quot;size&quot;, size);</code></pre></li><li><p>【强制】不允许直接拿 HashMap 与 Hashtable 作为查询结果集的输出。<br><strong>说明：</strong> resultClass=”Hashtable”，会置入字段名和属性值，但是值的类型不可控。</p></li><li><p>【强制】更新数据表记录时，必须同时更新记录对应的 gmt_modified 字段值为当前时间。</p></li><li><p>【推荐】不要写一个大而全的数据更新接口，传入为 POJO 类，不管是不是自己的目标更新字段，都进行 update table set c1=value1,c2=value2,c3=value3; 这是不对的。执行 SQL 时，不要更新无改动的字段，一是易出错；二是效率低；三是增加 binlog 存储。</p></li><li><p>【参考】@Transactional 事务不要滥用。事务会影响数据库的 QPS，另外使用事务的地方需要考虑各方面的回滚方案，包括缓存回滚、搜索引擎回滚、消息补偿、统计修正等。</p></li><li><p>【参考】<isEqual>中的 compareValue 是与属性值对比的常量，一般是数字，表示相等时带上此条件；<isNotEmpty>表示不为空且不为 null 时执行；<isNotNull>表示不为 null 值时执行。 </p></li></ol><h2 id="工程结构"><a href="#工程结构" class="headerlink" title="工程结构"></a>工程结构</h2><h4 id="应用分层"><a href="#应用分层" class="headerlink" title="应用分层"></a>应用分层</h4><ol><li><p>【推荐】图中默认上层依赖于下层，箭头关系表示可直接依赖，如：开放接口层可以依赖于 Web 层，也可以直接依赖于 Service 层，依此类推：</p><p><img src="app_layout.png" alt="未加载图片"></p><ul><li><strong>开放接口层：</strong>可直接封装 Service 方法暴露成 RPC 接口；通过 Web 封装成 http 接口；进行网关安全控制、流量控制等。</li><li><strong>终端显示层：</strong>各个端的模板渲染并执行显示的层。当前主要是 velocity 渲染，JS 渲染，JSP 渲染，移动端展示等。</li><li><strong>Web 层：</strong>主要是对访问控制进行转发，各类基本参数校验，或者不复用的业务简单处理等。</li><li><strong>Service 层：</strong>相对具体的业务逻辑服务层。</li><li><strong>Manager 层：</strong>通用业务处理层，它有如下特征：  <ol><li>对第三方平台封装的层，预处理返回结果及转化异常信息；  </li><li>对 Service 层通用能力的下沉，如缓存方案、中间件通用处理；  </li><li>与 DAO 层交互，对多个 DAO 的组合复用。</li></ol></li><li><strong>DAO 层：</strong>数据访问层，与底层 MySQL、Oracle、Hbase 进行数据交互。</li><li><strong>外部接口或第三方平台：</strong>包括其它部门 RPC 开放接口，基础平台，其它公司的 HTTP 接口。</li></ul></li><li><p>【参考】 （分层异常处理规约）在 DAO 层，产生的异常类型有很多，无法用细粒度的异常进行 catch，使用 catch(Exception e)方式，并 throw new DAOException(e)，不需要打印<br>日志，因为日志在 Manager/Service 层一定需要捕获并打到日志文件中去，如果同台服务器再打日志，浪费性能和存储。在 Service 层出现异常时，必须记录出错日志到磁盘，尽可能带上参数信息，相当于保护案发现场。如果 Manager 层与 Service 同机部署，日志方式与 DAO 层处理一致，如果是单独部署，则采用与 Service 一致的处理方式。Web 层绝不应该继续往上抛异常，因为已经处于顶层，无继续处理异常的方式，如果意识到这个异常将导致页面无法正常渲染，那么就应该直接跳转到友好错误页面，加上友好的错误提示信息。开放接口层要将异常处理成错误码和错误信息方式返回。</p></li><li><p>【参考】分层领域模型规约：</p><ul><li><strong>DO（Data Object）：</strong>与数据库表结构一一对应，通过 DAO 层向上传输数据源对象。</li><li><strong>DTO（Data Transfer Object）：</strong>数据传输对象，Service 和 Manager 向外传输的对象。</li><li><strong>BO（Business Object）：</strong>业务对象。可以由 Service 层输出的封装业务逻辑的对象。</li><li><strong>Query：</strong>数据查询对象，各层接收上层的查询请求。注：超过 2 个参数的查询封装，禁止使用 Map 类来传输。</li><li><strong>VO（View Object）：</strong>显示层对象，通常是 Web 向模板渲染引擎层传输的对象。</li></ul></li></ol><h4 id="二方库依赖"><a href="#二方库依赖" class="headerlink" title="二方库依赖"></a>二方库依赖</h4><ol><li><p>【强制】定义 GAV 遵从以下规则：<br>1） GroupID 格式：com.{公司/BU }.业务线.[子业务线]，最多 4 级。<br><strong>说明：</strong> {公司/BU} 例如：alibaba/taobao/tmall/aliexpress 等 BU 一级；子业务线可选。<br><strong>正例：</strong> com.taobao.jstorm 或 com.alibaba.dubbo.register<br>2） ArtifactID 格式：产品线名-模块名。语义不重复不遗漏，先到中央仓库去查证一下。<br><strong>正例：</strong> dubbo-client / fastjson-api / jstorm-tool<br>3） Version：详细规定参考下方。</p></li><li><p>【强制】二方库版本号命名方式：主版本号.次版本号.修订号<br>1） 主版本号：当做了不兼容的 API 修改，或者增加了能改变产品方向的新功能。<br>2） 次版本号：当做了向下兼容的功能性新增（新增类、接口等）。<br>3） 修订号：修复 bug，没有修改方法签名的功能加强，保持 API 兼容性。<br><strong>说明：</strong> 注意：起始版本号必须为：1.0.0，而不是 0.0.1 正式发布的类库必须先去中央仓库进行查证，使版本号有延续性，正式版本号不允许覆盖升级。如当前版本：1.3.3，那么下一个合理的版本号：1.3.4 或 1.4.0 或 2.0.0</p></li><li><p>【强制】线上应用不要依赖 SNAPSHOT 版本（安全包除外）。<br><strong>说明：</strong> 不依赖 SNAPSHOT 版本是保证应用发布的幂等性。另外，也可以加快编译时的打包构建。</p></li><li><p>【强制】二方库的新增或升级，保持除功能点之外的其它 jar 包仲裁结果不变。如果有改变，<br>必须明确评估和验证，建议进行 dependency:resolve 前后信息比对，如果仲裁结果完全不一<br>致，那么通过 dependency:tree 命令，找出差异点，进行<excludes>排除 jar 包。</p></li><li><p>【强制】二方库里可以定义枚举类型，参数可以使用枚举类型，但是接口返回值不允许使用枚<br>举类型或者包含枚举类型的 POJO 对象。</p></li><li><p>【强制】依赖于一个二方库群时，必须定义一个统一的版本变量，避免版本号不一致。<br>说明：依赖 springframework-core,-context,-beans，它们都是同一个版本，可以定义一<br>个变量来保存版本：${spring.version}，定义依赖的时候，引用该版本。</p></li><li><p>【强制】禁止在子项目的 pom 依赖中出现相同的 GroupId，相同的 ArtifactId，但是不同的<br>Version。<br><strong>说明：</strong> 在本地调试时会使用各子项目指定的版本号，但是合并成一个 war，只能有一个版本号<br>出现在最后的 lib 目录中。可能出现线下调试是正确的，发布到线上却出故障的问题。</p></li><li><p>【推荐】所有 pom 文件中的依赖声明放在<dependencies>语句块中，所有版本仲裁放在<br><dependencyManagement>语句块中。<br>说明：<dependencyManagement>里只是声明版本，并不实现引入，因此子项目需要显式的声<br>明依赖，version 和 scope 都读取自父 pom。而<dependencies>所有声明在主 pom 的<br><dependencies>里的依赖都会自动引入，并默认被所有的子项目继承。</p></li><li><p>【推荐】二方库不要有配置项，最低限度不要再增加配置项。</p></li><li><p>【参考】为避免应用二方库的依赖冲突问题，二方库发布者应当遵循以下原则：<br>1）精简可控原则。移除一切不必要的 API 和依赖，只包含 Service API、必要的领域模型对<br>象、Utils 类、常量、枚举等。如果依赖其它二方库，尽量是 provided 引入，让二方库使用<br>者去依赖具体版本号；无 log 具体实现，只依赖日志框架。<br>2）稳定可追溯原则。每个版本的变化应该被记录，二方库由谁维护，源码在哪里，都需要能<br>方便查到。除非用户主动升级版本，否则公共二方库的行为不应该发生变化。</p></li></ol><h4 id="服务器"><a href="#服务器" class="headerlink" title="服务器"></a>服务器</h4><ol><li><p>【推荐】高并发服务器建议调小 TCP 协议的 time_wait 超时时间。<br>说明：操作系统默认 240 秒后，才会关闭处于 time_wait 状态的连接，在高并发访问下，服<br>务器端会因为处于 time_wait 的连接数太多，可能无法建立新的连接，所以需要在服务器上<br>调小此等待值。<br><strong>正例：</strong> 在 linux 服务器上请通过变更/etc/sysctl.conf 文件去修改该缺省值（秒）：<br>net.ipv4.tcp_fin_timeout = 30</p></li><li><p>【推荐】调大服务器所支持的最大文件句柄数（File Descriptor，简写为 fd）。<br><strong>说明：</strong> 主流操作系统的设计是将 TCP/UDP 连接采用与文件一样的方式去管理，即一个连接对<br>应于一个 fd。主流的 linux 服务器默认所支持最大 fd 数量为 1024，当并发连接数很大时很容易因为 fd 不足而出现“open too many files”错误，导致新的连接无法建立。 建议将 linux<br>服务器所支持的最大句柄数调高数倍（与服务器的内存数量相关）。</p></li><li><p>【推荐】给 JVM 设置-XX:+HeapDumpOnOutOfMemoryError 参数，让 JVM 碰到 OOM 场景时输出<br>dump 信息。<br><strong>说明：</strong> OOM 的发生是有概率的，甚至有规律地相隔数月才出现一例，出现时的现场信息对查错<br>非常有价值。</p></li><li><p>【参考】服务器内部重定向使用 forward；外部重定向地址使用 URL 拼装工具类来生成，否则<br>会带来 URL 维护不一致的问题和潜在的安全风险。</p></li></ol><h2 id="安全规约"><a href="#安全规约" class="headerlink" title="安全规约"></a>安全规约</h2><ol><li><p>【强制】隶属于用户个人的页面或者功能必须进行权限控制校验。<br><strong>说明：</strong> 防止没有做水平权限校验就可随意访问、修改、删除别人的数据，比如查看他人的私信<br>内容、修改他人的订单。</p></li><li><p>【强制】用户敏感数据禁止直接展示，必须对展示数据进行脱敏。<br><strong>说明：</strong> 查看个人手机号码会显示成:158<em>**</em>9119，隐藏中间 4 位，防止隐私泄露。</p></li><li><p>【强制】用户输入的 SQL 参数严格使用参数绑定或者 METADATA 字段值限定，防止 SQL 注入，<br>禁止字符串拼接 SQL 访问数据库。</p></li><li><p>【强制】用户请求传入的任何参数必须做有效性验证。<br><strong>说明：</strong> 忽略参数校验可能导致：</p><ul><li>page size 过大导致内存溢出</li><li>恶意 order by 导致数据库慢查询</li><li>任意重定向</li><li>SQL 注入</li><li>反序列化注入</li><li>正则输入源串拒绝服务 ReDoS  </li></ul><p><strong>说明：</strong> Java 代码用正则来验证客户端的输入，有些正则写法验证普通用户输入没有问题，<br>但是如果攻击人员使用的是特殊构造的字符串来验证，有可能导致死循环的结果。</p></li><li><p>【强制】禁止向 HTML 页面输出未经安全过滤或未正确转义的用户数据。</p></li><li><p>【强制】表单、AJAX 提交必须执行 CSRF 安全过滤。<br><strong>说明：</strong> CSRF(Cross-site request forgery)跨站请求伪造是一类常见编程漏洞。对于存在<br>CSRF 漏洞的应用/网站，攻击者可以事先构造好 URL，只要受害者用户一访问，后台便在用户<br>不知情情况下对数据库中用户参数进行相应修改。</p></li><li><p>【强制】在使用平台资源，譬如短信、邮件、电话、下单、支付，必须实现正确的防重放限制，<br>如数量限制、疲劳度控制、验证码校验，避免被滥刷、资损。<br>说明：如注册时发送验证码到手机，如果没有限制次数和频率，那么可以利用此功能骚扰到其<br>它用户，并造成短信平台资源浪费。</p></li><li><p>【推荐】发贴、评论、发送即时消息等用户生成内容的场景必须实现防刷、文本内容违禁词过<br>滤等风控策略。</p></li></ol><h2 id="附-1：版本历史"><a href="#附-1：版本历史" class="headerlink" title="附 1：版本历史"></a>附 1：版本历史</h2><div class="table-container"><table><thead><tr><th style="text-align:left">版本号</th><th style="text-align:left">更新日期</th><th style="text-align:left">备注</th></tr></thead><tbody><tr><td style="text-align:left">1.0.0</td><td style="text-align:left">2017.2.9</td><td style="text-align:left">阿里巴巴集团正式对外发布</td></tr><tr><td style="text-align:left">1.0.1</td><td style="text-align:left">2017.2.13</td><td style="text-align:left">1）修正 String[]的前后矛盾。2）vm 修正成 velocity。3）修正 countdown 描述错误。</td></tr><tr><td style="text-align:left">1.0.2</td><td style="text-align:left">2017.2.20</td><td style="text-align:left">1）去除文底水印。2）数据类型中引用太阳系年龄问题。3）修正关于异常和方法签名的部分描述。4）修正 final 描述。5）去除 Comparator 部分描述。</td></tr><tr><td style="text-align:left">1.1.0</td><td style="text-align:left">2017.2.27</td><td style="text-align:left">1）增加前言。2）增加&lt;? extends T&gt;描述和说明。3）增加版本历史。4）增加专有名词解释。</td></tr><tr><td style="text-align:left">1.1.1</td><td style="text-align:left">2017.3.31</td><td style="text-align:left">修正页码总数和部分示例</td></tr><tr><td style="text-align:left">1.2.0</td><td style="text-align:left">2017.5.20</td><td style="text-align:left">1）根据云栖社区的“聚能聊”活动反馈，对手册的页码、排版、描述进行修正。2）增加 final的适用场景描述。3）增加关于锁的粒度的说明。4）增加“指定集合大小”的详细说明以及正反例。5）增加卫语句的示例代码。6）明确数据库表示删除概念的字段名为 is_deleted</td></tr></tbody></table></div><h2 id="附-2：本手册专有名词"><a href="#附-2：本手册专有名词" class="headerlink" title="附 2：本手册专有名词"></a>附 2：本手册专有名词</h2><ol><li><p><strong>POJO</strong>（Plain Ordinary Java Object）：在本手册中，POJO 专指只有 setter / getter<br>/ toString 的简单类，包括 DO/DTO/BO/VO 等。</p></li><li><p><strong>DO</strong>（Data Object）：本手册指数据库表一一对应的 POJO 类。</p></li><li><p><strong>GAV</strong>（GroupId、ArtifactctId、Version）：Maven 坐标，是用来唯一标识 jar 包。</p></li><li><p><strong>OOP</strong>（Object Oriented Programming）: 本手册泛指类、对象的编程处理方式。</p></li><li><p><strong>ORM</strong>（Object Relation Mapping）: 对象关系映射，对象领域模型与底层数据之间的转换，<br>本文泛指 iBATIS, mybatis 等框架。</p></li><li><p><strong>NPE</strong>（java.lang.NullPointerException）: 空指针异常。</p></li><li><p><strong>SOA</strong>（Service-Oriented Architecture）: 面向服务架构，它可以根据需求通过网络对松散<br>耦合的粗粒度应用组件进行分布式部署、组合和使用，有利于提升组件可重用性，可维护性。</p></li><li><p><strong>一方库</strong>：本工程内部子项目模块依赖的库（jar 包）。</p></li><li><p><strong>二方库</strong>：公司内部发布到中央仓库，可供公司内部其它应用依赖的库（jar 包）。</p></li><li><p><strong>三方库</strong>：公司之外的开源库（jar 包）。</p></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;本文转载自：&lt;a href=&quot;https://github.com/mysterin/alibaba-java-specification&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://github.com/mysterin/alibaba
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>JUC之常见工具类</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%B8%B8%E8%A7%81%E5%B7%A5%E5%85%B7%E7%B1%BB/</id>
    <published>2020-09-30T07:57:37.000Z</published>
    <updated>2020-10-12T13:29:07.049Z</updated>
    
    <content type="html"><![CDATA[<h2 id="CountDownLatch"><a href="#CountDownLatch" class="headerlink" title="CountDownLatch"></a>CountDownLatch</h2><p>在日常开发中经常会遇到需要在主线程中开启多个线程去并行执行任务，并且主线程需要等待所有子线程执行完毕后再进行汇总的场景。在CountDownLatch出现之前一般都使用线程的join方法来实现这一点，但是在使用ExecutorService时我们就没办法了。</p><h3 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span></span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"child threadOne over!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(()-&gt;&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                System.out.println(<span class="string">"child threadTwo over!"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        System.out.println(<span class="string">"mainThread wait for all childThread over"</span>);</span><br><span class="line">        countDownLatch.await();</span><br><span class="line">        System.out.println(<span class="string">"all childThread over"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输出结果如下：</span><br><span class="line">mainThread wait for all childThread over</span><br><span class="line">child threadTwo over!</span><br><span class="line">child threadOne over!</span><br><span class="line">all childThread over</span><br></pre></td></tr></table></figure><p>在如上代码中，因为有两个子线程所以构造函数传入参数为2。主线程调用CountDownLatch.await()后会被阻塞，子线程执行完毕后调用countDownLatch.countDown()使内部计数器(state)减1，所有子线程执行完毕后计数器为0，此时主线程的await方法才会返回。</p><h3 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h3><p>CountDownLatch基于AQS实现。</p><p><img src="CountDownLatch.png" alt=""></p><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Sync sync;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CountDownLatch</span><span class="params">(<span class="keyword">int</span> count)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (count &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"count &lt; 0"</span>);</span><br><span class="line">    <span class="keyword">this</span>.sync = <span class="keyword">new</span> Sync(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//内部类Sync继承自AQS，其构造方法如下</span></span><br><span class="line">Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">    setState(count);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法可知CountDownLatch的计数器实际就是AQS的state。</p><h4 id="void-await"><a href="#void-await" class="headerlink" title="void await()"></a>void await()</h4><p>调用await后当前线程被阻塞，只有当计数器值为0或者被中断该方法才会返回。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())<span class="comment">//被中断则抛异常</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)<span class="comment">//查看计数器是否为0，不是则进入AQS阻塞队列</span></span><br><span class="line">        doAcquireSharedInterruptibly(arg);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync实现的AQS的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boolean-await-long-timeout-TimeUnit-unit"><a href="#boolean-await-long-timeout-TimeUnit-unit" class="headerlink" title="boolean await(long timeout, TimeUnit unit)"></a>boolean await(long timeout, TimeUnit unit)</h4><p>相比void await()多了一个超时设置，设置的timeout时间到了，因为超时而返回false。</p><h4 id="void-countDown"><a href="#void-countDown" class="headerlink" title="void countDown()"></a>void countDown()</h4><p>线程调用该方法后，计数器值减1，减1后若计数器为0则唤醒<strong>所有</strong>因调用await方法而被阻塞的线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        doReleaseShared();<span class="comment">//唤醒AQS中所有阻塞的线程</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sync实现的AQS的模板方法</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = getState();</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">        <span class="comment">//CAS更新state</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">            <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="long-getCount"><a href="#long-getCount" class="headerlink" title="long getCount()"></a>long getCount()</h4><p>获取state的值，该方法一般用于测试。</p><h2 id="CyclicBarrier"><a href="#CyclicBarrier" class="headerlink" title="CyclicBarrier"></a>CyclicBarrier</h2><p>CountDownLatch的计数器是一次性的，当计数器值为0后，再调用await和countdown方法均会立即返回。为了满足计数器可以重置的需要，这才有了CyclicBarrier（回环屏障）。屏障的含义是：当线程调用await方法就会被阻塞，这个阻塞点就称为屏障点，当所有线程都调用了await方法后，线程就会冲破屏障，所有线程被唤醒继续向下执行（注意：最后一个调用await的线程不会被阻塞）。回环的含义是：所有线程到达屏障点后，CyclicBarrier的状态会被重置，因此它可以被重用。</p><h3 id="使用案例-1"><a href="#使用案例-1" class="headerlink" title="使用案例"></a>使用案例</h3><p>下面的例子实现的是：使用两个线程执行一个被分解的任务，两个线程并发执行任务的两个步骤后再由CyclicBarrier汇总。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">": task merge result"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": task step-1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": enter in barrier"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": out from barrier"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": task step-2"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": enter in barrier"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": out from barrier"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1: task step-1</span><br><span class="line">pool-1-thread-1: enter in barrier</span><br><span class="line">pool-1-thread-2: task step-2</span><br><span class="line">pool-1-thread-2: enter in barrier</span><br><span class="line">pool-1-thread-2: task merge result</span><br><span class="line">pool-1-thread-1: out from barrier</span><br><span class="line">pool-1-thread-2: out from barrier</span><br></pre></td></tr></table></figure><p>CyclicBarrier的构造方法参数列表中，第一个参数是计数器的初始值，第二个参数Runnable是当计数器值为0时由CyclicBarrier执行的任务。</p><p>在线程中CyclicBarrier对象调用await方法后，其计数器值-1，若此时计数器值不为0，当前线程被阻塞；若计数器值为0，则执行CyclicBarrier构造方法中传入的任务，然后唤醒条件队列中所有阻塞线程，重置计数器并新建Generation（重置broken标志）。</p><p>以下例子体现了CyclicBarrier的可复用性（所谓回环）：</p><p>以下任务被分为三个阶段，由两个线程并发执行该任务，只有当两个线程都完成了step1后才能进入step2，只有当两个线程都完成了step2才能进入step3。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest2</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": step-1"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-2"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-3"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">      </span><br><span class="line">        executorService.submit(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() +  <span class="string">": step-1"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-2"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">": step-3"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">pool-1-thread-1: step-1</span><br><span class="line">pool-1-thread-2: step-1</span><br><span class="line">pool-1-thread-2: step-2</span><br><span class="line">pool-1-thread-1: step-2</span><br><span class="line">pool-1-thread-1: step-3</span><br><span class="line">pool-1-thread-2: step-3</span><br></pre></td></tr></table></figure><h3 id="实现原理-1"><a href="#实现原理-1" class="headerlink" title="实现原理"></a>实现原理</h3><p>CyclicBarrier基于ReentrantLock实现。</p><p><img src="CyclicBarrier.png" alt=""></p><p>parties用于记录线程个数，当parties个线程都调用await方法后所有线程才会冲破屏障点。count才是真正的计数器，一开始等于parties，每当有线程调用await方法后就-1，当count==0时所有线程都到了屏障点，此时会重置count的值为parties。</p><p>独占锁lock首先保证了更新计数器count的原子性，另外使用lock的条件变量trip支持线程间同步操作。</p><p>最后，在Generation对象内部有一个变量broken，用于记录当前屏障是否被打破。</p><h4 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (parties &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.parties = parties;</span><br><span class="line">    <span class="keyword">this</span>.count = parties;</span><br><span class="line">    <span class="keyword">this</span>.barrierCommand = barrierAction;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(parties, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="int-await"><a href="#int-await" class="headerlink" title="int await()"></a>int await()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">                          BrokenBarrierException </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="boolean-await-long-timeout-TimeUnit-unit-1"><a href="#boolean-await-long-timeout-TimeUnit-unit-1" class="headerlink" title="boolean await(long timeout, TimeUnit unit)"></a>boolean await(long timeout, TimeUnit unit)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException,</span></span><br><span class="line"><span class="function">           BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> dowait(<span class="keyword">true</span>, unit.toNanos(timeout));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>超时返回。</p><h4 id="int-dowait-boolean-timed-long-nanos"><a href="#int-dowait-boolean-timed-long-nanos" class="headerlink" title="int dowait(boolean timed, long nanos)"></a>int dowait(boolean timed, long nanos)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="keyword">int</span> index = --count;</span><br><span class="line">        <span class="comment">//index==0说明所有线程都到达了屏障点</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped</span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="comment">//执行任务</span></span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();</span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//激活其他因调用await而被阻塞的线程，并重置CyclicBarrier</span></span><br><span class="line">                nextGeneration();</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)</span><br><span class="line">                    breakBarrier();</span><br><span class="line">             &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//index!=0则阻塞当前线程（进入条件队列）</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">              ...</span><br><span class="line">            &#125;</span><br><span class="line">             ...</span><br><span class="line">               </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//所有线程节点进入AQS队列并唤醒所有线程</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">//重置CyclicBarrier</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Semaphore"><a href="#Semaphore" class="headerlink" title="Semaphore"></a>Semaphore</h2><p>Semaphore称为计数信号量，它允许n个任务同时访问某个资源，可以将信号量看做是在向外分发使用资源的许可证，只有成功获取许可证，才能使用资源。</p><h3 id="使用案例-2"><a href="#使用案例-2" class="headerlink" title="使用案例"></a>使用案例</h3><p>Semaphore可以用于做流量控制，特别公用资源有限的应用场景，比如数据库连接。假如有一个需求，要读取几万个文件的数据，因为都是IO密集型任务，我们可以启动几十个线程并发的读取，但是如果读到内存后，还需要存储到数据库中，而数据库的连接数只有10个，这时我们必须控制只有十个线程同时获取数据库连接保存数据，否则会报错无法获取数据库连接。这个时候，我们就可以使用Semaphore来做流控，代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREAD_COUNT = <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> ExecutorService threadPool = Executors</span><br><span class="line">.newFixedThreadPool(THREAD_COUNT);</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Semaphore s = <span class="keyword">new</span> Semaphore(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREAD_COUNT; i++) &#123;</span><br><span class="line">threadPool.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">s.acquire();</span><br><span class="line"><span class="comment">//存储到数据库操作</span></span><br><span class="line">s.release();</span><br><span class="line">&#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">threadPool.shutdown();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="实现原理-2"><a href="#实现原理-2" class="headerlink" title="实现原理"></a>实现原理</h3><p>Semaphore基于AQS实现。</p><p><img src="Semaphore.png" alt=""></p><h4 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Sync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    setState(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">NonfairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    <span class="keyword">super</span>(permits);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">FairSync(<span class="keyword">int</span> permits) &#123;</span><br><span class="line">    <span class="keyword">super</span>(permits);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>构造方法传入许可证数量，许可证数量对应于AQS中的state，默认采用非公平策略。</p><h4 id="acquire"><a href="#acquire" class="headerlink" title="acquire"></a>acquire</h4><p>在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减1，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。</p><p>该方法可被中断。</p><h4 id="acquire-int-permits"><a href="#acquire-int-permits" class="headerlink" title="acquire(int permits)"></a>acquire(int permits)</h4><p>在当前线程调用该方法后，若当前许可证个数大于0，则许可证个数减permits，然后方法返回；若许可证个数等于0，则当前线程会被放入AQS阻塞队列。</p><p>该方法可被中断。</p><h4 id="release"><a href="#release" class="headerlink" title="release"></a>release</h4><p>许可证个数加1，并根据公平策略在AQS阻塞队列中选择一个“许可证个数可以被满足”的线程唤醒。</p><h4 id="release-int-permits"><a href="#release-int-permits" class="headerlink" title="release(int permits)"></a>release(int permits)</h4><p>许可证个数加permits。</p><h2 id="Phaser"><a href="#Phaser" class="headerlink" title="Phaser"></a>Phaser</h2><p>Phaser是JDK 7新增的一个同步辅助类，它可以实现CyclicBarrier和CountDownLatch类似的功能，而且它支持对任务的动态调整，并支持分层结构来达到更高的吞吐量。</p><h2 id="Exchanger"><a href="#Exchanger" class="headerlink" title="Exchanger"></a>Exchanger</h2><p>Exchanger是用于线程协作的工具类, 主要用于两个线程之间的数据交换。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;CountDownLatch&quot;&gt;&lt;a href=&quot;#CountDownLatch&quot; class=&quot;headerlink&quot; title=&quot;CountDownLatch&quot;&gt;&lt;/a&gt;CountDownLatch&lt;/h2&gt;&lt;p&gt;在日常开发中经常会遇到需要在主线程中开启多个
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC之线程池</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2020-09-30T07:52:36.000Z</published>
    <updated>2020-10-12T14:06:02.031Z</updated>
    
    <content type="html"><![CDATA[<h2 id="FutureTask"><a href="#FutureTask" class="headerlink" title="FutureTask"></a>FutureTask</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>FutureTask 为 Future 提供了基础实现，如<strong>获取任务执行结果</strong>(get)和<strong>取消任务</strong>(cancel)等。<strong>若任务尚未完成，获取任务执行结果时主线程将会阻塞</strong>。</p><p>FutureTask 的线程安全由CAS来保证。</p><h3 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="java-thread-x-juc-futuretask-1.png" alt=""></p><p>以上几个接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Callable</span>&lt;<span class="title">V</span>&gt; </span>&#123;<span class="function">V <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Runnable</span> </span>&#123;<span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line">    <span class="function">V <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">RunnableFuture</span>&lt;<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Runnable</span>, <span class="title">Future</span>&lt;<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>FutureTask构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (callable == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="keyword">this</span>.callable = callable;</span><br><span class="line">    <span class="keyword">this</span>.state = NEW; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">FutureTask</span><span class="params">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//把传入的Runnable封装成一个Callable对象，若任务执行成功返回传入的result</span></span><br><span class="line">    <span class="keyword">this</span>.callable = Executors.callable(runnable, result);</span><br><span class="line">    <span class="keyword">this</span>.state = NEW;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由类图和构造方法可知，FutureTask既能当做一个Runnable直接被Thread执行，也能作为Future用来得到Callable的计算结果。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><h3 id="线程池的好处"><a href="#线程池的好处" class="headerlink" title="线程池的好处"></a>线程池的好处</h3><ol><li>提供较好的性能：线程池中的线程是可复用的，不需要每次执行异步任务时都重新创建和销毁线程。</li><li>统一分配和管理：比如可以限制线程的个数、动态新增线程等。</li></ol><h3 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h3><p><img src="java-thread-x-juc-executors-1.png" alt=""></p><p>以上类图中主要接口的源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Executor</span> </span>&#123;<span class="function"><span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span></span>;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ExecutorService</span> <span class="keyword">extends</span> <span class="title">Executor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">List&lt;Runnable&gt; <span class="title">shutdownNow</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isShutdown</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">isTerminated</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">awaitTermination</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span></span>;</span><br><span class="line">    &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span></span>;</span><br><span class="line">    Future&lt;?&gt; submit(Runnable task);</span><br><span class="line">    </span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, <span class="keyword">long</span> timeout, TimeUnit unit)</span><br><span class="line">        <span class="keyword">throws</span> InterruptedException;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class="line"></span><br><span class="line">    &lt;T&gt; <span class="function">T <span class="title">invokeAny</span><span class="params">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class="line"><span class="function"><span class="params"> <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line"><span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,<span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,</span><br><span class="line"><span class="keyword">long</span> delay,TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ThreadPoolExecutor原理"><a href="#ThreadPoolExecutor原理" class="headerlink" title="ThreadPoolExecutor原理"></a>ThreadPoolExecutor原理</h3><h4 id="概述-1"><a href="#概述-1" class="headerlink" title="概述"></a>概述</h4><p>JDK实现的线程池核心主要为两大部分：一个<strong>线程集合workerSet</strong>和一个<strong>阻塞队列workQueue</strong>。当用户向线程池提交一个任务时，该任务将先被放入workQueue中，workerSet中的线程会不断从workQueue中获取线程然后执行，当workQueue中没有任务时，worker就会阻塞，直至队列中又有任务了。</p><p><img src="java-thread-x-executors-1.png" alt=""></p><h4 id="部分属性"><a href="#部分属性" class="headerlink" title="部分属性"></a>部分属性</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//存放任务的阻塞队列</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue&lt;Runnable&gt; workQueue;</span><br><span class="line"><span class="comment">//工作线程集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> HashSet&lt;Worker&gt; workers = <span class="keyword">new</span> HashSet&lt;Worker&gt;();</span><br><span class="line"><span class="comment">//历史达到的worker数最大值</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> largestPoolSize;</span><br><span class="line"><span class="comment">//创建线程的工厂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> ThreadFactory threadFactory;</span><br><span class="line"><span class="comment">//饱和策略：当workQueue满了并且worker的数量达到maxSize的时候,执行具体的拒绝策略</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> RejectedExecutionHandler handler;</span><br><span class="line"><span class="comment">//线程池中超出corePoolSize的闲置状态的worker的存活时间，单位为纳秒</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> keepAliveTime;</span><br><span class="line"><span class="comment">//核心worker数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> corePoolSize;</span><br><span class="line"><span class="comment">//最大worker的数量,一般当workQueue满了才会用到这个参数</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> maximumPoolSize;</span><br><span class="line"></span><br><span class="line"><span class="comment">//控制新增worker线程操作的原子性</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line"></span><br><span class="line"><span class="comment">//条件队列，在线程调用awaitTermination时用于存放阻塞的线程</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition termination = mainLock.newCondition();</span><br><span class="line"></span><br><span class="line"><span class="comment">//记录线程池状态与线程个数</span></span><br><span class="line"><span class="comment">//对于int是32位的平台，高3位表示线程池状态,低29位记录worker数量</span></span><br><span class="line"><span class="comment">//默认是RUNNING状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br></pre></td></tr></table></figure><h4 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line"><span class="comment">//线程数量掩码位数：对于int是32位的平台，该值是29</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line"><span class="comment">//线程最大数量：000111...111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//接受新任务并处理阻塞队列中的任务：高3位111</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//拒绝新任务但是处理阻塞队列中的任务：高3位000</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务：高3位001</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//所有任务（含阻塞队列中的）都执行完后当前活动线程为0，将要调用terminated方法：高3位010</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"><span class="comment">//terminated执行完成后的状态：高3位011</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line"><span class="comment">//获取运行状态：高3位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line"><span class="comment">//获取线程数量：低29位</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line"><span class="comment">//计算ctl新值</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><p>线程池状态转换图如下：</p><p><img src="java-thread-x-executors-2.png" alt=""></p><h4 id="线程池类型"><a href="#线程池类型" class="headerlink" title="线程池类型"></a>线程池类型</h4><p>ThreadPoolExecutor核心构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>Executors工厂类提供创建的线程池类型如下：</p><ul><li><p>newFixedThreadPool：创建一个corePoolSize和maximunPoolSize都为nThreads的线程池，并且阻塞队列长度为<code>Integer.MAX_VALUE</code>。keepAliveTime为0说明只要有多于corePoolSize的空闲线程则回收。由于使用了无界队列，因此饱和策略失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//使用自定义线程工厂</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>newSingleThreadExecutor：创建一个corePoolSize和maximunPoolSize都为1的线程池，并且阻塞队列长度为<code>Integer.MAX_VALUE</code>。keepAliveTime为0。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>, <span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,<span class="number">0L</span>, TimeUnit.MILLISECONDS,<span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;(),threadFactory));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>newCachedThreadPool：创建一个<strong>按需自动创建线程</strong>的线程池，corePoolSize为0，maximunPoolSize为<code>Integer.MAX_VALUE</code>，阻塞队列为SynchronousQueue。keepAliveTime为60纳秒。</p><p>该类型的特殊之处在于使用了同步阻塞队列，加入队列的任务会马上执行，同步队列中最多只能有一个任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">(ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,<span class="number">60L</span>, TimeUnit.SECONDS,<span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;(),threadFactory);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="execute方法"><a href="#execute方法" class="headerlink" title="execute方法"></a>execute方法</h4><p>execute方法的作用是提交Runnable实例到线程池执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//Runnable实例为null则抛出NPE</span></span><br><span class="line">    <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//获取线程池状态和线程数量</span></span><br><span class="line">    <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断当前线程池线程个数是否小于corePoolSize，小于则新增worker</span></span><br><span class="line">    <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">            <span class="keyword">return</span>;<span class="comment">//新增成功后直接返回</span></span><br><span class="line">        c = ctl.get();<span class="comment">//新增失败则重新获取ctl</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若线程池状态为RUNNING，则任务进入阻塞队列</span></span><br><span class="line">    <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        <span class="comment">//二次检查：添加任务时线程池状态可能已变化</span></span><br><span class="line">        <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">        <span class="comment">//不是RUNNING则从阻塞队列删除任务，并执行拒绝策略</span></span><br><span class="line">        <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        <span class="comment">//worker数量为0则添加一个worker</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">            addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//阻塞队列满则新增worker，新增失败则执行拒绝策略</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">        reject(command);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ThreadPoolExecutor的内部类Worker源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span></span></span><br><span class="line"><span class="class">        <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class">    </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * This class will never be serialized, but we provide a</span></span><br><span class="line"><span class="comment">         * serialVersionUID to suppress a javac warning.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class="line">        <span class="keyword">final</span> Thread thread;</span><br><span class="line">        <span class="comment">/** Initial task to run.  Possibly null. */</span></span><br><span class="line">        Runnable firstTask;</span><br><span class="line">        <span class="comment">/** Per-thread task counter */</span></span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Creates with given first task and thread from ThreadFactory.</span></span><br><span class="line"><span class="comment">         * <span class="doctag">@param</span> firstTask the first task (null if none)</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Worker(Runnable firstTask) &#123;</span><br><span class="line">            setState(-<span class="number">1</span>); <span class="comment">// inhibit interrupts until runWorker</span></span><br><span class="line">            <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">            <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/** Delegates main run loop to outer runWorker  */</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            runWorker(<span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Lock methods</span></span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">        <span class="comment">// The value 0 represents the unlocked state.</span></span><br><span class="line">        <span class="comment">// The value 1 represents the locked state.</span></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">                setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread t;</span><br><span class="line">            <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    t.interrupt();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知，Worker继承自AQS并实现了Runnable接口，是具体承载任务的对象。Worker类实现了简单的不可重入独占锁，state=0表示锁未被获取状态，state=1表示锁已经被获取，state=-1是创建Worker实例默认的状态。</p><p>addWorker与runWorker方法源码分析（有空再看）。</p><h4 id="sumbit方法"><a href="#sumbit方法" class="headerlink" title="sumbit方法"></a>sumbit方法</h4><p>sumbit方法在ThreadPoolExecutor的父抽象类AbstractExecutorService中实现，Runnable或Callable对象被封装为FutureTask对象传入execute方法，最终执行的是FutureTask的run方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class="keyword">null</span>);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Runnable task, T result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">submit</span><span class="params">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (task == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class="line">    execute(ftask);</span><br><span class="line">    <span class="keyword">return</span> ftask;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Runnable runnable, T value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(runnable, value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> &lt;T&gt; <span class="function">RunnableFuture&lt;T&gt; <span class="title">newTaskFor</span><span class="params">(Callable&lt;T&gt; callable)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> FutureTask&lt;T&gt;(callable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="shutdown与shutdownNow"><a href="#shutdown与shutdownNow" class="headerlink" title="shutdown与shutdownNow"></a>shutdown与shutdownNow</h4><ul><li>shutdown方法：调用后线程池状态变为SHUTDOWN，此时拒绝新任务但是处理阻塞队列中的任务。</li><li>shutdownNow方法：调用后线程池状态变为STOP，此时拒绝新任务并抛弃阻塞队列中的任务，同时中断（设置中断标记）正在处理的任务。</li></ul><h4 id="awaitTermination方法"><a href="#awaitTermination方法" class="headerlink" title="awaitTermination方法"></a>awaitTermination方法</h4><p>当线程调用该方法后会被阻塞，直到线程池状态变为TERMINATED才返回，或者等待时间超时才返回。</p><h3 id="为什么不建议使用Executors创建线程池？"><a href="#为什么不建议使用Executors创建线程池？" class="headerlink" title="为什么不建议使用Executors创建线程池？"></a>为什么不建议使用Executors创建线程池？</h3><p>阿里巴巴Java开发手册并发处理部分中，不允许使用 Executors 创建线程池，而是通过 ThreadPoolExecutor 的构造方法，这样的处理方式让写的同学更加明确线程池的运行规则，规避资源耗尽的风险。</p><ul><li><p>newFixedThreadPool和newSingleThreadExecutor:  阻塞队列允许的长度为<code>Integer.MAX_VALUE</code>，可能会堆积大量请求，从而导致OOM。</p></li><li><p>newCachedThreadPool和newScheduledThreadPool:  maximunPoolSize是Integer.MAX_VALUE，可能会创建大量线程，从而导致OOM。</p></li></ul><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p>ScheduledThreadPoolExecutor内部使用DelayQueue来存放任务。</p><h3 id="schedule"><a href="#schedule" class="headerlink" title="schedule"></a>schedule</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,<span class="keyword">long</span> delay,TimeUnit unit) &#123;&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params"><span class="keyword">long</span> delay,TimeUnit unit)</span></span>&#123;&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用是提交一个延迟执行的任务。从提交时间算起，delay时间后开始执行任务，unit为delay的时间单位。任务只执行一次。</p><h3 id="scheduleWithFixedDelay"><a href="#scheduleWithFixedDelay" class="headerlink" title="scheduleWithFixedDelay"></a>scheduleWithFixedDelay</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> delay,TimeUnit unit) &#123;&#125;</span><br></pre></td></tr></table></figure><p>该方法的作用是，当任务执行完毕后，让其延迟固定时间后再次运行(fixed-delay任务)。</p><p>initialDelay表示提交任务后延迟多少时间开始执行任务command，delay表示当任务初次执行完毕后延迟多少时间后再次运行command任务，unit是initialDelay和delay的时间单位。任务会一直重复运行，直到任务运行抛出异常、被取消了、或者关闭了线程池。</p><h3 id="scheduleAtFixedRate"><a href="#scheduleAtFixedRate" class="headerlink" title="scheduleAtFixedRate"></a>scheduleAtFixedRate</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,<span class="keyword">long</span> initialDelay,<span class="keyword">long</span> period,TimeUnit unit) &#123;&#125;</span><br></pre></td></tr></table></figure><p>fixed-rate任务的执行规则为：从提交时间算起，在时间点为initialDealy+n*period(n = 0, 1, 2, 3…)的时刻执行任务。若前一次任务还没执行完毕，下一次任务的执行时刻就到了，则下次任务要等到前一次任务执行完毕后才执行。</p><p>具体执行流程为：当任务提交后，initialDelay时间后执行command，然后在initialDelay+period时刻再次执行，而后在initialDelay+2*period时刻再次执行，循环往复，直到抛出异常、调用了任务的cancel方法取消了任务或关闭了线程池。</p><h2 id="Fork-Join"><a href="#Fork-Join" class="headerlink" title="Fork/Join"></a>Fork/Join</h2><p>Fork/Join框架是Java并发工具包中的一种可以将一个大任务拆分为很多小任务来异步执行的工具，自JDK1.7引入。</p><p>待后续补充。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;FutureTask&quot;&gt;&lt;a href=&quot;#FutureTask&quot; class=&quot;headerlink&quot; title=&quot;FutureTask&quot;&gt;&lt;/a&gt;FutureTask&lt;/h2&gt;&lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerli
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器之并发队列</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8B%E5%B9%B6%E5%8F%91%E9%98%9F%E5%88%97/</id>
    <published>2020-09-27T02:30:32.000Z</published>
    <updated>2020-10-01T09:48:09.289Z</updated>
    
    <content type="html"><![CDATA[<p>JUC提供了一系列场景的并发安全队列，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，后者使用CAS非阻塞算法实现。</p><h2 id="非阻塞队列"><a href="#非阻塞队列" class="headerlink" title="非阻塞队列"></a>非阻塞队列</h2><h3 id="ConcurrentLinkedQueue"><a href="#ConcurrentLinkedQueue" class="headerlink" title="ConcurrentLinkedQueue"></a>ConcurrentLinkedQueue</h3><p>ConcurrentLinkedQueue是线程安全的<strong>无界非阻塞</strong>队列，其底层使用单向链表实现，对于入队和出队操作使用CAS来实现线程安全，因此执行该队列的方法失败不会导致线程阻塞。</p><h4 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ConcurrentLinkedQueue.png" alt=""></p><h4 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认头尾节点都是指向item为null的哨兵节点</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casTail</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, tailOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">casHead</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, headOffset, cmp, val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> headOffset;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> tailOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">        Class&lt;?&gt; k = ConcurrentLinkedQueue<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        headOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"head"</span>));</span><br><span class="line">        tailOffset = UNSAFE.objectFieldOffset</span><br><span class="line">            (k.getDeclaredField(<span class="string">"tail"</span>));</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">volatile</span> E item;</span><br><span class="line">    <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line">    </span><br><span class="line">    Node(E item) &#123;</span><br><span class="line">        UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Unsafe mechanics</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; k = Node<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">            nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h4><ul><li><strong>offer</strong>：通过CAS操作来控制某时只有一个线程可以添加元素到队列末尾，<strong>进行CAS竞争失败的线程会不断自旋，直至成功，其余出入队操作均是如此</strong>。相比阻塞算法，这是使用CPU资源换取阻塞所带来的开销。</li><li><strong>add</strong>：调用offer方法。</li><li><strong>poll</strong>：该方法在移除队首元素时，只是简单地使用CAS操作把节点的item值设置为null，然后重新设置head到下一个节点。移除的对象会在GC时被回收。</li><li><strong>peek</strong>：peek方法的实现与poll类似，只是没有删除步骤。另外，在第一次调用peek操作时，会删除哨兵节点，并让head指向队列的第一个元素或者null。</li><li><strong>size</strong>：该方法遍历链表计数，由于无锁策略，并发环境下结果并不准确。问：为什么不使用一个原子变量count来记录元素个数？因为这需要保证“入队操作+(count++)”或者“出队操作+(count—)”是原子操作，而ConcurrentLinkedQueue采用CAS无阻塞算法无法做到这一点。</li><li><strong>remove</strong>：删除遍历时第一个匹配的元素。</li><li><strong>contains</strong>：遍历链表查找元素，由于无锁策略，该方法并发环境下不准确。</li></ul><h4 id="延迟更新策略"><a href="#延迟更新策略" class="headerlink" title="延迟更新策略"></a>延迟更新策略</h4><p>通过对offer和poll方法的分析，我们发现tail和head是延迟更新的，两者更新触发时机为：</p><ul><li><code>tail更新触发时机</code>：tail的下一个节点不为null时，定位真正的队尾，找到队尾节点并完成插入之后才会通过casTail进行tail更新；<strong>当tail的下一个节点为null时，只插入节点不更新tail。</strong></li><li><code>head更新触发时机</code>：当head的item域为null时，定位真正的队头，找到队头节点并完成删除之后才会通过updateHead进行head更新；<strong>当head的item域不为null时，只删除节点不更新head。</strong></li></ul><p><strong>在高并发写（大量出队入队）的情景下，通过延迟更新head和tail，减少了head和tail更新（CAS自旋）带来的CPU损耗</strong>。</p><h4 id="适用场景"><a href="#适用场景" class="headerlink" title="适用场景"></a>适用场景</h4><p>ConcurrentLinkedQueue通过无锁做到了更高的并发量，在并发量特别大的情况下，是个不错的选择，性能上好很多。</p><h2 id="阻塞队列"><a href="#阻塞队列" class="headerlink" title="阻塞队列"></a>阻塞队列</h2><h3 id="BlockingQueue"><a href="#BlockingQueue" class="headerlink" title="BlockingQueue"></a>BlockingQueue</h3><p>BlockingQueue通常用于生产者消费者场景。</p><p><img src="java-thread-x-blocking-queue-1.png" alt=""></p><p>一个线程将会持续生产新对象并将其插入到队列之中，直到队列达到它所能容纳的临界点。也就是说，它是有限的。如果该阻塞队列到达了其临界点，负责生产的线程将会在往里边插入新对象时发生阻塞。它会一直处于阻塞之中，直到负责消费的线程从队列中拿走一个对象。 负责消费的线程将会一直从该阻塞队列中拿出对象。如果消费线程尝试去从一个空的队列中提取对象的话，这个消费线程将会处于阻塞之中，直到一个生产线程把一个对象丢进队列。</p><h4 id="BlockingQueue常见方法"><a href="#BlockingQueue常见方法" class="headerlink" title="BlockingQueue常见方法"></a>BlockingQueue常见方法</h4><p>BlockingQueue 具有 4 组不同的方法用于插入、移除以及对队列中的元素进行检查。如果请求的操作不能得到立即执行的话，每个方法的表现也不同。这些方法如下:</p><p><img src="BlockingQueue_method.png" alt=""></p><p>四组不同的行为方式解释:</p><ul><li>抛异常: 如果试图的操作无法立即执行，抛一个异常。</li><li>特定值: 如果试图的操作无法立即执行，返回一个特定的值(常常是 true / false)。</li><li>阻塞: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行。</li><li>超时: 如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功(典型的是 true / false)。</li></ul><p>另外，BlockingQueue不接受null值，插入null会导致NullPointerException。</p><h3 id="BlockingDeque"><a href="#BlockingDeque" class="headerlink" title="BlockingDeque"></a>BlockingDeque</h3><p>BlockingDeque是一个双端队列，我们可以从队列两端进行入队和出队操作。该接口继承自BlockingQueue接口。</p><p><img src="java-thread-x-blocking-deque-1.png" alt=""></p><p>在线程既是一个队列的生产者又是这个队列的消费者的时候可以使用到 BlockingDeque。如果生产者线程需要在队列的两端都可以插入数据，消费者线程需要在队列的两端都可以移除数据，这个时候也可以使用 BlockingDeque。</p><h4 id="BlockingDeque常见方法"><a href="#BlockingDeque常见方法" class="headerlink" title="BlockingDeque常见方法"></a>BlockingDeque常见方法</h4><p><img src="BlockingDeque_method.png" alt=""></p><h2 id="BlockingQueue实现类"><a href="#BlockingQueue实现类" class="headerlink" title="BlockingQueue实现类"></a>BlockingQueue实现类</h2><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p><img src="LinkedBlockingQueue_uml.png" alt=""></p><p>LinkedBlockingQueue是一个<strong>有界</strong>链表，创建时可指定容量，默认上限为<code>Integer.MAX_VALUE</code>（没指定就是无界），由原子变量计数器count计数。其内部以 FIFO的顺序对元素进行存储。</p><p>如下图所示：</p><p><img src="LinkedBlockingQueue.png" alt=""></p><p>LinkedBlockingQueue对头、尾节点的操作分别使用了单独的独占锁从而保证了并发下出入队的正确性，竞争锁失败的线程进入相应的AQS阻塞队列。头尾节点的独占锁都有一个自己的条件队列，用于存放队列空(满)时执行take(put)操作的被阻塞的线程。另外，<strong>有两个独占锁意味着该队列可以同时进行出入队操作，因此count必须要使用原子变量</strong>。</p><p>注意：LinkedBlockingQueue的remove方法执行时会同时获取takeLock和putLock。</p><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p><img src="ArrayBlockingQueue_uml.png" alt=""></p><p>ArrayBlockingQueue是一个<strong>有界</strong>数组，创建时必须指定容量，并且一旦指定容量便不能更改。其内部以 FIFO的顺序对元素进行存储。</p><p>如下图所示：</p><p><img src="ArrayBlockingQueue.png" alt=""></p><p>ArrayBlockingQueue只有一个独占锁，这个锁的粒度较大，只要是对数组更改就必须加锁，因此<strong>不能同时进行入队出队操作</strong>。其中offer和poll操作通过简单的加锁实现，而put和take则使用锁加条件变量实现。另外，ArrayBlockingQueue的size方法相比LinkedBlockingQueue则是完全精确的，因为计算前加了全局锁。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p><img src="PriorityBlockQueue_uml.png" alt=""></p><p>PriorityBlockingQueue是一个<strong>无界</strong>二叉堆（数组实现），每次出队的元素都是堆的根节点，保证返回的是优先级最高(低)的元素。 默认使用对象的compareTo方法提供比较规则，因此入队元素必须实现Comparable接口。如果需要自定义比较规则，也可在创建队列时传入Comparator比较器。</p><p>PriorityBlockingQueue的数组是可<strong>自动扩容</strong>的，其默认初始容量为11。当当前元素个数&gt;=容量时会通过CAS算法扩容。allocationSpinLock是个自旋锁，其使用<strong>volatile修饰和CAS操作</strong>来保证同时只有一个线程可以扩容队列，状态为0表示当前没有进行扩容，状态为1表示正在进行扩容。</p><p>如下图所示：</p><p><img src="PriorityBlockingQueue.png" alt=""></p><p>PriorityBlockingQueue只有一个条件变量notEmpty，存放take操作时因队列空而阻塞的线程，因为该队列是无界队列，所以可以一直put，没有notFull条件变量。</p><p>使用案例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PriorityBlockingQueueTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Comparable</span>&lt;<span class="title">Task</span>&gt;</span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">int</span> priority;</span><br><span class="line">        <span class="keyword">private</span> String taskName;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Task</span><span class="params">(<span class="keyword">int</span> priority, String taskName)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.priority = priority;</span><br><span class="line">            <span class="keyword">this</span>.taskName = taskName;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">compareTo</span><span class="params">(Task o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="keyword">this</span>.priority &gt;= o.priority) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">printTask</span><span class="params">()</span></span>&#123;</span><br><span class="line">            System.out.println(taskName + <span class="string">":"</span> + priority);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        PriorityBlockingQueue&lt;Task&gt; priorityBlockingQueue =</span><br><span class="line">                <span class="keyword">new</span> PriorityBlockingQueue&lt;Task&gt;();</span><br><span class="line">        Random random = <span class="keyword">new</span> Random();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            Task task = <span class="keyword">new</span> Task(random.nextInt(<span class="number">10</span>), <span class="string">"taskName"</span>+i);</span><br><span class="line">            priorityBlockingQueue.offer(task);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!priorityBlockingQueue.isEmpty())&#123;</span><br><span class="line">            priorityBlockingQueue.poll().printTask();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">taskName1:1</span><br><span class="line">taskName7:2</span><br><span class="line">taskName4:3</span><br><span class="line">taskName0:3</span><br><span class="line">taskName9:4</span><br><span class="line">taskName5:7</span><br><span class="line">taskName2:8</span><br><span class="line">taskName6:9</span><br><span class="line">taskName8:9</span><br><span class="line">taskName3:9</span><br></pre></td></tr></table></figure><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p><img src="DelayQueue_uml.png" alt=""></p><p>DelayQueue是一个<strong>无界</strong>阻塞延迟队列，队列中的每个元素都有一个过期时间，<strong>每个元素都必须实现<code>java.util.concurrent.Delayed</code>接口</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Delayed</span> <span class="keyword">extends</span> <span class="title">Comparable</span>&lt;<span class="title">Delayed</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">getDelay</span><span class="params">(TimeUnit unit)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>出队时判断元素是否过期，<strong>只有过期元素才会出队列</strong>，队列头元素是最快要过期的元素。</p><p>由类图知，DelayQueue内部使用PriorityQueue存放数据。</p><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。 据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p><h2 id="BlockingDeque实现类"><a href="#BlockingDeque实现类" class="headerlink" title="BlockingDeque实现类"></a>BlockingDeque实现类</h2><h3 id="LinkedBlockingDeque"><a href="#LinkedBlockingDeque" class="headerlink" title="LinkedBlockingDeque"></a>LinkedBlockingDeque</h3><p>BlockingDeque唯一的一个实现类。LinkedBlockingDeque是一个有界链表双端队列，默认容量为<code>Integer.MAX_VALUE</code>。但与LinkedBlockingQueue不同的是，<strong>该队列不能同时进行出入队操作，因为只有一个独占锁</strong>。并且count计数器不是原子变量，size方法会在调用count时加锁，因此该方法返回值是精确的。</p><h2 id="BlockingQueue实现生产者消费者"><a href="#BlockingQueue实现生产者消费者" class="headerlink" title="BlockingQueue实现生产者消费者"></a>BlockingQueue实现生产者消费者</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span></span>&#123;</span><br><span class="line">    <span class="keyword">static</span> BlockingQueue&lt;Integer&gt; blockingQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;Integer&gt;(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Producer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    blockingQueue.put(<span class="number">0</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName()+<span class="string">"生产了"</span>+<span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        BlockingQueue&lt;Integer&gt; blockingQueue;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">Consumer</span><span class="params">(BlockingQueue&lt;Integer&gt; blockingQueue)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.blockingQueue = blockingQueue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">while</span>(!Thread.interrupted())&#123;</span><br><span class="line">                Integer integer = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    integer = blockingQueue.take();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">"消费了"</span> + integer);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Producer producer1 = <span class="keyword">new</span> Producer(blockingQueue);</span><br><span class="line"></span><br><span class="line">        Consumer consumer1 = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line">        Consumer consumer2 = <span class="keyword">new</span> Consumer(blockingQueue);</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newCachedThreadPool();</span><br><span class="line">        executorService.execute(producer1);</span><br><span class="line">        executorService.execute(consumer1);</span><br><span class="line">        executorService.execute(consumer2);</span><br><span class="line"></span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        executorService.shutdownNow();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;JUC提供了一系列场景的并发安全队列，按照实现方式的不同可分为阻塞队列和非阻塞队列，前者使用锁实现，后者使用CAS非阻塞算法实现。&lt;/p&gt;
&lt;h2 id=&quot;非阻塞队列&quot;&gt;&lt;a href=&quot;#非阻塞队列&quot; class=&quot;headerlink&quot; title=&quot;非阻塞队列&quot;&gt;&lt;/
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器之ConcurrentHashMap</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BConcurrentHashMap/</id>
    <published>2020-09-26T09:10:01.000Z</published>
    <updated>2020-10-13T06:34:12.038Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#juc%e9%9b%86%e5%90%88-concurrenthashmap%e8%af%a6%e8%a7%a3" target="_blank" rel="noopener">ConcurrentHashMap详解</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;a href=&quot;https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentHashMap.html#juc%e9%9b%86%e5%90%88-concurrenthashmap
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC容器之CopyOnWriteArrayList</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E5%AE%B9%E5%99%A8%E4%B9%8BCopyOnWriteArrayList/</id>
    <published>2020-09-26T07:50:39.000Z</published>
    <updated>2020-09-27T02:41:51.293Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>CopyOnWriteArrayList是一个线程安全的ArrayList，底层采用<code>private transient volatile Object[] array;</code>存储数据，使用独占锁ReentrantLock保证同时只有一个线程对array进行修改。另外，该类采用了<strong>写时复制策略</strong>，也即<strong>对array的修改操作都是在一个复制的数组上进行的</strong>。</p><h3 id="源码剖析"><a href="#源码剖析" class="headerlink" title="源码剖析"></a>源码剖析</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//默认构造创建大小为0的Object数组</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">()</span> </span>&#123;setArray(<span class="keyword">new</span> Object[<span class="number">0</span>]);&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用传入数组的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(E[] toCopyIn)</span> </span>&#123;</span><br><span class="line">    setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[]<span class="class">.<span class="keyword">class</span>))</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用集合元素的拷贝</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Object[] elements;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArrayList<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">        <span class="title">elements</span> </span>= ((CopyOnWriteArrayList&lt;?&gt;)c).getArray();</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        elements = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> (elements.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">            <span class="title">elements</span> </span>= Arrays.copyOf(elements,elements.length, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    setArray(elements);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="add方法"><a href="#add方法" class="headerlink" title="add方法"></a>add方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;<span class="comment">//获取独占锁</span></span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();<span class="comment">//获取array</span></span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        Object[] newElements = Arrays.copyOf(elements, len + <span class="number">1</span>);<span class="comment">//复制一个新数组</span></span><br><span class="line">        newElements[len] = e;<span class="comment">//在新数组中添加</span></span><br><span class="line">        setArray(newElements);<span class="comment">//将引用指向新数组，旧数组等待GC</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">final</span> Object[] getArray() &#123;</span><br><span class="line">    <span class="keyword">return</span> array;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">setArray</span><span class="params">(Object[] a)</span> </span>&#123;</span><br><span class="line">    array = a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> get(getArray(), index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">get</span><span class="params">(Object[] a, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (E) a[index];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于采用<strong>写时复制策略</strong>，即使我们在调用get方法时没有进行同步，也不会导致获取到错误的值。因为删除操作是在复制的数组上进行的，最后才会将array指向复制的数组。</p><h4 id="set方法"><a href="#set方法" class="headerlink" title="set方法"></a>set方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (oldValue != element) &#123;</span><br><span class="line">            <span class="comment">//在新数组上修改指定位置的元素值并设置新数组到array</span></span><br><span class="line">            <span class="keyword">int</span> len = elements.length;</span><br><span class="line">            Object[] newElements = Arrays.copyOf(elements, len);</span><br><span class="line">            newElements[index] = element;</span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            setArray(elements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="remove方法"><a href="#remove方法" class="headerlink" title="remove方法"></a>remove方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        Object[] elements = getArray();</span><br><span class="line">        <span class="keyword">int</span> len = elements.length;</span><br><span class="line">        E oldValue = get(elements, index);</span><br><span class="line">        <span class="keyword">int</span> numMoved = len - index - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//如果要删除的是最后一个元素</span></span><br><span class="line">        <span class="keyword">if</span> (numMoved == <span class="number">0</span>)</span><br><span class="line">            setArray(Arrays.copyOf(elements, len - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Object[] newElements = <span class="keyword">new</span> Object[len - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//复制前半段</span></span><br><span class="line">            System.arraycopy(elements, <span class="number">0</span>, newElements, <span class="number">0</span>, index);</span><br><span class="line">            <span class="comment">//复制后半段</span></span><br><span class="line">            System.arraycopy(elements, index + <span class="number">1</span>, newElements, index, numMoved);</span><br><span class="line">            <span class="comment">//设置新数组到array</span></span><br><span class="line">            setArray(newElements);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="弱一致性的迭代器"><a href="#弱一致性的迭代器" class="headerlink" title="弱一致性的迭代器"></a>弱一致性的迭代器</h4><p>迭代器的弱一致性是指：返回迭代器后，其他线程对list的增删改对迭代器是不可见的。该容器迭代器源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Iterator&lt;E&gt; <span class="title">iterator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> COWIterator&lt;E&gt;(getArray(), <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">COWIterator</span>&lt;<span class="title">E</span>&gt; <span class="keyword">implements</span> <span class="title">ListIterator</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Object[] snapshot;<span class="comment">//array的快照</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> cursor;<span class="comment">//数组下标</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">COWIterator</span><span class="params">(Object[] elements, <span class="keyword">int</span> initialCursor)</span> </span>&#123;</span><br><span class="line">        cursor = initialCursor;</span><br><span class="line">        snapshot = elements;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasNext</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> cursor &lt; snapshot.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> E <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (! hasNext())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> (E) snapshot[cursor++];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//其他方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，迭代器的snapshot引用指向旧数组，在迭代的过程中如果有其他线程进行增删改，都是在新创建的数组中进行的，它们操作的是不同的两个数组。</p><h3 id="CopyOnWriteArraySet"><a href="#CopyOnWriteArraySet" class="headerlink" title="CopyOnWriteArraySet"></a>CopyOnWriteArraySet</h3><p>该容器底层使用CopyOnWriteArrayList实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> CopyOnWriteArrayList&lt;E&gt; al;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CopyOnWriteArraySet</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (c.getClass() == CopyOnWriteArraySet<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">        CopyOnWriteArraySet&lt;E&gt; cc =</span><br><span class="line">            (CopyOnWriteArraySet&lt;E&gt;)c;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;(cc.al);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        al = <span class="keyword">new</span> CopyOnWriteArrayList&lt;E&gt;();</span><br><span class="line">        al.addAllAbsent(c);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;p&gt;CopyOnWriteArrayList是一个线程安全的ArrayList，底层采用&lt;code&gt;private transient vola
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC之锁</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E9%94%81/</id>
    <published>2020-09-21T05:25:08.000Z</published>
    <updated>2020-10-11T13:11:55.998Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OverView"><a href="#OverView" class="headerlink" title="OverView"></a>OverView</h3><p>锁相关类关系图：</p><p><img src="java-thread-x-juc-overview-lock.png" alt=""></p><h3 id="锁概述"><a href="#锁概述" class="headerlink" title="锁概述"></a>锁概述</h3><h4 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h4><p>乐观锁和悲观锁是在数据库中引入的名词，但是在并发包中也引入了类似的思想，非阻塞同步CAS操作就是乐观的并发策略，阻塞同步synchronized就是悲观的并发策略。</p><p>悲观锁指对数据被外界修改持保守态度，在数据被处理前先加锁，提交事务后才释放锁。悲观锁的实现往往依靠数据库提供的锁机制。</p><p>乐观锁则认为数据在一般情况下不会造成冲突，访问数据前不加锁，在事务提交时才检测是否存在冲突。乐观锁的实现一般是在表中添加version字段或者使用业务状态。</p><h4 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h4><p>公平锁表示线程获取锁的顺序是按照线程请求锁的时间顺序来决定，而非公平锁则按调度策略决定。在没有公平性需求的前提下尽量使用非公平锁，因为公平锁开销较大。</p><p>ReentrantLock提供了公平锁和非公平锁。</p><p>公平锁：<code>ReentrantLock pairLock = new ReentrantLock(true);</code></p><p>非公平锁：<code>ReentrantLock pairLock = new ReentrantLock(false);</code>。如果构造函数不传递参数，则默认为false。</p><h4 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h4><p>根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。</p><p>独占锁保证任何时候都只有一个线程能得到锁，ReentrantLock就是独占锁。独占锁是一种悲观锁，由于读操作并不会影响数据的一致性，而独占锁只允许同一时间由一个线程读取数据，因此限制了并发性。</p><p>共享锁则可以同时多个线程持有，例如ReadWriteLock。共享锁是一种乐观锁，它允许多个线程同时进行读操作。</p><h4 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h4><p>一个线程再次获取它自己已经获取的锁时不会被阻塞，那么该锁就是可重入锁。synchronized锁和ReentrantLock均为可重入锁。</p><p>可重入锁的原理是在锁内部维护一个线程标识和一个计数器。计数器初始值为0，说明该锁没有被任何线程占用。当一个线程获取了该锁，计数器值+1。当获取了该锁的线程再次获取锁时发现线程标识是自己，计数器值再+1。释放一次锁则计数器值-1。当计数器值为0时，线程标识置null，阻塞线程被唤醒竞争该锁。</p><h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>自旋锁的思想是<strong>让一个线程在请求一个共享数据的锁时执行忙循环</strong>（自旋）一段时间，如果在这段时间内能获得锁，就可以避免进入阻塞状态。可以通过<code>-XX:PreBlockSpinsh</code>设置尝试次数，默认为10次。</p><p>JDK层面的锁由java.util.concurrent.locks包提供，其接口和类如下图所示：</p><p><img src="juc_locks.png" alt=""></p><h3 id="LockSupport"><a href="#LockSupport" class="headerlink" title="LockSupport"></a>LockSupport</h3><p>LockSupport类是个工具类，其主要作用是挂起和唤醒线程，它是创建锁和其他同步类的基础。</p><p>LockSupport类与每个使用它的线程都会关联一个许可证，在默认情况下调用LockSupport的方法的线程是<strong>不</strong>持有许可证的。该类是使用Unsafe类实现的。</p><p>LockSupport的构造方法为私有构造方法，无法被实例化，其方法基本为静态方法。</p><h4 id="Unsafe的park和unpark方法"><a href="#Unsafe的park和unpark方法" class="headerlink" title="Unsafe的park和unpark方法"></a>Unsafe的park和unpark方法</h4><p>因为LockSupport的核心函数都是基于Unsafe类中定义的park和unpark函数，下面给出两个函数的定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> isAbsolute, <span class="keyword">long</span> time)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">unpark</span><span class="params">(Thread thread)</span></span>;</span><br></pre></td></tr></table></figure><p>对两个函数的说明如下:</p><ul><li>park函数，阻塞线程，并且该线程在下列情况发生之前都会被阻塞: ① 调用unpark函数，给予该线程许可。② 该线程被中断。③ 设置的时间到了。并且，当time为绝对时间时，isAbsolute为true，否则，isAbsolute为false。当time为0时，表示无限等待，直到unpark发生。</li><li>unpark函数，给予线程许可，即激活调用park后阻塞的线程。这个函数不是安全的，调用这个函数时要确保线程依旧存活。</li></ul><h4 id="park"><a href="#park" class="headerlink" title="park()"></a>park()</h4><p>初次调用该方法后，当前线程挂起。</p><p>由于可能存在虚假唤醒的情况，所以调用时最好也使用循环条件判断方式。</p><p>如当前线程被其他线程中断，不会抛出InterruptedException。</p><h4 id="park-Object-blocker"><a href="#park-Object-blocker" class="headerlink" title="park(Object blocker)"></a>park(Object blocker)</h4><p>Thread类中有个变量<code>volatile Object parkBlocker</code>，用于存放该方法传递的blocker对象，也就是把blocker变量存放到了调用该方法的线程成员变量中。</p><p>使用该类的好处是，方便使用诊断工具查看阻塞原因。</p><h4 id="parkNanos-long-nanos"><a href="#parkNanos-long-nanos" class="headerlink" title="parkNanos(long nanos)"></a>parkNanos(long nanos)</h4><p>与park()的不同仅在于会在nanos时间之后自动返回。</p><h4 id="parkUntil-Object-blocker-long-deadline"><a href="#parkUntil-Object-blocker-long-deadline" class="headerlink" title="parkUntil(Object blocker, long deadline)"></a>parkUntil(Object blocker, long deadline)</h4><p>在指定的时间内阻塞线程。deadline单位是ms，表示从1970到未来某个时刻的总毫秒数。</p><h4 id="unpark-Thread-thread"><a href="#unpark-Thread-thread" class="headerlink" title="unpark(Thread thread)"></a>unpark(Thread thread)</h4><p>调用该方法后，如果线程没有持有与LockSupport关联的许可证，则使shi线程持有。如果线程已经因park()而挂起，则唤醒线程。若unpark()调用前未调用过park()，那么由于线程持有许可证，再次调用park()后线程不会挂起并失去许可证。</p><p>注意：park()方法不会释放锁，ConditionObject的await()会释放锁，并且该await()方法挂起线程就是使用park()实现的。</p><h3 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h3><p>AQS全称抽象队列同步器(AbstractQueuedSynchronizer)，它是实现JDK层面锁的基础组件，locks包ReentrantLock和ReentrantReadWriteLock均由AQS实现，同时CountDownLatch与Semaphore也是由AQS实现。</p><h4 id="类图结构"><a href="#类图结构" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="AQS_UML.png" alt=""></p><p>由该图可知AQS继承自AbstractOwnableSynchronizer，并有内部类ConditionObject和Node。AQS的核心是<strong>state变量</strong>与<strong>队列</strong>，它的所有实现类都是围绕着对此二者的操作来进行的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node head;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node tail;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> state;</span><br></pre></td></tr></table></figure><h4 id="AQS概述"><a href="#AQS概述" class="headerlink" title="AQS概述"></a>AQS概述</h4><h5 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h5><p>AQS是一个FIFO的双向队列，该队列用于<strong>存放竞争资源失败的线程</strong>，队列元素为Node。Node中的thread变量用来存放进入AQS队列的线程，<strong>SHARED</strong>用于<strong>标记线程是获取共享资源时失败而放入AQS队列</strong>的，<strong>EXCLUSIVE</strong>则用于<strong>标记线程是获取独占资源时失败而放入AQS队列的</strong>，<strong>waitStatus</strong>记录<strong>线程等待状态</strong>，可以取如下值：</p><ol><li><strong>SIGNAL=-1</strong>：线程需要被唤醒。</li><li><strong>CONDITION=-2</strong>：线程在条件队列(ConditionObject)中等待，而非AQS队列。</li><li><strong>CANCELLED=1</strong>：线程被取消了。</li><li><strong>PROPAGATE=-3</strong>：释放共享资源时需要通知其他节点。</li><li>0：线程新加入队列。</li></ol><h5 id="state变量"><a href="#state变量" class="headerlink" title="state变量"></a>state变量</h5><p>在AQS中维持了一个状态值state变量，<strong>AQS的不同实现中对state含义的定义均不同</strong>。JUC中的实现主要如下：</p><ol><li>ReentrantLock：state为0表示没有线程获取锁，大于1的整数表示线程获取锁的可重入次数。</li><li>ReentrantReadWriteLock：state的高16位表示读锁的的个数，低16位表示线程获取写锁的可重入次数。</li><li>Semaphore：state表示当前可用信号的个数。</li><li>CountDownLatch：state表示计数器当前的值。</li></ol><p>操作state的方式分为<strong>独占方式</strong>和<strong>共享方式</strong>，两种方式获取和释放资源使用的方法分别为：</p><ul><li>独占：void acquire(int arg);  void acquireInterruptibly(int arg);  boolean release(int arg)。</li><li>共享：void acquireShared(int arg);  void acquireSharedInterruptibly(int arg);  boolean release(int arg)。</li></ul><p>在上述方法中调用了一系列<strong>需要实现类自己实现的模板方法</strong>，一共有以下五个：</p><p><img src="template_method.png" alt=""></p><h4 id="锁的底层支持"><a href="#锁的底层支持" class="headerlink" title="锁的底层支持"></a>锁的底层支持</h4><h5 id="AbstractOwnableSynchronizer"><a href="#AbstractOwnableSynchronizer" class="headerlink" title="AbstractOwnableSynchronizer"></a>AbstractOwnableSynchronizer</h5><p>该抽象类中定义了一个变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread exclusiveOwnerThread;</span><br></pre></td></tr></table></figure><p>表示<strong>独占模式下当前占有锁和资源的线程</strong>。</p><h5 id="独占锁-ReentrantLock与WriteLock"><a href="#独占锁-ReentrantLock与WriteLock" class="headerlink" title="独占锁-ReentrantLock与WriteLock"></a>独占锁-ReentrantLock与WriteLock</h5><p>对于AQS独占锁，当多个线程同时调用lock.lock()获取锁，只有一个线程获取到锁，其他线程会被转换为Node节点插入到lock锁对应的AQS队列中，并做自旋CAS尝试获取锁，尝试失败后阻塞。“自旋CAS/阻塞”的操作在acquireQueued()和doAcquire*()系列方法中实现。</p><p>线程通过调用acquire(int arg)获取独占资源，<strong>void acquire(int arg)源码</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>tryAcquire()尝试CAS修改state值获取锁，若成功则表达式<code>!tryAcquire(arg)</code>为false，&amp;&amp;后的表达式无需继续执行，方法直接结束；若失败，则addWaiter()将当前线程封装为类型为NODE.EXCLUSIVE的Node节点插入AQS队列末尾，acquireQueued()方法中节点自旋CAS尝试获取锁，失败则阻塞。</p><p><strong>addWaiter方法源码</strong>如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">//判断尾节点是否为null</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                <span class="comment">//通过CAS完成“tail = node”操作</span></span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="comment">//如果tail为null, 说明当前节点为AQS队列第一个节点，再调用enq入AQS队列</span></span><br><span class="line">    <span class="comment">//或CAS设置tail失败，调用enq方法重新入队</span></span><br><span class="line">        enq(node);</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>enq方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node t = tail;</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123; <span class="comment">// Must initialize</span></span><br><span class="line">                <span class="comment">//tail为空则设置当前节点为头(尾)节点</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                    tail = head;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//addWaiter中CAS设置tail失败，说明有其他线程竞争进入AQS队列</span></span><br><span class="line">                <span class="comment">//由for循环知，该方法会不断自旋直到当前节点入队成功</span></span><br><span class="line">                node.prev = t;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                    t.next = node;</span><br><span class="line">                    <span class="keyword">return</span> t;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>acquireQueued方法源码</strong>如下:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前节点的前驱节点</span></span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="comment">//只有当前节点是队列中第二个节点时才重新tryAcquire</span></span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    <span class="comment">//满足一定条件则阻塞当前线程，停止自旋</span></span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>shouldParkAfterFailedAcquire方法和parkAndCheckInterrupt方法源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = pred.waitStatus;<span class="comment">//获取前驱节点的等待状态</span></span><br><span class="line">        <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This node has already set status asking a release</span></span><br><span class="line"><span class="comment">             * to signal it, so it can safely park.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;<span class="comment">//只有当前驱节点等待状态为SIGNAL时才能阻塞当前线程</span></span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;<span class="comment">//取消前驱节点，跳过</span></span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * Predecessor was cancelled. Skip over predecessors and</span></span><br><span class="line"><span class="comment">             * indicate retry.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                node.prev = pred = pred.prev;</span><br><span class="line">            &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">            pred.next = node;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * waitStatus must be 0 or PROPAGATE.  Indicate that we</span></span><br><span class="line"><span class="comment">             * need a signal, but don't park yet.  Caller will need to</span></span><br><span class="line"><span class="comment">             * retry to make sure it cannot acquire before parking.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">            <span class="comment">//设置前驱节点的等待状态为SIGNAL，下一次当前节点线程就会阻塞，说明只会自旋一次</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">parkAndCheckInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//shouldParkAfterFailedAcquire返回true，阻塞当前线程，停止自旋，被唤醒后继续执行for循环</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">return</span> Thread.interrupted();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>接下来讲release方法，该方法释放独占方式获取的锁和资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="comment">//释放成功并且头节点不为空，头节点等待状态不为0</span></span><br><span class="line">            <span class="comment">//则唤醒后继节点</span></span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="共享锁-ReadLock"><a href="#共享锁-ReadLock" class="headerlink" title="共享锁-ReadLock"></a>共享锁-ReadLock</h5><p>线程通过调用acquireShared方法获取共享资源：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知，共享方式与独占方式实现类似。tryAcquireShared成功则直接返回，失败则入AQS阻塞队列尾部，自旋一次后阻塞挂起自己。releaseShared源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>释放锁成功则调用doReleaseShared唤醒阻塞队列的<strong>所有</strong>线程。</p><h4 id="条件变量ConditionObejct"><a href="#条件变量ConditionObejct" class="headerlink" title="条件变量ConditionObejct"></a>条件变量ConditionObejct</h4><p>ConditionObject实现了Condition接口，是AQS的内部类，其含义是<strong>条件变量</strong>，用于<strong>结合锁实现同步</strong>。</p><p>ConditionObject通过AQS锁对象的newCondition()创建(该方法是Lock接口的方法，需要实现类实现)，它可以直接访问AQS对象内部的变量，比如state值和队列。<strong>每个ConditionObject对应一个条件队列</strong>（单向链表队列），用于<strong>存放调用await()方法后被阻塞的线程</strong>，而signal()/signalAll()方法用于唤醒条件队列中阻塞的线程并将节点加入AQS队列。条件队列的队头、尾分别为firstWaiter和lastWaiter。</p><p>与synchronized内置锁不同，synchronized只能与一个共享变量的wait()或notify()方法实现同步，而AQS实现的<strong>一个锁可以创建多个ConditionObject</strong>。与wait()和notify()类似，<strong>调用条件变量的await()和signal()之前，必须先获取条件变量对应的锁</strong>，否则也会抛出IllegalMonitorStateException。条件变量使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">        Condition condition = lock.newCondition();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="string">"begin wait"</span>);</span><br><span class="line">                condition.await();</span><br><span class="line">                System.out.println(<span class="string">"end wait"</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                lock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(()-&gt;&#123;</span><br><span class="line">            lock.lock();</span><br><span class="line">            System.out.println(<span class="string">"begin signal"</span>);</span><br><span class="line">            condition.signal();</span><br><span class="line">            System.out.println(<span class="string">"end signal"</span>);</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;).start();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">begin wait</span><br><span class="line">begin signal</span><br><span class="line">end signal</span><br><span class="line">end wait</span><br></pre></td></tr></table></figure><p>注意，<strong>await()方法会释放锁</strong>，而<strong>signal()方法不会释放锁</strong>，<strong>必须手动调用锁对象的unlock()方法</strong>释放锁。await()源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="comment">//创建类型为Node.CONDITION的节点并加入条件队列</span></span><br><span class="line">    Node node = addConditionWaiter();</span><br><span class="line">    <span class="comment">//释放当前线程的锁</span></span><br><span class="line">    <span class="keyword">int</span> savedState = fullyRelease(node);</span><br><span class="line">    <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;</span><br><span class="line">        <span class="comment">//阻塞当前线程</span></span><br><span class="line">        LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> ((interruptMode =</span><br><span class="line">             checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//线程被唤醒后在AQS队列中，自旋CAS尝试获取锁</span></span><br><span class="line">    <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">        interruptMode = REINTERRUPT;</span><br><span class="line">    <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">        unlinkCancelledWaiters();</span><br><span class="line">    <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">        reportInterruptAfterWait(interruptMode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用await()后，在内部会构造一个类型为Node.CONDITION的节点并插入条件队列末尾，之后当前线程会释放锁（修改state的值），然后通过LockSupport阻塞当前线程。另一个线程调用signal()后，<strong>条件队列队头节点出队放入AQS队列的队尾，然后唤醒线程</strong>，该线程继续执行await()方法中<code>LockSupport.park(this)</code>之后的代码，调用acquireQueued()方法<strong>自旋CAS尝试获取锁</strong>。</p><p>最后总结如下图：一个锁对应一个AQS队列，对应多个条件变量，每个条件变量有自己的一个条件队列。</p><p><img src="AQS.png" alt=""></p><h3 id="ReentrantLock详解"><a href="#ReentrantLock详解" class="headerlink" title="ReentrantLock详解"></a>ReentrantLock详解</h3><h4 id="类图结构-1"><a href="#类图结构-1" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ReentrantLock_UML.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync = <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法可知，默认是创建非公平锁。</p><h4 id="获取锁"><a href="#获取锁" class="headerlink" title="获取锁"></a>获取锁</h4><h5 id="void-lock-方法"><a href="#void-lock-方法" class="headerlink" title="void lock()方法"></a>void lock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;sync.lock();&#125;</span><br><span class="line"><span class="comment">//非公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取锁成功则设置当前线程为独占线程，失败则调用AQS的acquire方法</span></span><br><span class="line">    <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>))</span><br><span class="line">        setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        acquire(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> nonfairTryAcquire(acquires);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">nonfairTryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//非公平锁的体现：如果state为0，不考虑是否有前驱节点，直接CAS获取锁</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">         &#125;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">         <span class="comment">//state不为0，但是当前线程是独占线程，则仅仅+1</span></span><br><span class="line">         <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">         <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">             <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">         setState(nextc);</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;acquire(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//公平锁体现：先检测是否有前驱节点</span></span><br><span class="line">        <span class="keyword">if</span> (!hasQueuedPredecessors() &amp;&amp;</span><br><span class="line">            compareAndSetState(<span class="number">0</span>, acquires)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class="line">        <span class="keyword">int</span> nextc = c + acquires;</span><br><span class="line">        <span class="keyword">if</span> (nextc &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">        setState(nextc);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="void-lockInterruptibly-方法"><a href="#void-lockInterruptibly-方法" class="headerlink" title="void lockInterruptibly()方法"></a>void lockInterruptibly()方法</h5><p>该方法对中断进行响应，也即当前线程调用该方法时，如果其他线程调用了当前线程的interrupt方法，则当前线程会抛出InterruptedException异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lockInterruptibly</span><span class="params">()</span> </span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"></span>&#123;sync.acquireInterruptibly(<span class="number">1</span>);&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">        doAcquireInterruptibly(arg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="boolean-tryLock-方法"><a href="#boolean-tryLock-方法" class="headerlink" title="boolean tryLock()方法"></a>boolean tryLock()方法</h5><p>尝试获取锁。若该方法失败当前线程不会入AQS队列，也不会阻塞。</p><h4 id="释放锁"><a href="#释放锁" class="headerlink" title="释放锁"></a>释放锁</h4><h5 id="void-unlock-方法"><a href="#void-unlock-方法" class="headerlink" title="void unlock()方法"></a>void unlock()方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    sync.release(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c = getState() - releases;</span><br><span class="line">    <span class="keyword">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">    <span class="keyword">boolean</span> free = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>) &#123;</span><br><span class="line">        free = <span class="keyword">true</span>;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    setState(c);</span><br><span class="line">    <span class="keyword">return</span> free;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="ReentrantReadWriteLock详解"><a href="#ReentrantReadWriteLock详解" class="headerlink" title="ReentrantReadWriteLock详解"></a>ReentrantReadWriteLock详解</h3><p>ReentrantReadWriteLock采用读写分离的策略，允许多个线程同时获取读锁，来满足实际中写少读多的场景。</p><h4 id="类图结构-2"><a href="#类图结构-2" class="headerlink" title="类图结构"></a>类图结构</h4><p><img src="ReentrantReadWriteLock_UML.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(<span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ReentrantReadWriteLock</span><span class="params">(<span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">    sync = fair ? <span class="keyword">new</span> FairSync() : <span class="keyword">new</span> NonfairSync();</span><br><span class="line">    readerLock = <span class="keyword">new</span> ReadLock(<span class="keyword">this</span>);</span><br><span class="line">    writerLock = <span class="keyword">new</span> WriteLock(<span class="keyword">this</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由构造方法可知，默认创建非公平锁。</p><p>读写锁的内部维护了一个<em>ReadLock</em>和一个<em>WriteLock</em>，它们依赖继承自AQS的Sync实现具体功能。读写锁使用state的高16位表示读状态，也即读锁线程个数；低16位表示写锁的可重入次数。Sync类源码表现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;<span class="comment">//偏移值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//低16位为0，第17位为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"></span><br><span class="line"><span class="comment">//读锁线程最大个数65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//低15位为1</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//无符号右移16位，低16位变为原高16位值，原高16位填0</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//按位与运算使高17位为0，低15位不变</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; </span><br><span class="line">    <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，通过<strong>无符号右移</strong>获取读锁线程个数，通过<strong>与掩码按位与</strong>获取写锁可重入次数。</p><h4 id="写锁"><a href="#写锁" class="headerlink" title="写锁"></a>写锁</h4><h5 id="下面只介绍tryAcquire方法"><a href="#下面只介绍tryAcquire方法" class="headerlink" title="下面只介绍tryAcquire方法"></a>下面只介绍tryAcquire方法</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">    Thread current = Thread.currentThread();</span><br><span class="line">    <span class="keyword">int</span> c = getState();<span class="comment">//获取state</span></span><br><span class="line">    <span class="keyword">int</span> w = exclusiveCount(c);<span class="comment">//获取写锁可重入次数</span></span><br><span class="line">    <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;<span class="comment">//说明读锁或写锁已被某线程获取</span></span><br><span class="line">        <span class="comment">//w=0说明有线程获取了读锁，w!=0并且当前线程不是写锁拥有者则返回</span></span><br><span class="line">        <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="comment">//说明当前线程获取了写锁，判断可重入次数是否超过最大值</span></span><br><span class="line">        <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">         setState(c + acquires);<span class="comment">//state+1</span></span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">     &#125;</span><br><span class="line">    <span class="comment">//c=0则根据writerShouldBlock的返回值判断是否执行CAS获取写锁</span></span><br><span class="line">     <span class="keyword">if</span> (writerShouldBlock() ||!compareAndSetState(c, c + acquires))</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">     setExclusiveOwnerThread(current);</span><br><span class="line">     <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于writerShouldBlock，非公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//公平锁实现</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> hasQueuedPredecessors();<span class="comment">//判断是否有前驱节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意：ReentrantReadWriteLock在采用非公平锁并且在读多写少的情况下，容易导致写线程饥饿。可以使用公平锁或者采用<em>StampedLock</em>。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OverView&quot;&gt;&lt;a href=&quot;#OverView&quot; class=&quot;headerlink&quot; title=&quot;OverView&quot;&gt;&lt;/a&gt;OverView&lt;/h3&gt;&lt;p&gt;锁相关类关系图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;java-thread-x-juc-ov
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
  <entry>
    <title>JUC之原子包</title>
    <link href="http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/"/>
    <id>http://thmasterplan.cn/Java%E5%B9%B6%E5%8F%91/JUC%E4%B9%8B%E5%8E%9F%E5%AD%90%E5%8C%85/</id>
    <published>2020-09-19T11:56:16.000Z</published>
    <updated>2020-09-27T02:52:28.747Z</updated>
    
    <content type="html"><![CDATA[<h3 id="CAS操作"><a href="#CAS操作" class="headerlink" title="CAS操作"></a>CAS操作</h3><h4 id="CAS（Compare-And-Swap）"><a href="#CAS（Compare-And-Swap）" class="headerlink" title="CAS（Compare-And-Swap）"></a>CAS（Compare-And-Swap）</h4><p>比较并交换(Compare-and-Swap，CAS)是硬件支持的原子性操作之一。 CAS 指令有 3 个操作数，分别是内存地址 V、旧的值 A 和新值 B。当CAS指令执行时，<strong>只有当 V 的值等于旧值A，才将 V 的值更新为 B</strong>。简单来说，就是CAS操作执行时，要检测旧值是否发生变化，如果变化了则不更新，没有变化才更新。<strong>CAS指令从硬件上保证了对单个变量的“读取-修改-写回”的原子性</strong>，因此多线程并发时使用CAS更新单个变量时不需要锁，JDK中大量使用了CAS来更新数据。</p><h4 id="CAS使用示例：AtomicInteger"><a href="#CAS使用示例：AtomicInteger" class="headerlink" title="CAS使用示例：AtomicInteger"></a>CAS使用示例：AtomicInteger</h4><p>java.util.concurrent.atomic包中的整数原子类AtomicInteger，其中的修改变量值的方法都采用了Unsafe类的CAS方法。以下代码使用了AtomicInteger执行了自增的操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add0</span><span class="params">()</span></span>&#123;count.incrementAndGet();&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add1</span><span class="params">()</span></span>&#123;count.getAndIncrement();&#125;</span><br></pre></td></tr></table></figure><p>以下代码是AtomicInteger中上述两个自增方法的源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>它们均调用了Unsafe类的getAndAddInt()，其源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAddInt</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">int</span> var4)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> var5;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        var5 = <span class="keyword">this</span>.getIntVolatile(var1, var2);</span><br><span class="line">    &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapInt(var1, var2, var5, var5 + var4));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> var5;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>参数的含义分别是：var1指示对象的起始内存地址，var2指示该字段相对对象内存地址的偏移，var1和var2决定了对象在内存中的位置。var4指示需要加的值，此处为1。</p><p>通过 getIntVolatile(var1, var2) 得到对象的旧值，通过调用 compareAndSwapInt() 来进行 CAS 比较，如果该字段内存地址中的值等于 var5(即没有被改变)，那么就更新内存地址为 var1+var2 的变量为 var5+var4。其中 compareAndSwapInt() 方法在Unsafe类中是native方法。我们注意到该方法在while循环中不断执行，对应的逻辑就是<strong>“如果发生冲突则不断尝试执行CAS操作”，这就是基于冲突检测的乐观并发策略</strong>。</p><p>最后需要注意的是，getAndAddInt()方法返回了var5，该值是<strong>旧值</strong>。其实add0和add1方法的执行效果是一样的，都是整数原子对象的值+1，由于incrementAndGet()和getAndIncrement()的返回值是整型，而前者的返回值比后者大1，因此容易误会。<strong>注意整数原子对象的值+1与它们的返回值无关，它的值是通过CAS操作直接修改的！</strong></p><h4 id="CAS的问题"><a href="#CAS的问题" class="headerlink" title="CAS的问题"></a>CAS的问题</h4><h5 id="ABA问题"><a href="#ABA问题" class="headerlink" title="ABA问题"></a>ABA问题</h5><p>如果一个变量初次读取的时候是A值，并且准备赋值时检测到其仍然是A值，那么我们能说它的值没有被其他线程修改过吗？</p><p>如果这段时间它的值曾被其他线程修改为B，后来又被改回了A，那么CAS操作就会误认为它从未改变过，该漏洞称为“ABA”问题。J.U.C包为了解决该问题，提供了一个带有时间戳的原子引用类AtomicStampedReference。不过绝大部分情况ABA问题并不会影响程序开发的正确性，因此该类不常使用。</p><h5 id="若自旋时间过长则开销大"><a href="#若自旋时间过长则开销大" class="headerlink" title="若自旋时间过长则开销大"></a>若自旋时间过长则开销大</h5><p>如果自旋CAS长时间不成功，那么它会一直占用CPU资源。</p><h5 id="只能保证单个共享变量的原子操作"><a href="#只能保证单个共享变量的原子操作" class="headerlink" title="只能保证单个共享变量的原子操作"></a>只能保证单个共享变量的原子操作</h5><p>如果要保证对多个共享变量操作的原子性，可以将多个共享变量放入AtomicReference对象中，来保证原子性。</p><h3 id="Unsafe类"><a href="#Unsafe类" class="headerlink" title="Unsafe类"></a>Unsafe类</h3><p>JDK中的rt.jar中sun.misc包中的<em>Unsafe</em>类提供了硬件级别的原子性操作，<em>Unsafe</em>类中的方法绝大部分都是native方法，它们使用JNI访问本地C++实现库。</p><p>Unsafe类主要提供一些用于执行低级别、不安全操作的方法，如直接访问系统内存资源、自主管理内存资源等，这些方法在提升Java运行效率、增强Java语言底层资源操作能力方面起到了很大的作用。但由于Unsafe类使Java语言拥有了类似C语言指针一样操作内存空间的能力，这无疑也增加了程序发生相关指针问题的风险。因此JDK开发组限制了开发人员通过一般方式使用Unsafe类，比如如下代码会报异常：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">priavte <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br></pre></td></tr></table></figure><p>J.U.C中原子类获取Unsafe对象就是如此，Unsafe类提供静态方法getUnsafe()返回Unsafe对象，但是如果<strong>在用户程序中这样写就会报异常</strong>。原因在于getUnsafe()方法源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取调用该方法的类的Class对象</span></span><br><span class="line">    Class var0 = Reflection.getCallerClass();</span><br><span class="line">    <span class="comment">//判断是不是BootstrapClassLoader加载的该类</span></span><br><span class="line">    <span class="keyword">if</span> (!VM.isSystemDomainLoader(var0.getClassLoader())) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> theUnsafe;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//sun.misc包下的VM类</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSystemDomainLoader</span><span class="params">(ClassLoader var0)</span></span>&#123;<span class="keyword">return</span> var0 == <span class="keyword">null</span>;&#125;</span><br></pre></td></tr></table></figure><p>显然由于用户类是由AppClassLoader加载的，因此会报异常。</p><p>要想使用Unsafe类，可以使用反射来获取unsafe对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    Field field = Unsafe.class.getDeclaredField("thUnsafe");</span><br><span class="line">    </span><br><span class="line">    field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">    </span><br><span class="line">    unsafe = (Unsafe) field.get(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>Unsafe</em>类总体功能如下：</p><p><img src="java-thread-x-atomicinteger-unsafe.png" alt=""></p><p>其中原子操作只支持如下三个方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapObject</span><span class="params">(Object paramObject1, <span class="keyword">long</span> paramLong, Object paramObject2, Object paramObject3)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapInt</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong, <span class="keyword">int</span> paramInt1, <span class="keyword">int</span> paramInt2)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object paramObject, <span class="keyword">long</span> paramLong1, <span class="keyword">long</span> paramLong2, <span class="keyword">long</span> paramLong3)</span></span>;</span><br></pre></td></tr></table></figure><p>其余关于CAS的常用方法有：getAndAddInt, getAndAddLong, getAndSetInt, getAndSetLong, getAndSetObject。</p><h3 id="原子包"><a href="#原子包" class="headerlink" title="原子包"></a>原子包</h3><p>原子包即java.util.concurrent.atomic包，它包含了一系列的原子性操作类，这些类都是使用非阻塞算法CAS实现的。一共有如下类：</p><p><img src="juc_atomic.png" alt=""></p><h4 id="AtomicInteger"><a href="#AtomicInteger" class="headerlink" title="AtomicInteger"></a>AtomicInteger</h4><p>依旧以AtomicInteger为例，其余原子类原理类似。</p><h5 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h5><p>public final int get()：获取当前值<br>public final int getAndSet(int newValue)：获取当前值，并设置新值<br>public final int getAndIncrement()：获取当前值，并自增<br>public final int getAndDecrement()：获取当前值，并自减<br>public final int getAndAdd(int delta)：获取当前值，并加上预期的值<br>void lazySet(int newValue): 最终会设置成newValue, 使用lazySet设置值后，可能导致其他线程在之后的一小段时间内还是可以读到旧的值。</p><h5 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h5><p>以下为部分源码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicInteger</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//用于获取value字段相对当前对象的“起始地址”的偏移量</span></span><br><span class="line">            valueOffset = unsafe.objectFieldOffset(AtomicInteger.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//返回当前值</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//递增加detla</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">getAndAdd</span><span class="params">(<span class="keyword">int</span> delta)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//三个参数，1、当前的实例 2、value实例变量的偏移量 3、当前value要加上的数(value+delta)。</span></span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddInt(<span class="keyword">this</span>, valueOffset, delta);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知：使用volatile修饰变量，保证了变量的可见性与有序性；使用CAS操作变量，保证了操作的原子性。因此最终效果与使用synchronized一致。</p><h4 id="原子更新基本类型"><a href="#原子更新基本类型" class="headerlink" title="原子更新基本类型"></a>原子更新基本类型</h4><ul><li><p>AtomicBoolean</p></li><li><p>AtomicInteger</p></li><li><p>AtomicLong</p></li></ul><p>上述三个原子类类似。</p><h4 id="原子更新数组"><a href="#原子更新数组" class="headerlink" title="原子更新数组"></a>原子更新数组</h4><p>使更新数组的某个元素满足原子性</p><ul><li>AtomicIntegerArray: 原子更新整型数组里的元素。</li><li>AtomicLongArray: 原子更新长整型数组里的元素。</li><li>AtomicReferenceArray: 原子更新引用类型数组里的元素。</li></ul><h4 id="原子更新引用类型"><a href="#原子更新引用类型" class="headerlink" title="原子更新引用类型"></a>原子更新引用类型</h4><ul><li>AtomicReference: 原子更新引用类型。</li><li>AtomicStampedReference: 原子更新引用类型, 内部使用Pair来存储元素值及其版本号。</li><li>AtomicMarkableReference: 原子更新带有标记位的引用类型。</li></ul><h4 id="原子更新Field"><a href="#原子更新Field" class="headerlink" title="原子更新Field"></a>原子更新Field</h4><ul><li>AtomicIntegerFieldUpdater: 原子更新整型的字段的更新器。</li><li>AtomicLongFieldUpdater: 原子更新长整型字段的更新器。</li><li>AtomicReferenceFieldUpdater: 原子更新引用类型字段的更新器。</li></ul><p>这三个类均为抽象类，使用方式都差不多，是基于反射的原子更新字段的值。要想原子地更新字段类需要两步:</p><ul><li>第一步，因为原子更新字段类都是抽象类，每次使用的时候必须使用静态方法newUpdater()创建一个更新器，并且需要设置想要更新的类和属性。</li><li>第二步，更新类的字段必须使用public volatile修饰。</li></ul><h4 id="JDK8新增的原子操作类LongAdder和DoubleAdder"><a href="#JDK8新增的原子操作类LongAdder和DoubleAdder" class="headerlink" title="JDK8新增的原子操作类LongAdder和DoubleAdder"></a>JDK8新增的原子操作类LongAdder和DoubleAdder</h4><p>使用AtomicLong时，在高并发下大量线程会同时去竞争更新同一个原子变量，那么就会由大量线程因为不断自旋而浪费CPU资源。因此JDK8新增了LongAdder用于克服在高并发下使用AtomicLong的缺点，提升性能。</p><p>如图所示，使用AtomicLong时，是多个线程同时竞争同一个原子变量：</p><p><img src="AtomicLong.png" alt=""></p><p>而使用LongAdder时，则为：</p><p><img src="LongAdder.png" alt=""></p><p>LongAdder维护了一个Cell数组，每个Cell里有一个初始值为0L的long型变量，这样在同等并发量的情况下，争夺单个变量更新操作的线程减少。并且如果多个线程争夺同一个Cell原子变量失败了，它并不是在当前Cell变量上一直自旋CAS重试，而是尝试在其他Cell的变量上进行CAS，这个改变增加了当前线程重试CAS成功的可能性。最后，<strong>在获取LongAdder当前值时，把所有Cell变量的value累加再加上base返回</strong>。</p><p>Cell数组默认是null，只有在高并发的情况下才会创建它。在并发量少的时候所有的累加操作都是对base变量进行的，此时与AtomicLong类似。</p><p>Cell类使用了<code>@sun.misc.Contended</code>修饰进行字节填充，这是因为数组元素的内存地址连续，为了避免伪共享。</p><p>总结：LongAdder在AtomicLong的基础上<strong>将单个变量的更新压力分散到各Cell</strong>，在<strong>低并发的时候通过对base的直接更新可以很好的保障与AtomicLong的性能基本保持一致，而在高并发的时候通过分散提高了性能。</strong><br><strong>缺点是LongAdder在求和的时候如果有并发更新，可能导致统计的数据有误差</strong>。</p><p>DoubleAdder与LongAdder类似。</p><h4 id="LongAccmulator和DoubleAccumulator"><a href="#LongAccmulator和DoubleAccumulator" class="headerlink" title="LongAccmulator和DoubleAccumulator"></a>LongAccmulator和DoubleAccumulator</h4><p>LongAdder可以看作是LongAccumulator的一个特例。LongAccumulator的构造方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongAccumulator</span><span class="params">(LongBinaryOperator accumulatorFunction, <span class="keyword">long</span> identity)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.function = accumulatorFunction;</span><br><span class="line">    base = <span class="keyword">this</span>.identity = identity;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LongBinaryOperator</span></span>&#123;</span><br><span class="line">    <span class="comment">//根据两个参数计算并返回一个值，具体的运算由用户自定义</span></span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用LongAdder其实就相当于如下使用LongAccumulator:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(<span class="keyword">new</span> LongBinaryOperator()&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;, <span class="number">0</span>);</span><br></pre></td></tr></table></figure><p>LongAccumulator可以<strong>自定义双目运算规则</strong>（<strong>applyAsLong()的返回值就是要更新的值</strong>。在LongAdder中该值就是<code>base+x</code>，<code>x</code>为其add方法的参数），并且可以<strong>指定base的初始值</strong>，而LongAdder只能默认base为0。</p><h4 id="如何实现AtomicByte-AtomicFloat-AtomicDouble"><a href="#如何实现AtomicByte-AtomicFloat-AtomicDouble" class="headerlink" title="如何实现AtomicByte/AtomicFloat/AtomicDouble?"></a>如何实现AtomicByte/AtomicFloat/AtomicDouble?</h4><p>查看atomic包文档描述，结尾处写道：Additionally, classes are provided only for those types that are commonly useful in intended applications. For example, there is no atomic class for representing <code>byte</code>. In those infrequent cases where you would like to do so, you can use an <code>AtomicInteger</code> to hold <code>byte</code> values, and cast appropriately. You can also hold floats using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#floatToRawIntBits-float-" target="_blank" rel="noopener"><code>Float.floatToRawIntBits(float)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Float.html#intBitsToFloat-int-" target="_blank" rel="noopener"><code>Float.intBitsToFloat(int)</code></a> conversions, and doubles using <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#doubleToRawLongBits-double-" target="_blank" rel="noopener"><code>Double.doubleToRawLongBits(double)</code></a> and <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#longBitsToDouble-long-" target="_blank" rel="noopener"><code>Double.longBitsToDouble(long)</code></a> conversions.</p><p>由文档描述可知，使用Float和Double的方法转换并包装AtomicInteger即可。</p><p>参考：</p><p>《Java并发编程之美》</p><p>《深入理解Java虚拟机》</p><p><a href="https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/thread/java-thread-x-juc-AtomicInteger.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;CAS操作&quot;&gt;&lt;a href=&quot;#CAS操作&quot; class=&quot;headerlink&quot; title=&quot;CAS操作&quot;&gt;&lt;/a&gt;CAS操作&lt;/h3&gt;&lt;h4 id=&quot;CAS（Compare-And-Swap）&quot;&gt;&lt;a href=&quot;#CAS（Compare-And-Swap
      
    
    </summary>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/categories/Java%E5%B9%B6%E5%8F%91/"/>
    
    
      <category term="Java并发" scheme="http://thmasterplan.cn/tags/Java%E5%B9%B6%E5%8F%91/"/>
    
  </entry>
  
</feed>
