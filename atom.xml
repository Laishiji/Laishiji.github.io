<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2020-09-09T07:18:55.600Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>TreeMap源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/TreeMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/TreeMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-09T07:13:28.000Z</published>
    <updated>2020-09-09T07:18:55.600Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator遍历TreeMap时，得到的记录是排过序的。如果使用排序的映射，建议使用TreeMap。在使用TreeMap时，key必须实现Comparable接口或者在构造TreeMap传入自定义的Comparator，否则会在运行时抛出java.lang.ClassCastException类型的异常。</p><h2 id="TreeMap的实现"><a href="#TreeMap的实现" class="headerlink" title="TreeMap的实现"></a><em>TreeMap</em>的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><h3 id="成员变量的含义"><a href="#成员变量的含义" class="headerlink" title="成员变量的含义"></a>成员变量的含义</h3><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h3 id="自动扩容机制"><a href="#自动扩容机制" class="headerlink" title="自动扩容机制"></a>自动扩容机制</h3><h3 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;TreeMap实现SortedMap接口，能够把它保存的记录根据键排序，默认是按键值的升序排序，也可以指定排序的比较器，当用Iterator
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LinkedHashMap源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedHashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-09T07:13:05.000Z</published>
    <updated>2020-09-09T07:16:12.167Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记录肯定是先插入的，也可以在构造时带参数，按照访问次序排序。</p><h2 id="LinkedHashMap的实现"><a href="#LinkedHashMap的实现" class="headerlink" title="LinkedHashMap的实现"></a><em>LinkedHashMap</em>的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><h3 id="成员变量的含义"><a href="#成员变量的含义" class="headerlink" title="成员变量的含义"></a>成员变量的含义</h3><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><h3 id="自动扩容机制"><a href="#自动扩容机制" class="headerlink" title="自动扩容机制"></a>自动扩容机制</h3><h3 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;LinkedHashMap是HashMap的一个子类，保存了记录的插入顺序，在用Iterator遍历LinkedHashMap时，先得到的记
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>HashMap源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/HashMap%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-09T05:10:49.000Z</published>
    <updated>2020-09-09T09:23:53.788Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><em>Map</em>接口主要实现类有四个：<em>HashMap</em>、<em>Hashtable</em>、<em>LinkedHashMap</em>和<em>TreeMap</em>，类继承关系如下图：</p><p><img src="D:\myblog\source\_posts\HashMap源码剖析\Map.jpg" alt=""></p><p>其中<em>HashMap</em>根据key的hashCode计算得到的哈希值存储数据，因此在访问数据时直接根据hash函数计算就可以得到数据在数组中的位置，访问速度很快，但是遍历顺序却是不确定的。</p><p><strong><em>HashMap</em>最多只允许一个节点的key为null，允许多个节点的value为null。</strong></p><p><em>HashMap</em>非线程安全。若要满足线程安全，可以使用<code>Collections.synchronizedMap</code>方法使<em>HashMap</em>具有线程安全的能力，或者直接使用<em>ConcurrentHashMap</em>。</p><h2 id="HashMap的实现"><a href="#HashMap的实现" class="headerlink" title="HashMap的实现"></a><em>HashMap</em>的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><img src="hashmap18_struc.png" alt=""></p><p>如上图所示，<em>HashMap</em>使用<strong>链地址法</strong>来解决冲突问题。jdk8后HashMap使用<strong>数组+链表/红黑树</strong>实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;<span class="comment">//用来定位数组索引位置</span></span><br><span class="line">        <span class="keyword">final</span> K key;<span class="comment">//final修饰，key不可变，否则根据hash函数计算所得的索引位置就变了</span></span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.value = value;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> K <span class="title">getKey</span><span class="params">()</span>        </span>&#123; <span class="keyword">return</span> key; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">getValue</span><span class="params">()</span>      </span>&#123; <span class="keyword">return</span> value; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> key + <span class="string">"="</span> + value; &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> Objects.hashCode(key) ^ Objects.hashCode(value);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> V <span class="title">setValue</span><span class="params">(V newValue)</span> </span>&#123;</span><br><span class="line">            V oldValue = value;</span><br><span class="line">            value = newValue;</span><br><span class="line">            <span class="keyword">return</span> oldValue;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (o == <span class="keyword">this</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (o <span class="keyword">instanceof</span> Map.Entry) &#123;</span><br><span class="line">                Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class="line">                <span class="keyword">if</span> (Objects.equals(key, e.getKey()) &amp;&amp;</span><br><span class="line">                    Objects.equals(value, e.getValue()))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="HashMap成员变量的含义"><a href="#HashMap成员变量的含义" class="headerlink" title="HashMap成员变量的含义"></a><em>HashMap</em>成员变量的含义</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//数组默认初始容量16.数组容量必须是2的幂</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//数组最大容量</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//默认负载因子</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当链表节点个数 &gt;= 8时，转换为红黑树，访问的时间复杂度由O(N)降为O(logN)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//当红黑树节点个数 &lt; 6时，退化为链表</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The smallest table capacity for which bins may be treeified.</span></span><br><span class="line"><span class="comment">     * (Otherwise the table is resized if too many nodes in a bin.)</span></span><br><span class="line"><span class="comment">     * Should be at least 4 * TREEIFY_THRESHOLD to avoid conflicts</span></span><br><span class="line"><span class="comment">     * between resizing and treeification thresholds.</span></span><br><span class="line"><span class="comment">     * 只有当数组容量&gt;=64时，bin中的链表才会转换为红黑树；</span></span><br><span class="line"><span class="comment">     * 否则就算链表节点个数&gt;=8，也不会树化，而是对数组进行扩容。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//等于capacity * load factor, 当哈希表中有threshold个bin有节点时，进行扩容</span></span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//记录HashMap发生结构性更改的次数，用于实现迭代器fail-fast机制</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"></span><br><span class="line"><span class="comment">//负载因子,如果内存空间充足，可以在构造HashMap时适当减小负载因子和增大初  始容量，以此来提高HashMap效率；</span></span><br><span class="line"><span class="comment">//相反，如果内存空间紧张而对时间效率要求不高，则可以适当调大负载因子</span></span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br><span class="line"></span><br><span class="line"><span class="comment">//总节点个数</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"></span><br><span class="line"><span class="comment">//用于entrySet()方法返回所有键值对</span></span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br></pre></td></tr></table></figure><h3 id="哈希方法"><a href="#哈希方法" class="headerlink" title="哈希方法"></a>哈希方法</h3><p>哈希函数用于确定节点在数组中的索引位置，其数学形式为<code>index = hash(key)</code>。jdk1.8实现源码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知，hash函数的返回值并不是数组索引，因为数组长度并没有参与运算。实际上，获取索引的最后一步操作在获取节点的方法中实现，比如getNode()方法中的代码片段<code>tab[(n - 1) &amp; hash]</code>，tab就是哈希数组，n为数组长度。</p><p>以上代码可分为三步：</p><ol><li><code>h = key.hashCode()</code>  取key的hashCode值。</li><li><code>hash = h ^ (h &gt;&gt;&gt; 16)</code> 无符号右移16bit(左边补0), 高位运算。</li><li><p><code>index = (n - 1) &amp; hash</code> 相当于求模运算，但是效率比<code>%</code>更高。因为数组的大小永远是2的幂，所以<code>n - 1</code>是<code>011..11</code>（32位）的形式，任何非负整数和它按位<code>&amp;</code>都会等于其本身。</p><p>举个例子：</p></li></ol><p><img src="hash_computing_ex.jpg" alt=""></p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建指定初始容量和负载因子的HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">            initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">        <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                               loadFactor);</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">        <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建指定初始容量和默认负载因子的HashMap  </span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">        putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>注意，构造方法中并没有创建哈希数组，初始化数组操作是通过resize()方法完成，而resize()方法是在放入键值对的时候才进行调用（初始化或者扩容2倍），比如putVal()方法。</p><p>构造方法中调用了tableSizeFor()来获取大于指定容量的最小的2的幂（在<em>ArrayDeque</em>中已分析），其源代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">        n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">        <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;<span class="comment">//从左往右依次运算</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自动扩容机制"><a href="#自动扩容机制" class="headerlink" title="自动扩容机制"></a>自动扩容机制</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes or doubles table size.  If null, allocates in</span></span><br><span class="line"><span class="comment">     * accord with initial capacity target held in field threshold.</span></span><br><span class="line"><span class="comment">     * Otherwise, because we are using power-of-two expansion, the</span></span><br><span class="line"><span class="comment">     * elements from each bin must either stay at same index, or move</span></span><br><span class="line"><span class="comment">     * with a power of two offset in the new table.</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> the table</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;</span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由注释知，resize()方法用于初始化哈希数组或者扩容2倍。</p><h3 id="常用方法分析"><a href="#常用方法分析" class="headerlink" title="常用方法分析"></a>常用方法分析</h3><h4 id="put"><a href="#put" class="headerlink" title="put()"></a>put()</h4><h4 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h4><h4 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h4><p>参考：<a href="https://zhuanlan.zhihu.com/p/21673805" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/21673805</a></p><p>​            <a href="http://irfen.me/java1-8-hashmap/" target="_blank" rel="noopener">http://irfen.me/java1-8-hashmap/</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Map&lt;/em&gt;接口主要实现类有四个：&lt;em&gt;HashMap&lt;/em&gt;、&lt;em&gt;Hashtable&lt;/em&gt;、&lt;em&gt;LinkedH
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>PriorityQueue源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/PriorityQueue%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-08T10:40:43.000Z</published>
    <updated>2020-09-08T12:36:44.247Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java中优先级队列通过<strong>二叉小根堆（任意一个非叶子节点的权值都不大于其孩子节点的权值）</strong>实现，可以用一棵<strong>完全二叉树</strong>表示，这意味着<strong>数组</strong>可以作为<em>PriorityQueue</em>的底层实现。<strong>优先队列的作用是能<em>保证每次取出的元素都是队列中权值最小的</em></strong>，<strong>元素大小的评判可以通过元素本身的自然顺序（natural ordering），也可以通过构造时传入的比较器</strong>。注意，<em>PriorityQueue</em>不允许放入null元素。</p><p><img src="PriorityQueue_base.png" alt=""></p><p>在完全二叉树中，假设某个节点的下标为Node，其左孩子下标为LNode、右孩子下标为RNode，那么有如下关系：</p><p><code>Node == (LNode - 1)/2 == (RNode - 1)/2</code></p><p><code>LNode == 2*Node + 1</code></p><p><code>RNode == 2*Node + 2</code></p><p>通过上述三个公式，可以很容易计算出某个节点的父节点和孩子节点的下标。</p><h2 id="PriorityQueue的实现"><a href="#PriorityQueue的实现" class="headerlink" title="PriorityQueue的实现"></a><em>PriorityQueue</em>的实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Priority queue represented as a balanced binary heap: the two</span></span><br><span class="line"><span class="comment">     * children of queue[n] are queue[2*n+1] and queue[2*(n+1)].  The</span></span><br><span class="line"><span class="comment">     * priority queue is ordered by comparator, or by the elements'</span></span><br><span class="line"><span class="comment">     * natural ordering, if comparator is null: For each node n in the</span></span><br><span class="line"><span class="comment">     * heap and each descendant d of n, n &lt;= d.  The element with the</span></span><br><span class="line"><span class="comment">     * lowest value is in queue[0], assuming the queue is nonempty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] queue; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The number of elements in the priority queue.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">11</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The comparator, or null if priority queue uses elements'</span></span><br><span class="line"><span class="comment">     * natural ordering.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Comparator&lt;? <span class="keyword">super</span> E&gt; comparator;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, <span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="comment">//默认构造，默认容量，不使用比较器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(initialCapacity, <span class="keyword">null</span>);</span><br><span class="line">    &#125;<span class="comment">//指定初始容量，不使用比较器</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(DEFAULT_INITIAL_CAPACITY, comparator);</span><br><span class="line">    &#125;<span class="comment">//指定比较器，使用默认容量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(<span class="keyword">int</span> initialCapacity,</span></span></span><br><span class="line"><span class="function"><span class="params">                         Comparator&lt;? <span class="keyword">super</span> E&gt; comparator)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Note: This restriction of at least one is not actually needed,</span></span><br><span class="line">        <span class="comment">// but continues for 1.5 compatibility</span></span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">this</span>.queue = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        <span class="keyword">this</span>.comparator = comparator;</span><br><span class="line">    &#125;<span class="comment">//以上构造都使用this()调用了本构造方法</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; containing the elements in the</span></span><br><span class="line"><span class="comment">     * specified collection.  If the specified collection is an instance of</span></span><br><span class="line"><span class="comment">     * a &#123;<span class="doctag">@link</span> SortedSet&#125; or is another &#123;<span class="doctag">@code</span> PriorityQueue&#125;, this</span></span><br><span class="line"><span class="comment">     * priority queue will be ordered according to the same ordering.</span></span><br><span class="line"><span class="comment">     * Otherwise, this priority queue will be ordered according to the</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@linkplain</span> Comparable natural ordering&#125; of its elements.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed</span></span><br><span class="line"><span class="comment">     *         into this priority queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if elements of the specified collection</span></span><br><span class="line"><span class="comment">     *         cannot be compared to one another according to the priority</span></span><br><span class="line"><span class="comment">     *         queue's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (c <span class="keyword">instanceof</span> SortedSet&lt;?&gt;) &#123;</span><br><span class="line">            SortedSet&lt;? extends E&gt; ss = (SortedSet&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) ss.comparator();</span><br><span class="line">            initElementsFromCollection(ss);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (c <span class="keyword">instanceof</span> PriorityQueue&lt;?&gt;) &#123;</span><br><span class="line">            PriorityQueue&lt;? extends E&gt; pq = (PriorityQueue&lt;? extends E&gt;) c;</span><br><span class="line">            <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) pq.comparator();</span><br><span class="line">            initFromPriorityQueue(pq);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.comparator = <span class="keyword">null</span>;</span><br><span class="line">            initFromCollection(c);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; containing the elements in the</span></span><br><span class="line"><span class="comment">     * specified priority queue.  This priority queue will be</span></span><br><span class="line"><span class="comment">     * ordered according to the same ordering as the given priority</span></span><br><span class="line"><span class="comment">     * queue.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the priority queue whose elements are to be placed</span></span><br><span class="line"><span class="comment">     *         into this priority queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if elements of &#123;<span class="doctag">@code</span> c&#125; cannot be</span></span><br><span class="line"><span class="comment">     *         compared to one another according to &#123;<span class="doctag">@code</span> c&#125;'s</span></span><br><span class="line"><span class="comment">     *         ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified priority queue or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(PriorityQueue&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initFromPriorityQueue(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Creates a &#123;<span class="doctag">@code</span> PriorityQueue&#125; containing the elements in the</span></span><br><span class="line"><span class="comment">     * specified sorted set.   This priority queue will be ordered</span></span><br><span class="line"><span class="comment">     * according to the same ordering as the given sorted set.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the sorted set whose elements are to be placed</span></span><br><span class="line"><span class="comment">     *         into this priority queue</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> ClassCastException if elements of the specified sorted</span></span><br><span class="line"><span class="comment">     *         set cannot be compared to one another according to the</span></span><br><span class="line"><span class="comment">     *         sorted set's ordering</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified sorted set or any</span></span><br><span class="line"><span class="comment">     *         of its elements are null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PriorityQueue</span><span class="params">(SortedSet&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.comparator = (Comparator&lt;? <span class="keyword">super</span> E&gt;) c.comparator();</span><br><span class="line">        initElementsFromCollection(c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;Java中优先级队列通过&lt;strong&gt;二叉小根堆（任意一个非叶子节点的权值都不大于其孩子节点的权值）&lt;/strong&gt;实现，可以用一棵&lt;s
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>ArrayDeque源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayDeque%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayDeque%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-08T07:05:08.000Z</published>
    <updated>2020-09-09T08:15:54.530Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><em>Deque</em>, 即“double ended queue”，表示双向队列，它既可以当作队列使用，也可以当作栈使用。<em>ArrayDeque</em>和<em>LinkedList</em>是<em>Deque</em>的两个通用实现，但是官方更推荐使用<em>AarryDeque</em>用作栈和队列。</p><p><em>ArrayDeque</em>底层通过数组实现，为了满足可以同时在数组两端插入或删除元素的需求，需要设置head指针和tail指针，<strong>head指向首端第一个有效元素</strong>，<strong>tail指向尾端第一个可以插入元素的空位</strong>。也就是说<em>ArrayDeque</em>底层实现是一个<strong>循环数组</strong>（circular array），并且<strong>数组的任何一点都可能被看作起点或终点</strong>。</p><p><em>ArrayDeque</em>是<strong>非线程安全</strong>的，另外该容器<strong>不允许放入null元素</strong>。</p><p><img src="ArrayDeque_base.png" alt=""></p><h2 id="ArrayDeque实现"><a href="#ArrayDeque实现" class="headerlink" title="ArrayDeque实现"></a><em>ArrayDeque</em>实现</h2><h3 id="底层数据机构"><a href="#底层数据机构" class="headerlink" title="底层数据机构"></a>底层数据机构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array in which the elements of the deque are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the deque is the length of this array, which is</span></span><br><span class="line"><span class="comment">     * always a power of two. The array is never allowed to become</span></span><br><span class="line"><span class="comment">     * full, except transiently within an addX method where it is</span></span><br><span class="line"><span class="comment">     * resized (see doubleCapacity) immediately upon becoming full,</span></span><br><span class="line"><span class="comment">     * thus avoiding head and tail wrapping around to equal each</span></span><br><span class="line"><span class="comment">     * other.  We also guarantee that all array cells not holding</span></span><br><span class="line"><span class="comment">     * deque elements are always null.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elements; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The index of the element at the head of the deque (which is the</span></span><br><span class="line"><span class="comment">     * element that would be removed by remove() or pop()); or an</span></span><br><span class="line"><span class="comment">     * arbitrary number equal to tail if the deque is empty.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> head;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The index at which the next element would be added to the tail</span></span><br><span class="line"><span class="comment">     * of the deque (via addLast(E), add(E), or push(E)).</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> <span class="keyword">int</span> tail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The minimum capacity that we'll use for a newly created deque.</span></span><br><span class="line"><span class="comment">     * Must be a power of 2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_INITIAL_CAPACITY = <span class="number">8</span>;</span><br></pre></td></tr></table></figure><p>由注释总结得出以下几点重要信息：</p><ol><li>最小初始容量为8，并且自动扩容后<strong>数组的大小永远是2的幂</strong>。</li><li>数组永远不能满，以避免head和tail指针相等。</li><li>数组元素不能为null。</li></ol><h3 id="构造函数"><a href="#构造函数" class="headerlink" title="构造函数"></a>构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[<span class="number">16</span>];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        allocateElements(numElements);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayDeque</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        allocateElements(c.size());</span><br><span class="line">        addAll(c);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">allocateElements</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        elements = <span class="keyword">new</span> Object[calculateSize(numElements)];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateSize</span><span class="params">(<span class="keyword">int</span> numElements)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> initialCapacity = MIN_INITIAL_CAPACITY;</span><br><span class="line">        <span class="comment">// Find the best power of two to hold elements.</span></span><br><span class="line">        <span class="comment">// Tests "&lt;=" because arrays aren't kept full.</span></span><br><span class="line">        <span class="keyword">if</span> (numElements &gt;= initialCapacity) &#123;</span><br><span class="line">            initialCapacity = numElements;</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">            initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">            initialCapacity++;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)   <span class="comment">// Too many elements, must back off</span></span><br><span class="line">                initialCapacity &gt;&gt;&gt;= <span class="number">1</span>;<span class="comment">// Good luck allocating 2 ^ 30 elements</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> initialCapacity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>由源码可知：</p><ol><li><p>如果不指定容量创建<em>ArrayDeque</em>，默认数组大小为16。</p></li><li><p>如果指定容量大小，构造方法会调用<code>static int calculateSize(int numElements)</code>计算最合适的2的幂来创建数组。若指定容量小于<code>MIN_INITIAL_CAPACITY</code>8，则直接创建大小为8的数组；若指定容量大于等于8，则会通过以下代码块来<strong>获得大于指定容量的最小2的次幂数</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">initialCapacity = numElements;</span><br><span class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">1</span>);</span><br><span class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">2</span>);</span><br><span class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">4</span>);</span><br><span class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt;  <span class="number">8</span>);</span><br><span class="line">initialCapacity |= (initialCapacity &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">initialCapacity++;</span><br></pre></td></tr></table></figure><p><code>&gt;&gt;&gt;</code>为无符号右移运算，以8为例，其二进制数为000…01000共32位，后面简写为1000。<code>8 &gt;&gt;&gt; 1</code>后则为0100，相当于除以2的1次幂；<code>8 &gt;&gt;&gt; 2</code>后则为0010，相当于除以2的2次幂…</p><p><code>|</code>为按位或，两数按位或，对应位只要有一个1该为结果即为1。</p><p>那么以initialCapacity等于8为例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ini &gt;&gt;&gt; 1, 得0100；1000 | 0100 得 ini &#x3D;1100</span><br><span class="line">ini &gt;&gt;&gt; 2, 得0011；1100 | 0011 得 ini &#x3D;1111</span><br><span class="line">ini &gt;&gt;&gt; 4, 得0000；1111 | 0000 得 ini &#x3D;1111</span><br><span class="line">ini &gt;&gt;&gt; 8, 得0000；1111 | 0000 得 ini &#x3D;1111</span><br><span class="line">ini &gt;&gt;&gt; 16, 得0000；1111 | 0000 得 ini &#x3D;1111</span><br></pre></td></tr></table></figure><p>最后结果为16。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt;  1);</span><br><span class="line">initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt;  2);</span><br><span class="line">initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt;  4);</span><br><span class="line">initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt;  8);</span><br><span class="line">initialCapacity |&#x3D; (initialCapacity &gt;&gt;&gt; 16);</span><br></pre></td></tr></table></figure><p>实际上，以上代码块的作用是<strong>将initialCapacity 的最高位1的所有低位全部变为1</strong>，如下图所示：</p><p><img src="calculateSize.png" alt=""></p><p>5次操作后再进行自加，就会得到大于initialCapacity的<code>最小2的次幂数</code>。</p><p>有一个特殊情况需要处理，即initialCapacity的最高位1是在第31位上：</p><blockquote><p>01XXXXXX XXXXXXXX XXXXXXXX XXXXXXXX</p></blockquote><p>这样在进行所有操作后initialCapacity会变为：</p><blockquote><p>10000000 00000000 00000000 00000000</p></blockquote><p>最高位为1，实际上就上溢为一个负数(-2^31)(32位整型范围为-2^31 ~ 2^31 - 1)。为了处理这种情况，会将initialCapacity右移一位，这样它就变为了一个很大的整数（2的30次幂）。</p><p>参考：<a href="https://blog.csdn.net/liubin119712/article/details/51075861" target="_blank" rel="noopener">https://blog.csdn.net/liubin119712/article/details/51075861</a></p></li><li><p>使用集合元素创建<em>ArrayDeque</em>调用的addAll()方法实际上继承自父抽象类<em>AbstractCollection<E></em>的，因为<em>ArrayDeque</em>没有重写该方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> modified = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (E e : c)</span><br><span class="line">            <span class="keyword">if</span> (add(e))</span><br><span class="line">                modified = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> modified;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>然后addAll中的add方法为<em>ArrayDeque</em>重写的add方法。</p></li></ol><h3 id="自动扩容：doubleCapacity方法"><a href="#自动扩容：doubleCapacity方法" class="headerlink" title="自动扩容：doubleCapacity方法"></a>自动扩容：doubleCapacity方法</h3><p><em>ArrayDeque</em>的自动扩容发生在<code>head == tail</code>的情况下，此时直接扩容为原来的两倍。<code>int newCapacity = n &lt;&lt; 1;</code>。</p><p><img src="ArrayDeque_doubleCapacity.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Doubles the capacity of this deque.  Call only when full, i.e.,</span></span><br><span class="line"><span class="comment">     * when head and tail have wrapped around to become equal.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doubleCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> head == tail;</span><br><span class="line">        <span class="keyword">int</span> p = head;</span><br><span class="line">        <span class="keyword">int</span> n = elements.length;</span><br><span class="line">        <span class="keyword">int</span> r = n - p; <span class="comment">// head右边元素个数</span></span><br><span class="line">        <span class="keyword">int</span> newCapacity = n &lt;&lt; <span class="number">1</span>;<span class="comment">//扩容为原空间2倍</span></span><br><span class="line">        <span class="keyword">if</span> (newCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Sorry, deque too big"</span>);</span><br><span class="line">        Object[] a = <span class="keyword">new</span> Object[newCapacity];</span><br><span class="line">        System.arraycopy(elements, p, a, <span class="number">0</span>, r);<span class="comment">//复制head右半部分</span></span><br><span class="line">        System.arraycopy(elements, <span class="number">0</span>, a, r, p);<span class="comment">//复制head左半部分</span></span><br><span class="line">        elements = a;</span><br><span class="line">        head = <span class="number">0</span>;</span><br><span class="line">        tail = n;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="addFirst"><a href="#addFirst" class="headerlink" title="addFirst()"></a>addFirst()</h3><p><img src="ArrayDeque_addFirst.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addFirst</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[head = (head - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)] = e;</span><br><span class="line">        <span class="keyword">if</span> (head == tail)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>因为tail指针总是指向下一个可插入的空位，也即在进行任何添加元素的操作时，总会有空位，所以不需要考虑空间问题。</p><p><code>head = (head - 1) &amp; (elements.length - 1)</code>：这段代码<strong>在head不为0时，相当于求模运算</strong>，但是效率比使用<code>%</code>高。因为数组的大小永远是2的幂，所以<code>elements.length - 1</code>是<code>011..11</code>（32位）的形式，任何非负整数和它按位与都会等于其本身；而<strong>在head为0时</strong>，head-1则为-1，其二进制源码为<code>1000...01</code>（32位），由于计算机运算使用补码，-1的补码则为除符号位外全部取反后+1，为<code>1111...11</code>（32位），那么它和<code>elements.length - 1</code>按位与的结果就是<code>elements.length - 1</code>本身，也就是在数组末尾插入。</p><h3 id="addLast"><a href="#addLast" class="headerlink" title="addLast()"></a>addLast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (e == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        elements[tail] = e;</span><br><span class="line">        <span class="keyword">if</span> ( (tail = (tail + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)) == head)</span><br><span class="line">            doubleCapacity();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><code>(tail = (tail + 1) &amp; (elements.length - 1)</code>相当于求模运算。</p><h3 id="pollFirst"><a href="#pollFirst" class="headerlink" title="pollFirst()"></a>pollFirst()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h = head;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E result = (E) elements[h];</span><br><span class="line">        <span class="comment">// Element is null if deque empty</span></span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[h] = <span class="keyword">null</span>;     <span class="comment">// 让GC回收</span></span><br><span class="line">        head = (h + <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);<span class="comment">//求模</span></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="pollLast"><a href="#pollLast" class="headerlink" title="pollLast()"></a>pollLast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">pollLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> t = (tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>);</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        E result = (E) elements[t];</span><br><span class="line">        <span class="keyword">if</span> (result == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        elements[t] = <span class="keyword">null</span>;</span><br><span class="line">        tail = t;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="peekFirst"><a href="#peekFirst" class="headerlink" title="peekFirst()"></a>peekFirst()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// elements[head] is null if deque empty</span></span><br><span class="line">        <span class="keyword">return</span> (E) elements[head];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="peekLast"><a href="#peekLast" class="headerlink" title="peekLast()"></a>peekLast()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peekLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elements[(tail - <span class="number">1</span>) &amp; (elements.length - <span class="number">1</span>)];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/collection/java-collection-Queue&amp;Stack.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;em&gt;Deque&lt;/em&gt;, 即“double ended queue”，表示双向队列，它既可以当作队列使用，也可以当作栈使用。&lt;em&gt;A
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>LinkedList源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/LinkedList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-07T12:11:21.000Z</published>
    <updated>2020-09-08T11:49:46.276Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p><em>LinkedList</em>同时实现了<em>List</em>, <em>Queue</em>和<em>Deque</em>三个接口，因此它既可以看作一个<strong>顺序容器</strong>，又可以看作一个<strong>队列</strong>，也可以看作一个<strong>栈</strong>。由于Java官方已经不建议使用<em>Vector</em>和<em>Stack</em>，因此<em>LinkedList</em>是一个选择。关于<strong>栈和队列，现在的首选是<em>ArrayDeque</em>，</strong>它 没有容量限制，可根据需求自动进行扩容。由于<em>ArrayDeque</em>的底层实现为数组，其作为队列或数组时效率相较于基于双向链表的 <em>LinkedList</em>也要更好一些。注意，<em>ArrayDeque</em> 不支持为 null 的元素，<em>LinkedList</em>支持null。</p><h2 id="LinkedList实现"><a href="#LinkedList实现" class="headerlink" title="LinkedList实现"></a>LinkedList实现</h2><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><p><em>LinkedList</em>底层通过<strong>双向链表</strong>实现，这决定了它所有与下标有关的操作都是线性时间，而在首尾插入删除元素只需要常数时间。为了追求效率<em>LinkedList</em>没有实现同步，如果需要并发访问，可以采用<code>Collections.synchronizedList()</code>方法进行包装。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; first;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;E&gt; last;</span><br><span class="line"></span><br><span class="line"><span class="comment">//节点内部类</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        E item;</span><br><span class="line">        Node&lt;E&gt; next;</span><br><span class="line">        Node&lt;E&gt; prev;</span><br><span class="line"></span><br><span class="line">        Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.item = element;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">            <span class="keyword">this</span>.prev = prev;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>();</span><br><span class="line">    addAll(c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="getFirst-getLast"><a href="#getFirst-getLast" class="headerlink" title="getFirst(), getLast()"></a>getFirst(), getLast()</h3><p>获取list的第一个元素和最后一个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">    <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> f.item;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">getLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">    <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">    <span class="keyword">return</span> l.item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="removeFirst-removeLast-remove-e-remove-index"><a href="#removeFirst-removeLast-remove-e-remove-index" class="headerlink" title="removeFirst(), removeLast(), remove(e), remove(index)"></a>removeFirst(), removeLast(), remove(e), remove(index)</h3><p>删除第一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeFirst</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; f = first;</span><br><span class="line">        <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkFirst(f);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkFirst</span><span class="params">(Node&lt;E&gt; f)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert f == first &amp;&amp; f != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = f.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = f.next;</span><br><span class="line">        f.item = <span class="keyword">null</span>;</span><br><span class="line">        f.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        first = next;</span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>)</span><br><span class="line">            last = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            next.prev = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;<span class="comment">//fast-fail</span></span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除最后一个节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">removeLast</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">        <span class="keyword">return</span> unlinkLast(l);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">unlinkLast</span><span class="params">(Node&lt;E&gt; l)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert l == last &amp;&amp; l != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = l.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = l.prev;</span><br><span class="line">        l.item = <span class="keyword">null</span>;</span><br><span class="line">        l.prev = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">        last = prev;</span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>)</span><br><span class="line">            first = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            prev.next = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除第一次出现的指定元素，若没有则返回false。注意<em>LinkedList</em>允许null元素，因此分为两种情况遍历。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item)) &#123;</span><br><span class="line">                    unlink(x);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">unlink</span><span class="params">(Node&lt;E&gt; x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert x != null;</span></span><br><span class="line">        <span class="keyword">final</span> E element = x.item;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; next = x.next;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; prev = x.prev;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (prev == <span class="keyword">null</span>) &#123;</span><br><span class="line">            first = next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = next;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (next == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = prev;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            next.prev = prev;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        x.item = <span class="keyword">null</span>;</span><br><span class="line">        size--;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> element;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>删除指定index的节点，使用<code>index &lt; (size &gt;&gt; 1</code>判断index在前半段还是后半段，以此来决定从头部还是尾部开始遍历，可以一定程度提高效率。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);<span class="comment">//检查是否越界</span></span><br><span class="line">        <span class="keyword">return</span> unlink(node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回指定index的节点</span></span><br><span class="line"><span class="function">Node&lt;E&gt; <span class="title">node</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert isElementIndex(index);</span></span><br><span class="line">        <span class="keyword">if</span> (index &lt; (size &gt;&gt; <span class="number">1</span>)) &#123;</span><br><span class="line">            Node&lt;E&gt; x = first;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; index; i++)</span><br><span class="line">                x = x.next;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Node&lt;E&gt; x = last;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size - <span class="number">1</span>; i &gt; index; i--)</span><br><span class="line">                x = x.prev;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="add-addAll"><a href="#add-addAll" class="headerlink" title="add(), addAll()"></a>add(), addAll()</h3><p>末尾添加节点</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        linkLast(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkLast</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; l = last;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(l, e, <span class="keyword">null</span>);</span><br><span class="line">        last = newNode;</span><br><span class="line">        <span class="keyword">if</span> (l == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            l.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定index添加元素。通过node(index)找到index处的节点，<strong>将element插入到该节点之<em>前</em></strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index == size)</span><br><span class="line">            linkLast(element);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            linkBefore(element, node(index));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">linkBefore</span><span class="params">(E e, Node&lt;E&gt; succ)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert succ != null;</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; pred = succ.prev;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, succ);</span><br><span class="line">        succ.prev = newNode;</span><br><span class="line">        <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">            first = newNode;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pred.next = newNode;</span><br><span class="line">        size++;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>末尾添加集合里所有元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> addAll(size, c);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>指定index添加集合元素。<strong>添加到指定元素之前。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        checkPositionIndex(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        <span class="keyword">if</span> (numNew == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node&lt;E&gt; pred, succ;</span><br><span class="line">        <span class="keyword">if</span> (index == size) &#123;</span><br><span class="line">            succ = <span class="keyword">null</span>;</span><br><span class="line">            pred = last;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            succ = node(index);</span><br><span class="line">            pred = succ.prev;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (Object o : a) &#123;</span><br><span class="line">            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>) E e = (E) o;</span><br><span class="line">            Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;&gt;(pred, e, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">if</span> (pred == <span class="keyword">null</span>)</span><br><span class="line">                first = newNode;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                pred.next = newNode;</span><br><span class="line">            pred = newNode;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (succ == <span class="keyword">null</span>) &#123;</span><br><span class="line">            last = pred;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pred.next = succ;</span><br><span class="line">            succ.prev = pred;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        size += numNew;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h3><p>清空链表</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Clearing all of the links between nodes is "unnecessary", but:</span></span><br><span class="line">        <span class="comment">// - helps a generational GC if the discarded nodes inhabit</span></span><br><span class="line">        <span class="comment">//   more than one generation</span></span><br><span class="line">        <span class="comment">// - is sure to free memory even if there is a reachable Iterator</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; ) &#123;</span><br><span class="line">            Node&lt;E&gt; next = x.next;</span><br><span class="line">            x.item = <span class="keyword">null</span>;</span><br><span class="line">            x.next = <span class="keyword">null</span>;</span><br><span class="line">            x.prev = <span class="keyword">null</span>;</span><br><span class="line">            x = next;</span><br><span class="line">        &#125;</span><br><span class="line">        first = last = <span class="keyword">null</span>;</span><br><span class="line">        size = <span class="number">0</span>;</span><br><span class="line">        modCount++;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="set-get"><a href="#set-get" class="headerlink" title="set(), get()"></a>set(), get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        Node&lt;E&gt; x = node(index);</span><br><span class="line">        E oldVal = x.item;</span><br><span class="line">        x.item = element;</span><br><span class="line">        <span class="keyword">return</span> oldVal;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        checkElementIndex(index);</span><br><span class="line">        <span class="keyword">return</span> node(index).item;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>查找第一次出现指定元素的下标和最后一次出现指定元素的下标，找不到则返回-1。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = first; x != <span class="keyword">null</span>; x = x.next) &#123;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">                index++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> index = size;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (x.item == <span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; x = last; x != <span class="keyword">null</span>; x = x.prev) &#123;</span><br><span class="line">                index--;</span><br><span class="line">                <span class="keyword">if</span> (o.equals(x.item))</span><br><span class="line">                    <span class="keyword">return</span> index;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Queue接口的方法"><a href="#Queue接口的方法" class="headerlink" title="Queue接口的方法"></a>Queue接口的方法</h3><p>peek(): 获取第一个元素。null不会抛异常。</p><p>element(): 获取第一个元素，如果为null会抛异常。</p><p>poll(): 获取并删除第一个元素。</p><p>offer(): 末尾添加元素。</p><p>参考：<a href="https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/collection/java-collection-LinkedList.html</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;&lt;em&gt;LinkedList&lt;/em&gt;同时实现了&lt;em&gt;List&lt;/em&gt;, &lt;em&gt;Queue&lt;/em&gt;和&lt;em&gt;Deque&lt;/em&gt;三个
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>ArrayList源码剖析</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/ArrayList%E6%BA%90%E7%A0%81%E5%89%96%E6%9E%90/</id>
    <published>2020-09-07T09:18:35.000Z</published>
    <updated>2020-09-08T10:47:58.408Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>​          <em>ArrayList</em>实现了<em>List</em>接口，是顺序容器，即元素存放的数据与放进去的顺序相同，允许放入<code>null</code>元素，底层通过<strong>数组实现</strong>。</p><p>​          每个<em>ArrayList</em>都有一个容量(capacity)，表示底层数组的实际大小。当向容器中添加元素时，如果容量不足，容器会自动增大底层数组的大小。</p><p><img src="ArrayList_base.png" alt=""></p><p>​          size(), isEmpty(), get(), set()方法均能在常数时间内完成，add()方法的时间开销跟插入位置有关，addAll()方法的时间开销跟添加元素的个数成正比。其余方法大都是线性时间。</p><p>​          为追求效率，ArrayList没有实现同步(synchronized)，如果需要多个线程并发访问，可使用Vector替代。ArrayList除未实现同步外，其余跟<em>Vector</em>大致相同。</p><h2 id="ArrayList的实现"><a href="#ArrayList的实现" class="headerlink" title="ArrayList的实现"></a>ArrayList的实现</h2><h3 id="ArrayList中的常量"><a href="#ArrayList中的常量" class="headerlink" title="ArrayList中的常量"></a>ArrayList中的常量</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Default initial capacity.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_CAPACITY = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for empty instances.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] EMPTY_ELEMENTDATA = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Shared empty array instance used for default sized empty instances. We</span></span><br><span class="line"><span class="comment">     * distinguish this from EMPTY_ELEMENTDATA to know how much to inflate when</span></span><br><span class="line"><span class="comment">     * first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;;</span><br></pre></td></tr></table></figure><h3 id="底层数据结构"><a href="#底层数据结构" class="headerlink" title="底层数据结构"></a>底层数据结构</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The array buffer into which the elements of the ArrayList are stored.</span></span><br><span class="line"><span class="comment">     * The capacity of the ArrayList is the length of this array buffer. Any</span></span><br><span class="line"><span class="comment">     * empty ArrayList with elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span></span><br><span class="line"><span class="comment">     * will be expanded to DEFAULT_CAPACITY when the first element is added.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">transient</span> Object[] elementData; <span class="comment">// non-private to simplify nested class access</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The size of the ArrayList (the number of elements it contains).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@serial</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> size;</span><br></pre></td></tr></table></figure><h3 id="三种构造函数"><a href="#三种构造函数" class="headerlink" title="三种构造函数"></a>三种构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with the specified initial capacity.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>  initialCapacity  the initial capacity of the list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IllegalArgumentException if the specified initial capacity</span></span><br><span class="line"><span class="comment">     *         is negative</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = <span class="keyword">new</span> Object[initialCapacity];</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (initialCapacity == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal Capacity: "</span>+</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs an empty list with an initial capacity of ten.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Constructs a list containing the elements of the specified</span></span><br><span class="line"><span class="comment">     * collection, in the order they are returned by the collection's</span></span><br><span class="line"><span class="comment">     * iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c the collection whose elements are to be placed into this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ArrayList</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        elementData = c.toArray();</span><br><span class="line">        <span class="keyword">if</span> ((size = elementData.length) != <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span></span><br><span class="line">            <span class="keyword">if</span> (elementData.getClass() != Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line"><span class="class">                <span class="title">elementData</span> </span>= Arrays.copyOf(elementData, size, Object[]<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// replace with empty array.</span></span><br><span class="line">            <span class="keyword">this</span>.elementData = EMPTY_ELEMENTDATA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="自动扩容机制"><a href="#自动扩容机制" class="headerlink" title="自动扩容机制"></a>自动扩容机制</h3><p>​          每当向数组中添加元素时，都要检查添加后元素的个数是否会超出当前数组的长度，如果超出，数组将会进行自动扩容。</p><p>​          数组扩容通过公开方法ensureCapacity(int minCapacity)实现。当需要使用<em>ArrayList</em>存储较多数据时，我们最好手动使用该方法进行扩容，以减少每次1.5倍自动扩容产生的复制数组元素的开销。因为<em>ArrayList</em>的初始容量只有10。</p><p>​          注意以下源码中，grow()方法中的<code>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1);</code>，可见每次扩容是在现有容量的基础上增加0.5倍容量。由于每次扩容老数组的元素会复制到新数组中，可见自动扩容机制的开销非常大。<strong>我们在实际使用ArrayList的时候，在可预知要保存多少个元素的情况下，应该在new ArrayList时指定容量大小。</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance, if</span></span><br><span class="line"><span class="comment">     * necessary, to ensure that it can hold at least the number of elements</span></span><br><span class="line"><span class="comment">     * specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span>   minCapacity   the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">ensureCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> minExpand = (elementData != DEFAULTCAPACITY_EMPTY_ELEMENTDATA)</span><br><span class="line">            <span class="comment">// any size if not default element table</span></span><br><span class="line">            ? <span class="number">0</span></span><br><span class="line">            <span class="comment">// larger than default for default empty table. It's already</span></span><br><span class="line">            <span class="comment">// supposed to be at default size.</span></span><br><span class="line">            : DEFAULT_CAPACITY;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (minCapacity &gt; minExpand) &#123;</span><br><span class="line">            ensureExplicitCapacity(minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">calculateCapacity</span><span class="params">(Object[] elementData, <span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;</span><br><span class="line">            <span class="keyword">return</span> Math.max(DEFAULT_CAPACITY, minCapacity);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> minCapacity;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureCapacityInternal</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        ensureExplicitCapacity(calculateCapacity(elementData, minCapacity));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">ensureExplicitCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">if</span> (minCapacity - elementData.length &gt; <span class="number">0</span>)</span><br><span class="line">            grow(minCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * The maximum size of array to allocate.</span></span><br><span class="line"><span class="comment">     * Some VMs reserve some header words in an array.</span></span><br><span class="line"><span class="comment">     * Attempts to allocate larger arrays may result in</span></span><br><span class="line"><span class="comment">     * OutOfMemoryError: Requested array size exceeds VM limit</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_ARRAY_SIZE = Integer.MAX_VALUE - <span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Increases the capacity to ensure that it can hold at least the</span></span><br><span class="line"><span class="comment">     * number of elements specified by the minimum capacity argument.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> minCapacity the desired minimum capacity</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">grow</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// overflow-conscious code</span></span><br><span class="line">        <span class="keyword">int</span> oldCapacity = elementData.length;</span><br><span class="line">        <span class="keyword">int</span> newCapacity = oldCapacity + (oldCapacity &gt;&gt; <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - minCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = minCapacity;</span><br><span class="line">        <span class="keyword">if</span> (newCapacity - MAX_ARRAY_SIZE &gt; <span class="number">0</span>)</span><br><span class="line">            newCapacity = hugeCapacity(minCapacity);</span><br><span class="line">        <span class="comment">// minCapacity is usually close to size, so this is a win:</span></span><br><span class="line">        elementData = Arrays.copyOf(elementData, newCapacity);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">hugeCapacity</span><span class="params">(<span class="keyword">int</span> minCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (minCapacity &lt; <span class="number">0</span>) <span class="comment">// overflow</span></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError();</span><br><span class="line">        <span class="keyword">return</span> (minCapacity &gt; MAX_ARRAY_SIZE) ?</span><br><span class="line">            Integer.MAX_VALUE :</span><br><span class="line">            MAX_ARRAY_SIZE;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="ArrayList_grow.png" alt=""></p><h3 id="add-addAll"><a href="#add-addAll" class="headerlink" title="add(), addAll()"></a>add(), addAll()</h3><p>​          添加元素之前，调用<code>ensureCapacityInternal(size + 1);</code>检查当前数组元素个数是否已达容量上限，是则进行grow操作。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends the specified element to the end of this list.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> e element to be appended to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; (as specified by &#123;<span class="doctag">@link</span> Collection#add&#125;)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        elementData[size++] = e;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts the specified element at the specified position in this</span></span><br><span class="line"><span class="comment">     * list. Shifts the element currently at that position (if any) and</span></span><br><span class="line"><span class="comment">     * any subsequent elements to the right (adds one to their indices).</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which the specified element is to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> element element to be inserted</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        ensureCapacityInternal(size + <span class="number">1</span>);  <span class="comment">// Increments modCount!!</span></span><br><span class="line">        System.arraycopy(elementData, index, elementData, index + <span class="number">1</span>,</span><br><span class="line">                         size - index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        size++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheckForAdd</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt; size || index &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><img src="ArrayList_add.png" alt=""></p><p>add(int index, E element)操作的时间复杂度与插入元素的位置相关。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Appends all of the elements in the specified collection to the end of</span></span><br><span class="line"><span class="comment">     * this list, in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection's Iterator.  The behavior of this operation is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is modified while the operation</span></span><br><span class="line"><span class="comment">     * is in progress.  (This implies that the behavior of this call is</span></span><br><span class="line"><span class="comment">     * undefined if the specified collection is this list, and this</span></span><br><span class="line"><span class="comment">     * list is nonempty.)</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, size, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Inserts all of the elements in the specified collection into this</span></span><br><span class="line"><span class="comment">     * list, starting at the specified position.  Shifts the element</span></span><br><span class="line"><span class="comment">     * currently at that position (if any) and any subsequent elements to</span></span><br><span class="line"><span class="comment">     * the right (increases their indices).  The new elements will appear</span></span><br><span class="line"><span class="comment">     * in the list in the order that they are returned by the</span></span><br><span class="line"><span class="comment">     * specified collection's iterator.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> index index at which to insert the first element from the</span></span><br><span class="line"><span class="comment">     *              specified collection</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c collection containing elements to be added to this list</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> &lt;tt&gt;true&lt;/tt&gt; if this list changed as a result of the call</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> IndexOutOfBoundsException &#123;<span class="doctag">@inheritDoc</span>&#125;</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@throws</span> NullPointerException if the specified collection is null</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">addAll</span><span class="params">(<span class="keyword">int</span> index, Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">        rangeCheckForAdd(index);</span><br><span class="line"></span><br><span class="line">        Object[] a = c.toArray();</span><br><span class="line">        <span class="keyword">int</span> numNew = a.length;</span><br><span class="line">        ensureCapacityInternal(size + numNew);  <span class="comment">// Increments modCount</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index, elementData, index + numNew,</span><br><span class="line">                             numMoved);</span><br><span class="line"></span><br><span class="line">        System.arraycopy(a, <span class="number">0</span>, elementData, index, numNew);</span><br><span class="line">        size += numNew;</span><br><span class="line">        <span class="keyword">return</span> numNew != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>与<code>add()</code>方法类似，在插入之前也需要进行空间检查，如果需要则自动扩容；如果从指定位置插入，也会存在移动元素的情况。 <code>addAll()</code>的时间复杂度不仅跟插入元素的多少有关，也跟插入的位置相关。</p><h3 id="set-get"><a href="#set-get" class="headerlink" title="set(), get()"></a>set(), get()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">set</span><span class="params">(<span class="keyword">int</span> index, E element)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line">        elementData[index] = element;</span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">rangeCheck</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (index &gt;= size)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException(outOfBoundsMsg(index));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="remove"><a href="#remove" class="headerlink" title="remove()"></a>remove()</h3><p><code>remove()</code>方法也有两个版本，一个是<code>remove(int index)</code>删除指定位置的元素，另一个是<code>remove(Object o)</code>删除第一个满足<code>o.equals(elementData[index])</code>的元素。删除操作是<code>add()</code>操作的逆过程，需要将删除点之后的元素向前移动一个位置。<u><strong>注意，根据可达性分析算法，必须将数组中最后一个位置的引用清除掉，堆中的对象才会被回收，也就是显式的为最后一个位置赋<code>null</code>值。</strong></u></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line"></span><br><span class="line">        modCount++;</span><br><span class="line">        E oldValue = elementData(index);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> oldValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[index] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; size; index++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[index])) &#123;</span><br><span class="line">                    fastRemove(index);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fastRemove</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">int</span> numMoved = size - index - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (numMoved &gt; <span class="number">0</span>)</span><br><span class="line">            System.arraycopy(elementData, index+<span class="number">1</span>, elementData, index,</span><br><span class="line">                             numMoved);</span><br><span class="line">        elementData[--size] = <span class="keyword">null</span>; <span class="comment">// clear to let GC do its work</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="trimToSize"><a href="#trimToSize" class="headerlink" title="trimToSize()"></a>trimToSize()</h3><p>将底层数组的容量调整为当前列表保存的实际元素的大小。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Trims the capacity of this &lt;tt&gt;ArrayList&lt;/tt&gt; instance to be the</span></span><br><span class="line"><span class="comment">     * list's current size.  An application can use this operation to minimize</span></span><br><span class="line"><span class="comment">     * the storage of an &lt;tt&gt;ArrayList&lt;/tt&gt; instance.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">trimToSize</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        modCount++;</span><br><span class="line">        <span class="keyword">if</span> (size &lt; elementData.length) &#123;</span><br><span class="line">            elementData = (size == <span class="number">0</span>)</span><br><span class="line">              ? EMPTY_ELEMENTDATA</span><br><span class="line">              : Arrays.copyOf(elementData, size);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="indexOf-lastIndexOf"><a href="#indexOf-lastIndexOf" class="headerlink" title="indexOf(), lastIndexOf()"></a>indexOf(), lastIndexOf()</h3><p>获取元素第一次出现的index:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the index of the first occurrence of the specified element</span></span><br><span class="line"><span class="comment">     * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment">     * More formally, returns the lowest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">indexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>获取元素最后一次出现的index: （倒序遍历数组）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns the index of the last occurrence of the specified element</span></span><br><span class="line"><span class="comment">     * in this list, or -1 if this list does not contain the element.</span></span><br><span class="line"><span class="comment">     * More formally, returns the highest index &lt;tt&gt;i&lt;/tt&gt; such that</span></span><br><span class="line"><span class="comment">     * &lt;tt&gt;(o==null&amp;nbsp;?&amp;nbsp;get(i)==null&amp;nbsp;:&amp;nbsp;o.equals(get(i)))&lt;/tt&gt;,</span></span><br><span class="line"><span class="comment">     * or -1 if there is no such index.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lastIndexOf</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (o == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (elementData[i]==<span class="keyword">null</span>)</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = size-<span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">                <span class="keyword">if</span> (o.equals(elementData[i]))</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="快速失败机制"><a href="#快速失败机制" class="headerlink" title="快速失败机制"></a>快速失败机制</h3><p><em>ArrayList</em>的Fail-Fast机制通过记录modCount的值来实现。该变量在ArrayList的父抽象类AbastractList定义，其含义是容器发生结构性修改的次数。详细介绍在迭代器篇。</p><h3 id="Arrays-copyof-和System-arraycopy"><a href="#Arrays-copyof-和System-arraycopy" class="headerlink" title="Arrays.copyof()和System.arraycopy()"></a>Arrays.copyof()和System.arraycopy()</h3><p>Arrays的copyof()方法有很多重载方法，以下为ArrayList中使用的重载版本。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; T[] copyOf(T[] original, <span class="keyword">int</span> newLength) &#123;</span><br><span class="line">        <span class="keyword">return</span> (T[]) copyOf(original, newLength, original.getClass());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T,U&gt; T[] copyOf(U[] original, <span class="keyword">int</span> newLength, Class&lt;? extends T[]&gt; newType) &#123;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        T[] copy = ((Object)newType == (Object)Object[]<span class="class">.<span class="keyword">class</span>)</span></span><br><span class="line">            ? (T[]) new Object[newLength]</span><br><span class="line">            : (T[]) Array.newInstance(newType.getComponentType(), newLength);</span><br><span class="line">        System.arraycopy(original, <span class="number">0</span>, copy, <span class="number">0</span>,</span><br><span class="line">                         Math.min(original.length, newLength));</span><br><span class="line">        <span class="keyword">return</span> copy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>第二个方法最后一个参数表示最后返回的数组元素数据类型，也就是新数组的数据元素类型。该方法在内部创建了了一个长度为newLength的新数组，又调用了System.arraycopy()方法将老数组的元素复制到新数组。</p><p>查看java.lang.System发现，System.arraycopy()为本地方法，最终调用了C语言的函数来实现复制。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">arraycopy</span><span class="params">(Object src, <span class="keyword">int</span> srcPos, Object dest, <span class="keyword">int</span> destPos, <span class="keyword">int</span> length)</span></span>;</span><br></pre></td></tr></table></figure><p>参考：<a href="https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html" target="_blank" rel="noopener">https://www.pdai.tech/md/java/collection/java-collection-ArrayList.html</a></p><p>​            <a href="https://blog.csdn.net/ns_code/article/details/35568011" target="_blank" rel="noopener">https://blog.csdn.net/ns_code/article/details/35568011</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;​          &lt;em&gt;ArrayList&lt;/em&gt;实现了&lt;em&gt;List&lt;/em&gt;接口，是顺序容器，即元素存放的数据与放进去的顺序相
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>集合知识体系结构</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E9%9B%86%E5%90%88%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</id>
    <published>2020-09-07T09:17:52.000Z</published>
    <updated>2020-09-08T00:50:53.075Z</updated>
    
    <content type="html"><![CDATA[<h2 id="集合知识体系结构"><a href="#集合知识体系结构" class="headerlink" title="集合知识体系结构"></a>集合知识体系结构</h2><p><img src="java_collections_overview.png" alt=""></p><h2 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h2><h3 id="List"><a href="#List" class="headerlink" title="List"></a>List</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><ul><li>基于动态数组实现，支持随机访问。</li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><ul><li>和 ArrayList 类似，但它是线程安全的。</li></ul><h5 id="Stack"><a href="#Stack" class="headerlink" title="Stack"></a>Stack</h5><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li>基于双向链表实现，只能顺序访问，但是可以快速地在链表中间插入和删除元素。不仅如此，LinkedList 还可以用作栈、队列和双向队列。</li></ul><h3 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h3><h4 id="LinkedList-1"><a href="#LinkedList-1" class="headerlink" title="LinkedList"></a>LinkedList</h4><ul><li>同上</li></ul><h4 id="PriorityQueue"><a href="#PriorityQueue" class="headerlink" title="PriorityQueue"></a>PriorityQueue</h4><ul><li>基于堆结构实现，可以用它来实现优先队列。</li></ul><h4 id="Deque-lt-gt"><a href="#Deque-lt-gt" class="headerlink" title="Deque&lt;&gt;"></a>Deque&lt;<Interface>&gt;</h4><h5 id="ArrayDeque"><a href="#ArrayDeque" class="headerlink" title="ArrayDeque"></a>ArrayDeque</h5><ul><li>基于数组实现的队列，比LinkedList性能更好。</li></ul><h3 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h3><h4 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h4><ul><li>基于哈希表实现，支持快速查找，但不支持有序性操作。并且失去了元素的插入顺序信息，也就是说使用 Iterator 遍历 HashSet 得到的结果是不确定的。</li></ul><h4 id="LinkedHashSet"><a href="#LinkedHashSet" class="headerlink" title="LinkedHashSet"></a>LinkedHashSet</h4><ul><li>具有 HashSet 的查找效率，且内部使用双向链表维护元素的插入顺序。</li></ul><h4 id="TreeSet"><a href="#TreeSet" class="headerlink" title="TreeSet"></a>TreeSet</h4><ul><li>基于红黑树实现，支持有序性操作，例如根据一个范围查找元素的操作。但是查找效率不如 HashSet，HashSet 查找的时间复杂度为 O(1)，TreeSet 则为 O(logN)。</li></ul><h2 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h2><h4 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h4><ul><li>基于哈希表实现。</li></ul><h4 id="LinkedHashMap"><a href="#LinkedHashMap" class="headerlink" title="LinkedHashMap"></a>LinkedHashMap</h4><ul><li>使用双向链表来维护元素的顺序，顺序为插入顺序或者最近最少使用(LRU)顺序。</li></ul><h4 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h4><ul><li>和 HashMap 类似，但它是线程安全的，这意味着同一时刻多个线程可以同时写入 HashTable 并且不会导致数据不一致。它是遗留类，不应该去使用它。现在可以使用 ConcurrentHashMap 来支持线程安全，并且 ConcurrentHashMap 的效率会更高，因为 ConcurrentHashMap 引入了分段锁。</li></ul><h4 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h4><ul><li>基于红黑树实现。</li></ul><h2 id="Collections工具类"><a href="#Collections工具类" class="headerlink" title="Collections工具类"></a>Collections工具类</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;集合知识体系结构&quot;&gt;&lt;a href=&quot;#集合知识体系结构&quot; class=&quot;headerlink&quot; title=&quot;集合知识体系结构&quot;&gt;&lt;/a&gt;集合知识体系结构&lt;/h2&gt;&lt;p&gt;&lt;img src=&quot;java_collections_overview.png&quot; alt=&quot;
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>比较器与迭代器</title>
    <link href="http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/"/>
    <id>http://thmasterplan.cn/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/%E6%AF%94%E8%BE%83%E5%99%A8%E4%B8%8E%E8%BF%AD%E4%BB%A3%E5%99%A8/</id>
    <published>2020-09-07T09:17:29.000Z</published>
    <updated>2020-09-07T11:36:53.302Z</updated>
    
    <content type="html"><![CDATA[<h2 id="比较器"><a href="#比较器" class="headerlink" title="比较器"></a>比较器</h2><h3 id="Comparable"><a href="#Comparable" class="headerlink" title="Comparable"></a>Comparable</h3><ul><li><p>java.lang.Comparable源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparable&lt;T&gt; &#123;</span><br><span class="line">    public int compareTo(T o);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Comparable的实现类，其实例化对象和同类型对象比较。</p><p>其<strong>compareTo方法只有一个参数</strong>，一个和自己比较的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。</p><p>对于容器来说，在<strong>容器内部实现</strong>compareTo方法。</p></li></ul><h3 id="Comparator"><a href="#Comparator" class="headerlink" title="Comparator"></a>Comparator</h3><ul><li><p>java.util.Comparator源码主要部分：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Comparator&lt;T&gt;&#123;</span><br><span class="line">     int compare(T o1, T o2);</span><br><span class="line">     boolean equals(Object obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Comparator的实现类，其实例化对象作为裁判。</p><p>其<strong>compare方法是两个参数</strong>，裁判来比较传入的对象，返回值为分为负整数、0、正整数三种情形，该值用于底层排序算法的条件判断。</p><p>对于容器来说，在<strong>容器外部实现</strong>compare方法。</p></li></ul><h3 id="二者的选择"><a href="#二者的选择" class="headerlink" title="二者的选择"></a>二者的选择</h3><ul><li>排序规则固定，Comparable接口。排序规则经常变化，Comparator接口。</li></ul><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>​           由于各种容器的底层实现结构（数组，链表，哈希表等）不同，把容器元素的访问逻辑从不同类型容器中抽取出来，从而避免暴露容器的内部结构，使用户对容器元素的操作更简单，即<strong>迭代器模式</strong>。</p><h3 id="Iterable"><a href="#Iterable" class="headerlink" title="Iterable"></a>Iterable</h3><ul><li><p>java.lang.Iteable源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterable&lt;T&gt; &#123;</span><br><span class="line"> </span><br><span class="line">    Iterator&lt;T&gt; iterator();</span><br><span class="line"></span><br><span class="line">    default void forEach(Consumer&lt;? super T&gt; action)&#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        for (T t : this) &#123;</span><br><span class="line">            action.accept(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    default Spliterator&lt;T&gt; spliterator() &#123;</span><br><span class="line">        return Spliterators.spliteratorUnknownSize(iterator(), 0);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Collection接口继承自Iterable接口，Iterable的作用是：</p><ul><li>使得其所有实现成为foreach语句的目标</li><li>其iterator()方法返回一个标准的Iterator实现</li></ul></li></ul><h3 id="Iterator"><a href="#Iterator" class="headerlink" title="Iterator"></a>Iterator</h3><ul><li><p>java.util.Iterator源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public interface Iterator&lt;E&gt; &#123;</span><br><span class="line"></span><br><span class="line">    boolean hasNext();&#x2F;&#x2F;判断是否存在下一个元素</span><br><span class="line"></span><br><span class="line">    E next();&#x2F;&#x2F;获取下一个元素</span><br><span class="line"></span><br><span class="line">    default void remove() &#123;</span><br><span class="line">        throw new UnsupportedOperationException(&quot;remove&quot;);</span><br><span class="line">    &#125;&#x2F;&#x2F;移除元素</span><br><span class="line"></span><br><span class="line">    default void forEachRemaining(Consumer&lt;? super E&gt; action) &#123;</span><br><span class="line">        Objects.requireNonNull(action);</span><br><span class="line">        while (hasNext())</span><br><span class="line">            action.accept(next());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>Iterator遍历时禁止对容器进行增删的问题</strong></p><p>​          使用Iterator或者foreach（foreach底层实现为Iterator）时，禁止对所遍历的容器进行改变其大小结构的操作，也即不能使用容器的add/remove方法，否则会报ConcurrentModificationException。</p><p>​          ArrayList中Iterator实现源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ArrayList的内部类</span><br><span class="line">private class Itr implements Iterator&lt;E&gt; &#123;</span><br><span class="line">        int cursor;       &#x2F;&#x2F; index of next element to return</span><br><span class="line">        int lastRet &#x3D; -1; &#x2F;&#x2F; index of last element returned; -1 if no such</span><br><span class="line">        int expectedModCount &#x3D; modCount;</span><br><span class="line"></span><br><span class="line">        Itr() &#123;&#125;</span><br><span class="line"></span><br><span class="line">        public boolean hasNext() &#123;</span><br><span class="line">            return cursor !&#x3D; size;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public E next() &#123;</span><br><span class="line">            checkForComodification();</span><br><span class="line">            int i &#x3D; cursor;</span><br><span class="line">            if (i &gt;&#x3D; size)</span><br><span class="line">                throw new NoSuchElementException();</span><br><span class="line">            Object[] elementData &#x3D; ArrayList.this.elementData;</span><br><span class="line">            if (i &gt;&#x3D; elementData.length)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            cursor &#x3D; i + 1;</span><br><span class="line">            return (E) elementData[lastRet &#x3D; i];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        public void remove() &#123;</span><br><span class="line">            if (lastRet &lt; 0)</span><br><span class="line">                throw new IllegalStateException();</span><br><span class="line">            checkForComodification();</span><br><span class="line"></span><br><span class="line">            try &#123;</span><br><span class="line">                ArrayList.this.remove(lastRet);</span><br><span class="line">                cursor &#x3D; lastRet;</span><br><span class="line">                lastRet &#x3D; -1;</span><br><span class="line">                expectedModCount &#x3D; modCount;</span><br><span class="line">            &#125; catch (IndexOutOfBoundsException ex) &#123;</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        @Override</span><br><span class="line">        @SuppressWarnings(&quot;unchecked&quot;)</span><br><span class="line">        public void forEachRemaining(Consumer&lt;? super E&gt; consumer) &#123;&#x2F;&#x2F;省略</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        final void checkForComodification() &#123;</span><br><span class="line">            if (modCount !&#x3D; expectedModCount)</span><br><span class="line">                throw new ConcurrentModificationException();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public Iterator&lt;E&gt; iterator() &#123;</span><br><span class="line">        return new Itr();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​          由源码可知，检查并抛出异常的是checkForComodification方法，其判断条件为modCount != expectedModCount。expectedModCount是迭代器类Itr的成员变量，在迭代器对象创建时赋初值为modCount。那么modCount是什么呢？</p><p>​          找遍ArrayList类也没有发现modCount，那么向上找，发现其是ArrayList的父抽象类AbstractList的成员变量，其注释如下图</p><p><img src="list_iterator_modCount.png" alt=""></p><p>​           由注释可知，modCount的含义是<strong>list被结构性修改的次数</strong>。</p><p>​           由此可知，当ArrayList调用其add/remove方法时，modCount会自加，而此时迭代器中的expectedModCount未同步，因此才会导致再次调用next方法时抛出异常。如若使用ArrayList迭代器自带的remove方法，迭代器会同步更新expectedModCount的值，因此再次调用next不会报异常。</p><p>​           使用该机制的主要目的是为了实现ArrayList中的快速失败机制（fail-fast），在<strong>Java集合中较大一部分集合是存在快速失败机制的</strong>。</p><p>​           快速失败机制产生的条件：当多个线程对Collection进行操作时，若其中某一个线程通过Iterator遍历集合时，该集合的内容被其他线程所改变，则会抛出ConcurrentModificationException异常。</p><p>　       所以要保证在使用Iterator遍历集合的时候不出错误，就应该保证在遍历集合的过程中不会对集合产生结构上的修改。</p></li><li><p><strong>总结</strong>：在使用迭代器时，ArrayList不能调用自身的add/remove方法。</p><p>​           但可以使用ArrayList的迭代器的remove方法，该方法移除迭代器返回的最后一个元素，且每调用一次next方法才能调用一次该remove方法（一对一）。</p><p>​           还可以使用ListIterator，它是一个更加强大的Iterator的子类型，可以使用add/remove方法。</p><p>​           参考：<a href="https://www.cnblogs.com/zyuze/p/7726582.html" target="_blank" rel="noopener">https://www.cnblogs.com/zyuze/p/7726582.html</a></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;比较器&quot;&gt;&lt;a href=&quot;#比较器&quot; class=&quot;headerlink&quot; title=&quot;比较器&quot;&gt;&lt;/a&gt;比较器&lt;/h2&gt;&lt;h3 id=&quot;Comparable&quot;&gt;&lt;a href=&quot;#Comparable&quot; class=&quot;headerlink&quot; title=&quot;C
      
    
    </summary>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/categories/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Java集合框架" scheme="http://thmasterplan.cn/tags/Java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Java泛型</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E6%B3%9B%E5%9E%8B/</id>
    <published>2020-09-04T11:06:21.000Z</published>
    <updated>2020-09-07T11:39:01.507Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><ul><li><p>在创建接口、类、方法时，为了<strong>代码复用</strong>和<strong>类型安全</strong>，使用泛型来作为类型。<strong>泛型可以看作形式参数</strong>，用于接受数据类型，当创建对象、实现接口、调用方法时才指定具体的类型。例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">List</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TestList</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">        List&lt;Integer&gt; list = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">        List&lt;Double&gt; list = <span class="keyword">new</span> List&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用类时才指定List中元素具体的类型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>Java泛型从JDK1.5引入，为了兼容之前的版本，Java泛型的实现采取了“伪泛型”的策略，即Java在语法上支持泛型，但在<strong>编译阶段</strong>会进行“<strong>类型擦除（Type Erasure）</strong>”，将所有的泛型表示都替换为具体的类型。</p></li></ul><h3 id="为什么引入泛型"><a href="#为什么引入泛型" class="headerlink" title="为什么引入泛型"></a>为什么引入泛型</h3><ul><li><p><strong>为了代码复用</strong>：适用于多种数据类型执行相同的代码，例如</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T extends Number&gt; double add(T a, T b) &#123;</span><br><span class="line">    return a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果没有泛型，则对于int、float、double等类型都需要重载一个add方法。</p></li><li><p><strong>为了类型安全</strong>：泛型类型在使用时指定，同时也就限定了集合中只能存储某一种具体类型的数据。以ArrayList为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ArrayList</span>&lt;<span class="title">E</span>&gt; <span class="keyword">extends</span> <span class="title">AbstractList</span>&lt;<span class="title">E</span>&gt;</span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">List</span>&lt;<span class="title">E</span>&gt;, <span class="title">RandomAccess</span>, <span class="title">Cloneable</span>, <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line"><span class="keyword">transient</span> Object[] elementData;<span class="comment">//ArrayList源码中定义的元素类型为Object</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">get</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        rangeCheck(index);</span><br><span class="line">        <span class="keyword">return</span> elementData(index);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">E <span class="title">elementData</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (E) elementData[index];<span class="comment">//强制类型转换，由Object向下转型</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由源码可知，当调用get方法获取ArrayList元素时，get方法调用elementData方法，其return时由ArrayList完成强制类型转换（向下转型）。</p><p><strong>如若ArrayList没有泛型机制会怎么样呢？</strong></p><p>那么，get方法只能返回Object类型的数据，<strong>好处</strong>是程序员可以使用ArrayList<strong>存储多种类型的数据</strong>。但是<strong>坏处</strong>也显而易见，当程序员使用ArrayList存储”String”、”Integer”、”Double”等各种类型的数据时，调用get方法得到的是Object类型，此时若程序员对这些数据向下转型为某种类型（比如String，<code>String s = (String) obj</code>），编译期不会报错，运行期才会报ClassCastException（因为Integer、Double不能强制转换为String），也就是<strong>类型不安全</strong>。</p></li></ul><h2 id="泛型的基本使用"><a href="#泛型的基本使用" class="headerlink" title="泛型的基本使用"></a>泛型的基本使用</h2><h3 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h3><ul><li><p>使用泛型类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> T element;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getElement</span><span class="params">()</span></span>&#123;</span><br><span class="line">        retruen element;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setElement</span><span class="params">(T elem)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.element = elem;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestA</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       A&lt;String&gt; a = <span class="keyword">new</span> A&lt;&gt;();</span><br><span class="line">       a.setElement(<span class="string">"test string..."</span>);</span><br><span class="line">       System.out.println(a.getElement().length());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>多元泛型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt;</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> K key;</span><br><span class="line">    <span class="keyword">private</span> V value;</span><br><span class="line">    <span class="comment">//set,get方法。。。</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestB</span></span>&#123;</span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       B&lt;String, Integer&gt; b = <span class="keyword">new</span> B&lt;&gt;();</span><br><span class="line">       b.setKey(<span class="string">"小明"</span>);</span><br><span class="line">       b.setValue(<span class="string">"18"</span>);</span><br><span class="line">       System.out.println(<span class="string">"姓名："</span>+b.getKey());</span><br><span class="line">       System.out.println(<span class="string">"年龄："</span>+b.getValue());</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型接口"><a href="#泛型接口" class="headerlink" title="泛型接口"></a>泛型接口</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">interface</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">getElem</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CImpl</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">C</span>&lt;<span class="title">T</span>&gt;</span>&#123;</span><br><span class="line">    <span class="comment">//....</span></span><br><span class="line">&#125;<span class="comment">//也可在接口的实现类这一步指定具体的类型</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestC</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">       C&lt;String&gt; c = <span class="keyword">new</span> CImpl&lt;&gt;();</span><br><span class="line">      <span class="comment">//...  </span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h3><ul><li><p>格式：<code>修饰符 &lt;泛型&gt; 返回值类型 方法名(参数列表(使用泛型)){ //方法体 }</code>。泛型方法在<strong>调用方法时确定数据类型</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">GenericMethod</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> &lt;T&gt; <span class="keyword">void</span> method&lt;T t&gt;&#123;</span><br><span class="line">        System.out.println(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestGenericMethod</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        GenericMethod gm = <span class="keyword">new</span> GenericMethod();</span><br><span class="line">        gm.method(<span class="string">"123"</span>);</span><br><span class="line">        gm.method(<span class="number">123</span>);</span><br><span class="line">        <span class="comment">//传递什么类型的参数，泛型就是什么类型</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="泛型的上下限"><a href="#泛型的上下限" class="headerlink" title="泛型的上下限"></a>泛型的上下限</h3><ul><li><p>有时候我们希望泛型只接收某些类型，而不是所有类型，那么我们就需要限定泛型的接收范围。</p><ul><li><p><code>&lt;?&gt;</code>：无限制通配符，表示任意类型。 </p></li><li><p><code>&lt;? extends E&gt;</code>： 表示只接收E类型，或者E类型的子类。</p></li><li><p><code>&lt;? super E&gt;</code>： 表示只接收E类型，或者E类型的父类。</p></li><li><p>例如：以下代码表示T类型只能是Number类或者其子类，在限定了接收类型的同时，还可以使用Number类的方法和成员变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">private static &lt;T extends Number&gt; double add(T a, T b) &#123;</span><br><span class="line">    return a.doubleValue() + b.doubleValue();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在创建接口、类、方法时，为了&lt;strong&gt;代码复用&lt;/strong&gt;和&lt;strong&gt;类型安全&lt;/strong&gt;，使用泛
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>虚拟机类加载机制</title>
    <link href="http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/"/>
    <id>http://thmasterplan.cn/JVM/%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%B1%BB%E5%8A%A0%E8%BD%BD%E6%9C%BA%E5%88%B6/</id>
    <published>2020-09-03T09:22:40.000Z</published>
    <updated>2020-09-07T11:34:07.032Z</updated>
    
    <content type="html"><![CDATA[<h3 id="类加载过程"><a href="#类加载过程" class="headerlink" title="类加载过程"></a>类加载过程</h3><ul><li>一个Java类从编写完成到被卸载的过程：X.java -&gt; X.class（编译为磁盘中的二进制文件）-&gt; 加载（ClassLoader将X.class加载到虚拟机内存）-&gt; 连接 （确定类与类之间的关系，包含验证、准备、解析三步） -&gt; 初始化  -&gt; 使用 -&gt; 卸载。类是在运行期间第一次使用时动态加载的，而不是一次性加载所有类。因为如果一次性加载，那么会占用很多的内存。类加载过程如下图：</li></ul><p><img src="ClassLoading_Procedure.png" alt=""></p><ul><li><p><strong>加载</strong>：加载是类加载的一个阶段，注意不要混淆。</p><p>加载阶段完成以下三件事：</p><ul><li>通过一个类的全限定名来<strong>获取</strong>定义此类的<strong>二进制字节流</strong>。</li><li>将该字节流表示的静态存储结构<strong>转换</strong>为<strong>方法区的运行时数据结构</strong>。</li><li>在内存中<strong>生成</strong>一个代表该类的java.lang.<strong>Class对象</strong>，<strong>作为</strong>方法区该类的各种<strong>数据的访问入口</strong>。</li></ul><p>二进制字节流的获取方式有：</p><ul><li>从<strong>ZIP包</strong>读取，成为 JAR、EAR、WAR 格式的基础。</li><li>从<strong>网络</strong>获取，典型应用为Applet</li><li><strong>运行时计算生成</strong>，比如动态代理技术，在java.lang.reflect.Proxy中使用ProxyGenerator.generateProxyClass来为特定接口生成代理类的二进制字节流。</li><li>由<strong>其他文件</strong>生成，比如由JSP文件生成对应的Class类。</li><li>从<strong>数据库</strong>读取。</li></ul></li><li><p><strong>连接</strong></p><ul><li><strong>验证</strong>：这一阶段的目的是确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。</li><li><strong>准备</strong>：在方法区中，为类的<strong>静态变量</strong>分配内存，并将其初始化为<strong>默认值</strong>（例如对于static int a = 10, 此时会赋值为默认值0；布尔类型默认为false；引用类型为null…），但是对于<strong>final修饰</strong>的常量则直接赋<strong>指定值</strong>。注意：实例变量（即未被static修饰的变量）不会在这阶段分配内存，它会在对象实例化时随着对象一起被分配在堆中，也就是类加载完成之后了。</li><li><strong>解析</strong>：将class文件常量池的<strong>符号引用替换为直接引用</strong>的过程。<ul><li>符号引用：与虚拟机的内存布局无关。可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</li><li>直接引用：与虚拟机实现的内存布局相关。可以是直接指向目标的指针、相对偏移量或者能间接定位到目标的句柄。</li></ul></li></ul></li><li><p><strong>初始化</strong>：<strong>为类的静态变量赋予正确的初始值</strong>（此时才赋予程序员设定的值），<strong>并执行静态代码块</strong>。</p><p>Java程序对类的使用方式可分为两种：主动引用与被动引用。每个类（接口）只有被Java程序“<strong>首次主动引用</strong>”时才<strong>初始化</strong>。包括：</p><ol><li>使用<strong>new</strong>实例化该类对象。</li><li><strong>读取或设置</strong>一个类（接口）的<strong>静态字段，</strong>以及<strong>调用</strong>一个类（接口）的<strong>静态方法</strong>。注：被final修饰的静态字段除外。</li><li>使用java.lang.reflect包的方法对类进行<strong>反射</strong>调用。</li><li><strong>初始化某类的子类</strong>（先初始化父类）。</li><li>带<strong>main</strong>方法的类。</li><li>JDK1.7开始提供的动态语言支持 *。</li></ol><p>被动引用例子：</p><ul><li><p>通过子类引用父类的静态字段，不会导致子类初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(SubClass.value);&#x2F;&#x2F;value字段在SuperClass中为静态字段</span><br></pre></td></tr></table></figure></li><li><p>通过数组定义来引用类，不会触发被引用类的初始化。但是该过程会对数组类进行初始化，数组类是一个由虚拟机自动生成的、直接继承自 Object 的子类，其中包含了数组的属性和方法。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SuperClass[] array &#x3D; new SuperClass[10];</span><br></pre></td></tr></table></figure></li><li><p>常量在编译阶段会存入调用类的常量池中，本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(ConstClass.HELLOWORLD);</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h3><ul><li><p><strong>类与类加载器</strong>：加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作在虚拟机外部实现，由类加载器实现。我们可以通过自定义类加载器去控制字节流的获取方式。注意：数组类不通过类加载器创建，它由JVM直接创建。</p><p>HotSpot VM内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li><strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的jar包和类或者或被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li><strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载目录 <code>%JRE_HOME%/lib/ext</code> 目录下的jar包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的jar包。</li><li><strong>AppClassLoader(应用程序类加载器)</strong> :面向用户的加载器，负责加载当前应用classpath下的所有jar包和类。</li></ol></li><li><p><strong>双亲委派模型</strong>：每一个类都有一个对应它的类加载器。系统中的 ClassLoder 在协同工作的时候会默认使用 <strong>双亲委派模型</strong> 。即在类加载的时候：</p><ol><li>系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。</li><li>加载的时候，首先会<strong>把该请求委派该父类加载器的 <code>loadClass()</code> 处理</strong>，因此所有的请求最终都应该传送到顶层的启动类加载器 <code>BootstrapClassLoader</code> 中。</li><li>当父类加载器无法处理时，才由自己来处理。当父类加载器为null时，会使用启动类加载器 <code>BootstrapClassLoader</code> 作为父类加载器。</li></ol><p><img src="classloader_PDM.png" alt=""></p><p>以上的父子关系一般通过组合关系（Composition）来实现，而不是继承关系（Inheritance）。</p><ul><li><strong>双亲委派模型的好处</strong>：双亲委派模型保证了Java程序的稳定运行，可以<strong>避免类的重复加载</strong>（JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类），也<strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</li></ul></li><li><p><strong>破坏双亲委派模型</strong>：自定义类加载器，需要继承ClassLoader。如果不想打破双亲委派模型，就重写 <code>ClassLoader</code> 类中的 <code>findClass()</code> 方法即可，无法被父类加载器加载的类最终会通过这个方法被加载；如果想打破双亲委派模型则需要重写 <code>loadClass()</code> 方法。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;类加载过程&quot;&gt;&lt;a href=&quot;#类加载过程&quot; class=&quot;headerlink&quot; title=&quot;类加载过程&quot;&gt;&lt;/a&gt;类加载过程&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;一个Java类从编写完成到被卸载的过程：X.java -&amp;gt; X.class（编译为磁盘中的二进制文
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>GC与内存分配策略</title>
    <link href="http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/"/>
    <id>http://thmasterplan.cn/JVM/GC%E4%B8%8E%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D%E7%AD%96%E7%95%A5/</id>
    <published>2020-09-02T07:17:43.000Z</published>
    <updated>2020-09-07T11:39:12.560Z</updated>
    
    <content type="html"><![CDATA[<h3 id="对象已死吗（GC回收的前提是判断对象已死）"><a href="#对象已死吗（GC回收的前提是判断对象已死）" class="headerlink" title="对象已死吗（GC回收的前提是判断对象已死）"></a>对象已死吗（GC回收的前提是判断对象已死）</h3><ul><li><p><strong>概述</strong>：对于程序计数器、虚拟机栈、本地方法栈，其内存区域和回收都具备确定性，方法结束或线程结束时，其内存自然就回收了。GC主要关注堆和方法区的分配与回收。</p></li><li><p><strong>引用计数算法（不常用）</strong>：给对象添加一个引用计数器，每当被引用时，计数器值+1；引用失效（引用不再指向该对象）时，计数器值-1。任何时刻计数器为0的对象就是不可能再被使用的。缺点：难以解决对象之间相互循环使用的问题。（比如对象A中的引用指向B，对象B中的引用指向A，对象A、B计数器永远为1）</p></li><li><p><strong>可达性分析算法（主流实现）</strong>：通过一系列的称为“GC Roots”的对象作为起始点向下搜索，搜索走过的路径称为“引用链”，当一个对象到“GC Roots”没有任何引用链相连，即证明对象不可达。</p><p><img src="Reachability_Analysis.png" alt=""></p><p>可作为GC Roots的对象包括：</p><ul><li>虚拟机栈：栈帧中局部变量表中引用的对象</li><li>方法区：<ul><li>类静态变量引用的对象</li><li>常量引用的对象</li></ul></li><li>本地方法栈：JNI引用的对象</li></ul></li><li><p><strong>再谈引用</strong>：JDK1.2之后，引用概念分为以下4种，强度依次减弱</p><ul><li><strong>强引用</strong>：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。</li><li><strong>软引用</strong>：描述有用但非必须的对象，当<strong>系统将要发生OOM异常时</strong>，软引用指向的对象才被真正回收。通过SoftReference类实现。</li><li><strong>弱引用</strong>：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。</li><li><strong>虚引用</strong>：为一个对象设置虚引用关联的唯一目的时能<strong>在对象被回收时收到一个系统通知</strong>。通过PhantomReference类实现。</li></ul></li><li><p><strong>生存还是死亡</strong>：即使在可达性分析算法中不可达的对象，在该对象的finalize()方法中也有一次自救的方法，即重新与引用链上的任何一个对象建立关联即可，譬如把this赋值给某个类变量或者对象的成员变量。但是，建议使用try-finally语法而尽量不使用finally()方法。</p></li><li><p><strong>回收方法区</strong>：主要回收<strong>废弃常量</strong>和<strong>无用的类</strong>。废弃常量的回收与堆中的对象类似，而无用类的判定则要复杂的多，需要满足：</p><ul><li>堆中不存在该类的实例</li><li>ClassLoader已被回收</li><li>Class对象没有被引用，且无法在任何地方通过反射访问该类的方法。</li><li>是否对类进行回收，HotSpot虚拟机提供了<code>-Xnoclassgc</code>参数进行控制，还可以使用<code>-verbose:class</code>以及<code>-XX:+TraceClassLoading</code>、<code>-XX:+TraceClassUnLoading</code>查看类加载和卸载信息。</li><li>注：对于大量使用反射、动态代理、CGLib等ByteCode框架的场景，要注意方法区的类卸载。</li></ul></li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><ul><li><p><strong>标记-清除算法</strong>：标记回收对象，标记完成后统一回收。</p><p><img src="mark_clean.jpeg" alt=""></p><ul><li>缺点：标记和清除效率都不高；会产生大量不连续的内存碎片，导致无法给大对象分配内存。</li></ul></li><li><p><strong>标记-整理算法</strong>：标记回收对象，让所有存活的对象向一端移动，然后直接清理掉对象所在的连续内存后的所有内存。</p><p><img src="mark_arrange.png" alt=""></p><ul><li>特点：适用于老年代的算法，不会产生内存碎片。</li></ul></li><li><p><strong>复制算法</strong>：对于现在的商业虚拟机，堆内存被划分为三块，一块较大的Eden空间、两块较小的Survivor空间。</p><ol><li><p>当Eden空间满时，第一次Minor-GC（针对新生代的GC）将Eden还存活的对象全部复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden；</p></li><li><p>当Eden满时，第二次Minor-GC将Eden和Survivor-0中还存活的对象复制到Survivor-1中，存活对象“寿命计数器”+1，清理Eden和Survivor-0；</p></li><li><p>当Eden满时，第三次Minor-GC将Eden和Survivor-1中还存活的对象复制到Survivor-0中，存活对象“寿命计数器”+1，清理Eden和Survivor-1；</p><p>…….</p></li><li><p>如此往复，当某个Survivor满或者对象“寿命计数器”值达到阈值，则将对象复制到老年代中。</p></li><li><p>当老年代和新生代都满时，会进行一次Full-GC。</p></li></ol><ul><li><p>HotSpot虚拟机的Eden和Survivor大小默认比例为8:1，保证了内存利用率达到90%。</p><p><img src="Copying.png" alt=""></p></li></ul></li><li><p><strong>分代收集算法</strong>：现在的商业虚拟机采用分代收集算法。</p><ul><li><strong>新生代：由于每次GC时都有绝大部分对象死去，只有少量对象存活</strong>，故采用<strong>复制算法</strong>，因为只需要付出少量存活对象的复制成本。</li><li><strong>老年代：由于老年代对象存活率高且没有额外空间对它分配担保</strong>，故采用标记-整理算法或标记-清除算法。</li></ul></li></ul><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><p><img src="GC.jpg" alt=""></p><p>以上是HotSpot虚拟机中的7个垃圾收集器，连线表示垃圾收集器之间可以搭配使用。</p><ul><li><p><strong>Serial收集器</strong>：单线程；简单高效，拥有最高的单线程收集效率；Client场景下的默认新生代收集器。</p><p><img src="Serial.jpg" alt=""></p></li><li><p><strong>ParNew收集器</strong>：Serial的多线程版本；Server场景下默认的新生代收集器；唯一能与CMS收集器配合使用的收集器。</p><p><img src="ParNew.jpg" alt=""></p></li><li><p><strong>Parallel Scavenge收集器</strong>：多线程，<strong>吞吐量</strong>（CPU运行用户代码的时间除以CPU总消耗时间）<strong>优先</strong>的收集器。</p></li><li><p><strong>Serial Old收集器</strong>：Serial的老年代版本，Client场景使用。</p><p><img src="Serial.jpg" alt=""></p></li><li><p><strong>Parallel Old收集器</strong>：Parallel Scavenge的老年代版本</p><p><img src="Parallel.jpg" alt=""></p></li><li><p><strong>CMS(Concurrent Mark Sweep)收集器</strong>：以获取<strong>最短回收停顿时间</strong>为目标，基于<strong>标记-清除</strong>算法。分为四个阶段：</p><ol><li>初始标记：只标记与GC Roots直接关联的对象，需要Stop The World。</li><li>并发标记：进行 GC Roots Tracing，耗时最长，不需要停顿。</li><li>重新标记：修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录，需要Stop The World。</li><li>并发清除：不需要停顿。</li></ol><p><img src="CMS.jpg" alt=""></p><ul><li>缺点明显：<ol><li>CPU资源敏感：CMS默认启动的回收线程数是（CPU数+3）/4，当CPU数较少时，吞吐量很低。</li><li>无法处理浮动垃圾：浮动垃圾是指<strong>并发清除阶段</strong>由于用户线程继续运行而产生的垃圾，这部分垃圾只能下一次GC清除。</li><li>标记-清除算法会产生大量空间碎片。</li></ol></li><li>总体上来说，CMS的垃圾回收过程是与用户线程一起并发执行的。</li></ul></li><li><p><strong>G1(Garbage First)收集器</strong>：面向服务端应用。</p><ul><li><p>使用G1时，Java堆内存布局与以往不同，它<strong>将整个Java堆划分为多个大小相等的独立Region</strong>，新生代与老年代是一部分不连续Region的集合，如图：</p><p><img src="G1HeapAllocation.png" alt=""></p></li><li><p>G1通过记录每个Region垃圾回收时间和回收所得空间（这两个值通过过去回收的经验计算），并维护一个优先列表，每次根据用户允许的收集时间，优先回收价值最大的Region。<strong>使用Region划分内存空间</strong>，<strong>有优先级的区域回收方式</strong>，保证了G1在有限的时间内获取尽可能高的收集效率。</p></li><li><p>每个Region都维护一个Remembered Set，用于记录Region之间的对象引用，来避免GC时的全堆扫描。（其他收集器新生代与老年代之间的对象引用也是使用Remembered Set，避免Minor-GC时全堆扫描）。</p></li><li><p>如不计算维护Remembered Set的操作，G1的运作可划分如下：</p><ol><li>初始标记：停顿。</li><li>并发标记</li><li>最终标记：停顿。为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程的 Remembered Set Logs 里面，最终标记阶段需要把 Remembered Set Logs 的数据合并到 Remembered Set 中。</li><li>筛选回收：根据用户允许的收集时间和优先列表来回收。</li></ol></li></ul><p><img src="G1.jpg" alt=""></p><ul><li>总结G1的特点如下：<ol><li>并行与并发：G1在多CPU和大内存的硬件优势下能有效缩短Stop-The-World的时间。</li><li>分代收集：新生代和老年代可以一起回收。</li><li>空间整合：整体上看基于“标记-整理”算法，局部上看基于“复制”算法。不会产生内存碎片。</li><li>可预测的停顿：能让用户自定义在一个长度为M毫秒的时间片段内，消耗在GC上的时间不超过N毫秒。</li></ol></li></ul></li><li><p><strong>垃圾收集器参数总结</strong></p><p><img src="GC_Args.png" alt=""></p></li></ul><h3 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h3><ul><li><strong>对象优先在Eden分配</strong></li><li><strong>大对象直接进入老年代</strong>：大对象是指<strong>需要连续内存空间的对象</strong>，最典型的大对象是那种<strong>很长的字符串以及数组</strong>。<ul><li>经常出现大对象会提前触发垃圾收集以获取足够的连续空间分配给大对象。</li><li>通过参数<code>-XX:PretenureSizeThreshold</code>，大于此值的对象直接在老年代分配，避免在 Eden 和 Survivor 之间的大量内存复制。</li></ul></li><li><strong>长期存活的对象将进入老年代</strong>：通过参数<code>-XX:MaxTenuringThreshold</code>用来定义年龄的阈值。</li><li><strong>动态对象年龄判定</strong>：虚拟机并不是永远要求对象的年龄必须达到 MaxTenuringThreshold 才能晋升老年代，<strong>如果在 Survivor 中相同年龄所有对象大小的总和大于 Survivor 空间的一半</strong>，则年龄大于或等于该年龄的对象可以直接进入老年代，无需等到 MaxTenuringThreshold 中要求的年龄。</li><li><strong>空间分配担保</strong>：在发生 Minor GC 之前，虚拟机先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果条件成立的话，那么 Minor GC 可以确认是安全的；如果不成立的话虚拟机会查看 HandlePromotionFailure 的值是否允许担保失败，如果允许那么就会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试着进行一次 Minor GC；如果小于，或者 HandlePromotionFailure 的值不允许冒险，那么就要进行一次 Full GC。</li></ul><h3 id="GC的触发条件"><a href="#GC的触发条件" class="headerlink" title="GC的触发条件"></a>GC的触发条件</h3><ul><li><p>对于Minor GC，其触发条件为Eden区满时。而对于Full GC:</p><ol><li>调用System.gc()。</li><li>老年代空间不足。</li><li>空间分配担保失败。</li><li>Concurrent Mode Failure。</li></ol></li><li><p>减少Full GC的方法：</p><ol><li>尽量不要创建大对象和数组。</li><li>通过<code>-Xmn</code>调大新生代大小。</li><li>通过<code>-XX:MaxTenuringThreshold</code>调大进入老年代的阈值。</li></ol></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;对象已死吗（GC回收的前提是判断对象已死）&quot;&gt;&lt;a href=&quot;#对象已死吗（GC回收的前提是判断对象已死）&quot; class=&quot;headerlink&quot; title=&quot;对象已死吗（GC回收的前提是判断对象已死）&quot;&gt;&lt;/a&gt;对象已死吗（GC回收的前提是判断对象已死）&lt;/
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>Java内存区域与内存溢出异常</title>
    <link href="http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/"/>
    <id>http://thmasterplan.cn/JVM/Java%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E4%B8%8E%E5%86%85%E5%AD%98%E6%BA%A2%E5%87%BA%E5%BC%82%E5%B8%B8/</id>
    <published>2020-08-23T03:24:45.000Z</published>
    <updated>2020-09-07T11:38:50.706Z</updated>
    
    <content type="html"><![CDATA[<h3 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h3><p>​            <img src="JVM_Runtime_DataArea.png" alt=""></p><ul><li><p><strong>线程私有：与线程生命周期相同</strong></p><ul><li><strong>程序计数器（Program Counter Register）</strong>：记住下一条JVM字节码指令的地址。每条线程都有一个独立的PCR。此内存区域是唯一一个在JVM规范中没有任何OOM情况的区域。</li><li><strong>Java虚拟机栈</strong>：描述Java方法执行的内存模型。每个方法在执行时都会创建一个栈帧，用于存储局部变量表、操作数栈等。每个方法从调用到执行完毕，对应一个栈帧从入栈到出栈的过程。<ul><li>局部变量表存放编译期可知的各种基本数据类型和引用。</li><li>JVM规范定义了该区域两种异常情况：<ul><li>线程请求的栈深度大于VM允许的深度，将抛出StackOverflowError异常。</li><li>若虚拟机栈可动态扩展，且扩展时无法申请到足够的内存，将抛出OOM异常。</li></ul></li></ul></li><li><strong>本地方法栈</strong>：与虚拟机栈的区别在于，虚拟机栈为VM执行Java方法服务，而本地方法栈为VM使用到的本地方法服务。<ul><li>异常情况同虚拟机栈。</li></ul></li></ul></li><li><p><strong>线程共享：VM启动时创建</strong></p><ul><li><p><strong>堆</strong>：用于存放对象实例和数组。</p><ul><li><p>Java堆是GC管理的主要区域。</p></li><li><p>扩：随着JIT（Just in Time）技术与逃逸分析技术逐渐成熟，所有对象都分配在堆上并不绝对了。</p><p><img src="JIT_flow.png" alt=""></p></li></ul><p>​                热代码：频繁调用的字节码。</p><p>​                [<a href="https://developer.ibm.com/zh/articles/j-lo-just-in-time/#" target="_blank" rel="noopener">https://developer.ibm.com/zh/articles/j-lo-just-in-time/#</a>]</p></li><li><p><strong>方法区</strong>：存储已被VM加载的类信息（变量和方法数据，方法和构造器的字节码等）、运行时常量池、JIT编译后的机器码等。</p><ul><li>许多主流框架都会用到CGLib或者JDK动态代理，动态生成大量Class容易导致方法区OOM异常。</li></ul></li><li><p><strong>三种常量池区分</strong></p><ul><li><p><strong>class文件常量池</strong>：编译阶段，存放编译期生成的<strong>字面量（常量值）</strong>和<strong>符号引用</strong>，其中符号引用包括类名、方法名、参数类型等信息。<code>javap -v Main.class</code>反编译如下代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    </span><br><span class="line">    final String stest &#x3D; &quot;String Test ...&quot;;</span><br><span class="line">    </span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">            System.out.println(&quot;helloworld&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p><img src="Constant_pool.png" alt=""></p></li><li><p><strong>字符串常量池</strong>：</p><p>类加载完后在<strong>堆</strong>中生成字符串对象实例（JDK1.7及以后），然后将该字符串对象实例的<strong>引用</strong>存到字符串常量池中。</p><p>在HotSpot VM里实现的string pool功能的是一个StringTable类，它是一个哈希表，里面存的是<strong>驻留字符串</strong>(也就是我们常说的用双引号括起来的)<strong>的引用</strong>（而不是驻留字符串实例本身），也就是说在堆中的某些字符串实例被这个StringTable引用之后就等同被赋予了”驻留字符串”的身份。这个StringTable在每个HotSpot VM的实例只有一份，被所有的类共享。注意：对于new的String对象，若在类中new，则其引用变量存于方法区；若在方法中new，则其引用在虚拟机栈的栈帧的局部变量表中。</p><p><strong>StringTable编译期优化</strong>：</p></li><li><p><strong>运行时常量池</strong>：类加载完成之后，编译期生成的非字符串类型常量和符号引用进入运行时常量池，由符号引用翻译而来的直接引用也会存入运行时常量池。</p></li></ul></li></ul></li></ul><h3 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h3><ul><li>直接内存并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但这部分内存也会频繁使用，可能导致OOM异常。</li><li>JDK1.4中加入了NIO类（New Input/Output），引入了一种基于Channel与Buffer的I/O方式，<strong>它可以使用本地函数库直接分配堆外内存</strong>，然后通过一个存储在Java堆中的DirectByteBuffer对象作为这块内存的引用进行操作。</li></ul><h3 id="常见的VM堆栈参数"><a href="#常见的VM堆栈参数" class="headerlink" title="常见的VM堆栈参数"></a>常见的VM堆栈参数</h3><ul><li>-Xms: 设置堆的最小值，如<code>-Xms20m</code></li><li>-Xmx: 设置堆的最大值，如<code>-Xmx20m</code></li><li>-Xmn: 设置堆新生代值</li><li>-Xss: 设置虚拟机栈容量</li><li>-Xoss: 设置本地方法栈容量（HotSpot的虚拟机栈和本地方法栈仅由-Xss决定）</li><li><code>-XX:Permsize=10M</code>: 设置方法区大小为10M</li><li><code>-XX:MaxDirectMemorySize=10M</code>: 设置本机直接内存大小为10M</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;运行时数据区域&quot;&gt;&lt;a href=&quot;#运行时数据区域&quot; class=&quot;headerlink&quot; title=&quot;运行时数据区域&quot;&gt;&lt;/a&gt;运行时数据区域&lt;/h3&gt;&lt;p&gt;​            &lt;img src=&quot;JVM_Runtime_DataArea.png&quot; a
      
    
    </summary>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/categories/JVM/"/>
    
    
      <category term="JVM" scheme="http://thmasterplan.cn/tags/JVM/"/>
    
  </entry>
  
  <entry>
    <title>SpringAOP</title>
    <link href="http://thmasterplan.cn/uncategorized/SpringAOP/"/>
    <id>http://thmasterplan.cn/uncategorized/SpringAOP/</id>
    <published>2020-04-23T08:36:02.000Z</published>
    <updated>2020-09-07T11:37:24.361Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>SpringIOC</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringIOC/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/SpringIOC/</id>
    <published>2020-04-14T13:36:18.000Z</published>
    <updated>2020-09-07T11:37:16.877Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Spring概述"><a href="#Spring概述" class="headerlink" title="Spring概述"></a>Spring概述</h3><ul><li>Spring以IOC(Inversion of Control)和AOP(Aspect Oriented Programming)为内核，提供了展现层SpringMVC和持久层Spring JDBC以及业务层事务管理等众多的企业级应用技术。</li></ul><h3 id="控制反转Inversion-of-Control-IOC"><a href="#控制反转Inversion-of-Control-IOC" class="headerlink" title="控制反转Inversion of Control(IOC)"></a>控制反转Inversion of Control(IOC)</h3><h5 id="耦合度"><a href="#耦合度" class="headerlink" title="耦合度"></a>耦合度</h5><ul><li><p>概念：模块（类）之间的<strong>关联、依赖的程度</strong>，是衡量<strong>代码独立性</strong>的一个指标，也是<strong>软件工程设计及编码质量评价</strong>的一个标准。耦合的程度依赖于以下几个因素：</p><ul><li>模块间的调用</li><li>模块间传递的数据量</li><li>一个模块施加到另一个模块的控制的多少</li><li>模块间接口的复杂程度</li></ul></li><li><p>耦合按从高到低的顺序可分为：</p><ul><li>内容耦合：<strong>一个模块直接修改或操作另一个模块的数据</strong>，或者直接转入另一个模块时，就发生了内容耦合。例如，类与类之间直接调用或继承关系都属于这种耦合。</li><li>公共耦合：<strong>多个模块共同引用一个全局数据项</strong>。</li><li>控制耦合：一个模块在界面上传递一个信号（如开关值、标志量等）控制另一个模块，接收信号的模块的动作根据信号值进行调整，称为控制耦合。</li><li>标记耦合：模块间通过<strong>参数传递复杂的内部数据结构</strong>。</li><li><strong><em>数据耦合</em></strong>：模块间通过<strong>参数传递基本类型的数据</strong>。</li></ul></li><li><p>需要低耦合的原因：在耦合度很高的情况下，维护代码时修改一个地方会牵连到很多地方，难以厘清，可谓是牵一发而动全身。</p></li><li><p>降低耦合度的方法：</p><ul><li>少用继承，多用接口。</li><li>模块的功能划分尽可能的单一（高内聚）。</li><li>遵循一个定义只在一个地方出现。</li><li>少使用全局变量。</li><li>类成员变量和方法少用public，多用private。</li><li>多使用设计模式，比如使用MVC设计模式就可以降低界面与业务逻辑的耦合度。</li><li><strong>如果模块间必须存在耦合，尽量使用数据耦合</strong>。例如使用配置文件或注解传递参数，使用反射创建对象等都属于数据耦合。</li></ul></li></ul><h5 id="工厂模式解耦例子"><a href="#工厂模式解耦例子" class="headerlink" title="工厂模式解耦例子"></a>工厂模式解耦例子</h5><ul><li><p>持久层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 账户的持久层接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IAccountDao &#123;</span><br><span class="line">    void saveAccount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 持久层实现类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;账户已经保存！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>业务层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 账户业务层的接口</span><br><span class="line"> *&#x2F;</span><br><span class="line">public interface IAccountService &#123;</span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 模拟保存账户</span><br><span class="line">     *&#x2F;</span><br><span class="line">    void saveAccount();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 业务层实现类</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line"></span><br><span class="line">    private IAccountDao accountDao &#x3D; (IAccountDao) BeanFactory.getBean(&quot;accountDao&quot;);</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>表现层</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 模拟表现层调用业务层，实际开发中类似Servlet</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class Client &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        IAccountService as &#x3D; (IAccountService) BeanFactory.getBean(&quot;accountService&quot;);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>bean.properties配置文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">accountService&#x3D;com.itheima.service.impl.AccountServiceImpl</span><br><span class="line">accountDao&#x3D;com.itheima.dao.impl.AccountDaoImpl</span><br></pre></td></tr></table></figure></li><li><p>BeanFactory</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 一个创建Bean对象的工厂</span><br><span class="line"> * Bean: 可重用组件，例如在Java中JavaBean有实体类、service和dao对象等</span><br><span class="line"> *</span><br><span class="line"> * 工厂模式解耦：使用配置文件或注解传递参数，使用反射创建对象。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class BeanFactory &#123;</span><br><span class="line">    &#x2F;&#x2F;定义一个Properties对象</span><br><span class="line">    private static Properties props;</span><br><span class="line">    &#x2F;&#x2F;定义Map存储bean对象，避免多实例降低效率（即避免每次调用getBean方法都要重新创建对象）</span><br><span class="line">    private static Map&lt;String, Object&gt; beansMap;</span><br><span class="line"></span><br><span class="line">    &#x2F;&#x2F;初始化</span><br><span class="line">    static&#123;</span><br><span class="line">        props &#x3D; new Properties();</span><br><span class="line">        try &#123;</span><br><span class="line">            &#x2F;&#x2F;获取properties文件的流对象并加载</span><br><span class="line">            props.load(BeanFactory.class.getClassLoader().getResourceAsStream(&quot;bean.properties&quot;));</span><br><span class="line">        &#125; catch (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            throw new ExceptionInInitializerError(&quot;初始化properties失败&quot;);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        beansMap &#x3D; new HashMap&lt;&gt;();</span><br><span class="line">        Enumeration keys &#x3D; props.keys();</span><br><span class="line">        &#x2F;&#x2F;遍历properties中的每个key，创建对应的实例并存入beansMap中</span><br><span class="line">        while(keys.hasMoreElements())&#123;</span><br><span class="line">            String beanName &#x3D; keys.nextElement().toString();</span><br><span class="line">            String beanPath &#x3D; props.getProperty(beanName);</span><br><span class="line">            Object bean &#x3D; null;</span><br><span class="line">            try &#123;</span><br><span class="line">                bean &#x3D; Class.forName(beanPath).newInstance();</span><br><span class="line">            &#125; catch (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            beansMap.put(beanName, bean);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     * 根据bean的名称获取bean对象</span><br><span class="line">     * @param beanName</span><br><span class="line">     * @return bean对象</span><br><span class="line">     *&#x2F;</span><br><span class="line">    public static Object getBean(String beanName)&#123;</span><br><span class="line">        return beansMap.get(beanName);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h5 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h5><ul><li><p>概念与作用：控制反转把创建对象的权力交给框架，它包括Dependency Injection与Dependency Lookup两部分。其作用在于<strong>降低程序的耦合度</strong>。</p></li><li><p><strong>基于XML的IoC配置</strong></p><ul><li><p>bean.xml示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans</span><br><span class="line">        https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;</span><br><span class="line">    &lt;!--将对象的创建交给spring管理--&gt;</span><br><span class="line">    &lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>ApplicationContext的三个常用实现类</p><ul><li>ClassPathXmlApplicationContext：加载类路径下的配置文件</li><li>FileSystemXmlApplicationContext：加载磁盘任意路径下的配置文件</li><li>AnnotationConfigApplicationContext：读取注解</li></ul></li><li><p><strong>核心容器的两个接口</strong>引发的问题</p><ul><li>ApplicationContext（常用）：单例对象适用。创建核心容器时，<strong>创建对象的策略为立即加载</strong>。只要一读取完配置文件就立马创建bean对象。</li><li>BeanFactory（ApplicationContext父接口的父接口）：多例对象适用。创建核心容器时，<strong>创建对象的策略为延迟加载</strong>。也即，何时调用获取bean对象的方法，那时才创建对象。</li></ul></li></ul></li><li><p>Spring对bean对象的管理细节</p><ul><li><p>创建bean对象的三种方式</p><ul><li><p><strong>使用默认构造函数创建</strong>：在spring的xml配置文件中使用bean标签，配置id和class属性后，且没有其他属性和标签时，采用的是默认构造函数创建bean对象(反射中的newInstance方法使用默认构造创建对象)，如果类没有默认构造函数则无法创建对象。</p></li><li><p><strong>使用普通类(工厂)中的方法创建对象并存入spring容器</strong>(比如jar包中的类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class InstanceFactory&#123;</span><br><span class="line">    public IAccountService getAccountService()&#123;</span><br><span class="line">        return new AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--创建实例工厂对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;instanceFactory&quot; class&#x3D;&quot;com.itheima.factory.InstanceFactory&quot;&gt;&lt;&#x2F;bean&gt; </span><br><span class="line">&lt;!--通过指定实例工厂对象的方法，创建指定对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; factory-bean&#x3D;&quot;instanceFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li><li><p><strong>使用工厂中的静态方法创建对象并存入容器</strong>(比如jar包中的类)：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public class StaticFactory&#123;</span><br><span class="line">    public static IAccountService getAccountService()&#123;</span><br><span class="line">        return new AccountServiceImpl();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--通过指定工厂类的静态方法创建对象--&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.factory.StaticFactory&quot; factory-method&#x3D;&quot;getAccountService&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>bean对象的作用范围调整：bean标签scope属性，取值为以下</p><ul><li>singleton：单例（默认的，不管new多少次，内存中只有一个实例对象）</li><li>prototype：多例</li><li>request：作用于web应用的请求范围</li><li>session：作用于web应用的会话范围</li><li>global-session：作用于集群环境的会话范围（全局会话范围），若不是集群环境，则效果与session相同</li></ul></li><li><p>bean对象的生命周期</p><ul><li>单例对象：单例对象的生命周期与容器相同，容器创建则对象创建，容器销毁时对象销毁，可在bean标签中指定init-method与destroy-method属性来执行bean对象中的init方法和destroy方法。</li><li>多例对象：使用对象时才创建对象，spring不能销毁，只能通过GC回收，因此无论如何都不会执行bean对象中的destroy方法。</li></ul></li></ul></li><li><p>依赖注入（Dependency Injection）：当调用者需要被调用者的协助时，在传统的程序设计过程中，通常由调用者来创建被调用者的实例，但在IoC中，创建被调用者的工作不再由调用者来完成，而是将被调用者的创建移到调用者的外部，从而反转被调用者的创建，消除了调用者对被调用者创建的控制，因此称为控制反转。要实现IoC，通常的解决方案是将创建被调用者实例的工作交由 IoC 容器来完成，然后在调用者中注入被调用者（通过【构造器/方法/注解】注入实现），这样我们就实现了调用者与被调用者的解耦，该过程被称为依赖注入。</p><ul><li><p>注入的数据类型</p><ul><li>基本数据类型和String</li><li>bean</li><li>复杂类型/集合类型</li></ul></li><li><p>注入的方式有</p><ul><li><p>构造器：通过bean标签中的<code>constructor-arg</code>标签配置实现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;读取xml，通过反射创建bean对象；依赖查找</span><br><span class="line">        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line"></span><br><span class="line"> &#x2F;&#x2F;     IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;);</span><br><span class="line">        IAccountService as &#x3D; ac.getBean(&quot;accountService&quot;, IAccountService.class);&#x2F;&#x2F;两种方式获取bean对象</span><br><span class="line">        as.saveAccount();</span><br><span class="line"></span><br><span class="line">        &#x2F;** 使用BeanFactory</span><br><span class="line">         * BeanFactory beanFactory &#x3D; new XmlBeanFactory(new ClassPathResource(&quot;bean.xml&quot;));</span><br><span class="line">         * IAccountService as &#x3D; (IAccountService) beanFactory.getBean(&quot;accountService&quot;);</span><br><span class="line">         *&#x2F;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line"></span><br><span class="line">    private IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public AccountServiceImpl(IAccountDao accountDao) &#123;</span><br><span class="line">        this.accountDao &#x3D; accountDao;</span><br><span class="line">    &#125;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">       accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;bean id&#x3D;&quot;accountService&quot; class&#x3D;&quot;com.itheima.service.impl.AccountServiceImpl&quot;&gt;</span><br><span class="line">        &lt;!--value属性用于注入基本类型和String类型，ref属性则为bean类型--&gt;</span><br><span class="line">        &lt;constructor-arg name&#x3D;&quot;accountDao&quot; ref&#x3D;&quot;accountDaoImpl&quot;&gt;&lt;&#x2F;constructor-arg&gt;</span><br><span class="line">   &lt;&#x2F;bean&gt;</span><br><span class="line">&lt;bean id&#x3D;&quot;accountDaoImpl&quot; class&#x3D;&quot;com.itheima.dao.impl.AccountDaoImpl&quot;&gt;&lt;&#x2F;bean&gt;</span><br></pre></td></tr></table></figure></li><li><p>set方法：<code>property</code>标签，<code>name</code>属性指定方法名，<code>value</code>属性用于注入基本类型和String类型，<code>ref</code>属性则为bean类型。bean类需要设置set方法。</p><ul><li>集合类型的注入：使用<code>set,list,arroCay,map,props</code>等子标签</li></ul></li><li><p>注解：<code>@Autowired</code></p></li></ul></li></ul></li><li><p><strong>基于注解的IoC配置</strong></p><ul><li><p>首先配置context</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;</span><br><span class="line">       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;</span><br><span class="line">       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;</span><br><span class="line">       xsi:schemaLocation&#x3D;&quot;</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd</span><br><span class="line">        http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context https:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt;</span><br><span class="line">    &lt;!--指定spring在创建容器时要扫描的包--&gt;</span><br><span class="line">    &lt;context:component-scan base-package&#x3D;&quot;com.itheima&quot;&gt;&lt;&#x2F;context:component-scan&gt;</span><br><span class="line">&lt;&#x2F;beans&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建bean对象的注解</p><ul><li><code>@Component</code>：被注解的类由spring创建并存入IoC容器</li><li><code>@Controller</code>：用于表现层</li><li><code>@Service</code>：用于业务层</li><li><code>@Repository</code>：用于持久层</li><li>后三个注解的作用与属性都与<code>@Component</code>相同</li></ul></li><li><p>依赖注入的注解</p><ul><li><p><code>@Resource</code>：在需要注入依赖的变量上标记，并在其实现类上标记<code>@Component</code>（或其余三种）注解。通过name属性匹配实现类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">@Component(&quot;accountService&quot;)</span><br><span class="line">public class AccountServiceImpl implements IAccountService &#123;</span><br><span class="line">    @Resource(name&#x3D;&quot;accountDao&quot;)</span><br><span class="line">    private IAccountDao accountDao;</span><br><span class="line"></span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">       accountDao.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">@Repository(&quot;accountDao&quot;)</span><br><span class="line">public class AccountDaoImpl implements IAccountDao &#123;</span><br><span class="line">    public void saveAccount() &#123;</span><br><span class="line">        System.out.println(&quot;Your Account has been saved!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">public class Client &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        ApplicationContext ac &#x3D; new ClassPathXmlApplicationContext(&quot;bean.xml&quot;);</span><br><span class="line">        IAccountService as &#x3D; (IAccountService) ac.getBean(&quot;accountService&quot;);</span><br><span class="line">        as.saveAccount();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><code>@Autowired</code>：<code>@Qualifier</code>需要与<code>@Autowired</code>一起使用。</p></li><li>以上的注解只能用于bean类型的注入，集合类型的注入只能通过xml配置文件实现。</li><li><code>@Value</code>：用于注入基本类型与String类型数据。</li></ul></li><li><p>改变作用范围的注解：<code>@Scope</code>，value属性常用取值为singleton，prototype</p></li><li><p>与生命周期相关的注解</p><ul><li><code>@PreDestroy</code>：指定销毁方法</li><li><code>@PostConstruct</code>：指定初始化方法</li></ul></li></ul></li><li><p><strong>基于注解的IoC配置（不再需要xml文件）</strong></p><ul><li><code>@Configuration</code>：创建一个代替bean.xml的配置类<code>SpringConfig</code>后，使用该注解标记该类为配置类</li><li><code>@Import</code>：标记<strong>主配置类</strong>，用于导入其他的从配置类。属性：<code>Class&lt;?&gt;[] value;</code>。使用该注解后可不再使用<code>@Configuration</code>注解。</li><li><code>@ComponentScan</code>：指定spring在创建容器时需要扫描的包</li><li><code>@Bean</code>：标记一个方法，将该方法的返回值作为bean对象存入IoC容器。其属性name用于指定bean对象的id，默认值为方法名。</li><li><code>@PropertySource</code>：指定properties配置文件的位置。用于配置数据库等字符串信息。</li><li>使用<code>new AnnotationConfigApplicationContext(SpringConfig.class);</code>获取容器。</li></ul></li></ul><h3 id="IoC案例"><a href="#IoC案例" class="headerlink" title="IoC案例"></a>IoC案例</h3><ul><li><p>使用xml配置，注解结合xml配置，纯注解配置三种方式</p><ul><li>Use “Sourcegraph” to view the code：<a href="https://github.com/Laishiji/SpringLearningDemo" target="_blank" rel="noopener">https://github.com/Laishiji/SpringLearningDemo</a></li></ul></li><li><p>Spring整合Junit</p><ul><li><p>导入依赖spring-test</p></li><li><p>使用Junit提供的<code>@RunWith</code>替换Runner(替换main方法)</p></li><li><p>使用<code>@ContextConfiguration</code>告知Spring的运行器，spring容器的创建是基于xml还是注解，并说明位置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;**</span><br><span class="line"> * 单元测试,Spring整合Junit</span><br><span class="line"> *&#x2F;</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">@ContextConfiguration(classes &#x3D; SpringConfig.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line"></span><br><span class="line">    @Autowired</span><br><span class="line">    IAccountService as;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindAll()&#123;</span><br><span class="line">        List&lt;Account&gt; accounts &#x3D; as.findAllAccount();</span><br><span class="line">        for (Account a : accounts) &#123;</span><br><span class="line">            System.out.println(a);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Spring概述&quot;&gt;&lt;a href=&quot;#Spring概述&quot; class=&quot;headerlink&quot; title=&quot;Spring概述&quot;&gt;&lt;/a&gt;Spring概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Spring以IOC(Inversion of Control)和AOP(Asp
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Spring" scheme="http://thmasterplan.cn/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>检索技巧</title>
    <link href="http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/"/>
    <id>http://thmasterplan.cn/Others/%E6%A3%80%E7%B4%A2%E6%8A%80%E5%B7%A7/</id>
    <published>2020-04-09T09:00:06.000Z</published>
    <updated>2020-09-07T11:35:36.764Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Github搜索"><a href="#Github搜索" class="headerlink" title="Github搜索"></a>Github搜索</h3><ul><li><code>in:name example</code>：项目名中包含”example“</li><li><code>in:readme example</code>：readme.md中包含”example“</li><li><code>in:description example</code>：描述中包含”example“</li><li><code>stars:&gt;1000</code>：项目 star数大于1000</li><li><code>forks:&gt;1000</code>：项目fork数大于1000</li><li><code>pushed:&gt;2020-03-05</code>：项目在该日期后有更新</li><li><code>language:java</code>：项目用Java编写</li><li>以上条件可组合使用</li></ul><h3 id="搜索引擎检索"><a href="#搜索引擎检索" class="headerlink" title="搜索引擎检索"></a>搜索引擎检索</h3><ul><li><code>&quot;example&quot;</code>：完全匹配</li><li><code>example site:www.xxx.com</code>：站点内搜索</li><li><code>example -csdn.net</code>：排除关键字</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Github搜索&quot;&gt;&lt;a href=&quot;#Github搜索&quot; class=&quot;headerlink&quot; title=&quot;Github搜索&quot;&gt;&lt;/a&gt;Github搜索&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;in:name example&lt;/code&gt;：项目名中包含”exam
      
    
    </summary>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/categories/Others/"/>
    
    
      <category term="Others" scheme="http://thmasterplan.cn/tags/Others/"/>
    
  </entry>
  
  <entry>
    <title>Java基础</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/Java%E5%9F%BA%E7%A1%80/</id>
    <published>2020-04-08T14:47:15.000Z</published>
    <updated>2020-09-09T04:12:18.967Z</updated>
    
    <content type="html"><![CDATA[<h3 id="面向对象三大特性"><a href="#面向对象三大特性" class="headerlink" title="面向对象三大特性"></a>面向对象三大特性</h3><h4 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h4><ul><li>Java类是<strong>单继承</strong>的，不允许子类继承多个父类的原因在于，编译器无法确定使用哪个父类方法。</li><li>在父子类的继承关系中，创建父或子类对象，访问成员方法的规则：优先使用创建的对象的方法，没有则向上找。</li><li><p>继承关系中，父子构造方法访问的特点</p><ul><li>子类构造方法有一个默认隐含的super()调用，因此一定是先调用的父类构造，后执行子类构造。</li><li>子类构造可以通过显示使用super()来调用<strong>父类重载构造</strong>，并且必须是子类构造的第一条语句。</li></ul></li><li><p>重载与重写</p><ul><li>重写：子类重写方法与父类方法名相同，参数列表相同。</li><li>重载：一个类中有多个相同的方法名，但参数列表不同。</li></ul></li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><ul><li>概念：父类（接口）引用指向子类对象。</li><li>多态代码中<ul><li>成员<strong>重写方法</strong>的访问规则：先在子类对象中找，没有则向上找。</li><li><strong>成员变量</strong>访问规则：直接使用父类成员变量。</li></ul></li><li>向上转型即多态：父类引用指向子类对象；引用无法调用原本<strong>子类特有的方法</strong>。</li><li>向下转型，例如<code>Anaimal a = new Cat();Cat cat = (Cat) a;</code>，这个过程将父类变量还原为子类类型，使其又可以访问<strong>子类特有的方法</strong>。</li><li>多态的作用？<ul><li>Polymorphism allows us to perform a single action in different ways. In other words, polymorphism allows you to define one interface and have multiple implementations.</li></ul></li></ul><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><ul><li>封装通过将类属性定义为私有，对外提供类属性的setters/getters方法来修改和获取属性值实现。</li><li>封装可以减少耦合，防止类数据被外部类定义的代码随机访问。</li></ul><h3 id="权限修饰符作用范围"><a href="#权限修饰符作用范围" class="headerlink" title="权限修饰符作用范围"></a>权限修饰符作用范围</h3><p><img src="权限修饰符.png" alt=""></p><ul><li>外部类只有public和default两种权限。</li><li>private：只能修饰<strong>类方法</strong>和<strong>类变量</strong>，<strong>类内部才能访问</strong>。</li><li>default：无论对于<strong>类</strong>、<strong>类变量</strong>还是<strong>类方法</strong>，只能<strong>同一包内才能访问</strong>。</li><li>protected：修饰<strong>类变量</strong>和<strong>类方法</strong>，<strong>同一包内的类</strong>和<strong>该类的子类</strong>可访问。</li></ul><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><h4 id="static"><a href="#static" class="headerlink" title="static"></a>static</h4><ul><li><p>修饰成员变量或成员方法：不需要创建对象就可通过类名调用，它们均属于类，而非某个对象</p></li><li><p>修饰内部类（不允许修饰普通类）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">public class StaticTest &#123;</span><br><span class="line"></span><br><span class="line">public static class Inner&#123;</span><br><span class="line">static&#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类静态代码块&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">Inner() &#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类构造方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">public void innerMethod()&#123;</span><br><span class="line">System.out.println(&quot;&#x3D;&#x3D;&#x3D;&#x3D;静态内部类普通方法&#x3D;&#x3D;&#x3D;&#x3D;&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Inner inner &#x3D; new Inner();</span><br><span class="line">inner.innerMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出：====静态内部类静态代码块====</p><pre><code>       ====静态内部类构造方法====       ====静态内部类普通方法====</code></pre><p><strong>结论：想要在普通类中创建内部类实例，可以用static修饰内部类</strong>。</p></li><li><p>静态代码块</p><ul><li>第一次使用类时，类的静态代码块执行唯一的一次。（类加载的初始化阶段执行静态代码块）</li><li>静态代码块先于构造方法执行。</li></ul></li><li><p>Tips:</p><ul><li>静态不能直接访问非静态</li><li>静态方法中不能用this, this代表当前对象。</li></ul></li></ul><h4 id="final"><a href="#final" class="headerlink" title="final"></a>final</h4><ul><li>修饰<strong>类</strong>：当前类<strong>不能有子类</strong>。</li><li>修饰<strong>方法</strong>：该方法不能被子类重写。（显然对于类、方法来说，abstract和final无法同时使用）</li><li>修饰<strong>数据</strong>：对于基本数据类型，其值不能再改变；对于引用数据类型，不能再改为存储其他对象的地址或引用（对象自身是可以改变的）。对于类变量，<strong>必须赋初始值</strong>或<strong>在构造方法中赋值</strong>。</li><li>修饰<strong>数组</strong>：数组的引用不能再指向其他数组，当数组内容可变。</li></ul><h4 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h4><ul><li>instanceof 的作用是测试它<strong>左边的对象是否是它右边的类的实例</strong>，返回 boolean类型。</li></ul><h4 id="native"><a href="#native" class="headerlink" title="native"></a>native</h4><ul><li>使用native关键字修饰方法，说明这个方法是本地函数，也就是这个方法是用C/C++语言（或者其他语言）实现的，并且被编译成了DLL，由JVM调用。</li><li>native修饰的方法没有方法体。</li></ul><h4 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h4><ul><li>实现Serilizable接口，<strong>将不需要序列化的属性前添加关键字transient</strong>，序列化对象的时候，这个属性就不会序列化到指定的目的地中，该属性的将只会存在于内存中。常见的应用有密码、银行卡号等敏感信息。</li><li>transient关键字只能修饰变量。</li></ul><h3 id="接口与抽象类"><a href="#接口与抽象类" class="headerlink" title="接口与抽象类"></a>接口与抽象类</h3><h4 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h4><ul><li><p><code>public abstract class Name{}</code>；<strong><em>抽象类是描述一个对象是什么</em></strong>，它可以包含成员变量、成员方法、构造方法等，<strong>与普通类不同的点只在于：它可能包含抽象方法</strong>；它必须要<strong>被非抽象子类继承</strong>才能实例化，并且非抽象子类必须实现抽象方法（假如父类有抽象方法的话）。</p></li><li><p>单继承。</p></li><li>抽象类中不一定包含抽象方法，但是有抽象方法的类必定是抽象类；抽象方法没有方法体。</li><li>抽象类使用：<ol><li>创建子类继承抽象父类。</li><li>子类重写父类抽象方法，去掉abstract关键字，实现方法体。</li></ol></li></ul><h4 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h4><ul><li><p><code>public interface IName{}</code>；接口是<strong>多个类的公共规范</strong>。</p></li><li><p>接口可以继承多个接口，实现类可以实现多个接口。（<strong>多继承，多实现</strong>）</p></li><li><p><strong>接口的成员变量默认都是<code>public static final</code>的</strong>：假如两个接口有相同的成员变量，一个类实现了这两个接口，那么实现类只能通过接口名.变量名来调用以避免歧义，因此必须为static。声明为final的原因是实现类不能够修改接口成员变量的值。</p></li><li><p>Java7：<strong>常量，抽象方法</strong></p></li><li><p>Java8：新增了<strong>默认方法</strong>(default修饰)，<strong>静态方法</strong>。</p><ul><li><p>增加默认方法的原因：Java升级后的兼容性问题。如果想在老版本接口中添加某个功能，在添加抽象方法的情况下，所有的老版本实现类都需要修改代码；而通过增加default方法来增加功能就不会有这种问题。</p></li><li><p>考虑这样的情况，一个类实现了多个接口，且这些接口有相同的默认方法。解决方案：<strong>重写方法，并使用<code>接口名.super.方法名()</code>调用指定接口的方法</strong>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public interface Vehicle &#123;</span><br><span class="line">  default void print()&#123;</span><br><span class="line">  System.out.println(&quot;vehicle...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  public interface FourWheeler &#123;</span><br><span class="line">  default void print()&#123;</span><br><span class="line">  System.out.println(&quot;fourWheeler...&quot;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">public class Car implements Vehicle, FourWheeler &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public void print() &#123;</span><br><span class="line">FourWheeler.super.print();</span><br><span class="line">Vehicle.super.print();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Vehicle car &#x3D; new Car();</span><br><span class="line">car.print();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>  ​                     输出：fourWheeler…<br>  ​                     vehicle…</p><ul><li><p>Java9：新增了<strong>私有方法</strong>，<strong>私有静态方法</strong></p></li><li><p><strong>面向接口编程？</strong></p></li></ul><h3 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h3><h4 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h4><ul><li><p>三种方法使用成员内部类</p><ul><li>在外部类的方法中创建内部类实例</li><li>main方法中：<code>Inner inner = new Outer.new Inner();</code></li><li>main方法中直接new，前提是静态内部类</li></ul></li><li><p>在内部类中访问重名的外部类变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">public class Outer &#123;</span><br><span class="line">private int num &#x3D; 10;&#x2F;&#x2F;外部类私有变量，内部类也可访问</span><br><span class="line"></span><br><span class="line">class Inner&#123;</span><br><span class="line">private int num &#x3D; 20;</span><br><span class="line"></span><br><span class="line">public void innerMethod()&#123;</span><br><span class="line">int num &#x3D; 30;</span><br><span class="line"></span><br><span class="line">System.out.println(num);</span><br><span class="line">System.out.println(this.num);</span><br><span class="line">System.out.println(Outer.this.num);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Inner inner  &#x3D; new Outer().new Inner();</span><br><span class="line">inner.innerMethod();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="局部内部类"><a href="#局部内部类" class="headerlink" title="局部内部类"></a>局部内部类</h4><ul><li><p>该类定义在方法内部，只有在该方法内部才能使用。</p></li><li><p>局部内部类中的<strong>匿名内部类</strong></p><ul><li><p>如果接口的实现类（或者父类的子类）只需要使用一次，那么这种情况下可以省略掉该类的定义，而使用匿名内部类。</p></li><li><p>最常见的使用：通过将Runnable接口的实现类的实例对象作为参数传给Thread，创建线程。<strong>不仅省略了类定义，同时完成了向上转型。</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">new Thread(new Runnable() &#123;</span><br><span class="line">@Override</span><br><span class="line">public void run() &#123;</span><br><span class="line">System.out.println(&quot;...&quot;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure></li></ul></li></ul><h3 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h3><ul><li><p>包装类通过将基本数据类型封装起来，在类中提供一些方法，便于操作这些基本数据类型。</p></li><li><p>Java自jdk5后提供自动装箱与自动拆箱机制。</p></li><li><p>基本类型与字符串的转换</p><ul><li>基本类型 -&gt; String：基本类型值+””</li><li>String -&gt; 基本类型：使用包装类的静态方法<code>parseXXX(&quot;str&quot;)</code><ul><li>Integer：<code>static int parseInt(String s)</code></li><li>Double：<code>static double parseDouble(String s)</code></li></ul></li></ul></li></ul><h3 id="值传递与引用传递"><a href="#值传递与引用传递" class="headerlink" title="值传递与引用传递"></a>值传递与引用传递</h3><ul><li>实参与形参：<ul><li>形式参数：<strong>定义函数时使用的参数</strong>，用来接收实际参数。</li><li>实际参数：调用有参函数时，<strong>传入的内容。</strong></li></ul></li><li>值类型与引用类型<ul><li>值类型（基本数据类型）：直接存储值。</li><li>引用类型：存储的是对象的地址。对象在堆中。</li></ul></li><li>求值策略（Evaluation Strategy）：值传递与引用传递，属于<strong>函数调用时参数的求值策略</strong>，是对调用函数时求值和传值的方式的描述，<strong>而非传递的内容的类型</strong>。（内容的类型是指：值类型还是引用类型。）值类型与引用类型，用于区分两种内存分配方式，值类型在虚拟机栈上分配，引用类型在堆上分配。</li><li><strong><em>值传递概念</em></strong>：调用函数时，将实际参数<strong>拷贝</strong>一份传递给函数。In call by value, the argument expression is evaluated, and the resulting value is bound to the corresponding variable in the function (<strong>frequently by copying the value into a new memory region</strong>). Java uses call by value evaluate function arguments left-to-right</li><li><strong><em>引用传递概念</em></strong>：调用函数时，将实际参数的<strong>地址传递</strong>给函数。Call by reference (or pass by reference) is an evaluation strategy where a function receives <strong>an implicit reference</strong> to a variable used as argument, <strong>rather than a copy of its value.</strong></li><li><strong>总结-“Java中只有值传递，值传递与引用传递的区别重点在于是否拷贝”</strong>：对于基本数据类型，传递的是<strong>基本数据类型的值的拷贝</strong>；对于引用类型，传递的是<strong>对象的地址值的拷贝</strong>，形参与实参都保存的是堆内存中同一个对象的地址。</li></ul><p>参考：<a href="https://en.wikipedia.org/wiki/Evaluation_strategy" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Evaluation_strategy</a></p><h3 id="Deep-Copy-Shallow-Copy"><a href="#Deep-Copy-Shallow-Copy" class="headerlink" title="Deep Copy, Shallow Copy"></a>Deep Copy, Shallow Copy</h3><h4 id="Shallow-Copy"><a href="#Shallow-Copy" class="headerlink" title="Shallow Copy"></a>Shallow Copy</h4><ul><li><p>B对A的浅拷贝：创建新对象B，将A的字段值复制到B。</p><ol><li>如果该<strong>字段值是</strong>对对象（例如，存储器地址）的<strong>引用</strong>，则复制该引用（地址）。因此如果A或B修改了引用的对象，会在另一个中可见。</li><li>如果该<strong>字段值是基本数据类型</strong>，则复制值。</li></ol></li><li><p>Java中如果要对对象A进行浅拷贝，则A必须实现Cloneable接口，并重写继承自Object的clone()方法，then <code>B = (A) new A().clone();</code></p></li></ul><h4 id="Deep-Copy"><a href="#Deep-Copy" class="headerlink" title="Deep Copy"></a>Deep Copy</h4><ul><li>B对A的深拷贝：创建新对象B，对于A的引用类型，在B中创建该引用对象的拷贝，而非像浅拷贝中那样只拷贝引用（地址）。</li></ul><p>参考：<a href="https://en.wikipedia.org/wiki/Object_copying#Methods_of_copying" target="_blank" rel="noopener">https://en.wikipedia.org/wiki/Object_copying#Methods_of_copying</a></p><h3 id="Java四种引用类型"><a href="#Java四种引用类型" class="headerlink" title="Java四种引用类型"></a>Java四种引用类型</h3><ul><li><p>JDK1.2之后，引用概念分为以下4种，强度依次减弱</p><ul><li><strong>强引用</strong>：类似“Object obj = new Object()”这类引用，只要强引用存在，GC永远不会回收被引用的对象。</li><li><strong>软引用</strong>：描述有用但非必须的对象，当<strong>系统将要发生OOM异常时</strong>，软引用指向的对象才被真正回收。通过SoftReference类实现。</li><li><strong>弱引用</strong>：GC工作时，无论当前内存是否足够，都会回收只被弱引用关联的对象。通过WeakReference类实现。</li><li><strong>虚引用</strong>：为一个对象设置虚引用关联的唯一目的时能<strong>在对象被回收时收到一个系统通知</strong>。通过PhantomReference类实现。</li></ul></li></ul><h3 id="集合的三种遍历方式"><a href="#集合的三种遍历方式" class="headerlink" title="集合的三种遍历方式"></a>集合的三种遍历方式</h3><ul><li>for<ul><li>形式：<code>for(初始化;结束条件;自增操作等)</code></li><li>需要知道集合的<strong>大小</strong>和元素<strong>类型</strong>，使用索引。</li></ul></li><li>foreach<ul><li>形式：<code>for(T element : colletion)</code></li><li>需要知道集合元素的<strong>类型</strong>，不需要索引。</li></ul></li><li><p>iterator</p><ul><li>形式：<code>Iterator it = collection.iterator();while(it.hasNext()){ object o =it.next(); ...}</code></li><li>集合的大小和类型都无需知道，也无需索引。</li></ul></li><li><p>Tips:</p><ul><li>foreach是iterator的语法糖，底层使用iterator实现。</li><li>使用for循环进行remove操作时，每一次操作完成后索引需要自减。</li><li>iterator/foreach遍历集合时的add/remove操作见“Java集合框架”。</li></ul></li></ul><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><ul><li><p>Java异常图解</p><p><img src="Exception.png" alt=""></p></li><li><p>Throwable类中定义了一些查看异常的方法：</p><ul><li><code>public String getMessage()</code>：获取异常的描述信息。</li><li><code>public String toString()</code>：获取异常的类型和异常描述信息。</li><li><code>void printStackTrace()</code>：打印异常的跟踪栈信息。最常用。</li></ul></li><li><p>捕获异常</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">try&#123;</span><br><span class="line">    &#x2F;&#x2F;可能产生异常的代码</span><br><span class="line">&#125;catch(异常类型1 e)&#123;</span><br><span class="line">    &#x2F;&#x2F;异常的处理逻辑；一般会记录到日志中</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"> catch(异常类型n e)&#123;</span><br><span class="line">     </span><br><span class="line"> &#125;finally&#123;</span><br><span class="line">     &#x2F;&#x2F;无论是否出现异常都会执行，常用于资源释放</span><br><span class="line"> &#125;</span><br><span class="line">&#x2F;&#x2F;jdk1.8之后支持try with resource写法</span><br><span class="line">try(需要释放资源的代码)&#123;</span><br><span class="line">&#125;catch(Exception e)&#123;&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class XXXException extends Exception&#123;</span><br><span class="line">    &#x2F;&#x2F;添加一个空参构造</span><br><span class="line">    public XXXException()&#123;</span><br><span class="line">       super();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    &#x2F;&#x2F;添加一个带异常信息的构造</span><br><span class="line">    public XXXException(String message)&#123;</span><br><span class="line">       super(message);&#x2F;&#x2F;所有的子类异常都交给父类处理</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>自定义异常类一般以命名Exception结尾，必须继承Exception类或者RuntimeException类：</p><ul><li>继承自Exception：自定义异常为编译期异常，必须处理。</li><li>继承自RuntimeException：运行期异常无需处理。</li></ul></li></ul><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><h4 id="String"><a href="#String" class="headerlink" title="String"></a>String</h4><ul><li><p>String类是final的，因此不能被继承。源码是一个<strong>final修饰的字符数组</strong>，因此一旦创建就是一个不可变的字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">private final char value[];</span><br></pre></td></tr></table></figure></li><li><p>StringTable编译期优化：</p></li><li><p>判断字符串是否相等？ </p><ol><li><p>值在编译阶段确定（相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">String b &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">String c &#x3D; &quot;hello&quot; + &quot;World&quot;;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;true</span><br><span class="line">System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：字符串常量在<strong>编译阶段</strong>会存入<strong>常量池</strong>中<strong>共享</strong>，编译阶段完成字符串的拼接（无引用的情况下），因此在运行期a,b,c均指向同一个地址。</p></li><li><p>值在编译器无法确定（不相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">String b &#x3D; new String(&quot;helloWorld&quot;);</span><br><span class="line">String c &#x3D; &quot;hello&quot; + new String(&quot;World&quot;);</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false</span><br><span class="line">System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：b,c均在运行期创建，存在于堆内存。</p></li><li><p>涉及引用操作，编译期值无法确定（不相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld2&quot;;</span><br><span class="line">String b &#x3D; a + 2;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;b);&#x2F;&#x2F;false</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：引用a的值在编译阶段无法确定，在运行期才给其分配内存来指向常量池中的字符串，因此a+2是在运行期创建的，两个对象地址并不相同。</p></li><li><p>涉及引用操作，编译期值确定（相等）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">String a &#x3D; &quot;helloWorld&quot;;</span><br><span class="line">final String b &#x3D; &quot;hello&quot;;</span><br><span class="line">String c &#x3D; b + &quot;World&quot;;</span><br><span class="line">System.out.println(a&#x3D;&#x3D;c);&#x2F;&#x2F;true</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>分析：变量b被final修饰，在编译时被解析为常量值的一个本地拷贝存储到自己的常量池中或嵌入到它的字节码流中，此时b已经确定指向”hello”,可以被引用。</p></li></ol></li><li><p><strong>字符串的拼接</strong>：由于常量池中字符串不可变，一个字符串和另一个字符串拼接需要开辟<strong>三块</strong>内存空间，效率低下。建议使用StringBuffer或StringBuilder，这两者的区别稍后讲解。</p></li><li><p>String常用方法</p><ul><li>比较</li><li><code>equals(Object obj)</code>：如果比较双方一个常量一个变量，应把常量写在前面，如<code>&quot;abc&quot;.equals(str)</code>。因为如使用<code>str.equals(&quot;abc&quot;)</code>，假如str为空会导致空指针异常。<ul><li><code>equalsIgnoreCase(String str)</code>：忽略大小写。</li><li><code>endsWith(String suffix)</code>：比较suffix是否为串的后缀。</li></ul></li><li>获取<ul><li><code>length()</code>：获取长度。</li><li><code>concat(String str)</code>：获取拼接后的串。</li><li><code>charAt(int index)</code>：获取指定索引字符。</li><li><code>public int indexOf(String str)</code>：查找参数串在本串中首次出现的索引位置，如无匹配结果返回-1。可用于<strong>字符串匹配</strong>。</li></ul></li><li>截取<ul><li><code>subString(int index)</code>：截取从参数位置开始后的子串。</li><li><code>subString(int begin, int end)</code>：截取[begin, end)子串。</li><li><code>trim()</code>：去除字符串的前后空格。</li></ul></li><li>转换<ul><li><code>toCharArray()</code>：串转换为字符数组</li><li><code>getBytes()</code>：串转换为底层的字节数组</li><li><code>toUpperCase()和toLowerCase()</code>：大小写转换。</li><li><code>replaceAll(String regex, String replacement)</code>：使用给定的replacement替换所有符合regex规则的子串。</li></ul></li><li>分割：<code>split(String regex)</code>：按照参数规则分割字符串为若干子串。</li></ul></li></ul><h4 id="StringBuffer与StringBuilder"><a href="#StringBuffer与StringBuilder" class="headerlink" title="StringBuffer与StringBuilder"></a>StringBuffer与StringBuilder</h4><ul><li>都由final修饰，不能被继承。</li><li>都继承于<strong>AbstractStringBuilder</strong>，底层使用的字符数组没有final修饰，因此在做字符串拼接就在原来的内存上拼接（<code>append()方法</code>），不会浪费内存空间。</li><li>StringBuffer：线程安全，StringBuilder：线程不安全。因为 StringBuffer 的所有public方法都是  synchronized 修饰的，而 StringBuilder 并没有。因此StringBuffer的性能低于StringBuilder。</li><li><p>StringBuffer 适用于多线程场景，如果是单线程场合 StringBuilder 更适合。</p></li><li><p>jdk1.9后String/StringBuffer/StringBuilder均不再使用字符数组，而是直接使用字节数组byte[] value。</p></li></ul><h3 id="Arrays常用方法"><a href="#Arrays常用方法" class="headerlink" title="Arrays常用方法"></a>Arrays常用方法</h3><ul><li><code>static List&lt;T&gt; asList&lt;T... a&gt;</code>：返回参数列表的List，例<code>List&lt;String&gt; stooges = Arrays.asList(&quot;Larry&quot;, &quot;Moe&quot;, &quot;Curly&quot;);</code></li><li><code>binarySearch()</code>：有多个重载的方法，二分查找</li><li><code>static String toString(数组)</code>：将参数数组变成字符串，默认格式为[元素1, 元素2, 元素3….]</li><li><code>sort(数组)</code>：按照默认升序对数组元素排序；自定义类型需要实现Comparator接口。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;面向对象三大特性&quot;&gt;&lt;a href=&quot;#面向对象三大特性&quot; class=&quot;headerlink&quot; title=&quot;面向对象三大特性&quot;&gt;&lt;/a&gt;面向对象三大特性&lt;/h3&gt;&lt;h4 id=&quot;继承&quot;&gt;&lt;a href=&quot;#继承&quot; class=&quot;headerlink&quot; titl
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JavaIO</title>
    <link href="http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/"/>
    <id>http://thmasterplan.cn/Java%E5%9F%BA%E7%A1%80/JavaIO/</id>
    <published>2020-04-08T14:23:56.000Z</published>
    <updated>2020-09-07T11:39:06.944Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Java-IO-NIO-AIO-Overview"><a href="#Java-IO-NIO-AIO-Overview" class="headerlink" title="Java IO/NIO/AIO - Overview"></a>Java IO/NIO/AIO - Overview</h2><p><img src="java-io-overview.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Java-IO-NIO-AIO-Overview&quot;&gt;&lt;a href=&quot;#Java-IO-NIO-AIO-Overview&quot; class=&quot;headerlink&quot; title=&quot;Java IO/NIO/AIO - Overview&quot;&gt;&lt;/a&gt;Java IO/NIO/
      
    
    </summary>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/categories/Java%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Java基础" scheme="http://thmasterplan.cn/tags/Java%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JDK动态代理</title>
    <link href="http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://thmasterplan.cn/JavaWeb/JDK%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/</id>
    <published>2020-04-05T08:53:39.000Z</published>
    <updated>2020-09-07T11:38:33.732Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一个小需求引入静态代理"><a href="#一个小需求引入静态代理" class="headerlink" title="一个小需求引入静态代理"></a>一个小需求引入静态代理</h3><ul><li><p>假设现有一个类Calculator，代表一个计算器，可以进行各种算数运算。现有一个需求：在每个方法执行前后打印日志。有什么好的方案？</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">public class Calculator&#123;</span><br><span class="line">  public int add(int a, int b)&#123;</span><br><span class="line">     return a+b;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  public int subtract(int a, int b)&#123;</span><br><span class="line">     return a-b;</span><br><span class="line">  &#125;</span><br><span class="line">  &#x2F;&#x2F;其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>方案：直接在Calculator类每个方法前后插入日志代码。缺点：</p><ol><li>直接修改源码，不符合<strong>开闭原则</strong>。应该<strong>对扩展开放，对修改关闭</strong>。</li><li>如果Calculator类有许多方法，修改量太大。</li><li>重复代码太多。</li><li>日志代码硬编码在代理类中，不利于后期维护。</li></ol></li></ul><h3 id="静态代理实现日志打印"><a href="#静态代理实现日志打印" class="headerlink" title="静态代理实现日志打印"></a>静态代理实现日志打印</h3><ul><li><p>代理模式：提供了对目标对象的间接访问方式，即通过代理对象访问目标对象。如此便于<strong>在目标实现的基础上增加额外的功能操作</strong>，以满足自身的业务需求。</p></li><li><p>静态代理的实现：编写一个代理类，<strong>实现与目标对象相同的接口</strong>，<strong>并在内部维护一个目标对象的引用</strong>。通过构造器塞入目标对象，在代理对象中调用目标对象的同名方法，并添加业务功能。</p></li><li><p>静态代理实现日志打印：</p><ul><li><p>将Calculator抽取为接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">public interface Calculator &#123;</span><br><span class="line">int add(int a, int b);</span><br><span class="line">int subtract(int a, int b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>目标对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorImpl implements Calculator &#123;</span><br><span class="line"></span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">return a + b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public int subtract(int a, int b) &#123;</span><br><span class="line">return a - b;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>代理对象实现类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">public class CalculatorProxy implements Calculator &#123;</span><br><span class="line">        &#x2F;&#x2F;代理对象内部维护一个目标对象引用</span><br><span class="line">private Calculator target;</span><br><span class="line">        </span><br><span class="line">        &#x2F;&#x2F;构造方法，传入目标对象</span><br><span class="line">public CalculatorProxy(Calculator target) &#123;</span><br><span class="line">this.target &#x3D; target;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用目标对象的add，并在前后打印日志</span><br><span class="line">@Override</span><br><span class="line">public int add(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;add方法开始...&quot;);</span><br><span class="line">int result &#x3D; target.add(a, b);</span><br><span class="line">System.out.println(&quot;add方法结束...&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;调用目标对象的subtract，并在前后打印日志</span><br><span class="line">@Override</span><br><span class="line">public int subtract(int a, int b) &#123;</span><br><span class="line">System.out.println(&quot;subtract方法开始...&quot;);</span><br><span class="line">int result &#x3D; target.subtract(a, b);</span><br><span class="line">System.out.println(&quot;subtract方法结束...&quot;);</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;其余算数运算方法。。。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用代理对象实现计算器并打印日志</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class Test &#123;</span><br><span class="line">public static void main(String[] args) &#123;</span><br><span class="line">Calculator calculator &#x3D; new CalculatorProxy(new CalculatorImpl());</span><br><span class="line">calculator.add(1, 2);</span><br><span class="line">calculator.subtract(2, 1);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>静态代理的优点：可以在不修改目标类的前提下，对目标类进行功能的扩展和拦截。</p></li><li><p>静态代理的缺点：</p><ul><li><strong>代理者与委托者一一对应</strong>，n个不同的委托类就需要编写n个不同的代理类，程序规模较大时无法胜任。</li><li>如果接口中增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。</li></ul></li></ul><h3 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h3><ul><li><p>我们的目标只是为了实现增强功能，如何才能不编写代理类，只<strong>提供接口和目标对象</strong>就直接<strong>得到代理对象</strong>呢？JDK提供了java.lang.reflect.InvocationHandler接口和java.lang.reflect.Proxy类实现动态代理。</p></li><li><p>Proxy类：提供了一个静态方法getProxyClass(ClassLoader clsLoader, Class&lt;?&gt;… interfaces)得到代理class对象，该对象封装了<strong>JVM动态生成的代理类</strong>的Field，Method，Constructor对象，通过constructor对象的newInstance方法创建代理对象并返回。实际开发中采用newProxyInstance方法，直接返回代理对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line">package reflect;</span><br><span class="line"></span><br><span class="line">import java.lang.reflect.Constructor;</span><br><span class="line">import java.lang.reflect.InvocationHandler;</span><br><span class="line">import java.lang.reflect.Method;</span><br><span class="line">import java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line">public class ProxyTest &#123;</span><br><span class="line">&#x2F;**</span><br><span class="line"> * 测试</span><br><span class="line"> * @param args</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">Calculator calculatorProxy &#x3D;(Calculator) getProxy(new CalculatorImpl());</span><br><span class="line">        calculatorProxy.add(1, 2);</span><br><span class="line">        calculatorProxy.subtract(3, 2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 传入目标对象，得到代理对象</span><br><span class="line"> * @param targetObj</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">private static Object getProxy(final Object targetObj) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;传入目标对象类实现的接口，返回代理class对象，该class对象实现了该接口</span><br><span class="line">&#x2F;&#x2F;proxyClass对象封装了代理类（代理类由JVM动态生成）的Method, Field, Constuctor等对象</span><br><span class="line">Class&lt;?&gt; proxyClass &#x3D;</span><br><span class="line">Proxy.getProxyClass(targetObj.getClass().getClassLoader(), targetObj.getClass().getInterfaces());</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;得到代理类（com.sun.proxy.$Proxy0）的构造器</span><br><span class="line">Constructor&lt;?&gt; constructor &#x3D; proxyClass.getConstructor(InvocationHandler.class);</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;通过构造器创建代理对象</span><br><span class="line">Object proxyObj &#x3D; constructor.newInstance(new InvocationHandler()&#123;</span><br><span class="line"></span><br><span class="line">&#x2F;&#x2F;在重写invoke方法中编写增强功能代码</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">Object result &#x3D; method.invoke(targetObj,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">private static Object getProxy1(final Object targetObj) throws Exception &#123;</span><br><span class="line"></span><br><span class="line">Object proxyObj &#x3D; Proxy.getProxyClass(</span><br><span class="line">targetObj.getClass().getClassLoader(),</span><br><span class="line">targetObj.getClass().getInterfaces()</span><br><span class="line">)</span><br><span class="line">.getConstructor(InvocationHandler.class)</span><br><span class="line">.newInstance(new InvocationHandler()&#123;</span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">Object result &#x3D; method.invoke(targetObj,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">return result;</span><br><span class="line">&#125;</span><br><span class="line">     &#125;);</span><br><span class="line">return proxyObj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> * 实际使用的方法newProxyInstance</span><br><span class="line"> * @param target</span><br><span class="line"> * @return</span><br><span class="line"> * @throws Exception</span><br><span class="line"> *&#x2F;</span><br><span class="line">public static Object getProxy2(final Object target) throws Exception &#123;</span><br><span class="line">Object proxy &#x3D; Proxy.newProxyInstance(target.getClass().getClassLoader(),</span><br><span class="line">target.getClass().getInterfaces(),</span><br><span class="line">new InvocationHandler() &#123;</span><br><span class="line"></span><br><span class="line">@Override</span><br><span class="line">public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;</span><br><span class="line">System.out.println(method.getName() + &quot;方法开始执行...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">Object result &#x3D; method.invoke(target,args);</span><br><span class="line">System.out.println(result);</span><br><span class="line">System.out.println(method.getName() + &quot;方法执行结束...&quot;);&#x2F;&#x2F;增强功能代码</span><br><span class="line">return result;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">return proxy;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>使用动态代理，在大量接口和目标对象需要实现某个增强功能时，我们只需要一段代码，传入目标对象作为参数，就可以实现需求。</p></li><li><p>mybatis Mapper以及springAOP都是通过动态代理实现。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一个小需求引入静态代理&quot;&gt;&lt;a href=&quot;#一个小需求引入静态代理&quot; class=&quot;headerlink&quot; title=&quot;一个小需求引入静态代理&quot;&gt;&lt;/a&gt;一个小需求引入静态代理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;假设现有一个类Calculator，代表一个计算器
      
    
    </summary>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/categories/JavaWeb/"/>
    
    
      <category term="JavaWeb" scheme="http://thmasterplan.cn/tags/JavaWeb/"/>
    
  </entry>
  
  <entry>
    <title>mybatisHelloWorld</title>
    <link href="http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/"/>
    <id>http://thmasterplan.cn/Java%E6%A1%86%E6%9E%B6/mybatisHelloWorld/</id>
    <published>2020-04-05T08:39:41.000Z</published>
    <updated>2020-09-07T11:37:45.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><ul><li>mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。<strong>开发者只需要关注sql语句本身（在配置文件或注解中编写，sql与java编码分离，一个专注数据，一个专注业务）</strong>，而不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。</li></ul><h3 id="MybatisHelloWorld"><a href="#MybatisHelloWorld" class="headerlink" title="MybatisHelloWorld"></a>MybatisHelloWorld</h3><ul><li><p>工程文件结构如图</p><p><img src="mybatisHelloWorld.jpg" alt=""></p></li></ul><ol><li><p>创建Maven工程，配置pom.xml，插入：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;dependencies&gt;</span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;mysql&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mysql-connector-java&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;5.1.48&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;org.mybatis&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;mybatis&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;3.5.4&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">   </span><br><span class="line">      &lt;dependency&gt;</span><br><span class="line">          &lt;groupId&gt;junit&lt;&#x2F;groupId&gt;</span><br><span class="line">          &lt;artifactId&gt;junit&lt;&#x2F;artifactId&gt;</span><br><span class="line">          &lt;version&gt;4.12&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;&#x2F;dependency&gt;</span><br><span class="line">   </span><br><span class="line">  &lt;&#x2F;dependencies&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建实体类和DAO接口</p><ul><li><p>实体类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class User &#123;</span><br><span class="line">    private Integer id;&#x2F;&#x2F;包装类默认为null</span><br><span class="line">    private String lastName;</span><br><span class="line">    private String email;</span><br><span class="line">    private String gender;</span><br><span class="line">    &#x2F;&#x2F;getters and setters, toString...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>DAO接口</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">public interface UserMapper &#123;</span><br><span class="line">    public User getUserById(Integer id);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>创建sql映射文件：<code>UserMapper.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Mapper 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- sql映射文件：保存了每一个sql语句的映射信息--&gt;</span><br><span class="line"></span><br><span class="line">&lt;mapper namespace&#x3D;&quot;com.laishiji.mybatis.dao.UserMapper&quot;&gt; &lt;!--名称空间指定DAO接口的全类名 --&gt;</span><br><span class="line">    &lt;!-- id指定DAO接口的抽象方法名，返回类型为实体类的全类名--&gt;</span><br><span class="line">    &lt;select id&#x3D;&quot;getUserById&quot; resultType&#x3D;&quot;com.laishiji.mybatis.bean.User&quot;&gt;</span><br><span class="line">         select id, last_name lastName, gender,email from user where id &#x3D; #&#123;id&#125;</span><br><span class="line">    &lt;&#x2F;select&gt;</span><br><span class="line">&lt;&#x2F;mapper&gt;</span><br></pre></td></tr></table></figure></li><li><p>创建mybatis全局配置文件，配置数据连接池信息，mapper信息等：<code>mybatisConfig.xml</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-&#x2F;&#x2F;mybatis.org&#x2F;&#x2F;DTD Config 3.0&#x2F;&#x2F;EN&quot;</span><br><span class="line">        &quot;http:&#x2F;&#x2F;mybatis.org&#x2F;dtd&#x2F;mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!-- mybatis全局配置文件：包含数据库连接池信息，事务管理器信息等--&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments default&#x3D;&quot;development&quot;&gt;</span><br><span class="line"></span><br><span class="line">        &lt;environment id&#x3D;&quot;development&quot;&gt;</span><br><span class="line"></span><br><span class="line">            &lt;transactionManager type&#x3D;&quot;JDBC&quot;&#x2F;&gt;</span><br><span class="line"></span><br><span class="line">              &lt;dataSource type&#x3D;&quot;POOLED&quot;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;driver&quot; value&#x3D;&quot;com.mysql.jdbc.Driver&quot;&#x2F;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;url&quot; value&#x3D;&quot;jdbc:mysql:&#x2F;&#x2F;localhost:3306&#x2F;mybatis&quot;&#x2F;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;username&quot; value&#x3D;&quot;root&quot;&#x2F;&gt;</span><br><span class="line">                  &lt;property name&#x3D;&quot;password&quot; value&#x3D;&quot;admin&quot;&#x2F;&gt;</span><br><span class="line">              &lt;&#x2F;dataSource&gt;</span><br><span class="line"></span><br><span class="line">        &lt;&#x2F;environment&gt;</span><br><span class="line"></span><br><span class="line">    &lt;&#x2F;environments&gt;</span><br><span class="line"></span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource&#x3D;&quot;UserMapper.xml&quot;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;mappers&gt;</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;configuration&gt;</span><br></pre></td></tr></table></figure></li><li><p>mysql中建表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">drop database if exists mybatis;</span><br><span class="line">create database mybatis default character set utf8;</span><br><span class="line"></span><br><span class="line">create table user(</span><br><span class="line">  id int(11) primary key auto_increment,</span><br><span class="line">  last_name varchar(255),</span><br><span class="line">  gender char(1),</span><br><span class="line">  email varchar(255)</span><br><span class="line">)engine&#x3D;innodb default charset&#x3D;utf8;</span><br><span class="line"></span><br><span class="line">insert into user(id,last_name,gender,email) values (1,&#39;Tom&#39;,&#39;男&#39;,&#39;123@qq.com&#39;),</span><br><span class="line">                                   (2,&#39;Jim&#39;,&#39;男&#39;,&#39;234@qq.com&#39;),</span><br><span class="line">                                    (3,&#39;Lisa&#39;,&#39;女&#39;,&#39;324@qq.com&#39;);</span><br></pre></td></tr></table></figure></li><li><p>创建测试类</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line">package com.laishiji.mybatis;</span><br><span class="line"></span><br><span class="line">import com.laishiji.mybatis.bean.User;</span><br><span class="line">import com.laishiji.mybatis.dao.UserMapper;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line">import org.junit.Test;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">&#x2F;**</span><br><span class="line"> *  SqlSession代表和数据库的一次会话，用完必须关闭；</span><br><span class="line"> *  SqlSession和Connection一样都是非线程安全的，因此不要写作类的成员变量；</span><br><span class="line"> *  mapper接口没有实现类，但是mybatis会为这个接口生成一个代理对象。</span><br><span class="line"> *&#x2F;</span><br><span class="line">public class MybatisTest &#123;</span><br><span class="line">    @Test</span><br><span class="line">    public void test() throws IOException &#123;</span><br><span class="line">        String resource &#x3D; &quot;mybatisConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory &#x3D;  new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession session &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        User user &#x3D; session.selectOne(&quot;com.laishiji.mybatis.dao.UserMapper.getUserById&quot;,1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        session.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    &#x2F;**</span><br><span class="line">     *   接口式编程：</span><br><span class="line">     *    原生：DAO类 ---&gt; DAOImpl实现类</span><br><span class="line">     *    mybatis：xxxMapper接口 ---&gt; xxxMapper.xml</span><br><span class="line">     * @throws IOException</span><br><span class="line">     *&#x2F;</span><br><span class="line">    @Test</span><br><span class="line">    public void test2() throws IOException &#123;</span><br><span class="line">        String resource &#x3D; &quot;mybatisConfig.xml&quot;;</span><br><span class="line">        InputStream inputStream &#x3D; Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory &#x3D;  new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession openSession &#x3D; sqlSessionFactory.openSession();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;通过反射+动态代理获取接口的实现类对象</span><br><span class="line">        UserMapper mapper &#x3D; openSession.getMapper(UserMapper.class);</span><br><span class="line"></span><br><span class="line">        User user &#x3D; mapper.getUserById(1);</span><br><span class="line">        System.out.println(user);</span><br><span class="line"></span><br><span class="line">        openSession.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;mybatis是基于Java的半自动化持久层框架，内部封装了JDBC。&lt;strong&gt;开发者只需要关注sql语句本身（在配置文件
      
    
    </summary>
    
    
      <category term="Java框架" scheme="http://thmasterplan.cn/categories/Java%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="Mybatis" scheme="http://thmasterplan.cn/tags/Mybatis/"/>
    
  </entry>
  
</feed>
