<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2019-11-19T10:44:11.625Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>java位运算</title>
    <link href="http://thmasterplan.cn/2019/11/19/java%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://thmasterplan.cn/2019/11/19/java%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2019-11-19T10:25:55.000Z</published>
    <updated>2019-11-19T10:44:11.625Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA位运算符"><a href="#JAVA位运算符" class="headerlink" title="JAVA位运算符"></a>JAVA位运算符</h3><ol><li>&amp; ：按位与。同时为1才为1，否则为0。</li><li>| ：按位或。有一个为1则为1。</li><li>~ ：按位取反。例如3：补码：0b00000000000000000000000000000011。~3–&gt;得:0b11111111111111111111111111111100。(依旧为补码)。减一后取反得原码(原码-&gt;补码的逆运算)：0b1000000000000000000000000000100。故3取反后为-4。</li><li>^ ：按位异或。不同为1，相同为0。<ul><li>一个数据对相同的数据异或两次，值不变,常应用于加密。即a^b^b == a。</li><li>使用异或实现两个变量值交换。a = a^b; b = a^b; a = a^b。</li></ul></li><li>&lt;&lt; ：左移。左操作数乘以2的n次幂。n是右操作数，即左移的位数。右边空出两位补0，左边两位被挤掉。</li><li><strong>&gt;&gt;</strong> ：右移。左操作数除以2的n次幂。n是右操作数，即右移的位数。左边空出两位用符号位填充，右边两位被挤掉。<ul><li>例如：-32 &gt;&gt; 2 ：原码：10000000000000000000000000100000，反码：11111111111111111111111111011111，补码：11111111111111111111111111100000。右移后为：11111111111111111111111111111000。求得原码为：10000000000000000000000000001000。得-8。</li></ul></li><li><strong>&gt;&gt;&gt;</strong> ：<strong>无符号右移</strong>。左边空出的位置用0补全。例如-32 &gt;&gt;&gt; 2变成一个很大的正数。</li><li>位运算均针对<strong>补码</strong>进行。正数的符号位为0，原、反、补码均为其本身；负数的符号位为1，其反码为对原码除符号位其余所有位求反，补码为对反码+1。</li><li>对于有符号数，计算机中存储的是<strong>补码</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA位运算符&quot;&gt;&lt;a href=&quot;#JAVA位运算符&quot; class=&quot;headerlink&quot; title=&quot;JAVA位运算符&quot;&gt;&lt;/a&gt;JAVA位运算符&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&amp;amp; ：按位与。同时为1才为1，否则为0。&lt;/li&gt;
&lt;li&gt;| ：按位或
      
    
    </summary>
    
    
      <category term="Java" scheme="http://thmasterplan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://thmasterplan.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>网络安全总结</title>
    <link href="http://thmasterplan.cn/2019/11/19/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/"/>
    <id>http://thmasterplan.cn/2019/11/19/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E6%80%BB%E7%BB%93/</id>
    <published>2019-11-19T10:21:36.000Z</published>
    <updated>2019-11-19T10:43:12.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Security"><a href="#Security" class="headerlink" title="Security"></a>Security</h2><h3 id="一、-介绍"><a href="#一、-介绍" class="headerlink" title="一、    介绍"></a>一、    介绍</h3><ol><li><strong>网络安全五个特征</strong>：<ul><li>保密性：信息不泄露给非授权用户、实体或过程，或供其利用的特性。 </li><li>完整性：数据未经授权不能进行改变的特性。即信息在存储或传输过程中保持不被修改、不被破坏和丢失的特性。 </li><li>可用性：可被授权实体访问并按需求使用的特性。即当需要时能否存取所需网络安全解决措施的信息。例如网络环境下拒绝服务、破坏网络和有关系统的正常运行等都属于对可用性的攻击； </li><li>可控性：对信息的传播及内容具有控制能力。</li><li>不可否认性：出现的安全问题时提供依据与手段。</li></ul></li><li><strong>安全机制</strong>:<ul><li>加密机制</li><li>数字签名机制</li><li>访问控制机制</li><li>数据完整性机制</li><li>认证交换机制</li><li>通信业务流填充</li><li>路由控制</li><li>公证机制</li><li>普遍性安全机制</li></ul></li><li><strong>网络攻击方法</strong>:<ul><li>被动攻击</li><li>主动攻击</li><li>物理临近攻击</li><li>内部人员攻击</li><li>软硬件装配攻击</li></ul></li></ol><h3 id="二、-古典加密技术"><a href="#二、-古典加密技术" class="headerlink" title="二、    古典加密技术"></a>二、    古典加密技术</h3><ol><li><strong>代替密码</strong>：明文中的每个字符被替换成密文中的另一个字符<ul><li>凯撒码<ul><li><img src="1.png" alt=""></li><li>将明文转换为数字，使用加密函数E（m）=m+k(mod 26)得密文。解密函数D（c）=c-k(mod 26)。（只是字母简单的偏移）</li></ul></li><li>维吉尼亚密码<ul><li>密钥：一个字符串，对应一个数表</li><li><img src="2.png" alt=""></li><li>暴力破解需要26的k次方</li></ul></li><li>代替密码特点：<ul><li>单字母代换密码 ：明文中字母的出现频度、重复字母的模式和字母相互之间的结合模式等统计特性不变，安全性差。</li><li>多字母代替密码 ：字符块被成组加密 ，有利于抗击统计分析。</li></ul></li></ul></li><li><strong>置换密码</strong>：又称换位密码（transposition cipher） ，并没有改变明文字母，只改变了这些字母的出现顺序。<br>在对密文进行统计之后，易于判断该密文是否使用了置换密码加密方案。</li><li><strong>Kerckhoffs假设</strong>：假定密码分析者知道对方所使用的密码系统，包括明文的统计特性，加密体制（操作方式、处理方法和加/解密算法）、密钥空间及其统计特性。但是，不知道密钥。在设计一个密码系统时，目标是在Kerckhoffs假设的前提下实现安全。</li><li><strong>密码分析方法</strong>：尝试发现明文或密钥的过程<ul><li>唯密文攻击：知道部分密文试图恢复明文，并试图推算密钥</li><li>已知明文攻击：知道部分消息密文及对应明文，试图推导密钥或算法</li><li>选择明文攻击：事先选择部分明文让被攻击者加密，并得到相应密文，试图推导出密钥或算法。</li><li>选择密文攻击：密码分析者需要掌握的内容包括：加密算法、截获的部分密文、自己选择的密文消息以及相应的被解密的明文。密码分析者事先任意搜集一定数量的密文，让这些密文透过被攻击的加密算法解密，透过未知的密钥获得解密后的明文。由此能够计算出加密者的私钥或者分解模数，运用这些信息，攻击者可以恢复所有的明文。</li></ul></li><li><strong>维吉尼亚密码的密码分析</strong><ul><li>字母频率统计用于猜测</li><li>Kasiski测试法确定密钥长度</li><li>重合指数法破译密文</li></ul></li></ol><h3 id="三、-对称加密"><a href="#三、-对称加密" class="headerlink" title="三、    对称加密"></a>三、    对称加密</h3><ol><li><strong>分组密码的设计原则</strong><ul><li>混乱原则：密码设计应保证明文与密文之间的依赖关系足够复杂。</li><li>扩散原则：密码设计应保证密钥的每位数字能够影响密文中的多位数字（避免对密钥逐段破译），同时应保证明文的每位数字能够影响密文中的多位数字（隐藏明文的统计特性）。</li></ul></li><li><strong>分组密码特点</strong><ul><li>优点：易于标准化，易于实现同步</li><li>缺点：不善于隐藏明文的数据模式，对于重放、插入、删除等攻击方式的抵御能力不强。</li></ul></li><li><strong>对称加密算法</strong>：DES/AES<ul><li><img src="3.png" alt=""></li></ul></li><li><strong>分组密码工作模式</strong><ul><li>ECB（Electronic Codebook）: 电码本<ul><li>用相同的密钥分别对明文分组独立加密</li><li>对长明文不安全，因为重复的明文块在密文中也是重复的</li></ul></li><li>CBC（Cipher Block Chaining）：密文分组链接<ul><li>加密算法的输入是上一个密文组和下一个明文组的异或</li><li>优点：能够隐蔽明文的数据模式；能够一定程度上防止分组的重放、插入和删除攻击。</li><li>缺点：易导致错误传播。任意一个明文或密文组出错会导致其后的密文分组出错。</li></ul></li><li>CFB（Cipher Feedback）:密文反馈<ul><li>一次处理s位（明文和密文均是），加密算法的输入是上一块密文，加密后产生的伪随机数输出与明文异或作为下一单元的密文。</li><li>实质是一种自同步流密码</li><li>适用于必须按比特或字符对明文进行加密的情况</li></ul></li><li>OFB（Output Feedback）：输出反馈<ul><li>与CFB类似，只是加密算法的输入是上一次加密算法的输出，且使用整个分组</li><li>优点：能够克服错误传播</li><li>缺点：很难发现密文被篡改；不具备自同步能力</li></ul></li><li>CTR计数器<ul><li>每个明文分组都与一个经过加密的计数器相异或。对每个后续分组计数器递增</li><li>并行加密效率高</li></ul></li></ul></li><li><strong>分组密码典型攻击方法</strong><ul><li>依据攻击者所掌握的信息：唯密文攻击、已知明文攻击、选择明文攻击</li><li>根据采用的技术方法<ul><li>强力攻击（适用于任何分组密码算法）：穷尽密钥搜索、字典、查表、时间-存储权衡</li><li>差分密码分析</li><li>线性密码分析</li><li>差分-线性密码分析</li></ul></li><li>攻击复杂度：数据复杂度（实施攻击所需输入的数据量）和处理复杂度（处理数据所需的计算量）。</li></ul></li><li><strong>对称密钥编码问题</strong>：通信密钥太多，管理与分发困难</li></ol><h3 id="四、-公钥加密"><a href="#四、-公钥加密" class="headerlink" title="四、    公钥加密"></a>四、    公钥加密</h3><ol><li><strong>RSA原理</strong><ul><li><img src="4.png" alt=""></li></ul></li><li><strong>计算</strong>：(a x b) mod n = [(a mod n) x (b mod n)] mod n.</li><li><strong>RSA实现上的问题</strong><br>在构造n时应选择p和q的长度相差不大</li><li><strong>RSA适合低频少量数据交换，如密钥分发；不适合数据量大，实时性强的场合（因为运算量大，慢）</strong></li></ol><h3 id="五、-消息鉴别"><a href="#五、-消息鉴别" class="headerlink" title="五、    消息鉴别"></a>五、    消息鉴别</h3><ol><li><strong>概念</strong>：消息接收者对消息进行验证（真实性：确认并非假冒）（完整性：内容未被篡改）。</li><li><strong>网络通信安全威胁</strong>：泄露、伪造、篡改、行为抵赖</li><li><strong>鉴别与保密</strong>：鉴别不能自动提供保密性，保密性不能自动提供鉴别功能。</li><li><strong>报文鉴别系统功能</strong>：鉴别算法（鉴别函数f产生鉴别码），鉴别协议，鉴别函数f是决定鉴别系统特性的主要因素。</li><li><strong>鉴别函数分类</strong>：<ul><li>以整个报文的密文作为鉴别符；<ul><li>对称密钥加密：加密的同时提供保密和鉴别（强制明文具有某种结构）</li><li>附加报文鉴别结构：发送端：校验码C = f（M），密文X = Ek[M || C]; 接收端：Y = Dk(X) = [M’ || C’], 若f(M’) = C’,则报文可信。</li><li>公钥加密：提供报文鉴别和签名，不提供加密功能。</li></ul></li><li>报文鉴别码(MAC)：核心是一个类似于加密的算法Ck()（k为密钥）, Ck(M)输出一个较短的定长数据分组也即MAC。发送[MAC || M]。接收端同样计算MAC，比较两个MAC是否相同。<br>PS：MAC与加密函数比较：MAC可以是单向的，而加密函数必须可逆；MAC算法不能提供保密性。</li><li>散列函数方式（采用一个公共散列函数，将任意长度的报文映射为一个定长的散列值，并以散列值作为鉴别符）。（常用SHA-3，MD5）<br>散列函数特性：<ul><li>输入任意大小数据块，输出定长</li><li>容易计算</li><li>单向性：对任意散列值h要找到一个M使得H(M) = h不可行。</li><li>弱抗冲突性：对任意给定M，要找到M’ != M,使得H(M)=H(M’)计算上不可行。该性质可防止伪造。</li><li>强抗冲突性：要找到两报文M和N使他们散列值相同不可行。该性质指出散列函数对“生日攻击”的抵抗能力。</li></ul></li></ul></li><li><strong>生日悖论攻击</strong>：伪造消息报文使hash值不变</li><li><strong>中间符合攻击概念</strong></li></ol><h3 id="六、-密钥建立和管理"><a href="#六、-密钥建立和管理" class="headerlink" title="六、    密钥建立和管理"></a>六、    密钥建立和管理</h3><ol><li><strong>密钥建立的模式</strong>：点到点（通信双方直接通信，分布式）；密钥分配中心KDC（用户与KDC有共享主密钥，KDC生成并分配会话密钥，集中式）；密钥转换中心KTC（只负责转发，集中式）</li><li><strong>Diff-Hellman密钥交换</strong><ul><li><img src="5.png" alt=""></li><li><img src="6.png" alt=""></li><li>如图，双方都计算出密钥为2</li></ul></li><li><strong>公钥加密体制的密钥分配</strong>：公钥的分配；使用公钥体制来分配对称密钥密码体制的密钥。</li><li><strong>伪随机数生成器</strong>:线性同余算法；基于密码算法的随机数生成器（循环加密方式，DES的OFB模式）；BBS生成器；</li><li><strong>密钥控制技术</strong>：密钥标签（DES的64位密钥中的8个校验位作为控制使用这一密钥的标签）；控制矢量</li></ol><h3 id="七、-用户认证"><a href="#七、-用户认证" class="headerlink" title="七、    用户认证"></a>七、    用户认证</h3><ol><li><strong>身份认证</strong>：密码，令牌（磁条卡，存储卡，智能卡），生物识别（虹膜，视网膜，指纹，签名，声音，脸）</li><li><strong>口令破解</strong>：字典攻击，密码猜测，彩虹表攻击（可见密码不能明文存储，要求哈希后加salt，盐：随机字符）</li><li><strong>口令的脆弱性</strong>：离线字典攻击；特定账户攻击；流行密码的攻击；单个用户的密码猜测；工作站劫持；电子监控；利用用户失误</li><li><strong>Bad Passwords</strong>:过短的密码；易猜测的密码</li><li><strong>Countermeasures</strong>：阻止未经授权访问密码文件；入侵检测措施；帐户锁定机制；自动工作站注销；加密的网络链接</li></ol><h3 id="八、-身份认证协议"><a href="#八、-身份认证协议" class="headerlink" title="八、    身份认证协议"></a>八、    身份认证协议</h3><ol><li><strong>Kerberos身份认证协议</strong>：集中式的认证服务器结构，认证服务器的功能是实现用户与其访问的服务器间的相互鉴别；采用对称加密技术</li><li><strong>数字签名</strong>：直接数字签名仅涉及通信双方<ul><li>使用公钥算法进行数字签名</li><li>假定接收方知道发送方的公钥</li><li>发送方用私钥加密整个消息或者消息的散列码</li><li>接收方用公钥解密即可确认发送方的身份</li></ul></li><li><strong>公钥基础设施(PKI)</strong><ul><li>提供三种安全服务：<ul><li>认证：身份认证，采用数字签名实现</li><li>完整性：数据完整性，采用数字签名或消息认证码</li><li>机密性：采用对称加密</li></ul></li><li>包括：认证机构CA，证书库，证书撤销，密钥备份和恢复，自动密钥更新，密钥历史档案，交叉认证，时间戳…</li></ul></li><li><strong>X.509认证服务</strong>：<ul><li>X.509协议实现基于公钥加密算法和数字签名技术</li><li>证书由CA创建，CA用其私钥对证书签名，用户可用CA的公钥验证证书有效性并提取被认证的用户的公钥</li></ul></li></ol><h3 id="九、-互联网安全协议和标准"><a href="#九、-互联网安全协议和标准" class="headerlink" title="九、    互联网安全协议和标准"></a>九、    互联网安全协议和标准</h3><ol><li><strong>IPSec</strong>:提供认证、保密性、密钥管理。优点：在传输层下，因而对应用程序、用户透明；抵抗旁路攻击；保护路由架构…</li><li><strong>IPSec架构</strong>：<ul><li><img src="7.png" alt=""></li><li>IPv6强制，IPv4可选</li></ul></li><li><strong>安全关联SA</strong>：<ul><li>发送方和接收方之间的单向的关系，为数据流提供安全保障</li><li>由三个参数定义：Security Parameters Index (SPI)；IP Destination Address；Security Protocol Identifier</li><li>有一个安全关联数据库（）</li></ul></li><li><strong>SA管理</strong>：<ul><li>创建：先协商SA参数，再更新SAD；可人工创建，也可动态创建</li><li>删除：有效期过期；密钥遭破坏；另一端要求删除该SA</li></ul></li><li><strong>认证头(AH)</strong>：<ul><li>提供数据整合和IP包认证</li><li>有限地抗重播攻击</li><li>基于消息认证码（MAC）</li></ul></li><li><strong>重放攻击</strong>：攻击者发送一个目的主机已接收过的包，来达到欺骗系统的目的，主要用于身份认证过程，破坏认证的正确性。</li><li><strong>抗重播服务</strong>：<ul><li>序列号字段：创建一个新的SA时，发送者会将序列号计数器初始化为0； 每当在这一SA上发送一个数据包，序列号计数器的值就加1并将序列号字段设置成计数器的值； 当达到其最大值2³²-1时，就应建立一个新的SA。</li><li>一种滑动窗口机制：IP是无连接的、不可靠的 ，需设立窗口；窗口的最左端对应于窗口起始位置的数据包序列号N，则最右端对应于可以接收的合法分组的最高序号N+WindowSize-1</li></ul></li><li><strong>ESP</strong>:提供保密性和抗重播服务</li><li><strong>密钥管理</strong>:密钥生成和分发；AH和ESP各一对密钥；</li><li><strong>安全套接层SSL</strong>：<ul><li><img src="8.png" alt=""></li><li><img src="9.png" alt=""></li></ul></li><li><strong>SSL的两个重要概念</strong>：<ul><li>SSL连接：<ul><li>一个连接是一个提供一种合适类型服务的传输</li><li>SSL连接是端对端的</li><li>连接是暂时的</li></ul></li><li>SSL会话：<ul><li>一个SSL会话是在客户端和服务器之间的一个关联</li><li>会话由Handshake Protocal创建。会话定义了一组可供多个连接共享的加密安全参数</li><li>会话用以：避免为每一个连接提供新的安全参数所需的昂贵的谈判代价</li></ul></li></ul></li></ol><h3 id="十、-Hacking"><a href="#十、-Hacking" class="headerlink" title="十、    Hacking"></a>十、    Hacking</h3><ol><li><strong>攻击思路</strong>：信息收集，获取权限，安装后门（木马），扩大影响（攻击该网络其他主机），清除痕迹</li><li><strong>安全评估</strong></li><li><strong>TCSEC，CC</strong></li></ol><h3 id="十一、-信息收集（选择题）"><a href="#十一、-信息收集（选择题）" class="headerlink" title="十一、    信息收集（选择题）"></a>十一、    信息收集（选择题）</h3><ol><li><strong>Web与搜索引擎服务</strong></li><li><strong>目标</strong>：获取目标网络或公司的URL，获取目标网络的拓扑结构</li><li><strong>扫描目的</strong>：查看目标网络中哪些主机是存活的，查看存活的主机运行了哪些服务，查看主机提供的服务有无漏洞<ul><li>IP扫描：判断目标网络有多少台主机存活（ping）（ping使用ICMP协议）</li><li>端口扫描：判断目标主机有哪些端口是打开的(TCP端口和UDP端口)（端口是入侵的通道）<ul><li>TCP扫描：TCP Connect，SYN，FIN</li><li>UDP扫描</li></ul></li><li>漏洞扫描</li></ul></li><li><strong>操作系统类型探测</strong></li></ol><h3 id="十二、-缓冲区溢出"><a href="#十二、-缓冲区溢出" class="headerlink" title="十二、    缓冲区溢出"></a>十二、    缓冲区溢出</h3><ol><li><strong>缓冲区</strong>：应用程序保存用户输入数据，程序临时数据的内存空间。缓冲区本质：数组。位置：堆、栈、数据段</li><li><strong>溢出</strong>：用户输入数据长度超出了程序为其分配的内存空间，这些数据会覆盖其他程序数据的内存空间。</li><li><strong>危害</strong>：程序异常，系统崩溃，程序跳到恶意代码，控制权被窃</li><li><strong>溢出种类</strong>：堆溢出、栈溢出、整型溢出、格式化字符串溢出、其他溢出</li><li><strong>溢出的共性</strong>：大对象向小对象复制数据，容纳不下造成溢出</li><li><strong>避免缓冲区溢出漏洞</strong>：<ul><li>人编写正确的代码</li><li>编译器进行数组边界检查</li><li>使用类型安全语言</li><li>RunTime保护</li><li>操作系统</li><li>硬件</li></ul></li></ol><h3 id="十三、-Web脚本攻击"><a href="#十三、-Web脚本攻击" class="headerlink" title="十三、    Web脚本攻击"></a>十三、    Web脚本攻击</h3><ol><li><strong>SQL注入攻击</strong> ：把SQL命令插入到Web表单提交或输入域名或页面请求的查询字符串中，最终达到欺骗服务器执行恶意的SQL命令。<br>步骤<ul><li>绕过认证：conditions：账号密码的查询是同一条查询语句；密码没有加密保护</li><li>判断能否进行SQL注入</li><li>判断数据库类型及注入方法</li><li>猜测表名和字段名</li><li>猜测用户名和密码</li></ul></li><li><strong>预防</strong><ul><li>过滤关键字</li><li>限制输入长度</li><li>秘密字段使用散列函数保护</li></ul></li><li><strong>XSS跨站脚本攻击</strong>：通过在链接中插入恶意代码就能盗取用户信息。</li><li><strong>预防</strong><ul><li>对动态生成页面的字符进行编码</li><li>对输入进行过滤限制</li><li>对动态内容使用HTML和URL编码</li><li>设置浏览器不执行任何脚本下载</li></ul></li></ol><h3 id="十四、-DOS攻击"><a href="#十四、-DOS攻击" class="headerlink" title="十四、    DOS攻击"></a>十四、    DOS攻击</h3><ol><li><strong>概念</strong>：利用网络协议漏洞或其他系统以及应用软件的漏洞耗尽被攻击目标资源，使得被攻击目标无法正常提供服务，直至系统停止响应甚至崩溃的攻击方式。</li><li><strong>原理</strong>：攻击者向服务器发送众多的带有虚假地址的请求，服务器发送回复信息后无限等待进而无法释放资源，连接超时后攻击者再度发送虚假请求。</li><li><strong>DOS分类</strong>：SYN Flood（请求方不发送ACK），ping of death（ping请求数据包声称超过64K，接收方TCP/IP堆栈崩溃），teardrop…</li><li><strong>发现僵尸网络</strong>：IDS（提取僵尸程序指纹信息），行为监测（僵尸程序行为模式），蜜獾捕获（捕获僵尸程序样本）</li></ol><h3 id="十五、-恶意代码、病毒、蠕虫"><a href="#十五、-恶意代码、病毒、蠕虫" class="headerlink" title="十五、    恶意代码、病毒、蠕虫"></a>十五、    恶意代码、病毒、蠕虫</h3><ol><li><strong>计算机病毒</strong>：是一个指令序列，能够把自身拷贝插入到其他主程序中</li><li><strong>病毒模块</strong>：引导、传染、表现</li><li><strong>病毒按链接方式分类</strong>：<ul><li>操作系统病毒：用自己的运行逻辑取代系统的正常逻辑模块</li><li>外壳型：将病毒本身包围在宿主程序周围，对原来程序不作修改</li><li>入侵型：将病毒插入攻击目标之中，一旦感染难以发现清除</li><li>源码病毒：利用java, VBS等网络语言编写放在e-mail附件或HTML主页中。</li></ul></li><li><strong>按传染对象分类</strong>：磁盘引导型（磁盘引导区），文件型（可执行文件），宏病毒（office系列）</li><li><strong>检测病毒方法</strong>：<ul><li>特征代码法：采样，提取特征代码，特征代码纳入病毒特征数据库，打开被检测文件检索，若出现新病毒重复1-3步</li><li>校验和法：在文件被感染前根据文件内容计算校验和保存在其他文件中。优点：既可发现已知病毒又可发现未知病毒；缺点：只能判断文件是否被修改，而不能识别病毒种类和名称，且对隐蔽性病毒无效。</li><li>行为监测法：利用病毒的特有行为来监测病毒的方法。</li></ul></li><li><strong>蠕虫</strong>：一种可以通过网络连接进行自身复制的程序，与以往病毒方式不同，文件型病毒、宏病毒需要在计算机的硬盘、软盘或文件系统中繁殖，而典型的蠕虫只会在内存中维持一个活动副本，甚至根本不向硬盘写入任何信息。</li></ol><h3 id="十六、-防火墙"><a href="#十六、-防火墙" class="headerlink" title="十六、    防火墙"></a>十六、    防火墙</h3><ol><li><strong>概念</strong>：防火墙指应用于内部网络和外部网络之间的，用来保护内部网络免受非法访问和破坏的网络安全系统。</li><li><strong>主要功能</strong>：<ul><li>过滤进出网络的数据</li><li>防止不安全的协议和服务</li><li>管理进出网络的访问行为</li><li>记录通过防火墙的信息内容与活动</li><li>对网络攻击进行检测与告警</li><li>防止外部对内部网络信息的获取</li><li>提供与外部连接的集中管理</li></ul></li><li><strong>不能防范的攻击</strong>：内部威胁、病毒、应用程序漏洞、木马、社会工程、不当配置</li><li><strong>防火墙分类</strong>：按实现技术（包过滤型（静态，动态），代理型（应用代理，电路代理，NAT））；按体系结构（双宿/多宿主机，屏蔽主机（双重保护安全性更高），屏蔽子网，混合结构）。</li><li><strong>静态包过滤（传输层和网络层）</strong>：对包头内容进行简单过滤（源和目的IP，IP选项，IP上层协议，TCP和UDP源及目的端口，ICMP报文类型和代码）。</li><li><strong>防火墙规则制定策略</strong>：a.拒绝任何访问，除非被规则特别允许。b.允许任何访问，除非规则特别禁止</li><li><strong>过滤的两种基本方式</strong>：按服务过滤（如Telnet，SMTP，FTP等等）；按规则过滤。</li><li><strong>静态包过滤的优缺点</strong>：速度快，价格低，对用户透明；配置难把握，防范能力低，没有用户身份验证机制。</li><li><strong>动态包过滤（网络层）（状态检测防火墙）</strong>：不仅以一个数据包的内容作为过滤依据，还根据这个数据包在信息流位置加以判断</li><li><strong>动态包过滤优缺点</strong>：基于应用程序信息验证一个包状态的能力，记录通过的每个包的详细信息；造成网络连接的迟滞，系统资源要求较高。</li><li><strong>应用代理防火墙（应用层）</strong>：对所有规则内允许的应用程序作中转转发；牺牲了对应用程序的透明性。</li><li><strong>应用代理优缺点</strong>：可以隐藏内部网络信息，具有强大的日志审核，实现内容过滤；价格高，速度慢，失效时造成网络瘫痪。</li><li><strong>电路级代理（传输层）优缺点</strong>：隐藏内部网络信息，配置简单（无需为每个应用程序配置一个代理）；多数电路级网关都是基于TCP端口配置，不对数据包检测可能会有漏洞。</li><li><strong>NAT优缺点</strong>：管理方便并且节约IP地址资源，隐藏内部IP地址信息；外部应用程序不能方便地与NAT网关后的应用程序联系。-</li><li><strong>理解防火墙的四种体系结构</strong></li></ol><h3 id="十七、-入侵检测IDS"><a href="#十七、-入侵检测IDS" class="headerlink" title="十七、    入侵检测IDS"></a>十七、    入侵检测IDS</h3><ol><li><strong>由于防火墙无法发现和阻止</strong>:a.对合法服务的攻击。b.源自其他入口的攻击。c.来自内部网络的攻击。d.来自木马的威胁。入侵检测技术通过对计算机网络或计算机系统中若干关键点信息的收集和分析，从中发现网络或系统中是否有违反安全策略行为和被攻击迹象的一种安全技术。</li><li><img src="10.png" alt=""></li><li><strong>IDS任务</strong>：从系统正常运行产生的和攻击者进行攻击时产生的混合数据中找出入侵痕迹。</li><li><strong>通用入侵检测框架CIDF</strong>：体系结构；组件通信（事件产生器（数据获取）；事件分析器（数据分析）；事件数据库（数据管理）；响应单元（行为响应））；语言规范；编程接口。</li><li><strong>小结</strong>：入侵检测技术收集主机日志及网络流量等信息，通过模式匹配、统计分析或完整性分析，能够有效发现入侵行为。入侵检测形成了网络的纵深防御，成为防火墙技术的有益补充。网络技术的发展给入侵检测带来各种新的困难，同时也带来机遇。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Security&quot;&gt;&lt;a href=&quot;#Security&quot; class=&quot;headerlink&quot; title=&quot;Security&quot;&gt;&lt;/a&gt;Security&lt;/h2&gt;&lt;h3 id=&quot;一、-介绍&quot;&gt;&lt;a href=&quot;#一、-介绍&quot; class=&quot;headerlink
      
    
    </summary>
    
    
      <category term="安全" scheme="http://thmasterplan.cn/categories/%E5%AE%89%E5%85%A8/"/>
    
    
      <category term="安全" scheme="http://thmasterplan.cn/tags/%E5%AE%89%E5%85%A8/"/>
    
  </entry>
  
  <entry>
    <title>Git笔记</title>
    <link href="http://thmasterplan.cn/2019/11/19/Git%E7%AC%94%E8%AE%B0/"/>
    <id>http://thmasterplan.cn/2019/11/19/Git%E7%AC%94%E8%AE%B0/</id>
    <published>2019-11-19T10:18:31.000Z</published>
    <updated>2019-11-19T10:43:31.442Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一-设置"><a href="#一-设置" class="headerlink" title="一.设置"></a>一.设置</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name &quot;Your Name&quot;</span><br><span class="line">git config --global user.email &quot;email@example.com&quot;</span><br></pre></td></tr></table></figure><h3 id="二-创建版本库"><a href="#二-创建版本库" class="headerlink" title="二.创建版本库"></a>二.创建版本库</h3><ol><li>创建空目录</li><li>隐藏目录.git为版本库<br><code>git init</code></li><li>添加</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git add xxx.txt</span><br><span class="line">git add xxxx.txt</span><br><span class="line">git add xxxxx.txt</span><br></pre></td></tr></table></figure><ol start="4"><li>提交<br><code>git commit -m &quot;说明文字&quot;</code></li></ol><h3 id="三-版本回退"><a href="#三-版本回退" class="headerlink" title="三.版本回退"></a>三.版本回退</h3><ol><li>查看版本日志<br><code>git log</code></li><li>回退</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git reset --hard [HEAD^,HEAD^^，HEAD~100]回退到以前某个版本</span><br><span class="line">git reset --hard [回退之前的版本号] 撤销回退</span><br></pre></td></tr></table></figure><ol start="3"><li>查看命令历史，以便确定回到未来哪个版本<br><code>git reflog</code></li></ol><h3 id="四-版本库的工作区与暂存区、分支"><a href="#四-版本库的工作区与暂存区、分支" class="headerlink" title="四.版本库的工作区与暂存区、分支"></a>四.版本库的工作区与暂存区、分支</h3><p><code>git add</code>命令实际上就是把要提交的所有修改放到暂存区（Stage），然后，执行<code>git commit</code>就可以一次性把暂存区的所有修改提交到分支。</p><h3 id="五-每次修改，如果不用git-add到暂存区，那就不会commit。"><a href="#五-每次修改，如果不用git-add到暂存区，那就不会commit。" class="headerlink" title="五.每次修改，如果不用git add到暂存区，那就不会commit。"></a>五.每次修改，如果不用git add到暂存区，那就不会commit。</h3><h3 id="六-撤销修改"><a href="#六-撤销修改" class="headerlink" title="六.撤销修改"></a>六.撤销修改</h3><ol><li>直接丢弃工作区的修改，用命令<code>git checkout -- file</code>。[误删也是一种修改]</li><li>当你不但改乱了工作区某个文件的内容，还添加到了暂存区时，想丢弃修改，分两步，第一步用命令<code>git reset HEAD &lt;file&gt;</code>，就回到了场景1，第二步按场景1操作。</li><li>已经提交了不合适的修改到版本库时，想要撤销本次提交，参考版本回退一节，不过前提是没有推送到远程库。</li></ol><h3 id="七-删除文件"><a href="#七-删除文件" class="headerlink" title="七.删除文件"></a>七.删除文件</h3> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git rm file</span><br><span class="line">git commit</span><br></pre></td></tr></table></figure><h3 id="八-推送到github"><a href="#八-推送到github" class="headerlink" title="八.推送到github"></a>八.推送到github</h3><p>   <code>git push origin master</code></p><h3 id="九-克隆远程库到本地"><a href="#九-克隆远程库到本地" class="headerlink" title="九.克隆远程库到本地"></a>九.克隆远程库到本地</h3><p><code>git clone git@github.com:Laishiji/directoryName.git</code></p><h3 id="十-分支"><a href="#十-分支" class="headerlink" title="十.分支"></a>十.分支</h3><ol><li>查看分支：<code>git branch</code></li><li>创建分支：<code>git branch name</code></li><li>切换分支：<code>git checkout name</code></li><li>创建+切换分支：<code>git checkout -b name</code></li><li>合并某分支到当前分支：<code>git merge name</code></li><li>删除分支：<code>git branch -d name</code></li></ol><h3 id="十一-分支合并失败"><a href="#十一-分支合并失败" class="headerlink" title="十一.分支合并失败"></a>十一.分支合并失败</h3><p>当Git无法自动合并分支时，就必须首先解决冲突。解决冲突后，再提交，合并完成。<br>解决冲突就是把Git合并失败的文件手动编辑为我们希望的内容，再提交。<br>用<code>git log --graph</code>命令可以看到分支合并图。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一-设置&quot;&gt;&lt;a href=&quot;#一-设置&quot; class=&quot;headerlink&quot; title=&quot;一.设置&quot;&gt;&lt;/a&gt;一.设置&lt;/h3&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pr
      
    
    </summary>
    
    
      <category term="git" scheme="http://thmasterplan.cn/categories/git/"/>
    
    
      <category term="git" scheme="http://thmasterplan.cn/tags/git/"/>
    
  </entry>
  
  <entry>
    <title>Java高级</title>
    <link href="http://thmasterplan.cn/2019/11/19/Java%E9%AB%98%E7%BA%A7/"/>
    <id>http://thmasterplan.cn/2019/11/19/Java%E9%AB%98%E7%BA%A7/</id>
    <published>2019-11-19T09:33:47.000Z</published>
    <updated>2019-11-19T10:43:54.208Z</updated>
    
    <content type="html"><![CDATA[<p><strong>JAVA复习笔记</strong></p><h1 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h1><p><img src="clip_image001.png" alt="img"></p><p><img src="clip_image002.png" alt="img"></p><p><img src="clip_image004.jpg" alt="img"></p><p><strong>String常用方法：</strong></p><p>1)   比较</p><p><img src="clip_image005.png" alt="img"></p><p>2)   获取</p><p><img src="clip_image007.jpg" alt="img"></p><p>3)   截取子串</p><p><img src="clip_image009.jpg" alt="img"></p><p>4)   转换</p><p><img src="clip_image011.jpg" alt="img"></p><p>5)   分割</p><p><img src="clip_image012.png" alt="img"></p><p>补充：boolean <a href="http://tool.oschina.net/uploads/apidocs/jdk_7u4/java/lang/String.html#endsWith(java.lang.String)" target="_blank" rel="noopener">endsWith</a>(<a href="http://tool.oschina.net/uploads/apidocs/jdk_7u4/java/lang/String.html" target="_blank" rel="noopener">String</a> suffix);判断字符串是否是以suffix为后缀。</p><h1 id="Static关键字"><a href="#Static关键字" class="headerlink" title="Static关键字"></a>Static关键字</h1><p><img src="clip_image013.png" alt="img"></p><p><img src="clip_image014.png" alt="img"></p><p>1)   内存图：</p><p><img src="clip_image015.png" alt="img"></p><p><img src="clip_image016.png" alt="img"></p><p>2)   静态代码块：</p><p><img src="clip_image017.png" alt="img"></p><h1 id="Arrays常用方法"><a href="#Arrays常用方法" class="headerlink" title="Arrays常用方法"></a>Arrays常用方法</h1><p><img src="clip_image018.png" alt="img"></p><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p><img src="clip_image019.png" alt="img"></p><p><img src="clip_image021.jpg" alt="img"></p><p><img src="clip_image022.png" alt="img"></p><h1 id="抽象类与接口"><a href="#抽象类与接口" class="headerlink" title="抽象类与接口"></a>抽象类与接口</h1><p><img src="clip_image023.png" alt="img"></p><p><img src="clip_image024.png" alt="img"></p><h1 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h1><p><img src="clip_image025.png" alt="img"></p><p>向上转型，即父类引用指向子类对象，则引用无法调用原本<strong>子类特有的方法</strong>，例如Animal a = new Cat();</p><p>向下转型，也即<strong>还原</strong>a的类型为cat，使其可以访问cat特有的方法，例如Cat cat = (Cat) a;[类似于强制类型转换]。</p><h1 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h1><p>1)   修饰类：当前类不能有任何子类。</p><p>2)   修饰方法：该方法不能被子类覆盖重写。（显然对于类、方法来说，abstract和final无法同时使用）</p><p>3)   修饰局部变量：该变量（引用类型不能再指向其他变量）不能再改变。</p><p>4)   修饰成员变量：该变量必须直接赋值或者在构造方法中赋值。</p><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><p>1)   成员内部类</p><p><img src="clip_image026.png" alt="img"></p><p>在内部类中访问重名的外部类成员变量：</p><p><img src="clip_image027.png" alt="img"></p><p>2)   局部内部类</p><p><img src="clip_image028.png" alt="img"></p><p><img src="clip_image029.png" alt="img"></p><p><img src="clip_image030.png" alt="img"></p><p>3)   局部内部类中的匿名内部类：</p><p><img src="clip_image031.png" alt="img"></p><p><img src="clip_image032.png" alt="img"></p><h1 id="包装类"><a href="#包装类" class="headerlink" title="包装类"></a>包装类</h1><p><img src="clip_image033.png" alt="img"></p><p>自动装箱与自动拆箱。</p><p>基本类型与字符串的转换：</p><p><img src="clip_image034.png" alt="img"></p><h1 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h1><p>+<img src="clip_image036.jpg" alt="img"></p><p><strong>1)</strong>   <strong>Collection</strong></p><p><img src="clip_image037.png" alt="img"></p><p><strong>2)</strong>   <strong>Iterator接口</strong></p><p><img src="clip_image038.png" alt="img"></p><p><img src="clip_image039.png" alt="img"></p><p><strong>3)</strong>   <strong>泛型</strong></p><p><img src="clip_image040.png" alt="img"></p><p><img src="clip_image041.png" alt="img"></p><p><img src="clip_image042.png" alt="img"></p><p><strong>4)</strong>   <strong>List</strong></p><p><img src="clip_image043.png" alt="img"></p><p><strong>List的子类：</strong></p><p><strong>A.</strong>   <strong>ArrayList:此实现不是同步的，底层是一个数组，增删慢，查询快。</strong></p><p><strong>B.</strong>   <strong>LinkedList:此实现不是同步的，底层是双向链表，增删快，查询慢。</strong></p><p><img src="clip_image044.png" alt="img"></p><p><strong>C.</strong>   <strong>Vector:底层是数组，同步，了解即可</strong></p><p><strong>5)</strong>   <strong>Set:set在调用add方法时，会调用元素的hashCode方法和equals方法判断元素是否重复，在存储自定义类型元素时，前提是需要重写对象中的hashCode和equals方法。</strong></p><p><img src="clip_image045.png" alt="img"></p><p><strong>A.</strong>   <strong>HashSet:不同步，底层是哈希表（查询速度快），无序。</strong></p><p><strong>哈希值：十进制整数，逻辑地址值，由哈希函数计算而得。</strong></p><p><strong>哈希表：jdk1.8之后，哈希表由数组+链表/红黑树构成。</strong></p><p><img src="clip_image046.png" alt="img"></p><p><strong>B.</strong>   <strong>LinkedHashSet:相较于HashSet多了一条链表记录元素的存储顺序，保证元素有序。</strong></p><p><strong>6)</strong>   <strong>可变参数：</strong></p><p><img src="clip_image047.png" alt="img"></p><p><img src="clip_image048.png" alt="img"></p><p><strong>7)</strong>   <strong>Collections集合工具类：</strong></p><p><img src="clip_image049.png" alt="img"></p><p><img src="clip_image050.png" alt="img"></p><p><strong>Comparator:</strong></p><p><img src="clip_image051.png" alt="img"></p><p><strong>Comparable:</strong></p><p><strong>要比较的类需要实现Comparable接口，同时覆盖compareTo方法：</strong></p><p><img src="clip_image052.png" alt="img"></p><p><strong>8)</strong>   <strong>Map</strong></p><p><strong>A.</strong>   <strong>概述</strong></p><p><img src="clip_image053.png" alt="img"></p><p><strong>B.</strong>   <strong>Map接口常用方法：</strong></p><p><img src="clip_image054.png" alt="img"></p><p><img src="clip_image055.png" alt="img"></p><p><img src="clip_image056.png" alt="img"></p><p><img src="clip_image057.png" alt="img"></p><p><strong>C.</strong>   <strong>Map遍历方法：</strong></p><p><strong>a)</strong>   <strong>键找值：</strong></p><p><img src="clip_image058.png" alt="img"></p><p><strong>b)</strong>   <strong>Entry键值对对象：Map.Entry，在Map接口中有一个内部接口Entry,Map集合一创建就会创建一个Entry对象，记录键值对对象。</strong></p><p><img src="clip_image059.png" alt="img"></p><p><strong>D.</strong>   <strong>HashMap存储自定义类型键值为防止键重复，必须重写自定义类型的hashCode和equals方法。</strong></p><p><strong>9)</strong>   <strong>HashTable:</strong></p><p><img src="clip_image060.png" alt="img"></p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="clip_image061.png" alt="img"></p><p><img src="clip_image062.png" alt="img"></p><p><img src="clip_image063.png" alt="img"></p><p>自定义异常：</p><p><img src="clip_image065.jpg" alt="img"></p><p><img src="clip_image067.jpg" alt="img"></p><h1 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h1><p><strong>1.</strong>   <strong>线程状态图：</strong></p><p>​                         </p><p>​                                <img src="clip_image068.jpg" alt="img"></p><p>等待-唤醒案例：</p><p><img src="clip_image069.png" alt="img"></p><p>notifyAll唤醒所有waiting状态的线程，唤醒之后的线程要与其他线程竞争锁，获取锁之后才能继续执行wait()方法之后的代码。</p><p><strong>2.</strong>   <strong>创建线程第一种方法：</strong></p><p><img src="clip_image070.png" alt="img"></p><p>每个线程都有自己的栈空间。</p><p><strong>3.</strong>   <strong>Thread**</strong>类构造方法和常用方法：**</p><p><img src="clip_image071.png" alt="img"></p><p><strong>4.</strong>   <strong>创建线程第二种方法：实现Runnable接口</strong></p><p><img src="clip_image072.png" alt="img"></p><p><strong>5.</strong>   <strong>两种创建方式的区别</strong></p><p><img src="clip_image073.png" alt="img"></p><p><img src="clip_image074.png" alt="img"></p><p><strong>6.</strong>   <strong>匿名内部类两种方式创建线程：</strong></p><p><img src="clip_image075.png" alt="img"></p><p><img src="clip_image076.png" alt="img"></p><p><strong>7.</strong>   <strong>线程安全与线程同步：</strong></p><p><strong>1)</strong>   <strong>同步代码块</strong></p><p><img src="clip_image077.png" alt="img"></p><p><strong>（可以直接用synchronized(this){</strong></p><p>​      <strong>///////////**</strong>代码块**</p><p><strong>}**</strong>）this代表Runnable的实现类对象，唯一。**</p><p>同步中的线程，没有执行完代码块中的内容不会释放锁，其余线程没有锁就算获取cpu执行权也会阻塞；同步保证了只能有一个线程在同步中执行共享数据，保证了安全；但是程序频繁地判断锁，获取锁，释放锁，程序效率会降低。</p><p><strong>2)</strong>   <strong>同步方法</strong></p><p><img src="clip_image078.png" alt="img"></p><p><img src="clip_image079.png" alt="img"></p><p><strong>静态同步方法：</strong></p><p><img src="clip_image080.png" alt="img"></p><p><strong>3)</strong>   <strong>加lock锁</strong></p><p><img src="clip_image081.png" alt="img"></p><p><strong>8.</strong>   <strong>线程池：一个容纳多个线程的容器（例如LinkedList），其中的线程可以反复使用，无需反复创建线程而消耗过多资源。</strong></p><p><img src="clip_image082.png" alt="img"></p><p><img src="clip_image083.png" alt="img"></p><p><strong>9.</strong>   <strong>Lambda**</strong>表达式：省略了实现接口，重写方法等。**</p><p><strong>例：</strong><img src="clip_image084.png" alt="img"></p><p><img src="clip_image085.png" alt="img"></p><h1 id="File"><a href="#File" class="headerlink" title="File"></a>File</h1><p><strong>1.</strong>   <strong>File类的静态成员变量：</strong></p><p><img src="clip_image086.png" alt="img"></p><p><strong>2.</strong>   <strong>File类构造方法</strong></p><p>1)   File（String pathname){}；</p><p>2)   File(String Parent, String child){}：这个构造意思是根据一个目录和子目录得到File对象。如果我们想对某一个文件路径下的多个文件进行操作，这个时候采用这个构造函数就显示优势。</p><p>3)   File(File parent, String child){}：这个函数的好处就是可以对parent进行File相关的操作，例如打印父路径下有多少个文件等。</p><p><strong>3.</strong>   <strong>获取类方法：</strong></p><p><img src="clip_image087.png" alt="img"></p><p><strong>4.</strong>   <strong>判断类方法：</strong></p><p><img src="clip_image088.png" alt="img"></p><p><strong>5.</strong>   <strong>创建删除类方法：</strong></p><p><img src="clip_image089.png" alt="img"></p><p><strong>6.</strong>   <strong>目录遍历</strong></p><p><img src="clip_image090.png" alt="img"></p><p><img src="clip_image091.png" alt="img"></p><p><strong>7.</strong>   <strong>文件过滤器：FileFilter接口</strong></p><p><strong>listFiles(传递过滤器实现类对象，可直接用lambda表达式简化)。例如：</strong></p><p><img src="clip_image092.png" alt="img"></p><p><img src="clip_image094.jpg" alt="img"></p><h1 id="IO"><a href="#IO" class="headerlink" title="IO"></a>IO</h1><p><img src="clip_image096.png" alt="img"></p><p><img src="clip_image097.png" alt="img"></p><p><strong>1.</strong>   <strong>OutputStream:</strong></p><p><strong>1)</strong>   <strong>FileOutputStream</strong></p><p><img src="clip_image098.png" alt="img"></p><p><strong>2)</strong>   <strong>一次写一个字节</strong></p><p><img src="clip_image099.png" alt="img"></p><p><img src="clip_image100.png" alt="img"></p><p><strong>3)</strong>   <strong>一次写多个字节</strong></p><p><img src="clip_image101.png" alt="img"></p><p><img src="clip_image102.png" alt="img"></p><p><strong>4)</strong>   <strong>续写与换行</strong></p><p><img src="clip_image103.png" alt="img"></p><p><strong>2.</strong>   <strong>InputStream&amp;FileInputStream</strong></p><p><img src="clip_image104.png" alt="img"></p><p><img src="clip_image105.png" alt="img"></p><p><strong>1)</strong>   <strong>一次读一个字节，read()方法返回一个ASCII码值。</strong></p><p><strong>2)</strong>   <strong>一次读多个字节：</strong></p><p><img src="clip_image107.jpg" alt="img"></p><p><strong>若未读取到字节，则同样返回-1.</strong></p><p><strong>3.</strong>   <strong>练习：文件复制操作：</strong></p><p><img src="clip_image108.png" alt="img"></p><p><img src="clip_image109.png" alt="img"></p><p><strong>4.</strong>   <strong>使用字节流读取中文时，会出现乱码的问题；一个中文字符：GBK占2个字节，UTF-8占3个字节。因此需要使用字符流。</strong></p><p><strong>5.</strong>   <strong>Reader&amp;FileReader</strong></p><p><img src="clip_image110.png" alt="img"></p><p><img src="clip_image111.png" alt="img"></p><p><strong>6.</strong>   <strong>writer&amp;FileWriter</strong></p><p><img src="clip_image112.png" alt="img"></p><p><img src="clip_image113.png" alt="img"></p><p><strong>7.</strong>   <strong>IO中的异常处理</strong></p><p><strong>1)</strong>   <strong>常规</strong></p><p><img src="clip_image115.jpg" alt="img"></p><p><strong>2)</strong>   <strong>JDK7新特性</strong></p><p><img src="clip_image116.png" alt="img"></p><p><strong>8.</strong>   <strong>属性集</strong></p><p><img src="clip_image117.png" alt="img"></p><p><strong>1)</strong>   <strong>setProperty/getProperty/stringPropertyNames</strong></p><p><img src="clip_image119.jpg" alt="img"></p><p><strong>2)</strong>   <strong>store</strong></p><p><img src="clip_image120.png" alt="img"></p><p><strong>3)</strong>   <strong>load</strong></p><p><img src="clip_image121.png" alt="img"></p><p><strong>9.</strong>   <strong>缓冲流</strong></p><p><strong>1)</strong>   <strong>BufferedOutputStream</strong></p><p><img src="clip_image122.png" alt="img"></p><p><img src="clip_image123.png" alt="img"></p><p><strong>2)</strong>   <strong>BufferedInputStream</strong></p><p><img src="clip_image124.png" alt="img"></p><p><img src="clip_image125.png" alt="img"></p><p><strong>3)</strong>   <strong>BufferedWriter</strong></p><p><img src="clip_image126.png" alt="img"></p><p><img src="clip_image127.png" alt="img"></p><p><img src="clip_image128.png" alt="img"></p><p><strong>4)</strong>   <strong>BufferedReader</strong></p><p><img src="clip_image129.png" alt="img"></p><p><img src="clip_image130.png" alt="img"></p><p><img src="clip_image131.png" alt="img"></p><p><strong>10.</strong>  <strong>转换流</strong></p><p><strong>1)</strong>   <strong>字符编码和字符集：</strong></p><p><strong>A.</strong>   <strong>字符编码：一套自然语言的字符与二进制数之间的对应规则。</strong></p><p><strong>B.</strong>   <strong>字符集：即编码表，生活中文字与二进制对应规则</strong></p><p><strong>C.</strong>   <strong>常用字符集：</strong></p><p><strong>a)</strong>   <strong>ASCII：美国</strong></p><p><strong>b)</strong>   <strong>ISO：欧洲</strong></p><p><strong>c)</strong>   <strong>GBxxx:GB2312,GBK,GB18030国标。GBK两个字节表示一个汉字。</strong></p><p><strong>d)</strong>   <strong>Unicode：万国码。UTF-8/UTF-16/UTF-32。UTF-8三个字节表示一个汉字。</strong></p><p><strong>2)</strong>   <strong>编码引出的问题：</strong></p><p><strong>FileReader可以读取IDE默认编码格式UTF-8的文件，但是读取系统默认编码为GBK时会产生乱码。</strong></p><p><strong>FileReader底层调用的是FileInputStream方法读取字节流，再通过字符集转换为字符，其父类为InputStreamReader.</strong></p><p><strong>FileWriter同理。</strong></p><p><strong>3)</strong>   <strong>OutputStreamWriter</strong></p><p><img src="clip_image132.png" alt="img"></p><p><img src="clip_image133.png" alt="img"></p><p><strong>4)</strong>   <strong>InputStreamReader</strong></p><p><img src="clip_image134.png" alt="img"></p><p><strong>11.</strong>  <strong>序列化流</strong></p><p><img src="clip_image135.png" alt="img"></p><p><strong>1)</strong>   <strong>ObjectOutputStream</strong></p><p><img src="clip_image136.png" alt="img"></p><p><strong>只需要序列化的类implements Serializable接口即可，并不需要实现任何方法。</strong></p><p><img src="clip_image137.png" alt="img"></p><p><img src="clip_image138.png" alt="img"></p><p><strong>2)</strong>   <strong>ObjectInputStream</strong></p><p><strong>与序列化相似。</strong></p><p><strong>3)</strong>   <strong>静态变量不能被序列化或反序列化。</strong></p><p><strong>4)</strong>   <strong>使用transient关键字修饰变量避免序列化。</strong></p><p><strong>A.</strong>   <strong>一旦变量被transient修饰，变量将不再是对象持久化的一部分，该变量内容在序列化后无法获得访问。</strong></p><p><strong>B.</strong>   <strong>transient关键字只能修饰变量，而不能修饰方法和类。注意，本地变量是不能被transient关键字修饰的。变量如果是用户自定义类变量，则该类需要实现Serializable接口。</strong></p><p><strong>C.</strong>   <strong>被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。</strong></p><p><strong>5)</strong>   <strong>InvalidClassException:</strong></p><p><img src="clip_image139.png" alt="img"></p><p><strong>序列化一个类后，又修改类的内容后，序列号会改变，反序列化时会出现InvalidClassException。</strong></p><p><strong>12.</strong>  <strong>PrintStream打印流</strong></p><h1 id="网络编程"><a href="#网络编程" class="headerlink" title="网络编程"></a>网络编程</h1><p><strong>1.</strong>   <strong>客户端：</strong></p><p><img src="clip_image140.png" alt="img"></p><p><img src="clip_image141.png" alt="img"></p><p><img src="clip_image142.png" alt="img"></p><p>注意：在客户端发送完毕之后，要调用socket的shutdownOutput()方法，以免服务端的inputStream.read()方法阻塞。</p><p><strong>2.</strong>   <strong>服务器端</strong></p><p><img src="clip_image143.png" alt="img"></p><p><img src="clip_image144.png" alt="img"></p><h1 id="JDK8新特性：函数式接口"><a href="#JDK8新特性：函数式接口" class="headerlink" title="JDK8新特性：函数式接口"></a>JDK8新特性：函数式接口</h1><p><strong>1.</strong>   <strong>概念：函数式接口在Java中是指：有且仅有一个抽象方法的接口；</strong></p><p><strong>@FunctionalInterface注解：可以检测接口是否为一个函数式接口。</strong></p><p><strong>注意：使用匿名内部类编译时会有匿名内部类class文件，而lambda表达式不会有，效率更高。</strong></p><p><strong>2.</strong>   <strong>函数式编程：</strong></p><p><strong>Lambda表达式延迟加载：作为参数（即接口的实现）时会判断其他参数是否满足条件，如若不满足调用者的条件则不会执行lambda表达式方法体，提高性能。</strong></p><p><strong>3.</strong>   <strong>Java.util.function：</strong></p><p><strong>1)</strong>   <strong>Supplier</strong></p><p><img src="clip_image145.png" alt="img"></p><p><strong>2)</strong>   <strong>Consumer</strong></p><p><img src="clip_image146.png" alt="img"></p><p><img src="clip_image147.png" alt="img"></p><p><img src="clip_image148.png" alt="img"></p><p><strong>3)</strong>   <strong>Predicate</strong></p><p><strong>4)</strong>   <strong>Function</strong></p><p><strong>5)</strong>   <strong>Stream流</strong></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;strong&gt;JAVA复习笔记&lt;/strong&gt;&lt;/p&gt;
&lt;h1 id=&quot;字符串&quot;&gt;&lt;a href=&quot;#字符串&quot; class=&quot;headerlink&quot; title=&quot;字符串&quot;&gt;&lt;/a&gt;字符串&lt;/h1&gt;&lt;p&gt;&lt;img src=&quot;clip_image001.png&quot; alt=
      
    
    </summary>
    
    
      <category term="Java" scheme="http://thmasterplan.cn/categories/Java/"/>
    
    
      <category term="Java" scheme="http://thmasterplan.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式及SHELL编程</title>
    <link href="http://thmasterplan.cn/2019/11/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8ASHELL%E7%BC%96%E7%A8%8B/"/>
    <id>http://thmasterplan.cn/2019/11/19/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8F%8ASHELL%E7%BC%96%E7%A8%8B/</id>
    <published>2019-11-19T05:07:05.000Z</published>
    <updated>2019-11-19T10:42:48.960Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>文件权限与用户组管理</title>
    <link href="http://thmasterplan.cn/2019/11/18/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/"/>
    <id>http://thmasterplan.cn/2019/11/18/%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90%E4%B8%8E%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/</id>
    <published>2019-11-17T16:16:20.000Z</published>
    <updated>2019-11-19T05:04:52.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux的文件权限与用户组管理"><a href="#Linux的文件权限与用户组管理" class="headerlink" title="Linux的文件权限与用户组管理"></a>Linux的文件权限与用户组管理</h3><ul><li><p>文件权限：<code>-rw-r--r-- 1 root root 4.0K 07-19 01:02 abc.log</code>:</p><ul><li>第1位：<ul><li>-：表示普通文件；</li><li>d：目录</li><li>b：设备文件（块文件，即可以用来存储的设备文件）</li><li>c：设备文件（字符文件，不能用来存储的设备文件）</li><li>l：软链接（快捷方式）</li></ul></li><li>p：管道文件pipe<ul><li>s：套接字文件socket</li></ul></li><li>后9位：r可读，w可写，x可执行。<ul><li>2-4位：用户的权限范围</li><li>5-7位：组的权限范围</li><li>8-10位：其余人的权限范围</li></ul></li><li>1表示该文件的硬链接数</li><li>第一个root表示该文件的所有者</li><li>第二个root表示该文件所属的组</li><li>4.0K表示该文件的大小</li><li>后面为最后一次修改的时间戳和文件名</li></ul></li><li><p>r/w/x权限对于目录的意义：</p><ul><li>r权限：可读取目录结构列表，即可查看目录下的文件名和子目录名。[注：不能查看文件内容]</li><li>w权限：可创建文件和目录，可删除，可重命名，可转移</li><li>x权限：可进入该目录。</li></ul></li><li><p>更改权限：<code>chmod</code></p><ul><li><code>chmod u+x,g+w,o-r abc.log</code>：abc.log权限由<code>-rw-r--r--</code>变为：<code>-rwxrw----</code></li><li><code>chmod a=r file</code>或者<code>chmod +r file</code>:表示对file的u,g,o同时都赋予可读权限</li><li>另一种更简单的权限赋予方式，令r = 4, w = 2, x = 1,则u,g,o的权限分别可用一个整数表示，例如<code>chmod 741 file</code>表示file的u,g,o权限为<code>-rwxr----x</code></li><li>参数-R：R及recursive（递归）；<code>chmod -R 741 directory</code>，表示改变目录及目录下所有文件的权限为741。</li></ul></li><li><p>更改文件的所有者：<code>chown</code></p><ul><li><code>chown user file</code>:将file的所有者改为user</li><li><code>chown user.group file</code>:将file的所有者改为user,同时更改其组为group</li><li><code>chown -R user directory</code>：若要更改目录的权限，则需要加-R才能将其里面所有内容的权限更改</li></ul></li><li><p>更改文件的所有组：<code>chgrp</code></p><ul><li><code>chgrp root file</code>: 将file的所有组改为root</li></ul></li><li><p>Linux组的类别：</p><ul><li>用户的主要组：用户必须属于一个且只有一个主组，组名同用户名，且仅包含用户自己。</li><li>用户的附加组：一个用户可属于0或多个附加组。</li><li><code>id 用户名</code>：查看用户的uid、gid（主组）、groups的id。管理员root的uid和gid为0。</li></ul></li><li><p>用户和组的配置文件：</p><ul><li><code>/etc/passwd</code>：用户及其属性信息(名称、UID、主组ID)。</li><li><code>/etc/group</code>：组及其属性信息。</li><li><code>/etc/shadow</code>：用户密码及其相关属性。</li><li><code>/etc/gshadow</code>：组密码及其相关信息。</li></ul></li><li><p>用户、组的增删改：</p><ul><li><code>useradd</code>，<code>userdel</code>，<code>usermod</code></li><li><code>groupadd</code>，<code>groupdel</code>，<code>groupmod</code></li><li><code>/etc/default/useradd</code>：创建用户时的默认设置</li></ul></li><li><p>文件与目录的默认权限与隐藏权限</p><ul><li><p>文件预设权限:在没有umask的情况下，目录默认权限为777，文件默认权限为666；<code>umask 022</code>，表示创建文件和目录，g和o都过滤掉写(2)权限。</p></li><li><p><code>lsattr -a</code>:显示所有隐藏属性</p></li><li><p><code>chattr [-RV][-v][+/-/=&lt;属性&gt;] [文件或目录]</code>:</p><ul><li><p>-R：递归处理，将指定目录下的所有文件及子目录一并处理</p></li><li><p>-v：&lt;版本编号&gt; 设置文件或目录版本</p></li><li><p>-V： 显示指令执行过程</p></li><li><p>+&lt;属性&gt;： 开启文件或目录的该项属性</p></li><li><p>-&lt;属性&gt; ：关闭文件或目录的该项属</p></li><li><p>=&lt;属性&gt;： 指定文件或目录的该项属性</p></li><li><p>属性：</p><ul><li><strong>a：让文件或目录只能加数据</strong>。</li><li><strong>i：不得任意更动文件或目录</strong>。</li><li>b：不更新文件或目录的最后存取时间。</li><li>c：将文件或目录压缩后存放。</li><li>d：将文件或目录排除在倾倒操作之外。</li><li>s：保密性删除文件或目录。</li><li>S：即时更新文件或目录。</li><li>u：预防意外删除。</li></ul></li><li><p>例如<code>chattr +a /var/log/messages</code>:让某个文件只能往里面追加数据，但不能删除，适用于各种日志文件</p></li></ul></li></ul></li><li><p>文件特殊权限</p><ul><li><p><strong>SUID</strong>（最常用）：<code>chmod u+s file</code>：使file文件x权限上显示为s，非用户(u)执行者可以获得u的所有权限</p><ul><li>SUID权限仅对二进制程序有效，不能用在脚本和目录上</li><li>执行者对于该程序有x的可执行权限</li><li>SUID权限仅在执行程序的过程中有效</li><li>让本没有相应权限的用户运行该程序时，可以获得其原本没有权限访问的资源</li></ul></li><li><p>SGID：非组(g)成员获得该组的权限</p><ul><li>非组成员对于该程序需要具备x的权限</li><li>SGID<strong>主要用于目录, 在该目录下创建的任何文件及子目录属于该目录所拥有的组</strong> 。</li></ul></li><li><p>SBIT: 目前只针对目录有效，切只能分配给其他人（o）;对于目录的作用是：当用户在该目录下建立文件或目录时，仅有<strong>自己与 root</strong>才有权力<strong>删除</strong>，例如/tmp。</p></li><li><p><strong>SUID/SGID/SBIT权限设置</strong> ：</p><ul><li><strong>文字法</strong> ：SUID: <strong>u+s</strong> ，SGID: <strong>g+s</strong>，SBIT: <strong>o+t</strong></li><li><em>数字法*</em>：将原来的三位数扩展为四位数即可，SUID为4，SGID为2，SBIT为1，把它们放在权限数字的最开头。例如设置SUID，可以写成<strong>4777</strong>，设置SGID可以写成，<strong>2777</strong> 。</li></ul></li></ul></li><li><p>ACL(Access Control List)实现灵活权限控制：</p><ul><li><p><code>setfacl -m u/g:用户名/组名:权限 file</code>。例如<code>setfacl -m u:Tom:rw abc.txt</code>，即Tom对abc.txt具有r和w权限，若不给权限则权限写<code>0</code>。</p></li><li><p><code>setfacl -x u/g:用户名/组名 file</code>：删除权限。</p></li><li><p><code>setfacl -R -b dir/</code>：删除dir下所有的ACL权限。</p></li><li><p><code>getfacl file</code>：显示file的ACL权限。</p></li><li><p>权限优先级：所有者&gt;ACL权限(用户&gt;组&gt;other)</p></li></ul></li></ul><ul><li><p>权限与指令间的关系(在用户模式下)</p><ul><li><p>用户能进入某目录：需要权限x</p><ul><li>进入目录后能利用ls查阅:需要权限r</li><li>进入目录后能够创建文件和目录:需要权限w</li></ul></li><li><p>用户在目录内打开读取文件：</p><ul><li>目录需要权限x</li><li>文件需要权限r</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux的文件权限与用户组管理&quot;&gt;&lt;a href=&quot;#Linux的文件权限与用户组管理&quot; class=&quot;headerlink&quot; title=&quot;Linux的文件权限与用户组管理&quot;&gt;&lt;/a&gt;Linux的文件权限与用户组管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;文件权限：
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>文件链接</title>
    <link href="http://thmasterplan.cn/2019/11/18/%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/"/>
    <id>http://thmasterplan.cn/2019/11/18/%E6%96%87%E4%BB%B6%E9%93%BE%E6%8E%A5/</id>
    <published>2019-11-17T16:15:31.000Z</published>
    <updated>2019-11-17T16:32:05.287Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件链接"><a href="#文件链接" class="headerlink" title="文件链接"></a>文件链接</h3><ul><li>硬链接：一个inode号对应多个文件名，硬链接也即同一个文件使用了多个别名，由命令<code>ln oldfile newfile</code>创建。<ul><li>文件有相同的inode和data block</li><li>只能对<strong>已存在的文件</strong>进行创建，链接计数加1</li><li><strong>不能交叉文件系统</strong>进行硬链接的创建</li><li>不能对目录进行创建，只可对文件创建</li><li>删除一个硬链接文件并不影响其他有相同inode号的文件</li></ul></li><li>软链接（符号链接）：软链接的data block中存放的内容是另一文件的路径名的指向。软链接有自己的inode号和data block。由命令<code>ln -s oldfile newfile</code>创建，其中<code>oldfile</code>的相对路径为相对于<code>newfile</code>的，而<code>newfile</code>的相对路径是相对于当前工作目录的。<code>rm -rf a.link/</code>删除的是链接指向的文件，而<code>rm -rf a.link</code>删除的才是链接。<ul><li>软链接有自己的文件属性及权限</li><li>可对不存在的文件或目录创建软链接</li><li>软链接可交叉文件系统</li><li>软链接可对文件或目录创建</li><li>创建软链接时，链接计数不会增加</li><li>删除软链接并不影响被指向的文件，但若被指向的原文件被删除，则相关软连接被称为死链接（即 dangling link，若被指向路径文件被重新创建，死链接可恢复为正常的软链接）</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件链接&quot;&gt;&lt;a href=&quot;#文件链接&quot; class=&quot;headerlink&quot; title=&quot;文件链接&quot;&gt;&lt;/a&gt;文件链接&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;硬链接：一个inode号对应多个文件名，硬链接也即同一个文件使用了多个别名，由命令&lt;code&gt;ln oldfil
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>目录配置与文件目录管理</title>
    <link href="http://thmasterplan.cn/2019/11/18/%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/"/>
    <id>http://thmasterplan.cn/2019/11/18/%E7%9B%AE%E5%BD%95%E9%85%8D%E7%BD%AE%E4%B8%8E%E6%96%87%E4%BB%B6%E7%9B%AE%E5%BD%95%E7%AE%A1%E7%90%86/</id>
    <published>2019-11-17T16:14:20.000Z</published>
    <updated>2019-11-17T16:33:05.292Z</updated>
    
    <content type="html"><![CDATA[<h3 id="目录配置与文件目录管理"><a href="#目录配置与文件目录管理" class="headerlink" title="目录配置与文件目录管理"></a>目录配置与文件目录管理</h3><ul><li><p>目录配置：可参考FHS标准</p><ul><li><code>/bin</code>:存放二进制文件，常用命令</li><li><code>/boot</code>：系统启动项文件,内核</li><li><code>/dev</code>:设备文件，硬盘等</li><li><code>/etc</code>：配置文件</li><li><code>/home</code>:用户家目录，每一个用户在/home下都有一个文件夹</li><li><code>/lib</code>：链接库文件</li><li><code>/media</code>：媒体自动挂载点，比如U盘，光盘等</li><li><code>/mnt</code>：媒体挂载点，手动挂载</li><li><code>/opt</code>：自定义软件安装处，默认安装处为/usr/local</li><li><code>/root</code>：超级用户目录</li><li><code>/sbin</code>：存放系统管理员所能执行的命令</li><li><code>/tmp</code>：临时文件</li><li><code>/usr</code>：类似于二层根目录</li><li><code>/var</code>:存放缓存，日志，数据库文件；该文件夹需要分配的空间较大，因此在磁盘分区时挂载在/var的分区要大一些。</li><li><code>/proc</code>：内存中的进程信息</li><li><code>/sys</code>：硬件相关信息</li></ul></li><li><p>文件与目录管理</p><ul><li><p>常用命令：</p><ul><li><code>cd ~</code>:切换到home;<code>cd -</code>:切换到上一次所在目录</li><li><code>pwd</code>：打印当前目录</li><li><code>basename 和 dirname</code>：分别获取当前路径的文件名和目录名</li><li><code>touch xx</code>:若xx不存在，则创建一个新文件xx。若xx存在，把xx的修改时间改为当前。</li><li><code>&gt; xx</code>：若文件不存在，则创建一个空文件xx；若文件存在，则清空现有文件xx(可用于清空大文件)。</li><li><code>mkdir 目录名 目录名 目录名 ...</code></li><li><code>mkdir -p test/{a,b,c}/{d,e}</code>:递归创建目录，分别在a,b,c三个目录下创建d,e两个目录。</li><li><code>rmdir 目录名</code>:只能删除空目录</li><li><code>rm -rf</code>目录:删除目录下所有东西（慎用<code>rm</code>）</li><li><code>cp [选项] /PATH1/xx /PATH2/yy</code>:若yy是一个目录，则把文件xx拷贝到yy下；若yy不是一个目录，则把文件xx拷贝到PATH2目录下并<strong>重命名</strong>为yy。cp不能直接拷贝目录，需要加选项参数，<code>cp -rfp /目录1 /目录2 == cp -a /目录1 /目录2</code>：将目录1及其所有子目录及文件拷贝到目录2。参数：-r即递归，-f即强制,-p同时复制属性信息。</li><li><code>mv [选项] /PATH1/xx /PATH2/yy</code>：若yy是一个目录，则把文件xx剪切到yy下；若yy不是一个目录，则把文件xx剪切到PATH2目录下并<strong>重命名</strong>为yy。例如<code>mv xx yy</code>:就是把xx重命名为yy。</li><li><code>rename .log .logabc *</code>：重命名，把所有文件名中的<code>.log</code>改为<code>.logabc</code></li></ul></li><li><p>关于执行文件路径的变量：执行程序必须在其所在目录下才能执行，亦可使用绝对路径调用，若要直接敲命令就可以执行，则需要设置PATH，把命令所在目录添加在PATH后面。</p></li><li><p>文件的三个时间属性:</p><ul><li><code>atime</code>:access time</li><li><code>mtime</code>:modify time</li><li><code>ctime</code>:change time</li></ul></li><li><p>文件名规则：</p><ul><li>文件名最长255字节</li><li>蓝色–&gt;目录；绿色–&gt;可执行文件；红色–&gt;压缩文件；浅蓝色–&gt;链接文件；黄色–&gt;设备文件；粉色–&gt;套接字文件；棕色–&gt;管道文件；灰色–&gt;其他文件</li></ul></li><li><p>文件通配符：</p><ul><li><code>*</code>：匹配0个或多个字符</li></ul></li><li><p><code>?</code>：匹配任意一个字符</p><ul><li><code>[1-5]</code>：匹配字符1,2,3,4,5</li><li><code>[a-c]</code>：匹配字符a、A、b、B、c(没有C)。</li><li><code>[A-C]</code>：匹配A，b，B，c，C</li><li><code>[^abcd]</code>：匹配除abcd外的所有单个字母</li><li><img src="filematch.jpg" alt=""></li></ul></li><li><p>文件内容查阅</p><ul><li><code>cat 文件名</code>:显示所有文件内容，适合查看小文件，参数-n显示行数。<code>cat -n 文件名== nl 文件名</code>。</li><li><code>tac</code>：从最后一行显示，倒数显示。</li><li><code>more/less 文件名</code>:按空格一屏一屏地显示，按回车一行一行地显示。同时在文档下方输入<code>/字符串</code>即可查找文档中的字符串。</li><li><code>head -n 21 文件名</code>:查看文件的前21行</li><li><code>tail -n 21 文件名</code>:查看文件的尾21行；参数-f,监测日志，实时监测日志的变化。</li><li><code>od</code>:查看非文本文档，比如二进制文件。</li></ul></li><li><p>命令与文件的查询：</p><ul><li><p><code>which -a 命令</code>:在PATH路径中搜寻命令位置</p></li><li><p><code>whereis 命令</code>:返回命令路径及其帮助文档的路径；参数-b只返回命令路径。</p></li><li><p><code>locate 字符串</code>:在<code>/var/lib/mlocate/mlocate.db</code>中查询所有文件名中包含该字符串的文件并返回，该数据库每天定时更新，亦可通过<code>updatedb</code>更新。</p></li><li><p><code>find [paths] [expression] [actions]</code>:</p><ul><li><p>若不写paths则默认在当前目录下递归查找；</p></li><li><p>expression:</p><ol><li>根据文件名检索</li></ol><p>find 命令中的 <code>-name</code> 选项可以根据文件名称进行检索（<strong>区分大小写</strong>）。如需要忽略文件名中的大小写，可以使用 <code>-iname</code> 选项。</p><p><code>-name</code> 和 <code>-iname</code> 两个选项都支持 <strong>wildcards</strong> 。如：</p><ul><li><code>?</code> 可以表示任意一个单一的符号</li><li><code>*</code> 可以表示任意数量（包括 0）的未知符号</li></ul><p><code>find /usr -name &#39;*.txt&#39;</code> 查找 /usr 目录下所有文件名以 <code>.txt</code> 结尾的文件<br><code>find /usr -name &#39;????&#39;</code> 查找 /usr 目录下所有文件名刚好为 4 个字符的文件</p><p>有些时候，你需要在搜索时匹配某个文件或目录的<strong>完整路径</strong>，而不仅仅是匹配文件名。可以使用 <code>-path</code> 或 <code>-ipath</code> 选项。</p><p>如查找 /usr 下所有文件名以 <code>.txt</code> 结尾的文件或目录，且该文件的父目录必须是 <code>src</code>。可以使用以下命令：<br> <code>find /usr -path &#39;*/src/*.txt&#39;</code></p><ol start="2"><li>根据文件类型检索</li></ol><p>如果只想搜索得到文件<strong>或</strong>目录，即不想它们同时出现在结果中。可以使用 <code>-type</code> 选项指定文件类型。</p><p><code>-type</code> 选项最常用的参数如下：</p><ul><li>f: 文件</li><li>d: 目录</li><li>l: 符号链接</li></ul><p><code>find /usr -type d -name &#39;python*&#39;</code> 检索 /usr 下所有文件名以 <code>python</code> 开头的<strong>目录</strong></p><ol start="3"><li>检索空文件</li></ol><p>find 命令支持 <code>-empty</code> 选项用来检索<strong>为空</strong>的文件或目录。空文件即文件里没有任何内容，空目录即目录中没有任何文件或子目录。</p><p><code>find ~ -type d -empty</code> 检索用户主目录下所有的空目录</p><ol start="4"><li>反义匹配</li></ol><p>find 命令也允许用户对当前的匹配条件进行<strong>“反义”</strong>（类似于<strong>逻辑非</strong>操作）。</p><p>如需要检索 /usr 下所有文件名<strong>不</strong>以 <code>.txt</code> 为后缀的文件。可以使用以下命令：<br> <code>find /usr -type f ! -name &#39;*.txt&#39;</code></p><p>也可以“翻转”任何其他的筛选条件，如：<br> <code>find /usr -type f ! -empty</code> 检索 /usr 下所有内容不为空的文件</p><ol start="5"><li>根据文件的所属权检索</li></ol><p>为了检索归属于特定用户的文件或目录，可以使用 <code>-user</code> 选项。</p><p><code>find / -type f -user starky</code> 检索根目录下所有属主为 starky 的文件</p><p>类似于 <code>-user</code>选项，<code>-group</code> 选项则可以根据文件或目录的<strong>属组</strong>进行检索。</p><ol start="6"><li>根据时间日期进行检索</li></ol><p>有些时候，需要根据文件创建或修改的时间进行检索。</p><p>Linux 系统中，与文件相关联的时间参数有以下三种：</p><ul><li>修改时间（Modification time）：最后一次文件内容有过更改的时间点</li><li>访问时间（Access time）：最后一次文件有被读取过的时间点</li><li>变更时间（Change time）：最后一次文件有被<strong>变更</strong>过的时间点（如内容被修改，或权限等 metadata 被修改）</li></ul><p>与此对应的是 find 命令中的 <code>-mtime</code>，<code>-atime</code> 和 <code>-ctime</code> 三个选项。</p><p>这三个选项的使用遵循以下示例中的规则：</p><ul><li><code>-mtime 2</code>：该文件 2 天前被修改过</li><li><code>-mtime -2</code>：该文件 2 天<strong>以内</strong>被修改过</li><li><code>-mtime +2</code>：该文件距离上次修改已经<strong>超过</strong> 2 天时间</li></ul><p><code>find /usr -type f -mtime 2</code> 检索 /usr 下两天前被修改过的文件</p><p>如果觉得 <code>-mtime</code> 等选项以<strong>天</strong>为单位时间有点长，还可以使用 <code>-mmin</code>，<code>-amin</code>，<code>-cmin</code> 三个选项：<br> <code>find /usr -type f -mtime +50 -mtime -100</code> 检索 /usr 下 50 到 100 天之前修改过的文件<br> <code>find /usr -type f -mtime 2 -amin 5</code> 检索 /usr 下两天前被修改过且 5 分钟前又读取过的文件</p><ol start="7"><li>根据文件大小检索</li></ol><p><code>-size</code> 选项允许用户通过文件大小进行搜索（只适用于文件，目录没有大小……）。</p><p>表示文件大小的单位由以下字符组成：</p><ul><li><code>c</code>：字节</li><li><code>k</code>：Kb</li><li><code>M</code>：Mb</li><li><code>G</code>：Gb</li></ul><p>另外，还可以使用 <code>+</code> 或 <code>-</code> 符号表示<strong>大于</strong>或<strong>小于</strong>当前条件。</p><p><code>find / -size +1G</code> 检索文件大小高于 1 GB 的文件</p><ol start="8"><li>根据文件权限检索</li></ol><p>find 命令可以使用 <code>-perm</code> 选项以文件权限为依据进行搜索。</p><h6 id="使用符号形式"><a href="#使用符号形式" class="headerlink" title="使用符号形式"></a>使用符号形式</h6><p>如需要检索 /usr 目录下权限为 <code>rwxr-xr-x</code> 的文件，可以使用以下命令：<br> <code>find /usr -perm u=rwx,g=rx,o=rx</code></p><p>搜索 /usr 目录下所有权限为 <code>r-xr-xr-x</code>（即系统中的所有用户都只有读写权限）的文件和目录，可以使用以下命令：<br> <code>find /usr -perm a=rx</code></p><p>很多时候，我们只想匹配文件权限的一个<strong>子集</strong>。比如，检索可以直接被任何用户执行的文件，即只关心文件的执行权限，而不用管其读写权限是什么。</p><p>上述的需求可以通过以下命令实现：<code>find / -type f -perm /a=x</code><br> 其中 <code>a=x</code> 前面的 <code>/</code> 符号即用来表示只匹配权限的某个子集（执行权限），而不用关心其他权限的具体设置。</p><h6 id="使用数字形式"><a href="#使用数字形式" class="headerlink" title="使用数字形式"></a>使用数字形式</h6><p><code>-perm</code> 选项也支持数字形式的文件权限标记。</p><p><code>find /usr -perm 644</code> 搜索 /usr 目录下权限为 <strong>644</strong>（即 <code>rwxr-xr-x</code>）的文件</p><ol start="9"><li>限制遍历的层数</li></ol><p>find 命令默认是以<strong>递归</strong>的方式检索项目的，这有时候会导致得到的结果数量非常巨大。可以使用 <code>-maxdepth</code> 限制 find 命令递归的层数。</p><p><code>find / -maxdepth 3</code> 搜索时向下递归的层数最大为 3</p><ol start="10"><li>逻辑组合</li></ol><p>在之前的例子中有出现多个搜索条件的<strong>组合</strong>以及对某个搜索条件的<strong>反转</strong>。<br> 实际上 find 命令支持 <strong>“and”</strong> 和 <strong>“or”</strong> 两种逻辑运算，对应的命令选项分别是 <code>-a</code> 和 <code>-o</code>。通过这两个选项可以对搜索条件进行更复杂的组合。</p><p>此外还可以使用<strong>小括号</strong>对搜索条件进行<strong>分组</strong>。注意 <code>find</code> 命令中的小括号常需要用<strong>单引号</strong>包裹起来。因小括号在 Shell 中有特殊的含义。</p><p>如检索 /usr 下文件名以 <code>python</code> 开头且类型为目录的文件<br> <code>find /usr -type d -name &#39;python*&#39;</code></p><p>该命令等同于：<br> <code>find /usr -type d -a -name &#39;python*&#39;</code></p><p>更复杂的组合形式如：<br> <code>find / &#39;(&#39; -mmin -5 -o -mtime +50 &#39;)&#39; -a -type f</code></p></li><li><p>对搜索结果执行actions：</p><ol><li>删除文件</li></ol><p><code>-delete</code> 选项可以用来删除搜索到的文件和目录。</p><p>如删除 home 目录下所有的空目录：<br> <code>find ~ -type d -empty -delete</code></p><ol start="2"><li>执行自定义命令</li></ol><p><code>-exec</code> 选项可以对搜索到的结果执行特定的命令。</p><p>如需要将 home 目录下所有的 MP3 音频文件复制到移动存储设备（假设路径是 <code>/media/MyDrive</code>），可使用下面的命令：<br> <code>find ~ -type f -name &#39;*.mp3&#39; -exec cp {} /media/MyDrive &#39;;&#39;</code></p><p>其中的<strong>大括号</strong>（<code>{}</code>）作为检索到的文件的 <strong>占位符</strong> ，而分号（ <code>;</code>）作为命令结束的标志。因为分号是 Shell 中有特殊含义的符号，所以需要使用单引号括起来。<br> 每当 find 命令检索到一个符合条件的文件，会使用其完整路径取代命令中的 <code>{}</code>，然后执行 <code>-exec</code> 后面的命令一次。</p><p>另一个很重要的用法是，在多个文件中检索某个指定的字符串。<br> 如在用户主目录下的所有文件中检索字符串 <code>hello</code> ，可以使用如下命令：<br> <code>find ~ -type f -exec grep -l hello {} &#39;;&#39;</code></p><h6 id="exec-选项中的-符号"><a href="#exec-选项中的-符号" class="headerlink" title="-exec 选项中的 + 符号"></a>-exec 选项中的 + 符号</h6><p>创建 Gzip 格式的压缩文件的命令为：<code>tar -czvf filename.tar.gz</code></p><p>现在假设需要将用户主目录下所有的 MP3 文件添加到压缩包 <code>music.tar.gz</code> 中，直观的感觉是，其命令应为如下形式：<br> <code>find ~ -type f -name &#39;*.mp3&#39; -exec tar -czvf music.tar.gz {} &#39;;&#39;</code></p><p>实际情况是，这样得到的 <code>music.tar.gz</code> 其实只包含一个 MP3 文件。<br> 原因是 find 命令<strong>每次</strong>发现一个音频文件，都会再执行一次 <code>-exec</code> 选项后面的压缩命令。导致先前生成的压缩包被覆盖。</p><p>可以先让 find 命令检索出所有符合条件的音频文件，再将得到的<strong>文件列表</strong>传递给后面的压缩命令。完整的命令如下：<br> <code>find ~ -type f -name &#39;*.mp3&#39; -exec tar -czvf music.tar.gz {} +</code></p><h6 id="显示文件信息"><a href="#显示文件信息" class="headerlink" title="显示文件信息"></a>显示文件信息</h6><p>如果想浏览搜索到的文件（目录）的详细信息（如权限和大小等），可以直接使用 <code>-ls</code> 选项。</p><p><code>find / -type file -size +1G -ls</code> 浏览所有 1G 以上大小的文件的详细信息</p></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;目录配置与文件目录管理&quot;&gt;&lt;a href=&quot;#目录配置与文件目录管理&quot; class=&quot;headerlink&quot; title=&quot;目录配置与文件目录管理&quot;&gt;&lt;/a&gt;目录配置与文件目录管理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;目录配置：可参考FHS标准&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>磁盘与文件系统简介</title>
    <link href="http://thmasterplan.cn/2019/11/18/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/"/>
    <id>http://thmasterplan.cn/2019/11/18/%E7%A3%81%E7%9B%98%E4%B8%8E%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B/</id>
    <published>2019-11-17T16:12:54.000Z</published>
    <updated>2019-11-17T17:49:39.647Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Linux磁盘与文件系统简介-centOS7之后使用xfs，centOS6使用ext4"><a href="#Linux磁盘与文件系统简介-centOS7之后使用xfs，centOS6使用ext4" class="headerlink" title="Linux磁盘与文件系统简介(centOS7之后使用xfs，centOS6使用ext4)"></a>Linux磁盘与文件系统简介(centOS7之后使用xfs，centOS6使用ext4)</h3><ul><li><p>文件系统特性</p><ul><li>索引式文件系统：对于linux，文件的权限和属性放置到inode中，文件的实际数据放在data block中。<ul><li>superblock:记录此filesystem的整体信息，包括inode/block的总量、使用量、剩余量,以及文件系统的格式与相关信息等。</li><li>inode:记录文件的属性，一个文件占用一个inode，同时记录此文件的数据所在的block号码。</li><li>block:实际记录文件的内容，若文件过大一般会占用多个block。</li></ul></li></ul></li><li><p>linux的EXT2</p><ul><li><p>ext2文件系统示意图</p><p><img src="ext2.jpg" alt=""></p></li><li><p>data clock：ext2文件系统所支持的block大小有1K,2K和4K三种</p><table><thead><tr><th align="center">Block大小</th><th>1KB</th><th>2KB</th><th>4KB</th></tr></thead><tbody><tr><td align="center">最大单一文件限制</td><td>16GB</td><td>256GB</td><td>2TB</td></tr><tr><td align="center">最大文件系统总容量</td><td>2TB</td><td>8TB</td><td>16TB</td></tr></tbody></table><ul><li>除非重新格式化，block的大小与数量在格式化完就不能再改变</li><li>每个blcok内最多只能放置一个文件的数据</li><li>若文件大于block,则一个文件占用多个block；若文件小于block，则该blcok的剩余容量就不能再被使用。</li></ul></li><li><p>inode table:记录文件的权限，拥有者与群组，容量，建立、最近一次读取、更改的时间。。。</p><ul><li>每个inode大小均为固定128字节（ext4和xfs可设定到256字节）</li><li>每个文件仅占用一个inode</li><li>系统读取文件时需要先找到inode，并分析inode所记录的权限与用户是否符合。</li></ul></li><li><p>superblock：一般为1024字节</p></li><li><p><code>dumpe2fs</code>：查询EXT系列superblock信息的指令</p></li></ul></li><li><p>文件系统与目录树的关系</p><ul><li>目录：当在linux下的文件系统建立一个目录时，文件系统会分配一个inode与至少一块block给该目录，其中inode记录该目录的相关权限和属性，并记录分配的那块block号码，而block则记录在这个目录下的文件名与该文件名占用的inode号；<code>ls -i</code>查询当前目录下文件的inode号码。</li><li>文件:在ext2建立一个文件时，ext2会分配一个inode和相对于该文件大小的block数量。</li><li>目录树:例如读取/etc/passwd过程:<code>/的inode -&gt; /的block -&gt; etc/的inode -&gt; etc/的block -&gt; passwd的inode -&gt; passwd的block</code>。</li></ul></li><li><p>日志式文件系统</p></li><li><p>挂载点的意义：挂载点一定是目录，该目录为进入该文件系统的入口。</p></li><li><p>Linux VFS用于管理所有类型的filesystem</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Linux磁盘与文件系统简介-centOS7之后使用xfs，centOS6使用ext4&quot;&gt;&lt;a href=&quot;#Linux磁盘与文件系统简介-centOS7之后使用xfs，centOS6使用ext4&quot; class=&quot;headerlink&quot; title=&quot;Linux磁
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>常用命令入门</title>
    <link href="http://thmasterplan.cn/2019/11/18/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/"/>
    <id>http://thmasterplan.cn/2019/11/18/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E5%85%A5%E9%97%A8/</id>
    <published>2019-11-17T16:11:48.000Z</published>
    <updated>2019-11-17T17:02:15.820Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常用命令入门"><a href="#常用命令入门" class="headerlink" title="常用命令入门"></a>常用命令入门</h3><ul><li><p>Xwindow与命令行界面的切换：<code>ctrl + alt + f1...f7</code>，其中只有f7为图形化界面，启动图形化界面也可以用<code>startx</code>命令。</p></li><li><p>命令帮助：</p><ul><li><p><code>whatis 命令</code>：列出命令的作用以及man帮助的章节。</p></li><li><p><code>命令 --help</code>：命令用法</p></li><li><p><code>man 章节号 命令</code>：命令更详细的用法</p></li><li><p><code>info 命令</code></p></li><li><p><code>man -k 字符串</code>:查找所有包含该字符串的命令</p></li><li><p><code>help</code>：列出所有的内部命令</p></li></ul></li><li><p>常见命令与快捷键：</p><ul><li><p><code>ls -a/-l</code>:列出当前目录所有文件；<code>ls -l == ll</code>;<code>ls -d .*/</code>：列出所有目录</p></li><li><p><code>date</code>:获取当前日期</p></li><li><p><code>cal</code>:获取日历</p></li><li><p><code>bc</code>:进入计算器,<code>scale = n</code>,n表示计算的精度</p></li><li><p><code>[Tab]</code>:命令、文件名、选项、参数补全，连续两次<code>Tab</code>键可列出所有选项</p></li><li><p><code>ctrl c</code>:终止目前程序</p></li><li><p><code>ctrl d</code> :等同于输入exit</p></li><li><p><code>shift pageup/pagedown</code>:翻页</p></li><li><p><code>nano</code>:一个简单的文本编辑器</p></li><li><p><code>reboot/shutdown -r</code>:重启；<code>shutdown/poweroff</code>:关机；<code>shutdown -h 1</code>:定时1分钟关机；<code>shutdown -h 8:20</code>:8:20关机</p></li><li><p><code>su -/su root</code>：获取root权限</p></li><li><p><code>sync</code>：将内存中的数据写入磁盘，防止丢失</p></li><li><p><code>clear</code>:清屏</p></li><li><p><code>file 文件名</code>:查看文件类型</p></li><li><p><code>tree</code>:查询当前目录的树形结构,需要安装；选项<code>-d</code>只显示目录；选项<code>-L</code>显示指定层级；例如<code>tree -d /boot -L 1</code>。</p></li><li><p><code>passwd</code>：更改密码</p></li><li><p><code>hostname</code>：查看主机名；<code>hostnamectl set-hostname 名字</code>：更改主机名。</p></li><li><p><code>ls -l $(which passwd)</code>：命令的嵌套执行，用$()表示。</p></li><li><p>修改提示符颜色:修改<code>PS1</code>变量的值，并保存在配置文件<code>/etc/profile.d/env.sh</code>中。</p></li><li><p><code>type 命令</code>：查看命令类型，内部命令集成在shell中。</p></li><li><p><code>enable</code>：查看所有内部命令；<code>enable -n 命令</code>:禁用内部命令</p></li><li><p><code>Hash缓存表:</code>系统初始hash表为空，当<strong>外部命令</strong>执行时，默认会从PATH路径下寻找该命令，找到后会将该命令的路径记录到hash表中，当再次使用该命令时，shell解释器首先查看hash表，存在则执行命令，不存在则去PATH路径下寻找，利用hash缓存表可大大提高命令的调用速率。</p><ul><li><code>hash</code>：显示hash缓存</li></ul></li><li><p>将外部命令路径添加到<code>/etc/profile</code>文件的<code>PATH=$PATH:/xxx/yy</code>中，再用<code>source /etc/profile</code>即可在任意路径下使用该外部命令。</p></li><li><p><code>alias 别名 = &#39;常用命令&#39;：</code>设立别名；在centos7中，需在<code>/root/.bashrc</code>中保存。</p><ul><li><code>alias</code>可列出所有别名。</li><li>命令执行优先级:别名&gt;内部命令&gt;外部命令hash表&gt;$PATH。</li><li>若别名与原命令同名，可通过<code>\命令名</code>执行原命令。</li><li>编辑配置文件不会立即生效，可通过<code>. 配置文件名</code>使bash进程重新读取配置文件使编辑生效。</li></ul></li><li><p>多个命令可以用<code>;</code>分开一起执行，一个长命令可以用<code>\</code>分成多行。</p></li><li><p><code>echo：</code>回显字符串；显示变量</p><ul><li>单引号：单引号中的内容就是字符串</li><li>反向单引号：其中的内容命令和变量均能识别。例如：<code>touch `date +%F`.log</code>：创建以当前时间命名的文件。反向单引号等价于<code>$()</code>。</li><li>双引号：能识别变量不能识别命令</li><li><code>{}</code>：打印重复字符串；例如<code>touch file{1..10}</code>：创建了10个文件分别为file1,file2,,,file10。</li></ul></li><li><p><code>Alt 数字n</code>:重复显示字符n次</p></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常用命令入门&quot;&gt;&lt;a href=&quot;#常用命令入门&quot; class=&quot;headerlink&quot; title=&quot;常用命令入门&quot;&gt;&lt;/a&gt;常用命令入门&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Xwindow与命令行界面的切换：&lt;code&gt;ctrl + alt + f1...f7&lt;/
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>标准IO和重定向</title>
    <link href="http://thmasterplan.cn/2019/11/18/%E6%A0%87%E5%87%86IO%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/"/>
    <id>http://thmasterplan.cn/2019/11/18/%E6%A0%87%E5%87%86IO%E5%92%8C%E9%87%8D%E5%AE%9A%E5%90%91/</id>
    <published>2019-11-17T16:09:31.000Z</published>
    <updated>2019-11-17T16:30:58.678Z</updated>
    
    <content type="html"><![CDATA[<h3 id="标准IO和重定向"><a href="#标准IO和重定向" class="headerlink" title="标准IO和重定向"></a>标准IO和重定向</h3><ul><li>三种I/O设备<ul><li>标准输入(STDIN)：（文件描述符0） 默认接收来自键盘的输入</li><li>标准输出（STDOUT）：（文件描述符1） 默认输出到终端窗口</li><li>标准错误（STDERR）：（文件描述符2） 默认输出到终端窗口</li></ul></li><li>I/O重定向至文件<ul><li>标准输出重定向：<code>&gt;</code>；例如<code>hostname &gt; /dev/pts/2</code>将输出重定向至另一设备；若为文件，则清空文件再写入。<code>&gt;&gt;</code>则是追加，而不清空原文件；例如<code>hostname &gt;&gt; /data/abc.log</code>。</li><li>标准错误重定向：<code>2&gt;</code>；<code>&gt;&gt;</code>则是追加。</li><li><code>&amp;&gt;</code>：标准输出和标准错误一起重定向。</li><li>标准输入重定向：<code>&lt;</code>；例如<code>bc &lt; bc.txt</code>，将bc.txt文件作为输入用bc计算。</li><li><code>tr [选项] set1 set2</code> ：将输入的文本中所有的s1替换为s2。·<ul><li><code>-d</code>：删除所有属于set1的字符。</li><li><code>-s</code>：把连续重复的字符以单独一个字符表示。</li><li><code>-t</code>：把set1对应字符转换为set2对应字符。</li></ul></li><li><code>cat &gt; abc.log</code>：标准输入单行重定向到文件；<code>cat &lt;&lt;EOF &gt;abc.log</code>标准输入多行重定向至文件，输入EOF才写入文件。</li></ul></li><li>使用管道<ul><li>管道<code>命令1 | 命令2 | 命令3 | ...</code>：将命令1的STDOUT发送给命令2的STDIN，再将命令2的STDOUT发送给命令3的STDIN。。。</li><li>STDERR默认不能通过管道转发，可利用<code>|&amp;</code>实现。</li><li>例子：<code>echo {1..100} | tr &#39; &#39; + | bc</code>：计算1到100的和。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;标准IO和重定向&quot;&gt;&lt;a href=&quot;#标准IO和重定向&quot; class=&quot;headerlink&quot; title=&quot;标准IO和重定向&quot;&gt;&lt;/a&gt;标准IO和重定向&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;三种I/O设备&lt;ul&gt;
&lt;li&gt;标准输入(STDIN)：（文件描述符0） 默认接
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>VIM的简单使用</title>
    <link href="http://thmasterplan.cn/2019/11/18/VIM%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/"/>
    <id>http://thmasterplan.cn/2019/11/18/VIM%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8/</id>
    <published>2019-11-17T16:08:02.000Z</published>
    <updated>2019-11-17T16:29:57.944Z</updated>
    
    <content type="html"><![CDATA[<h3 id="VIM：一个模式编辑器"><a href="#VIM：一个模式编辑器" class="headerlink" title="VIM：一个模式编辑器"></a>VIM：一个模式编辑器</h3><ul><li>三种主要模式：<ul><li>Normal（命令）模式：默认模式，可移动光标，剪切/粘贴文本。<ul><li><code>-&gt; Insert模式：输入i,a,o,I,A,O任意一个</code>；</li><li><code>-&gt; extended command模式:输入:</code>；</li><li><code>h:左; l:右; j:下; k:上</code>；</li><li><code>)</code>：下一句；<code>(</code>：上一句</li><li><code>}</code>：下一段；<code>{</code>：上一段</li><li><code>ctrl d</code>：向下翻半屏</li><li><code>ctrl u</code>：向上翻半屏</li><li><code>/字符串</code>：全文查找字符串</li></ul></li><li>Insert(编辑)模式：可修改文本。<ul><li><code>-&gt; Normal模式:ESC键</code>；</li></ul></li><li>扩展命令(extended command)模式：保存，退出等。<ul><li><code>-&gt; Normal模式：ESC键</code>；</li><li><code>wq</code>：存盘退出；</li><li><code>q!</code>：不存盘退出；</li><li><code>w</code>：临时保存，类似于win下的ctrl+s；</li><li><code>r filename</code>：将filename的文件内容读到当前文件中；</li><li><code>w filename</code>：将当前文件内容写入filename文件中；</li><li><code>!命令</code>：在不退出vim的情况下执行命令；</li></ul></li><li><code>r!命令</code>：在不退出vim的情况下，将执行命令的结果写入当前文件。<ul><li><code>set number</code>：显示行号；输入数字再输入<code>+</code>或<code>-</code>则向下或向上跳相应行数。</li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;VIM：一个模式编辑器&quot;&gt;&lt;a href=&quot;#VIM：一个模式编辑器&quot; class=&quot;headerlink&quot; title=&quot;VIM：一个模式编辑器&quot;&gt;&lt;/a&gt;VIM：一个模式编辑器&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;三种主要模式：&lt;ul&gt;
&lt;li&gt;Normal（命令）模式
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
</feed>
