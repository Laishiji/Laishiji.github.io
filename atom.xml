<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="https://www.w3.org/2005/Atom">
  <title>TheMasterplan</title>
  
  <subtitle>TheMasterplan</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://thmasterplan.cn/"/>
  <updated>2020-02-14T14:44:19.265Z</updated>
  <id>http://thmasterplan.cn/</id>
  
  <author>
    <name>LSJ</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>栈与队列</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%A0%88%E4%B8%8E%E9%98%9F%E5%88%97/</id>
    <published>2020-02-14T14:43:29.000Z</published>
    <updated>2020-02-14T14:44:19.265Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>用栈实现队列：232</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; tempStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            tempStack.push(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = tempStack.pop();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!tempStack.empty())&#123;</span><br><span class="line">            stack.push(tempStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; tempStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(!stack.empty())&#123;</span><br><span class="line">            tempStack.push(stack.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = tempStack.peek();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!tempStack.empty())&#123;</span><br><span class="line">            stack.push(tempStack.pop());</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>用队列实现栈：225</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Queue&lt;Integer&gt; queue;</span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x onto stack. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        queue.offer(x);</span><br><span class="line">        <span class="keyword">int</span> size = queue.size();</span><br><span class="line">        <span class="keyword">while</span>(size-- &gt; <span class="number">1</span>)&#123;</span><br><span class="line">            queue.offer(queue.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element on top of the stack and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the top element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the stack is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> queue.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>最小栈：155</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; stack;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; minStack;<span class="comment">//minStack的栈顶元素即是当前stack的最小值</span></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MinStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        stack.push(x);</span><br><span class="line">        <span class="keyword">if</span>(minStack.empty())&#123;</span><br><span class="line">            minStack.push(x);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(x &lt;= minStack.peek())&#123;</span><br><span class="line">                minStack.push(x);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> pop = stack.pop();</span><br><span class="line">        <span class="keyword">if</span>(pop == minStack.peek()) minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> stack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有效的括号：20</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValid</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Character&gt; stack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="comment">//遍历字符串，每遇到一种类型的左括号，则将其对应的右括号入栈；若不是左括号，且栈不为空，则出栈，出栈的有括号应与遍历到的右括号一致。</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">char</span> c: s.toCharArray())&#123;</span><br><span class="line">            <span class="keyword">if</span>(c == <span class="string">'('</span>) stack.push(<span class="string">')'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c == <span class="string">'['</span>) stack.push(<span class="string">']'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>((c== <span class="string">'&#123;'</span>)) stack.push(<span class="string">'&#125;'</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(stack.empty() || c != stack.pop()) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.empty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;用栈实现队列：232&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;lin
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://thmasterplan.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>链表</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E9%93%BE%E8%A1%A8/</id>
    <published>2020-02-13T12:45:27.000Z</published>
    <updated>2020-02-13T12:46:24.855Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>找出两个链表的交点：160</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*设 A 的长度为 a + c，B 的长度为 b + c，其中 c 为尾部公共部分长度，可知 a + c + b = b + c + a。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">当访问 A 链表的指针访问到链表尾部时，令它从链表 B 的头部开始访问链表 B；同样地，当访问 B 链表的指针访问到链表尾部时，令它从链表 A 的头部开始访问链表 A。这样就能控制访问 A 和 B 两个链表的指针能同时访问到交点。</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">如果不存在交点，那么 a + b = b + a，以下实现代码中 l1 和 l2 会同时为 null，从而退出循环。*/</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        </span><br><span class="line">        ListNode pA = headA, pB = headB;</span><br><span class="line">        <span class="keyword">while</span>(pA != pB)&#123;</span><br><span class="line">            pA = pA == <span class="keyword">null</span> ? headB : pA.next;</span><br><span class="line">            pB = pB == <span class="keyword">null</span> ? headA : pB.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pA;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反转链表：206</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//原地翻转三个主要变量，当前节点cur，前一个节点pre,后一个节点nextTemp</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextTemp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并两个有序链表：21</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//类似于归并排序中的merge过程</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        ListNode newList = <span class="keyword">new</span> ListNode(<span class="number">0</span>);</span><br><span class="line">        ListNode cur = newList;</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(l1.val &lt;= l2.val)&#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                cur = cur.next;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="keyword">null</span>) cur.next = l2;<span class="comment">//任一链表为空，直接连接另一条链表</span></span><br><span class="line">        <span class="keyword">else</span> cur.next = l1;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> newList.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除排序链表中的重复元素：83</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">deleteDuplicates</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span> &amp;&amp; cur.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.val == cur.next.val)&#123;</span><br><span class="line">                cur.next = cur.next.next;</span><br><span class="line">            &#125;<span class="keyword">else</span> cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>删除链表的倒数第N个节点：19</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//先使快指针移动n个节点，然后快慢指针同时移动直到快指针达到链表尾部，此时慢指针即指向要删除的节点的前一个节点</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">removeNthFromEnd</span><span class="params">(ListNode head, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode first = head, second = head;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) second = second.next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(second == <span class="keyword">null</span>) <span class="keyword">return</span> head.next;<span class="comment">//若n等于链表节点数，直接返回head.next</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(second.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            first = first.next;</span><br><span class="line">            second = second.next;</span><br><span class="line">        &#125;</span><br><span class="line">        first.next = first.next.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两两交换链表中的节点：24</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">     <span class="function"><span class="keyword">public</span> ListNode <span class="title">swapPairs</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode firstNode = head, secondNode = head.next;</span><br><span class="line"></span><br><span class="line">        firstNode.next = swapPairs(secondNode.next);<span class="comment">//swapParis交换一对节点，并返回第二个节点</span></span><br><span class="line">        secondNode.next = firstNode;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> secondNode;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>两数相加：445</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="comment">//两栈用于存储两个数，另一个栈存储和</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">addTwoNumbers</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        Stack&lt;Integer&gt; first = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        Stack&lt;Integer&gt; second = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(l1 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            first.push(l1.val);</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(l2 != <span class="keyword">null</span>)&#123;</span><br><span class="line">            second.push(l2.val);</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Stack&lt;Integer&gt; sumStack = <span class="keyword">new</span> Stack&lt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> carry = <span class="number">0</span>;<span class="comment">//进位</span></span><br><span class="line">        <span class="keyword">while</span>(!first.empty() &amp;&amp; !second.empty())&#123;</span><br><span class="line">            <span class="keyword">int</span> sum = first.pop() + second.pop() + carry;</span><br><span class="line">            carry = <span class="number">0</span>;<span class="comment">//进位用完归0</span></span><br><span class="line">            <span class="keyword">if</span>(sum &gt;= <span class="number">10</span>)&#123;</span><br><span class="line">                carry = <span class="number">1</span>;</span><br><span class="line">                sum = sum % <span class="number">10</span>;</span><br><span class="line">            &#125; </span><br><span class="line">            sumStack.push(sum);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(!first.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = first.pop() + carry;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">10</span>)&#123;</span><br><span class="line">                    carry = <span class="number">1</span>;</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sumStack.push(sum);</span><br><span class="line">            &#125;<span class="keyword">else</span> sumStack.push(first.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(!second.empty())&#123;</span><br><span class="line">            <span class="keyword">if</span>(carry == <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="keyword">int</span> sum = second.pop() + carry;</span><br><span class="line">                carry = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(sum == <span class="number">10</span>)&#123;</span><br><span class="line">                    carry = <span class="number">1</span>;</span><br><span class="line">                    sum = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                sumStack.push(sum);</span><br><span class="line">            &#125;<span class="keyword">else</span> sumStack.push(second.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(carry == <span class="number">1</span>) sumStack.push(<span class="number">1</span>);<span class="comment">//和的第二位有进位的情况</span></span><br><span class="line">        ListNode sumList = <span class="keyword">new</span> ListNode(sumStack.pop());</span><br><span class="line">        ListNode cur = sumList;</span><br><span class="line">        <span class="keyword">while</span>(!sumStack.empty())&#123;</span><br><span class="line">            cur.next = <span class="keyword">new</span> ListNode(sumStack.pop());</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sumList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断一个链表是否为回文链表：234（要求O（n）和O（1））</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">sclass Solution &#123;</span><br><span class="line">    <span class="comment">//该算法使用快慢指针找到链表中间节点，然后将链表切分，将后半部分翻转，再进行比较</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        ListNode slow = head, fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            slow = slow.next;</span><br><span class="line">            fast = fast.next.next;</span><br><span class="line">        &#125;<span class="comment">//使用快慢指针使slow指针到达链表中间</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(fast != <span class="keyword">null</span>) slow = slow.next;<span class="comment">//链表节点个数为奇数，slow指针右移离开中间节点</span></span><br><span class="line"></span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur.next != slow)&#123;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = <span class="keyword">null</span>;<span class="comment">//切分链表为两部分，后半部分第一个节点为slow</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> isEqual(head, reverseList(slow));</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">        ListNode cur = head;</span><br><span class="line">        <span class="keyword">while</span>(cur != <span class="keyword">null</span>)&#123;</span><br><span class="line">            ListNode nextTemp = cur.next;</span><br><span class="line">            cur.next = pre;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = nextTemp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isEqual</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val != l2.val) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>将链表奇数节点和偶数节点分别放在一起：328 （O（n）和O（1））</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">oddEvenList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="keyword">null</span>) <span class="keyword">return</span> head;</span><br><span class="line"></span><br><span class="line">        ListNode odd = head, even = head.next;</span><br><span class="line">        ListNode evenHead = even;</span><br><span class="line">        <span class="keyword">while</span>(even != <span class="keyword">null</span> &amp;&amp; even.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">            odd.next = even.next;</span><br><span class="line">            odd = odd.next;</span><br><span class="line">            even.next = odd.next;</span><br><span class="line">            even = even.next;</span><br><span class="line">        &#125;</span><br><span class="line">        odd.next = evenHead;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;找出两个链表的交点：160&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://thmasterplan.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>二分查找</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/</id>
    <published>2020-02-12T07:23:45.000Z</published>
    <updated>2020-02-12T07:24:36.505Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>求开方：69</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">mySqrt</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(x &lt;= <span class="number">1</span>) <span class="keyword">return</span> x;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">1</span>, end = x;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> sqrt = x/mid;<span class="comment">//不使用square与mid*mid判断是因为可能整型溢出</span></span><br><span class="line">            <span class="keyword">if</span>(sqrt == mid) <span class="keyword">return</span> mid;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(sqrt &lt; mid) end = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> start = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> end;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>寻找比目标字母大的最小字母：744</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">char</span> <span class="title">nextGreatestLetter</span><span class="params">(<span class="keyword">char</span>[] letters, <span class="keyword">char</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(target &lt; letters[<span class="number">0</span>] || target &gt;= letters[letters.length-<span class="number">1</span>]) <span class="keyword">return</span> letters[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = letters.length - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(letters[mid] == target)&#123;</span><br><span class="line">                <span class="keyword">int</span> i = mid+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">while</span>(letters[i] == target) i++;</span><br><span class="line">                <span class="keyword">return</span> letters[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(letters[mid] &lt; target) start = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> end = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> letters[end+<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>有序数组中的单一元素：540（时空复杂度要求为O（logn）和O(1)）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">singleNonDuplicate</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = start + (end - start)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(mid%<span class="number">2</span> == <span class="number">1</span>) mid--;<span class="comment">//只对偶数索引进行二分查找</span></span><br><span class="line">            <span class="comment">//以[3,3,7,7,10,11,11]为例，只有当单一元素出现后，其后的数组部分，偶数索引mid处才不满足nums[mid] == nums[mid+1]</span></span><br><span class="line">            <span class="keyword">if</span>(nums[mid] == nums[mid+<span class="number">1</span>]) start = mid + <span class="number">2</span>;<span class="comment">//单一元素一定在mid后</span></span><br><span class="line">            <span class="keyword">else</span> end = mid;<span class="comment">//单一元素为mid或者在mid之前</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[start];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>寻找第一个错误的版本：278</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> <span class="keyword">extends</span> <span class="title">VersionControl</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">firstBadVersion</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = n;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(isBadVersion(mid)) high = mid;<span class="comment">//第mid个版本错误，之后全是错的，向前继续找第一个错误的版本</span></span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;<span class="comment">//第mid个版本正确，向后找</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>寻找旋转排序数组中的最小值：153</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findMin</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= nums[high]) high = mid;</span><br><span class="line">            <span class="keyword">else</span> low = mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[low];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*时间复杂度O(n)</span></span><br><span class="line"><span class="comment">    public int findMin(int[] nums) &#123;</span></span><br><span class="line"><span class="comment">        for(int i = 0; i &lt; nums.length - 1; i++)&#123;</span></span><br><span class="line"><span class="comment">            if(nums[i] &gt; nums[i+1]) return nums[i+1];</span></span><br><span class="line"><span class="comment">        &#125;</span></span><br><span class="line"><span class="comment">        return nums[0];</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>在排序数组中查找元素的第一个和最后一个位置：34</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] searchRange(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> firstIndex = findFirst(nums, target);</span><br><span class="line">        <span class="keyword">if</span>(nums[firstIndex] != target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;-<span class="number">1</span>,-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> lastIndex = findLast(nums,target);</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length-<span class="number">1</span>] == target) <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstIndex,nums.length-<span class="number">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;firstIndex, firstIndex &lt; lastIndex ? lastIndex : firstIndex&#125;;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findFirst</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &gt;= target) high = mid;<span class="comment">//向左逼近，找左边界</span></span><br><span class="line">            <span class="keyword">else</span> low = mid + <span class="number">1</span>;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">findLast</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">0</span>, high = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)&#123;</span><br><span class="line">            <span class="keyword">int</span> mid = low + (high - low)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid] &lt;= target) low = mid + <span class="number">1</span>;<span class="comment">//向右逼近，找右边界，注意若最后一个数为target，则low不用-1</span></span><br><span class="line">            <span class="keyword">else</span> high = mid;</span><br><span class="line">           </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> low-<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;求开方：69&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://thmasterplan.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>排序</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E6%8E%92%E5%BA%8F/</id>
    <published>2020-02-11T08:07:19.000Z</published>
    <updated>2020-02-11T08:09:13.250Z</updated>
    
    <content type="html"><![CDATA[<h3 id="常见排序算法"><a href="#常见排序算法" class="headerlink" title="常见排序算法"></a>常见排序算法</h3><p><img src="排序.jpg" alt=""></p><ul><li><p>选择排序：从数组开始处遍历，找到剩余未遍历数组中的最小值，与本次遍历第一个数交换，重复此过程，每一次内层循环找到未遍历数组的最小值，外层循环中将一个最小值排好序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length - <span class="number">1</span>; i++)&#123;</span><br><span class="line"><span class="keyword">int</span> minPostion = i;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt; nums.length; j++)&#123;</span><br><span class="line">minPostion = nums[minPostion] &gt; nums[j] ? j :minPostion;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(nums, minPostion, i);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p>冒泡排序：内层循环两两比较，将大的数放在后面，最终结果是一次内层循环将一个最大的数排好顺序，与选择排序恰好相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length-<span class="number">1</span>; i &gt; <span class="number">0</span>; i--)&#123;<span class="comment">//外层循环决定最大的数的位置</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[j] &gt; nums[j+<span class="number">1</span>]) swap(nums, j, j+<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>插入排序</strong>：外层循环遍历数组（选择某张牌），内层循环将外层循环选择的牌插入到前面已经排好序的牌中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[j] &lt; nums[j-<span class="number">1</span>]) swap(nums, j, j-<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>插入排序在样本较小且基本有序时效率较高。</p></li><li><p><strong>堆排序</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums)</span></span>&#123;</span><br><span class="line"><span class="comment">//1.构建大顶堆</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.length/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)&#123;</span><br><span class="line">           <span class="comment">//从第一个非叶子结点从下至上，从右至左调整结构</span></span><br><span class="line">           adjustHeap(nums,i,nums.length);</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="comment">//2.调整堆结构+交换堆顶元素与末尾元素</span></span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> j = nums.length - <span class="number">1</span>; j &gt; <span class="number">0</span>; j--)&#123;</span><br><span class="line">           swap(nums,<span class="number">0</span>,j);<span class="comment">//将堆顶元素与末尾元素进行交换</span></span><br><span class="line">           adjustHeap(nums,<span class="number">0</span>,j);<span class="comment">//重新对堆进行调整</span></span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">adjustHeap</span><span class="params">(<span class="keyword">int</span>[] nums,<span class="keyword">int</span> i,<span class="keyword">int</span> length)</span></span>&#123;</span><br><span class="line">       <span class="keyword">int</span> temp =  nums[i];<span class="comment">//先取出当前元素i</span></span><br><span class="line">       </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> k = i*<span class="number">2</span> + <span class="number">1</span>; k &lt; length; k = k*<span class="number">2</span> + <span class="number">1</span>)&#123;<span class="comment">//从i结点的左子结点开始，也就是2i+1处开始</span></span><br><span class="line">           <span class="keyword">if</span>(k + <span class="number">1</span> &lt; length &amp;&amp;  nums[k] &lt; nums[k+<span class="number">1</span>]) k++;<span class="comment">//如果左子结点小于右子结点，k指向右子结点</span></span><br><span class="line">               </span><br><span class="line">           <span class="keyword">if</span>( nums[k] &gt;temp)&#123;<span class="comment">//如果子节点大于父节点，将子节点值赋给父节点（不用进行交换）</span></span><br><span class="line">               nums[i] =  nums[k];</span><br><span class="line">               i = k;</span><br><span class="line">           &#125;<span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">           </span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">        nums[i] = temp;<span class="comment">//将temp值放到最终的位置</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>归并排序</strong>（Java<strong>对象排序</strong>使用，对象排序要求稳定性）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">/**   </span></span><br><span class="line"><span class="comment">    * 对数组的left至right这部分进行排序</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> left</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span> right</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(left == right) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = left + (right - left)/<span class="number">2</span>;<span class="comment">//防止整型溢出</span></span><br><span class="line">sort(nums, left, mid);<span class="comment">//对数组的左半部分排序</span></span><br><span class="line">sort(nums, mid+<span class="number">1</span>, right);<span class="comment">//对数组的右半部分排序</span></span><br><span class="line">merge(nums, left, mid+<span class="number">1</span>, right);<span class="comment">//合并数组的两半部分</span></span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 合并数组的任意两半部分（均有序的情况下）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> left, <span class="keyword">int</span> mid, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span>[] result = <span class="keyword">new</span> <span class="keyword">int</span>[right - left + <span class="number">1</span>];</span><br><span class="line">  </span><br><span class="line"><span class="keyword">int</span> i = left, j = mid;</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span>(i &lt; mid &amp;&amp; j &lt;= right)&#123;</span><br><span class="line"><span class="keyword">if</span>(nums[i] &lt;= nums[j])&#123;</span><br><span class="line">result[k++] = nums[i++];</span><br><span class="line">&#125;<span class="keyword">else</span> result[k++] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(i &lt; mid)&#123;</span><br><span class="line">result[k++] = nums[i++];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">while</span>(j &lt;= right)&#123;</span><br><span class="line">result[k++] = nums[j++];</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line">k = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(i = left; i &lt;= right; i++)&#123;</span><br><span class="line">nums[i] = result[k++];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><ul><li><p><strong>快速排序</strong>（Java<strong>基础类型数据排序</strong>使用双轴快排）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">sort</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> leftBound, <span class="keyword">int</span> rightBound)</span></span>&#123;</span><br><span class="line"><span class="keyword">if</span>(leftBound &gt;= rightBound) <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> pivotIndex = partition(nums, leftBound, rightBound);<span class="comment">//得到每一次划分后轴的位置</span></span><br><span class="line">sort(nums, leftBound, pivotIndex-<span class="number">1</span>);<span class="comment">//对轴左边的部分继续进行划分</span></span><br><span class="line">sort(nums, pivotIndex+<span class="number">1</span>, rightBound);<span class="comment">//对轴右边的部分进行划分</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 一次划分将小于轴的数放在其左边，大于轴的数放在其右边</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> leftBound</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> rightBound</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> pivotIndex(轴的位置)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> leftBound, <span class="keyword">int</span> rightBound)</span></span>&#123;</span><br><span class="line"><span class="keyword">int</span> pivot = nums[rightBound];<span class="comment">//将右边界的数定义为轴</span></span><br><span class="line"><span class="keyword">int</span> left = leftBound, right = rightBound - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line"><span class="keyword">while</span>(left &lt;= right &amp;&amp; nums[left] &lt;= pivot) left++;<span class="comment">//从左往右找到第一个比轴大的数</span></span><br><span class="line"><span class="keyword">while</span>(left &lt;=  right &amp;&amp; nums[right] &gt; pivot) right--;<span class="comment">//从右往左找到第一个比轴小的数</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(left &lt; right) swap(nums, left, right);<span class="comment">//交换</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">swap(nums, left, rightBound);<span class="comment">//交换nums[left]与轴则完成一次划分</span></span><br><span class="line"><span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;常见排序算法&quot;&gt;&lt;a href=&quot;#常见排序算法&quot; class=&quot;headerlink&quot; title=&quot;常见排序算法&quot;&gt;&lt;/a&gt;常见排序算法&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;排序.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;选择排序：从数组开始处遍
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://thmasterplan.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>双指针</title>
    <link href="http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/"/>
    <id>http://thmasterplan.cn/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/%E5%8F%8C%E6%8C%87%E9%92%88/</id>
    <published>2020-02-09T11:05:21.000Z</published>
    <updated>2020-02-09T11:06:47.339Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>升序数组的TwoSum:167</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] twoSum(<span class="keyword">int</span>[] numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">if</span>(numbers == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = numbers.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)&#123;</span><br><span class="line">            <span class="keyword">if</span>(numbers[start] + numbers[end] == target)&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;start+<span class="number">1</span>, end+<span class="number">1</span>&#125;;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(numbers[start] + numbers[end] &lt; target)&#123;</span><br><span class="line">                start++;</span><br><span class="line">            &#125; <span class="keyword">else</span> end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断某个数是否为平方数之和：633</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">judgeSquareSum</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(c &lt; <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = (<span class="keyword">int</span>)Math.sqrt(c);</span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">int</span> squareSum = start*start + end*end;</span><br><span class="line">            <span class="keyword">if</span>(squareSum == c) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(squareSum &lt; c) start++;</span><br><span class="line">            <span class="keyword">else</span> end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>反转字符串中的元音字母：345</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">reverseVowels</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        HashSet&lt;Character&gt; vowels = <span class="keyword">new</span> HashSet&lt;&gt;(</span><br><span class="line">        Arrays.asList(<span class="string">'a'</span>, <span class="string">'e'</span>, <span class="string">'i'</span>, <span class="string">'o'</span>, <span class="string">'u'</span>, <span class="string">'A'</span>, <span class="string">'E'</span>, <span class="string">'I'</span>, <span class="string">'O'</span>, <span class="string">'U'</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">char</span>[] result = <span class="keyword">new</span> <span class="keyword">char</span>[s.length()];</span><br><span class="line">    </span><br><span class="line">        <span class="keyword">while</span>(start &lt;= end)&#123;</span><br><span class="line">            <span class="keyword">char</span> startC = s.charAt(start);</span><br><span class="line">            <span class="keyword">char</span> endC = s.charAt(end);</span><br><span class="line">            <span class="keyword">if</span>(!vowels.contains(startC))&#123;</span><br><span class="line">                result[start++] = startC;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!vowels.contains(endC))&#123;</span><br><span class="line">                result[end--] = endC;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                result[start++] = endC;</span><br><span class="line">                result[end--] = startC;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String(result);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>给定一个非空字符串 <code>s</code>，<strong>最多</strong>删除一个字符。判断是否能成为回文字符串:680</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">validPalindrome</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> left = <span class="number">0</span>, right = s.length() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) == s.charAt(right))&#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">return</span> isPalindrome(s, left+<span class="number">1</span>, right) || isPalindrome(s, left, right-<span class="number">1</span>);<span class="comment">//如果左右不对称，则判断删除s.charAt(left)或者s.charAt(right)后的子字符串是否为回文串</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isPalindrome</span><span class="params">(String s, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(left &lt;= right)&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(left) != s.charAt(right)) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                left++;</span><br><span class="line">                right--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>合并两个有序数组：88</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">merge</span><span class="params">(<span class="keyword">int</span>[] nums1, <span class="keyword">int</span> m, <span class="keyword">int</span>[] nums2, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = m - <span class="number">1</span>, j = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> k = m+n-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span> &amp;&amp; j &gt;= <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums2[j] &gt; nums1[i]) nums1[k--] = nums2[j--];</span><br><span class="line">            <span class="keyword">else</span> nums1[k--] = nums1[i--];</span><br><span class="line">        &#125;<span class="comment">//从两个数组尾部开始比较大小</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//将剩余的某个数组中未比较的元素写入nums1</span></span><br><span class="line">        <span class="keyword">while</span>(i &gt;= <span class="number">0</span>)</span><br><span class="line">            nums1[k--] = nums1[i--];</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span>)</span><br><span class="line">            nums1[k--] = nums2[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>判断链表中是否有环：141（快慢指针）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode fast = head;</span><br><span class="line">        ListNode slow = head;</span><br><span class="line">        <span class="keyword">while</span>(slow != <span class="keyword">null</span> &amp;&amp; fast!= <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>)&#123;</span><br><span class="line">                slow = slow.next;</span><br><span class="line">                fast = fast.next.next;</span><br><span class="line">                <span class="keyword">if</span>(fast == slow)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>通过删除字母匹配到字典里最长单词：524</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">findLongestWord</span><span class="params">(String s, List&lt;String&gt; d)</span> </span>&#123;</span><br><span class="line">        String result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(String target : d)&#123;</span><br><span class="line">            <span class="keyword">int</span> targetLen = target.length();</span><br><span class="line">            <span class="keyword">if</span>(isSubStr(s, target))&#123;</span><br><span class="line">               <span class="keyword">if</span>(maxLength &lt; targetLen)&#123;</span><br><span class="line">                   maxLength = targetLen;</span><br><span class="line">                   result = target;</span><br><span class="line">               &#125;<span class="keyword">else</span> <span class="keyword">if</span>(maxLength == targetLen)&#123;</span><br><span class="line">                   <span class="keyword">if</span>(result.compareTo(target) &lt; <span class="number">0</span>) <span class="keyword">continue</span>;<span class="comment">//比较字符串之间的字典顺序使用compareTo方法</span></span><br><span class="line">                   <span class="keyword">else</span> result = target;</span><br><span class="line">               &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">isSubStr</span><span class="params">(String s, String target)</span></span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//遍历字符串s,每匹配一个target的字符j加1</span></span><br><span class="line">        <span class="keyword">while</span>(i &lt; s.length() &amp;&amp; j &lt; target.length())&#123;</span><br><span class="line">            <span class="keyword">if</span>(s.charAt(i) == target.charAt(j)) j++;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> j == target.length();<span class="comment">//若j等于target.length(),说明target是s的一部分</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;升序数组的TwoSum:167&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="面试刷题" scheme="http://thmasterplan.cn/categories/%E9%9D%A2%E8%AF%95%E5%88%B7%E9%A2%98/"/>
    
    
      <category term="leetcode" scheme="http://thmasterplan.cn/tags/leetcode/"/>
    
  </entry>
  
  <entry>
    <title>for foreach iterator</title>
    <link href="http://thmasterplan.cn/JAVA/for-foreach-iterator/"/>
    <id>http://thmasterplan.cn/JAVA/for-foreach-iterator/</id>
    <published>2020-01-31T08:23:18.000Z</published>
    <updated>2020-01-31T08:36:35.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、形式"><a href="#一、形式" class="headerlink" title="一、形式"></a>一、形式</h3><ol><li>for: <code>for（int i=0;i&lt;arr.size();i++）{...}</code></li><li>foreach:<code>for（int　i：arr）{...}</code></li><li>iterator:<code>Iterator it = arr.iterator();while(it.hasNext()){ object o =it.next(); ...}</code></li></ol><h3 id="二、差别"><a href="#二、差别" class="headerlink" title="二、差别"></a>二、差别</h3><ol><li>for需要指定集合的大小和集合元素的类型。</li><li>foreach需要知道集合元素的类型。</li><li>iterator既不需要指定集合元素的类型也不需要指定集合的大小。</li><li>foreach是iterator的语法糖，其底层使用iterator实现。</li><li>不能使用foreach语句进行add/remove操作。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、形式&quot;&gt;&lt;a href=&quot;#一、形式&quot; class=&quot;headerlink&quot; title=&quot;一、形式&quot;&gt;&lt;/a&gt;一、形式&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;for: &lt;code&gt;for（int i=0;i&amp;lt;arr.size();i++）{...}&lt;/code&gt;&lt;
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>Java容器</title>
    <link href="http://thmasterplan.cn/JAVA/Java%E5%AE%B9%E5%99%A8/"/>
    <id>http://thmasterplan.cn/JAVA/Java%E5%AE%B9%E5%99%A8/</id>
    <published>2020-01-18T07:35:59.000Z</published>
    <updated>2020-01-18T07:44:02.102Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Java容器关系图"><a href="#Java容器关系图" class="headerlink" title="Java容器关系图"></a>Java容器关系图</h3><p><img src="Java容器.jpg" alt=""></p><ul><li>图片来源：<a href="https://zhuanlan.zhihu.com/p/29421226" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/29421226</a></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Java容器关系图&quot;&gt;&lt;a href=&quot;#Java容器关系图&quot; class=&quot;headerlink&quot; title=&quot;Java容器关系图&quot;&gt;&lt;/a&gt;Java容器关系图&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;Java容器.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>接口与抽象类</title>
    <link href="http://thmasterplan.cn/JAVA/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/"/>
    <id>http://thmasterplan.cn/JAVA/%E6%8E%A5%E5%8F%A3%E4%B8%8E%E6%8A%BD%E8%B1%A1%E7%B1%BB/</id>
    <published>2020-01-14T03:50:19.000Z</published>
    <updated>2020-01-14T04:16:11.139Z</updated>
    
    <content type="html"><![CDATA[<h3 id="接口与抽象类的异同"><a href="#接口与抽象类的异同" class="headerlink" title="接口与抽象类的异同"></a>接口与抽象类的异同</h3><p><img src="接口与抽象类的区别.png" alt=""></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;接口与抽象类的异同&quot;&gt;&lt;a href=&quot;#接口与抽象类的异同&quot; class=&quot;headerlink&quot; title=&quot;接口与抽象类的异同&quot;&gt;&lt;/a&gt;接口与抽象类的异同&lt;/h3&gt;&lt;p&gt;&lt;img src=&quot;接口与抽象类的区别.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/tags/JAVA/"/>
    
  </entry>
  
  <entry>
    <title>进程管理</title>
    <link href="http://thmasterplan.cn/Linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"/>
    <id>http://thmasterplan.cn/Linux/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</id>
    <published>2019-12-09T05:54:57.000Z</published>
    <updated>2019-12-11T07:28:24.900Z</updated>
    
    <content type="html"><![CDATA[<h3 id="进程管理工具"><a href="#进程管理工具" class="headerlink" title="进程管理工具"></a>进程管理工具</h3><ul><li><p><code>lscpu</code>：显示cpu信息</p></li><li><p><code>pstree -p</code>：打印进程树</p></li><li><p><code>ps</code>：(process state)，Linux系统各进程的相关信息均保存在/proc/PID下</p><ul><li><p>BSD选项，选项前没有<code>-</code>：</p><ul><li><p><code>a</code>：打印所有终端中的进程</p><ul><li><p>STAT：</p><p><img src="STAT.jpg" alt=""></p></li></ul></li><li><p><code>x</code>：与终端无关的进程，例如守护进程</p></li><li><p><code>u</code>：额外显示进程的USER，CPU/MEM占比，RSS（常驻内存集，不包括交换分区）与VSZ（分配给进程的虚拟内存，包括交换分区），START（开始运行的时间）。</p></li><li><p><code>f</code>：显示进程父子关系</p></li><li><p><code>k -%cpu</code>：倒序排序显示cpu占比，<code>-</code>表示倒序</p></li><li><p><code>o</code>：只显示某些选项，后面跟要显示的选项；例如<code>ps axo psr</code>：显示命令使用哪个CPU核</p></li><li><p>Linux优先级：<code>o ni,pri,rtprio</code></p><p><img src="Linux优先级.jpg" alt=""></p></li></ul></li></ul></li><li><p>搜索进程</p><ul><li><p>按预定义的模式：<code>pgrep [options] pattern</code>：</p><ul><li><code>-u uid</code>：有效用户</li><li><code>-U uid</code>：运行命令者</li><li><code>-t terminal</code>：与指定终端相关的进程</li><li><code>-l</code>：显示进程名，例如<code>pgrep -l &#39;^ba.*&#39;</code></li><li><code>-a</code>：显示完整格式的进程名</li><li><code>-P pid</code>：显示指定进程的子进程</li></ul></li><li><p>按程序名称: <code>pidof 程序名</code></p></li></ul></li><li><p>进程管理工具：<code>top</code>，内置命令：</p><ul><li>排序：<code>P</code>：按%CPU；<code>M</code>：按%MEM；<code>T</code>：按累积占据CPU时长(TIME+)</li><li><p>首部信息显示：</p><ul><li>uptime信息：<code>l</code></li><li>tasks及cpu信息：<code>t</code></li><li>cpu内核分别显示：<code>1</code></li><li>内存信息：<code>m</code></li></ul></li><li><p>退出：<code>q</code></p></li><li>修改刷新时间间隔：<code>s</code></li><li>终止进程：<code>k</code></li><li>保存当前进程信息：<code>W</code></li><li><p>栏位信息：</p><ul><li><code>us</code>：用户空间</li><li><code>sy</code>：内核空间</li><li><code>ni</code>：调整nice时间</li><li><code>id</code>：空闲</li><li><code>wa</code>：等待IO时间</li><li><code>hi</code>：硬中断</li><li><code>si</code>：软中断</li><li><code>st</code>：虚拟机偷走的时间</li></ul></li><li><p>选项：</p><ul><li><code>-b</code>：显示所有进程（默认只显示前一部分）</li><li><code>-p</code>：指定显示某些进程</li><li><code>-H</code>：线程模式；示例：<code>top -H -p PID</code>，指定显示某个进程的所有线程</li></ul></li><li><p>EPEL源的<code>htop</code>，功能更丰富的进程管理工具</p></li></ul></li><li><p>内存空间使用状态：<code>free</code></p><ul><li><code>-h</code>：易读格式</li><li><code>-s n</code>：指定刷新间隔为n秒</li></ul></li><li><p>查看虚拟内存使用状态：<code>vmstat</code></p></li><li><p>系统监控工具：</p><ul><li><p><code>iostat</code>：统计CPU和设备IO信息</p></li><li><p><code>iftop</code>：显示带宽使用情况，EPEL源</p></li><li><p><code>dstat</code>：替代iostat,vmstat,ifstat</p></li><li><p><code>iotop</code>：I/O监视器</p></li><li><p><code>nload</code>：查看网络实时吞吐量</p></li><li><p><code>lsof</code>：list open files；恢复文件：</p><p><img src="恢复文件.jpg" alt=""></p></li></ul></li><li><p>进程信号与计划任务实现</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;进程管理工具&quot;&gt;&lt;a href=&quot;#进程管理工具&quot; class=&quot;headerlink&quot; title=&quot;进程管理工具&quot;&gt;&lt;/a&gt;进程管理工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;lscpu&lt;/code&gt;：显示cpu信息&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>matplotlib</title>
    <link href="http://thmasterplan.cn/Python/matplotlib/"/>
    <id>http://thmasterplan.cn/Python/matplotlib/</id>
    <published>2019-12-05T04:50:04.000Z</published>
    <updated>2019-12-06T06:38:21.568Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>基本用法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">y = x**<span class="number">3</span>+<span class="number">1</span></span><br><span class="line">plt.plot(x,y)</span><br><span class="line">plt.show</span><br></pre></td></tr></table></figure></li><li><p>figure</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">x = np.linspace(<span class="number">-1</span>,<span class="number">1</span>,<span class="number">50</span>)</span><br><span class="line">y = x**<span class="number">3</span>+<span class="number">1</span></span><br><span class="line">y2 = x**<span class="number">2</span><span class="number">-2</span></span><br><span class="line"></span><br><span class="line">plt.figure() <span class="comment">#创建一张图</span></span><br><span class="line">plt.plot(x,y,label=<span class="string">'up'</span>)</span><br><span class="line">plt.plot(x,y2,color=<span class="string">'red'</span>,linewidth=<span class="number">1.5</span>,linestyle=<span class="string">'--'</span>,label=<span class="string">'down'</span>)</span><br><span class="line"></span><br><span class="line">plt.legend()<span class="comment">#设置图例，需在调用plot()方法时指定label</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#plt.annotate()该方法对图中数据作详细注释</span></span><br><span class="line"><span class="comment">#plt.text()该方法在作简单的文本注释</span></span><br><span class="line"></span><br><span class="line">plt.xlim((<span class="number">-1</span>,<span class="number">2</span>)) <span class="comment">#设置x轴范围</span></span><br><span class="line">plt.ylim((<span class="number">-2</span>,<span class="number">3</span>)) <span class="comment">#设置y轴范围</span></span><br><span class="line"><span class="comment">#plt.xticks(np.linspace(-1,2,5)) #设置x轴范围并均匀划分为5段</span></span><br><span class="line"><span class="comment">#plt.yticks([-2,0,3],['bad','normal','good']) #以文字代替数字表示y轴范围</span></span><br><span class="line">plt.xlabel(<span class="string">'This is x'</span>) <span class="comment">#设置x轴的标签</span></span><br><span class="line">plt.ylabel(<span class="string">'This is y'</span>)</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>散点图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">X = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1024</span>)</span><br><span class="line">Y = np.random.normal(<span class="number">0</span>,<span class="number">1</span>,<span class="number">1024</span>)</span><br><span class="line">T = np.arctan2(Y,X)</span><br><span class="line">plt.scatter(X,Y,s=<span class="number">75</span>,c=T,alpha=<span class="number">0.5</span>)</span><br><span class="line"><span class="comment">#plt.bar()柱状图</span></span><br><span class="line">plt.xlim((<span class="number">-1.5</span>,<span class="number">1.5</span>))</span><br><span class="line">plt.ylim((<span class="number">-1.5</span>,<span class="number">1.5</span>))</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li><li><p>subplot</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">plt.figure()</span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">2</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">3</span>])</span><br><span class="line"></span><br><span class="line">plt.subplot(<span class="number">2</span>,<span class="number">2</span>,<span class="number">4</span>)</span><br><span class="line">plt.plot([<span class="number">0</span>,<span class="number">1</span>],[<span class="number">0</span>,<span class="number">4</span>])</span><br><span class="line"></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;基本用法&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thmasterplan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://thmasterplan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Numpy_Pandas</title>
    <link href="http://thmasterplan.cn/Python/Numpy-Pandas/"/>
    <id>http://thmasterplan.cn/Python/Numpy-Pandas/</id>
    <published>2019-12-05T04:49:23.000Z</published>
    <updated>2019-12-05T13:27:39.968Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><ul><li><p>创建数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line">arr = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>],[<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"></span><br><span class="line">print(arr)</span><br><span class="line">print(<span class="string">'元素类型：'</span>,arr.dtype) <span class="comment">#默认为int32，也可在np.array()中指定参数dtype=np.float/np.float32/...</span></span><br><span class="line">print(<span class="string">'维度:'</span>,arr.ndim) <span class="comment">#2</span></span><br><span class="line">print(<span class="string">'形状:'</span>,arr.shape) <span class="comment">#（2，3）</span></span><br><span class="line">print(<span class="string">'大小：'</span>,arr.size) <span class="comment">#6</span></span><br><span class="line"></span><br><span class="line">arr = np.zeros((<span class="number">3</span>,<span class="number">4</span>)) <span class="comment">#返回3行4列全为0的二维数组</span></span><br><span class="line"></span><br><span class="line">arr = np.ones((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#返回2行2列全为1的二维数组</span></span><br><span class="line"></span><br><span class="line">arr = np.arange(<span class="number">12</span>,<span class="number">20</span>, <span class="number">2</span>).reshape((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#arange返回一个一维数组，取值区间为[12,20)步长为2，数组的reshape方法将其变为2行2列的二维数组并返回</span></span><br><span class="line"></span><br><span class="line">arr = np.linspace(<span class="number">1</span>,<span class="number">10</span>,<span class="number">10</span>) <span class="comment">#生成等差数列</span></span><br></pre></td></tr></table></figure></li><li><p>基础运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">a = np.array([<span class="number">2</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">8</span>])</span><br><span class="line">b = np.arange(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(a-b) <span class="comment">#[2 3 4 5]</span></span><br><span class="line">print(b**<span class="number">2</span>) <span class="comment">#[0 1 4 9]</span></span><br><span class="line">print(np.sin(a)) <span class="comment">#[ 0.90929743 -0.7568025  -0.2794155   0.98935825]</span></span><br><span class="line">print(<span class="number">10</span>*np.cos(b)) <span class="comment">#[10.     5.40302306 -4.16146837 -9.89992497]</span></span><br><span class="line">print(b==<span class="number">2</span>) <span class="comment">#[False False  True False]</span></span><br><span class="line"></span><br><span class="line">a = np.array([[<span class="number">1</span>,<span class="number">2</span>],</span><br><span class="line">          [<span class="number">0</span>,<span class="number">1</span>]])</span><br><span class="line">b = np.arange(<span class="number">4</span>).reshape(<span class="number">2</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">print(a*b) <span class="comment">#对应位置做乘法：[[0 2] [0 3]]</span></span><br><span class="line">print(a.dot(b)) <span class="comment">#矩阵乘法：[[4 7] [2 3]]</span></span><br><span class="line"></span><br><span class="line">a = np.random.random((<span class="number">2</span>,<span class="number">2</span>)) <span class="comment">#随机生成两行两列的二维数组</span></span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line">print(np.sum(a)) <span class="comment">#求数组a中所有元素之和</span></span><br><span class="line">print(np.min(a,axis=<span class="number">1</span>)[<span class="number">1</span>]) <span class="comment">#axis=1表示取每一行的最小值，axis=0表示取每一列的最小值</span></span><br><span class="line">print(np.max(a)) <span class="comment">#求最大值</span></span><br><span class="line">print(np.argmin(a)) <span class="comment">#最小值的索引</span></span><br><span class="line">print(np.argmax(a)) <span class="comment">#最大值的索引</span></span><br><span class="line">print(np.mean(a)) <span class="comment">#求平均值</span></span><br><span class="line">print(np.median(a)) <span class="comment">#求中位数</span></span><br><span class="line">print(np.cumsum(a)) <span class="comment">#求累加和，返回一个数组</span></span><br><span class="line">print(np,sort(a)) <span class="comment">#返回每一行的排序结果（二维数组）</span></span><br><span class="line">print(a.T) <span class="comment">#转置二维数组</span></span><br></pre></td></tr></table></figure></li><li><p>访问数组：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">A = np.arange(<span class="number">1</span>,<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line">print(A[<span class="number">1</span>,<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">#5；格式：A[行，列]，同时可分别对行、列做切片操作</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> row <span class="keyword">in</span> A:</span><br><span class="line">    print(row) <span class="comment">#迭代打印每一行</span></span><br><span class="line"><span class="keyword">for</span> col <span class="keyword">in</span> A.T:</span><br><span class="line">    print(col) <span class="comment">#迭代打印A每的一列</span></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> A.flat:</span><br><span class="line">    print(item) <span class="comment">#迭代访问二维数组的每一个元素</span></span><br></pre></td></tr></table></figure></li><li><p>数组的合并和分割：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>])</span><br><span class="line">B = np.array([<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br><span class="line"></span><br><span class="line">print(np.vstack((A,B))) <span class="comment">#垂直合并</span></span><br><span class="line"><span class="comment">#[[1 2 3]</span></span><br><span class="line"><span class="comment"># [4 5 6]]</span></span><br><span class="line">    </span><br><span class="line">print(np.hstack((A,b))) <span class="comment">#水平合并</span></span><br><span class="line"><span class="comment">#[1 2 3 4 5 6]</span></span><br><span class="line"></span><br><span class="line">A = np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line"><span class="comment"># 等量分割：np.split(A,3,axis=0) &lt;==&gt; np.vsplit(A,3)</span></span><br><span class="line">      <span class="comment">#  np.split(A,2,axis=1) &lt;==&gt; np.hsplit(A,2)</span></span><br><span class="line"><span class="comment">#不等量分割：np.array_split(A,3,axis=1)</span></span><br></pre></td></tr></table></figure></li><li><p>copy与deepcopy</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = np.arange(<span class="number">4</span>) <span class="comment"># a=[0,1,2,3]</span></span><br><span class="line">b = a <span class="comment"># b=[0,1,2,3] 浅拷贝</span></span><br><span class="line">a[<span class="number">0</span>] = <span class="number">10</span> <span class="comment"># b=[10,1,2,3],也即b是a的引用,a改变b也会改变</span></span><br><span class="line"></span><br><span class="line">b = a.copy() <span class="comment">#deep copy：b是一个新的对象</span></span><br></pre></td></tr></table></figure></li><li><p>NumPy 中包含了一个矩阵库<code>numpy.matlib</code>，该模块中的函数返回的是一个矩阵，而不是 ndarray 对象</p></li></ul><h3 id="Pandas"><a href="#Pandas" class="headerlink" title="Pandas"></a>Pandas</h3><ul><li><p>Pandas处理三类数据结构：<code>Series</code>、<code>DataFrame</code>、<code>Panel</code>，它们均构建在Numpy数组之上；<code>DataFrame</code>是<code>Series</code>的容器，<code>Panel</code>是<code>DataFrame</code>的容器。</p><ul><li><p><code>Series</code>是具有均匀数据的<strong>一维数组</strong>结构，其尺寸大小不可变</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">s = pd.Series([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,np.nan,<span class="number">5</span>])</span><br><span class="line">print(s)</span><br><span class="line"><span class="comment"># 0    1.0</span></span><br><span class="line"><span class="comment"># 1    2.0</span></span><br><span class="line"><span class="comment"># 2    3.0</span></span><br><span class="line"><span class="comment"># 3    NaN</span></span><br><span class="line"><span class="comment"># 4    5.0</span></span><br><span class="line"><span class="comment"># dtype: float64</span></span><br></pre></td></tr></table></figure></li><li><p><code>DataFrame</code>是一个具有异构数据的<strong>二维数组</strong>，一个表格其每一列的数据类型可以不同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">dates = pd.date_range(<span class="string">'20190101'</span>,periods=<span class="number">6</span>)</span><br><span class="line">df = pd.DataFrame(np.random.randn(<span class="number">6</span>,<span class="number">4</span>),index=dates,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])<span class="comment">#可以传入字典</span></span><br><span class="line">print(df)</span><br><span class="line"><span class="comment">#          a       b      c       d</span></span><br><span class="line"><span class="comment">#2019-01-01 -0.151005  0.193516 -2.719792 -0.889789</span></span><br><span class="line"><span class="comment">#2019-01-02  1.454217 -0.251116  0.115353  1.467178</span></span><br><span class="line"><span class="comment">#2019-01-03  2.329084 -1.141316 -0.566037 -0.012965</span></span><br><span class="line"><span class="comment">#2019-01-04  0.230406  0.466682  0.156473  1.464802</span></span><br><span class="line"><span class="comment">#2019-01-05  0.628908  0.093684 -0.342491 -0.215695</span></span><br><span class="line"><span class="comment">#2019-01-06 -1.175620  1.210320  0.352923 -0.112040</span></span><br></pre></td></tr></table></figure></li></ul></li></ul><ul><li><code>Panel</code>是具有异构数据的三维数据结构</li></ul><ul><li><p>数据选取</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">df = pd.DataFrame(np.arange(<span class="number">12</span>).reshape(<span class="number">3</span>,<span class="number">4</span>),index=[<span class="string">'A'</span>,<span class="string">'B'</span>,<span class="string">'C'</span>],columns=[<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'d'</span>])</span><br><span class="line">print(df)</span><br><span class="line"><span class="comment">#   a  b   c   d</span></span><br><span class="line"><span class="comment"># A  0  1   2   3</span></span><br><span class="line"><span class="comment"># B  4  5   6   7</span></span><br><span class="line"><span class="comment"># C  8  9   10  11</span></span><br><span class="line"></span><br><span class="line">print(df[<span class="string">'a'</span>]) <span class="comment">#或者print(df.a),打印选取的某列，不能选行，数组类型</span></span><br><span class="line"><span class="comment"># A    0</span></span><br><span class="line"><span class="comment"># B    4</span></span><br><span class="line"><span class="comment"># C    8</span></span><br><span class="line"><span class="comment"># Name: a, dtype: int32</span></span><br><span class="line"></span><br><span class="line">print(df.loc[<span class="string">'A'</span>]) <span class="comment">#打印行，数组类型 &lt;==&gt;df.iloc[0]</span></span><br><span class="line"><span class="comment"># a    0</span></span><br><span class="line"><span class="comment"># b    1</span></span><br><span class="line"><span class="comment"># c    2</span></span><br><span class="line"><span class="comment"># d    3</span></span><br><span class="line"><span class="comment"># Name: A, dtype: int32</span></span><br><span class="line"></span><br><span class="line">print(df[<span class="number">1</span>:<span class="number">2</span>]) <span class="comment">#打印行，DataFrame类型</span></span><br><span class="line"><span class="comment">#   a  b  c  d</span></span><br><span class="line"><span class="comment"># B  4  5  6  7</span></span><br><span class="line"></span><br><span class="line">print(df[<span class="string">'A'</span>:<span class="string">'B'</span>]) <span class="comment">#打印行，DataFrame类型</span></span><br><span class="line"><span class="comment">#   a  b  c  d</span></span><br><span class="line"><span class="comment"># A  0  1  2  3</span></span><br><span class="line"><span class="comment"># B  4  5  6  7</span></span><br></pre></td></tr></table></figure></li><li><p>导入导出数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">data = pd.read_xxx(<span class="string">'fileName.xxx'</span>) <span class="comment">#读取哪种格式的文件就用对应的方法</span></span><br><span class="line">data.to_yyy(<span class="string">'newFileName.yyy'</span>) <span class="comment">#保存为哪种格式的文件就用对应的方法</span></span><br></pre></td></tr></table></figure></li><li><p>合并</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">1</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">df3 = pd.DataFrame(np.ones((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">2</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">print(pd.concat([df1,df2,df3],axis=<span class="number">0</span>,ignore_index=<span class="literal">True</span>))</span><br><span class="line"><span class="comment">#     a    b</span></span><br><span class="line"><span class="comment">#   0  0.0  0.0</span></span><br><span class="line"><span class="comment">#   1  0.0  0.0</span></span><br><span class="line"><span class="comment">#   2  1.0  1.0</span></span><br><span class="line"><span class="comment">#   3  1.0  1.0</span></span><br><span class="line"><span class="comment">#   4  2.0  2.0</span></span><br><span class="line"><span class="comment">#   5  2.0  2.0</span></span><br><span class="line"></span><br><span class="line">df1 = pd.DataFrame(np.ones((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">0</span>,columns=[<span class="string">'a'</span>,<span class="string">'b'</span>])</span><br><span class="line">df2 = pd.DataFrame(np.ones((<span class="number">2</span>,<span class="number">2</span>))*<span class="number">1</span>,columns=[<span class="string">'b'</span>,<span class="string">'c'</span>])</span><br><span class="line">print(pd.concat([df1,df2],ignore_index=<span class="literal">True</span>))<span class="comment">#默认为外连接</span></span><br><span class="line"><span class="comment">#     a    b    c</span></span><br><span class="line"><span class="comment">#  0  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment">#  1  0.0  0.0  NaN</span></span><br><span class="line"><span class="comment">#  2  NaN  1.0  1.0</span></span><br><span class="line"><span class="comment">#  3  NaN  1.0  1.0</span></span><br><span class="line">print(pd.concat([df1,df2],join=<span class="string">'inner'</span>,ignore_index=<span class="literal">True</span>))</span><br><span class="line"><span class="comment">#     b</span></span><br><span class="line"><span class="comment">#  0  0.0</span></span><br><span class="line"><span class="comment">#  1  0.0</span></span><br><span class="line"><span class="comment">#  2  1.0</span></span><br><span class="line"><span class="comment">#  3  1.0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#pd.merge()也可用于合并</span></span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Numpy&quot;&gt;&lt;a href=&quot;#Numpy&quot; class=&quot;headerlink&quot; title=&quot;Numpy&quot;&gt;&lt;/a&gt;Numpy&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;创建数组：&lt;/p&gt;
&lt;figure class=&quot;highlight python&quot;&gt;&lt;table
      
    
    </summary>
    
    
      <category term="Python" scheme="http://thmasterplan.cn/categories/Python/"/>
    
    
      <category term="Python" scheme="http://thmasterplan.cn/tags/Python/"/>
    
  </entry>
  
  <entry>
    <title>Fuzzy CMeans</title>
    <link href="http://thmasterplan.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Fuzzy-CMeans/"/>
    <id>http://thmasterplan.cn/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/Fuzzy-CMeans/</id>
    <published>2019-12-04T08:01:31.000Z</published>
    <updated>2019-12-20T08:38:20.164Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Fuzzy-C-Means-Clustering"><a href="#Fuzzy-C-Means-Clustering" class="headerlink" title="Fuzzy C-Means Clustering"></a>Fuzzy C-Means Clustering</h3><ul><li><p>算法原理</p><p>FCM基于以下目标函数的最小化：</p><script type="math/tex; mode=display">J_m=\sum_{i=1}^N\sum_{j=1}^Cu_{ij}^m\|x_i-c_j\|^2, 1\leq m<\propto</script><script type="math/tex; mode=display">约束条件为\sum_{j=1}^Cu_{ij}=1,i=1,2,3,...,n</script><p>$x_i$表示第$i$个样本点，$c_j$表示簇心，$j$表示簇的个数，$m$是任意大于1的实数，$u_{ij}$表示$x_i$属于簇$j$的概率。</p><p>通过对上述目标函数的迭代优化实现模糊划分，同时更新$u_{ij}$和簇心$c_j$：</p><script type="math/tex; mode=display">u_{ij}=\cfrac{1}{\sum_{k=1}^C(\cfrac{\|x_i-c_j\|}{\|x_i-c_k\|})^\cfrac{2}{m-1}}</script><script type="math/tex; mode=display">c_j=\cfrac{\sum_{i=1}^Nu_{ij}^m.x_i}{\sum_{i=1}^Nu_{ij}^m}</script><p>当$max_{1\leq k \leq c}{||c_{k,new}-c_{k,old}||^2 &lt; \varepsilon}$时迭代终止，$0&lt;\varepsilon&lt;1$，$k$为迭代次数，此过程收敛到局部最小值或$J_m$的鞍点。</p></li><li><p>步骤：</p><ol><li>初始化 矩阵$U=[u_{ij}],U^{(0)}$</li><li>在第$k$次迭代过程中，用$U^{(k)}$计算簇心向量$C^{(k)}=[c_j]$</li><li>更新$U^{(k)},U^{(k+1)}$</li><li>如果满足$||U^{(k+1)}-U^{(k)}|| &lt; \varepsilon$或者$max_{1\leq k \leq c}{||c_{k,new}-c_{k,old}||^2 &lt; \varepsilon}$或者迭代次数达到限制则停止，否则返回步骤2</li></ol></li><li><p>[参考链接]: <a href="https://home.deib.polimi.it/matteucc/Clustering/tutorial_html/cmeans.html" target="_blank" rel="noopener">https://home.deib.polimi.it/matteucc/Clustering/tutorial_html/cmeans.html</a></p></li><li><p>使用<code>skfuzzy.cluster</code>的<code>cmeans</code></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> skfuzzy.cluster <span class="keyword">import</span> cmeans</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据集，500个样本点，二维向量</span></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">500</span>, n_features=<span class="number">2</span>, centers=<span class="number">3</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">plt.scatter(X[:,<span class="number">0</span>],X[:,<span class="number">1</span>],c=<span class="string">'r'</span>,s=<span class="number">8</span>)<span class="comment">#显示原始样本点分布</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line">X = X.T</span><br><span class="line">center, u, u0, d, jm, p, fpc = cmeans(X, c=<span class="number">3</span>, m=<span class="number">2</span>, error=<span class="number">0.005</span>, maxiter=<span class="number">1000</span>)</span><br><span class="line"><span class="comment">#参数：X：样本点；</span></span><br><span class="line">    <span class="comment">#c：指定聚类簇数；</span></span><br><span class="line">    <span class="comment">#m:隶属度指数，一般为2；</span></span><br><span class="line">    <span class="comment">#error：隶属度的变化值小于此则提前结束迭代；</span></span><br><span class="line">    <span class="comment">#maxiter:最大迭代次数</span></span><br><span class="line"><span class="comment">#返回值：center:簇心；</span></span><br><span class="line">    <span class="comment">#u:最后的隶属度矩阵；</span></span><br><span class="line">    <span class="comment">#u0:初始的隶属度矩阵；</span></span><br><span class="line">    <span class="comment">#jm:目标函数的优化历史值；</span></span><br><span class="line">    <span class="comment">#p:迭代次数；</span></span><br><span class="line">    <span class="comment">#fpc:评价聚类好坏的指标，取值0-1，越接近1越好</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> u:</span><br><span class="line">    label = np.argmax(u, axis=<span class="number">0</span>)<span class="comment">#从隶属度矩阵中选取每个样本点隶属度最大的标签，将其归为一类</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">    <span class="keyword">if</span> label[i] == <span class="number">0</span>:</span><br><span class="line">        plt.scatter(X[<span class="number">0</span>][i], X[<span class="number">1</span>][i], c = <span class="string">'r'</span>,s=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">elif</span> label[i] == <span class="number">1</span>:</span><br><span class="line">        plt.scatter(X[<span class="number">0</span>][i], X[<span class="number">1</span>][i], c = <span class="string">'g'</span>,s=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">elif</span> label[i] == <span class="number">2</span>:</span><br><span class="line">        plt.scatter(X[<span class="number">0</span>][i], X[<span class="number">1</span>][i], c = <span class="string">'b'</span>,s=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p><img src="skfuzzy_cmeans.png" alt="原始样本点图像"></p><p><img src="skfuzzy_cmeans1.png" alt="聚类后样本点图像"></p></li><li><p>python实现FCM算法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> make_blobs</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fcm</span><span class="params">(data,center,m,epsilon,maxiter)</span>:</span></span><br><span class="line">    <span class="comment">#初始化模糊矩阵U</span></span><br><span class="line">    u = np.zeros((center,data.shape[<span class="number">0</span>]))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(data.shape[<span class="number">0</span>]):</span><br><span class="line">        sum = <span class="number">0</span></span><br><span class="line">        <span class="keyword">for</span> j <span class="keyword">in</span> range(center):</span><br><span class="line">            <span class="keyword">if</span>(j==center<span class="number">-1</span>):</span><br><span class="line">                u[j][i] = <span class="number">1</span>-sum</span><br><span class="line">            <span class="keyword">else</span>: </span><br><span class="line">                u[j][i]=np.random.rand()</span><br><span class="line">                sum+=u[j][i]</span><br><span class="line">            <span class="keyword">while</span> (sum &gt;= <span class="number">1</span>):</span><br><span class="line">                sum -=u[j][i]</span><br><span class="line">                u[j][i] = u[j][i]/<span class="number">2</span></span><br><span class="line">                sum +=u[j][i]</span><br><span class="line">    c = np.zeros((center,data.shape[<span class="number">1</span>]))</span><br><span class="line">    count = <span class="number">0</span> <span class="comment">#迭代次数</span></span><br><span class="line">    <span class="comment">#计算簇心向量c</span></span><br><span class="line">    <span class="keyword">while</span> count &lt; maxiter<span class="number">-1</span>:</span><br><span class="line">        u2 = u.copy()</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(center):</span><br><span class="line">            sum = <span class="number">0</span></span><br><span class="line">            x = <span class="number">0</span></span><br><span class="line">            y = <span class="number">0</span></span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(u.shape[<span class="number">1</span>]):</span><br><span class="line">                temp = u2[i][j]**m</span><br><span class="line">                x += temp*data[j][<span class="number">0</span>]</span><br><span class="line">                y += temp*data[j][<span class="number">1</span>]</span><br><span class="line">                sum += temp</span><br><span class="line">            c[i]=[x/sum,y/sum]</span><br><span class="line">        <span class="comment">#print(c)</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(u.shape[<span class="number">1</span>]):</span><br><span class="line">            <span class="keyword">for</span> j <span class="keyword">in</span> range(center):</span><br><span class="line">                sum = <span class="number">0</span></span><br><span class="line">                <span class="keyword">for</span> k <span class="keyword">in</span> range(center):</span><br><span class="line">                    temp = np.linalg.norm(data[i]-c[j])/np.linalg.norm(data[i]-c[k])</span><br><span class="line">                    sum += temp**(<span class="number">2</span>/(m<span class="number">-1</span>))</span><br><span class="line">                u[j][i] = <span class="number">1</span>/sum</span><br><span class="line">    </span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">        print(np.linalg.norm(u2 - u))</span><br><span class="line">        <span class="keyword">if</span> np.linalg.norm(u2 - u) &lt; epsilon:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">return</span> u2, u, c, count</span><br><span class="line"></span><br><span class="line"><span class="comment">#创建数据集，1000个样本点，二维向量</span></span><br><span class="line">X, y = make_blobs(n_samples=<span class="number">1000</span>, n_features=<span class="number">2</span>, centers=<span class="number">3</span>, random_state=<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(len(y)):</span><br><span class="line">    <span class="keyword">if</span> y[i] == <span class="number">0</span>:</span><br><span class="line">        plt.scatter(X[i][<span class="number">0</span>],X[i][<span class="number">1</span>],c=<span class="string">'red'</span>,s=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">elif</span> y[i]==<span class="number">1</span>:</span><br><span class="line">        plt.scatter(X[i][<span class="number">0</span>],X[i][<span class="number">1</span>],c=<span class="string">'green'</span>,s=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">elif</span> y[i]==<span class="number">2</span>:</span><br><span class="line">        plt.scatter(X[i][<span class="number">0</span>],X[i][<span class="number">1</span>],c=<span class="string">'blue'</span>,s=<span class="number">8</span>)</span><br><span class="line">    </span><br><span class="line"><span class="comment">#plt.scatter(X[:,0],X[:,1],c='r',s=8)#显示原始样本点分布</span></span><br><span class="line">plt.show()</span><br><span class="line"></span><br><span class="line">plt.figure()</span><br><span class="line"></span><br><span class="line">u, u0, center, count= fcm(X, <span class="number">3</span>, <span class="number">2</span>, <span class="number">0.005</span>, <span class="number">1000</span>)</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> u:</span><br><span class="line">    label = np.argmax(u, axis=<span class="number">0</span>)<span class="comment">#从隶属度矩阵中选取每个样本点隶属度最大的标签，将其归为一类</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000</span>):</span><br><span class="line">    <span class="keyword">if</span> label[i] == <span class="number">0</span>:</span><br><span class="line">        plt.scatter(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], c = <span class="string">'red'</span>,s=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">elif</span> label[i] == <span class="number">1</span>:</span><br><span class="line">        plt.scatter(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], c = <span class="string">'green'</span>,s=<span class="number">8</span>)</span><br><span class="line">    <span class="keyword">elif</span> label[i] == <span class="number">2</span>:</span><br><span class="line">        plt.scatter(X[i][<span class="number">0</span>], X[i][<span class="number">1</span>], c = <span class="string">'b'</span>,s=<span class="number">8</span>)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Fuzzy-C-Means-Clustering&quot;&gt;&lt;a href=&quot;#Fuzzy-C-Means-Clustering&quot; class=&quot;headerlink&quot; title=&quot;Fuzzy C-Means Clustering&quot;&gt;&lt;/a&gt;Fuzzy C-Means 
      
    
    </summary>
    
    
      <category term="机器学习" scheme="http://thmasterplan.cn/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="机器学习" scheme="http://thmasterplan.cn/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>磁盘管理</title>
    <link href="http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
    <id>http://thmasterplan.cn/Linux/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</id>
    <published>2019-11-29T07:26:51.000Z</published>
    <updated>2019-12-02T06:47:09.737Z</updated>
    
    <content type="html"><![CDATA[<h3 id="磁盘工作原理"><a href="#磁盘工作原理" class="headerlink" title="磁盘工作原理"></a>磁盘工作原理</h3><ul><li><p>不同硬盘标识：a-z，aa，ab…</p><p>​      /dev/sda，/dev/sdb</p></li><li><p>同一磁盘的不同分区：1，2，…</p><p>​     /dev/sda1，/dev/sda2，…</p></li><li><p>磁盘存储术语：head(磁头)，track(磁道)，cylinder(柱面)，sector(扇区)</p></li><li><p>磁盘使用步骤：磁盘分区 -&gt; 分区上创建文件系统 -&gt; 将分区挂载到目录</p></li></ul><h3 id="分区管理"><a href="#分区管理" class="headerlink" title="分区管理"></a>分区管理</h3><ul><li><p>分区原因</p><ul><li>隔离系统和程序，可安装多个OS</li><li><p>采用不同文件系统</p></li><li><p>优化I/O性能</p></li><li>实现磁盘空间配额限制</li><li>提高修复速度</li></ul></li><li><p>MBR分区管理</p><ul><li><p>分区不超过2T</p></li><li><p>一块硬盘最多有4个主分区，也可以3主分区+1扩展分区（扩展分区包含N给逻辑分区）</p></li><li><p>MBR分区结构：</p><p><img src="MBR.jpg" alt=""></p></li></ul></li><li><p>GPT分区管理</p><ul><li><p>支持128个分区，分区可达ZB级别</p></li><li><p>GPT分区结构</p><p><img src="GPT.jpg" alt=""></p></li></ul></li><li><p>分区管理命令</p><ul><li>列出块设备：<code>lsblk</code></li><li>查看块设备的UUID（通用唯一识别码）：<code>blkid</code></li><li>创建分区：<ul><li>创建MBR分区：<code>fdisk</code><ul><li><code>fdisk -l</code>查看当前分区情况</li><li><code>fdisk [device]</code>，管理分区，常用子命令：<ul><li>p：分区列表</li><li>t：更改分区ID（输入L查询，不同的ID标识分区的类型）</li><li>n：创建新分区</li><li>d：删除分区</li><li>v：校验分区</li></ul></li><li>u：转换单位</li><li>w：保存退出<ul><li>q：不保存退出</li><li>fdisk实时更改硬盘的分区，分区完成后注意与内存分区表同步（partprobe），查看内核是否已经识别新的分区<code>cat /proc/partitions</code>。</li></ul></li></ul></li><li>创建GPT分区：<code>gdisk</code>，用法与<code>fdisk</code>相似</li><li>高级分区操作：<code>parted</code><ul><li><code>parted</code>命令操作都是实时生效，需谨慎操作</li><li><code>parted /dev/sdb mklabel gpt</code>：设置<code>/dev/sdb</code>这块磁盘为gpt类型</li><li><code>parted /dev/sdb print</code>：打印<code>/dev/sdb</code>的分区信息</li><li><code>parted /dev/sdb mkpart primary 1 200</code>：设置一个分区，从1MB到200MB，大小为199MB（注意分区需是连续空间）</li><li><code>parted /dev/sdb rm 1</code>：删除第一个分区</li><li><code>parted -l</code>：列出所有硬盘的分区信息</li></ul></li></ul></li><li>重新设置内存中的内核分区表版本：<code>partprobe</code></li></ul></li></ul><h3 id="文件系统管理"><a href="#文件系统管理" class="headerlink" title="文件系统管理"></a>文件系统管理</h3><ul><li><p>查看当前OS支持的文件系统：<code>cat /proc/filesystems</code></p></li><li><p>创建文件系统：<code>mkfs -t [type] [device]</code>：例如<code>mkfs -t xfs /dev/sdb2</code>，若要创建swap类型，使用<code>mkswap /dev/xxx</code>命令</p></li><li><p>管理文件系统：</p><ul><li><p><code>tune2fs</code>：重新设定ext系列文件系统参数的值</p><ul><li><code>-l</code>：查看指定文件系统superblock信息</li><li><code>-L &#39;LABEL&#39;</code>：修改卷标</li><li><code>-O</code>：文件系统属性的启用或禁用</li></ul></li><li><p><code>dumpe2fs</code>：显示ext文件系统信息，将磁盘块分组管理</p></li><li><code>xfs_info 挂载点</code>：显示已挂载的xfs文件系统信息</li></ul></li><li><p>文件系统检测和修复：</p><ul><li>文件系统故障常发生于死机或非正常关机后，注意一定要取消挂载后执行修复命令</li><li><code>fsck</code> 、<code>e2fsck</code>、<code>xfs_repair</code></li></ul></li><li><p>常用工具：</p><ul><li><p><code>df</code>：查看文件系统和磁盘空间使用情况，常用选项<code>-T,-h</code></p></li><li><p><code>du -h /xxx/yyy</code>：查看某目录总体空间占用状态，<code>--max-depth=3</code>指定最大目录层级为3</p></li><li><p><code>dd</code>：convert and copy a file</p><ul><li>用法：<code>dd if=/x/y of=/a/b bs=# count=#</code></li><li><code>if=/x/y</code>：从指定文件读取</li><li><code>of=/a/b</code>：写入到指定文件</li><li><code>ibs=size</code>：一次读size个字节</li><li><code>obs=size</code>：一次写size个字节</li><li><code>bs=size</code>：block size，指定块大小(既是ibs也是obs)</li><li><code>cbs=size</code>：一次转换size个字节</li><li><code>skip=blocks</code>：从开头忽略blocks个ibs大小的块，只复制之后的内容</li><li><code>seek=blocks</code>：从开头忽略blocks个obs大小的块，用if中复制的内容替换blocks个obs大小的块之后的内容。</li><li><code>count=n</code>：复制n个bs</li><li><img src="dd.jpg" alt=""></li><li><p>备份：</p><ul><li><code>dd if=/dev/sdx of=/dev/sdy</code>：整盘备份到另一磁盘</li><li><code>dd if=/dev/sdx of=/xxx/image</code>：整盘备份到文件</li><li><code>dd if=/dev/sdx | gzip &gt; /xxx/image.gz</code>：整盘备份并压缩</li></ul></li><li><p>恢复：</p><ul><li><code>dd if=/xxx/image of=/dev/sdx</code></li><li><code>gzip -dc /xxx/image.gz | dd of=/dev/sdx</code></li></ul></li></ul></li></ul></li></ul><h3 id="挂载设备"><a href="#挂载设备" class="headerlink" title="挂载设备"></a>挂载设备</h3><ul><li><p>将分区挂载到目录，则该目录下的文件都存储于该分区中；若有其他分区挂载在该目录的子目录下，则子目录下的文件存储与另一分区中。</p></li><li><p>挂载点下原有文件在挂载完成后会被临时隐藏，因此挂载点目录一般为空。</p></li><li><p>一个分区可以同时挂载在多个目录下，一个目录只能与一个分区关联</p></li><li><p><strong>实现永久挂载需要写入配置文件<code>/etc/fstab</code></strong>，使用<code>blkid</code>查看UUID（也可使用设备分区名例如<code>/dev/sda2</code>）并按格式写入配置文件；若需要更改挂载点所属文件系统属性（是否启用acl，suid，exec等），亦可在该配置文件中更改，默认为defaults，然后<code>mount -o remount /dev/xxx</code>重新挂载使更改生效</p></li><li><p>swap的挂载：写入<code>/etc/fstab</code>，挂载点和文件系统均为<code>swap</code>，保存退出后键入<code>swapon -a</code>;<code>swapoff</code>命令取消交换分区。</p></li><li><p><code>mount /dev/sda2 /mnt</code>：将分区sda2挂载在/mnt目录下</p><ul><li><p><code>-r</code>：只读挂载</p></li><li><p><code>-w</code>：读写挂载，默认</p></li><li><p><code>mount -B 目录1 目录2</code>：类似与软连接的效果，两个目录的文件共享。</p></li><li><p><code>-o options</code>：挂载文件系统的选项</p><p><img src="mount.jpg" alt=""></p></li></ul></li><li><p><code>umount /mnt</code>：取消挂载</p></li><li><p><code>cat /etc/mtab</code>：查看目前的挂载情况</p></li><li><p>查看挂载情况：<code>findmnt 挂载点/设备分区</code></p></li><li><p>查看正在访问指定挂载点的进程：<code>lsof 挂载点</code>、<code>fuser -v 挂载点</code></p></li><li><p>终止所有正在访问指定挂载点的进程：<code>fuser -km 挂载点</code></p></li></ul><h3 id="外围设备使用"><a href="#外围设备使用" class="headerlink" title="外围设备使用"></a>外围设备使用</h3><ul><li><p>使用光盘：</p><ul><li>手动挂载：<code>mount /dev/cdrom /mnt</code></li><li>操作光盘：<code>eject</code>弹出光盘；<code>eject -t</code>弹入光盘</li><li>创建ISO文件：<code>cp /dev/cdrom /root/xxx.iso</code>；<code>mkisofs -r -o ./xxx.iso /etc</code>…</li></ul></li><li><p>挂载USB介质：</p><ul><li>查看USB设备是否识别：<code>lsusb</code></li><li>被内核探测为SCSI设备：<code>/dev/sdaX、/dev/sdbX</code>或类似的设备文件</li><li>手动挂载：<code>mount /dev/sdbX /mnt</code></li></ul></li></ul><h3 id="管理虚拟内存"><a href="#管理虚拟内存" class="headerlink" title="管理虚拟内存"></a>管理虚拟内存</h3><ul><li><p>swap交换分区是系统内存的补充，支持虚拟内存，当没有足够的内存保存系统处理的数据时会将数据写入swap分区</p></li><li><p>推荐系统swap空间</p><p>|  系统RAM   | 推荐的swap空间 | 允许机器休眠的swap建议 |<br>| :————: | :——————: | :——————————: |<br>|  低于2GB   |   RAM的倍数    |       RAM的三倍        |<br>| 2GB - 8GB  |    等于RAM     |       RAM的倍数        |<br>| 8GB - 64GB |      8GB       |       RAM的1.5倍       |<br>|   &gt; 64GB   |      16GB      |   不建议使用休眠功能   |</p></li><li><p><code>free</code>：查看内存使用情况</p></li></ul><h3 id="RAID管理"><a href="#RAID管理" class="headerlink" title="RAID管理"></a>RAID管理</h3><ul><li><p>RAID：Redundant Arrays of Independent Disks（独立冗余磁盘阵列）</p><ul><li>提高IO能力：磁盘并行读写</li><li>提高容错性</li><li>多块磁盘组织在一起工作</li><li>实现方式：<ul><li>外接式：通过扩展卡提供适配能力</li><li>内接式：主板集成RAID控制器，安装OS前在BIOS里配置</li><li>软件RAID：软件实现</li></ul></li></ul></li><li><p>RAID级别：</p><ul><li><p>RAID-0：同一文件分块存储在多块硬盘上，读写性能提升，无容错能力</p><p><img src="RAID-0.jpg" alt=""></p></li><li><p>RAID-1：同一文件完全一样地存储于两块磁盘（镜像），读性能提升，写性能略有下降，有容错能力，磁盘利用率只有一半</p><p><img src="RAID-1.jpg" alt=""></p></li><li><p>RAID-5：读写性能提升，至少3块磁盘，有容错能力（允许最多1块磁盘损坏），每一块磁盘都划分一部分空间充当校验位</p><p><img src="RAID-5.jpg" alt=""></p></li><li><p>RAID-6：读写性能提升，至少4块磁盘，两个校验位，允许最多2块磁盘损坏，容错性较RAID-5高</p><p><img src="RAID-6.jpg" alt=""></p></li><li><p>RAID-10与RAID-01（实际使用RAID-10，RAID-10容错性较RAID-01好）</p><p><img src="RAID-01.jpg" alt=""></p><p><img src="RAID-10.jpg" alt=""></p></li><li><p>RAID-50</p><p><img src="RAID-50.jpg" alt=""></p></li><li><p>RAID-7：自身带操作系统和管理工具，理论上性能最高的RAID模式</p></li></ul></li></ul><h3 id="LVM（逻辑卷管理器）"><a href="#LVM（逻辑卷管理器）" class="headerlink" title="LVM（逻辑卷管理器）"></a>LVM（逻辑卷管理器）</h3><ul><li><p>LVM：允许对卷进行方便操作的抽象层</p><ol><li><p>将物理块设备指定为物理卷</p></li><li><p>用多个物理卷来创建一个卷组（物理卷是用固定大小的物理区域[PE,physical extent]来定义的）</p></li><li><p>从卷组中划分逻辑卷，可在逻辑卷上创建文件系统，逻辑卷大小可扩展。</p><p>示意图：</p><p><img src="LVM-2.jpg" alt=""></p><p><img src="LVM-1.jpg" alt=""></p></li></ol></li><li><p>使用逻辑卷步骤：</p><ol><li>将设备指定为物理卷，例如<code>pvcreate /dev/sdb1 /dev/sdd</code>或<code>pvcreate /dev/sd{b1,d}</code>，同时将分区和磁盘指定为物理卷。（如果是分区，需要将分区ID改为<code>8e</code>，表示Linux LVM类型）</li><li>用多个物理卷创建卷组，<code>vgcreate [选项] vgName pv1 pv2 ...</code>，例如<code>vgcreate -s 16M vg0 /dev/sdb1 /dev/sdd</code>，选项<code>-s</code>指定PE大小。</li><li>从卷组中划分逻辑卷，<code>lvcreate -n mysql -L 8G vg0</code>，<code>-n</code>指定逻辑卷名，<code>-L</code>指定大小，<code>-l</code>也是指定大小但是单位是PE个数。</li><li><code>ll /dev/vg0/mysql</code>发现<code>/dev/vg0/mysql</code>为软链接，指向<code>/dev/dm-0</code>，其另一软链接为<code>/dev/mapper/vg0-mysql</code>，若继续创建逻辑卷，其真实设备名依次为<code>/dev/dm-1</code>、<code>/dev/dm-2</code>…</li><li>在逻辑卷上创建文件系统，<code>mkfs.xfs /dev/vg0/mysql</code></li><li>挂载，<code>mount /dev/vg0/mysql /mnt/mysql</code>；将挂载写入配置文件<code>/etc/fstab</code>，在vim扩展命令模式下键入<code>r!blkid /dev/vg0/mysql</code>进行修改</li></ol></li><li><p>列出现有的物理卷：<code>pvs</code>、<code>pvdisplay</code></p></li><li><p>列出现有卷组：<code>vgs</code>、<code>vgdisplay</code></p></li><li><p>列出现有逻辑卷：<code>lvs</code>、<code>lvdisplay</code></p></li><li><p>扩展现有逻辑卷：<code>lvextend -l +48%free /dev/vg0/mysql</code>：剩余卷组的48%分配给逻辑卷，亦可使用PE数进行分配<code>lvextend -l +200 /dev/vg0/mysql</code>；此时使用<code>lsblk</code>或者<code>fdisk -l</code>查看已分配成功，但是<code>df</code>查看并未改变，还需要<strong>为新扩展的逻辑卷创建相同的文件系统</strong></p><ul><li><p>xfs：<code>xfs_growfs 挂载点</code></p></li><li><p>ext：<code>resize2fs 逻辑卷名</code>（注意xfs与ext的区别）</p></li><li>亦可一次搞定（加上<code>-r</code>选项）：<code>lvextend -r -l +xxx /dev/vg0/mysql</code></li></ul></li><li><p>扩展现有的卷组：<code>vgextend vg0 PV名</code></p></li><li><p>删除逻辑卷、卷组、物理卷：迁移数据 -&gt; <code>umount /mnt/mysql</code> -&gt; <code>lvremove /dev/vg0/mysql</code> -&gt; <code>vgremove vg0</code> -&gt; <code>pvremove /dev/sdb1 /dev/sdd</code> </p></li><li><p>LVM快照管理：</p><ul><li>逻辑卷的快照需要与该逻辑卷在同一个卷组，且快照的容量小于等于逻辑卷</li><li>逻辑卷中每一个发生修改的文件都会备份到快照中</li><li>使用快照：<ul><li><code>lvcreate -n mysql_snapshot -s -L 1G /dev/vg0/mysql</code>：创建逻辑卷mysql的快照，选项<code>-s</code>用于创建快照，快照上的文件系统与原逻辑卷相同</li><li>挂载快照到目录：<code>mount -o nouuid /dev/vg0/mysql_snapshot /mnt/snap</code>，由于快照的UUID与原逻辑卷一样，所以挂载时需要指定nouuid选项，不然挂载不上（xfs是这样，ext4不用）</li><li>还原快照到逻辑卷（逻辑卷恢复为快照）：<ul><li><code>umount /mnt/snap</code>,<code>umount /mnt/mysql</code>：卸载快照和逻辑卷</li><li><code>lvconvert --merge /dev/vg0/mysql_snapshot</code>：还原，此时快照已经删除</li><li><code>mount /dev/vg0/mysql /mnt/mysql</code>：重新挂载</li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;磁盘工作原理&quot;&gt;&lt;a href=&quot;#磁盘工作原理&quot; class=&quot;headerlink&quot; title=&quot;磁盘工作原理&quot;&gt;&lt;/a&gt;磁盘工作原理&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;不同硬盘标识：a-z，aa，ab…&lt;/p&gt;
&lt;p&gt;​      /dev/sda，/dev
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Linux软件安装和包管理</title>
    <link href="http://thmasterplan.cn/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/"/>
    <id>http://thmasterplan.cn/Linux/Linux%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85%E5%92%8C%E5%8C%85%E7%AE%A1%E7%90%86/</id>
    <published>2019-11-25T04:47:01.000Z</published>
    <updated>2019-11-29T07:25:41.582Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件运行环境"><a href="#软件运行环境" class="headerlink" title="软件运行环境"></a>软件运行环境</h3><ul><li>静态链接：<code>libxxx.a</code>，程序对应的依赖库复制到程序包，占用空间多,迁移容易，升级难，需重新编译。</li><li>动态链接：<code>libxxx.so</code>，只把依赖做一个动态链接，占用空间少。</li><li><code>ldd 命令</code>：查看二进制程序所依赖的共享库文件。</li><li><code>ldconfig -p</code>：查看本机已经缓存的所有可用库文件名及文件路径映射关系。</li></ul><h3 id="程序包的来源"><a href="#程序包的来源" class="headerlink" title="程序包的来源"></a>程序包的来源</h3><ul><li><p>管理程序包：</p><ul><li>使用包管理器：<code>rpm</code></li><li>使用前端工具：<code>yum,dnf</code></li></ul></li><li><p>获取程序包的途径：官方服务器，镜像站点，epel源（Extra Packages for Enterprise Linux）</p></li></ul><h3 id="rpm包管理"><a href="#rpm包管理" class="headerlink" title="rpm包管理"></a>rpm包管理</h3><ul><li><code>rpm: redhat package manager</code>，rpm包中是已经编译好的程序文件。</li><li><code>/var/lib/rpm/</code>：数据库，其中包含了所有rpm包的名称及版本，依赖关系，功能说明，包安装后生成的各文件路径及校验码信息。</li><li><code>rpm -ivh [install-options] PACKAGE_FILES</code>：<ul><li><code>-i</code>：安装</li><li><code>-v</code>：显示安装过程</li><li><code>-h</code>：显示程序包管理执行进度</li><li><code>-q</code>：查询包是否安装，与<code>-l</code>一起使用，列出包中的文件；与<code>-f</code>使用，查询文件的所属包；<code>-a</code>，查询所有安装的包</li><li><code>-e</code>：卸载</li><li><code>-U</code>：升级</li><li><code>-V</code>：包校验</li><li>…其余查询man帮助</li></ul></li></ul><h3 id="yum管理"><a href="#yum管理" class="headerlink" title="yum管理"></a>yum管理</h3><ul><li><p>YUM：Yellowdog Update Modifier，rpm的前端程序，基于C/S架构，可解决软件包相关依赖性，可在多个库之间定位软件包</p></li><li><p>配置yum源：<code>/etc/yum.repos.d/</code>路径下<code>xxx.repo</code>中配置源服务器路径，yum命令安装时，查询本地repo源 -&gt; 查询服务器端元数据 -&gt; 下载元数据到缓冲区 -&gt; 下载rpm包到缓冲区 -&gt; 按依赖顺序安装包。</p><ul><li><p>使用本地光盘配置yum源</p><ol><li><p>检查是否安装autofs(自动挂载服务)</p></li><li><p><code>systemctl start autofs</code>：启动</p></li><li><p><code>systemctl enable autofs</code>：设置开机自启动</p></li><li><p><code>systemctl status autofs</code>：查看服务状态</p></li><li><p><code>ls /misc/cd -&gt; df</code>：光盘<code>/dev/sr0</code>已自动挂载到<code>/misc/cd</code>目录下</p></li><li><p><code>cd /etc/yum.repos.d/</code>，将原有的国外源删除（备份），创建一个新的以.repo结尾的配置文件，例如创建<code>base.repo</code>,配置如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[base]</span><br><span class="line">name=cdrom base</span><br><span class="line">baseurl=file:///misc/cd</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure></li><li><p><code>yum repolist</code>：查看可用的repo列表</p></li></ol></li><li><p>网络源配置</p><ol><li><p>可单独创建一个xxx.repo，也可在现有的repo中追加，例如在<code>base.repo</code>中追加</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[epel]</span><br><span class="line">name=aliyun epel</span><br><span class="line">baseurl=https://mirrors.aliyun.com/epel/$releasever/$basearch/</span><br><span class="line">gpgcheck=0</span><br></pre></td></tr></table></figure><p>其中releasever变量代表当前OS发行版本，basearch代表cpu架构</p></li></ol></li></ul></li><li><p><code>yum clean all</code>：清空yum源缓存</p></li><li><p><code>yum list</code>：列出repo源所有包</p></li><li><p><code>yum install xxx</code>：安装</p></li><li><p><code>yum remove xxx</code>：删除</p></li><li><p><code>yum update pkgxxx</code></p></li><li><p><code>yum info xxx</code>：查看详细信息</p></li></ul><h3 id="定制yum仓库"><a href="#定制yum仓库" class="headerlink" title="定制yum仓库"></a>定制yum仓库</h3><ul><li>使用httpd定制本地yum源</li></ul><h3 id="dnf管理"><a href="#dnf管理" class="headerlink" title="dnf管理"></a>dnf管理</h3><ul><li>centos8之后默认安装</li></ul><h3 id="源码编译安装"><a href="#源码编译安装" class="headerlink" title="源码编译安装"></a>源码编译安装</h3><ul><li><p>首先使用<code>wget URL</code>下载好源码包</p></li><li><p><code>C/C++</code>：make项目管理器</p><ul><li>安装<code>gcc</code></li><li>解压，进入到源码包目录中，运行<code>./configure</code>，通过选项传递参数指定启用特性、安装路径等；执行时会参考用户的指定以及Makefile.in文件生成Makefile（安装前查看源码包中的说明帮助文档README、INSTALL等，亦可通过<code>./configure --help</code>查看可选项）</li><li><code>make -j n</code>根据Makefile文件，构建应用程序，j选项表示多线程并行编译。</li><li><code>make install</code></li><li>更改PATH</li></ul></li><li><code>Java</code>：maven</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;软件运行环境&quot;&gt;&lt;a href=&quot;#软件运行环境&quot; class=&quot;headerlink&quot; title=&quot;软件运行环境&quot;&gt;&lt;/a&gt;软件运行环境&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;静态链接：&lt;code&gt;libxxx.a&lt;/code&gt;，程序对应的依赖库复制到程序包，占用空间多,
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>压缩与解压缩</title>
    <link href="http://thmasterplan.cn/Linux/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/"/>
    <id>http://thmasterplan.cn/Linux/%E5%8E%8B%E7%BC%A9%E4%B8%8E%E6%89%93%E5%8C%85/</id>
    <published>2019-11-23T00:43:05.000Z</published>
    <updated>2019-11-23T13:25:30.409Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、压缩、解压缩工具"><a href="#一、压缩、解压缩工具" class="headerlink" title="一、压缩、解压缩工具"></a>一、压缩、解压缩工具</h3><ul><li><p><code>.Z</code>后缀</p><ul><li><p><code>compress</code>：压缩后会删除原文件，可读取STDOUT内容进行压缩，支持管道</p><ul><li><code>-c</code>：结果输出至标准输出，不删除原文件。常见用法：<code>compress -c file &gt; file.Z</code></li><li><code>-v</code>：显示详情</li></ul></li><li><p><code>uncompress file.Z</code></p></li><li><code>zcat file.Z</code>：不显示解压缩的前提下查看文本文件内容</li></ul></li><li><p><code>.gz</code>后缀</p><ul><li><code>gzip</code>：<ul><li><code>-c</code>：同<code>compress -c</code></li><li><code>-#</code>：#取1-9，指定压缩比，值越大压缩比越大</li></ul></li><li><code>gunzip file.gz</code></li><li><code>zcat file.Z</code></li></ul></li><li><p><code>.bz2</code>后缀</p><ul><li><p><code>bzip2</code>：</p><ul><li><code>-k</code>：</li><li><code>-#</code>：默认为9</li></ul></li><li><p><code>bunzip2 file.bz2</code></p></li><li><code>bzcat file.bz2</code></li></ul></li><li><p><code>.xz</code></p><ul><li><p><code>xz</code>：</p><ul><li><code>-k</code>：</li><li><code>-#</code>：默认为6</li></ul></li><li><p><code>unxz</code></p></li><li><code>xzcat</code></li></ul></li><li><p>一般来说压缩比：<code>xz &gt; bzip2 &gt; gz &gt; compress</code>，均不能压缩目录</p></li><li><code>.zip</code><ul><li><code>zip</code>：支持压缩目录</li><li><code>unzip</code></li></ul></li></ul><h3 id="二、打包-存档-和解包工具"><a href="#二、打包-存档-和解包工具" class="headerlink" title="二、打包(存档)和解包工具"></a>二、打包(存档)和解包工具</h3><ul><li><p><code>tar</code>常见用法：具体选项见man帮助</p><ul><li>打包，保留权限：<code>tar -cpvf xxx.tar file1 file2 file3...</code></li><li>追加文件至xxx.tar：<code>tar -rf xxx.tar file1 file2..</code>注：不支持对压缩文件追加</li><li>查看包中的文件列表：<code>tar -tf xxx.tar</code></li><li>解包<code>tar -xf xxx.tar [可选：-C /PATH]</code></li><li><p>结合压缩工具，打包并压缩：</p><ul><li><code>tar zcvf xxx.tar.gz [可选：/PATH]</code>；<code>.tar.gz</code>也可写成<code>.tgz</code></li><li><code>tar jcvf xxx.tar.bz2 [可选：/PATH]</code></li><li><code>tar Jcvf xxx.tar.xz [可选：/PATH]</code></li></ul></li><li><p><code>--eclude=/PATH/文件名</code>：打包时排除某文件：<code>tar -zcvf xxx.tgz --exclude=/a/b/abc.txt</code></p></li><li><code>-T</code>：指定打包列表；<code>-X</code>：指定排除列表<ul><li><code>tar -zcvf xxx.tgz -T /a/list -X /a/excludeList</code></li></ul></li></ul></li><li><p><code>split</code>：分割一个文件为多份小文件</p><ul><li><code>split -b SIZE  xxx.tgz yyy</code>：<code>yyy</code>为切割后的文件前缀，SIZE为每份大小</li><li>合并：<code>cat yyy* &gt; xxx.tgz</code></li></ul></li><li><p><code>cpio</code>：一种老的存档格式。</p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、压缩、解压缩工具&quot;&gt;&lt;a href=&quot;#一、压缩、解压缩工具&quot; class=&quot;headerlink&quot; title=&quot;一、压缩、解压缩工具&quot;&gt;&lt;/a&gt;一、压缩、解压缩工具&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;.Z&lt;/code&gt;后缀&lt;/p&gt;
&lt;ul&gt;
&lt;l
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>文件查找工具</title>
    <link href="http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/"/>
    <id>http://thmasterplan.cn/Linux/%E6%96%87%E4%BB%B6%E6%9F%A5%E6%89%BE%E5%B7%A5%E5%85%B7/</id>
    <published>2019-11-22T07:44:54.000Z</published>
    <updated>2019-11-23T13:25:06.354Z</updated>
    
    <content type="html"><![CDATA[<h3 id="文件查找"><a href="#文件查找" class="headerlink" title="文件查找"></a>文件查找</h3><ul><li><p>在文件系统上查找符合条件的文件</p><ul><li><p>非实时查找（数据库查找）：<code>locate</code></p><ul><li><p>查询系统上预建的文件索引数据库<code>/var/lib/mlocate/mlocate.db</code></p></li><li><p>索引构建过程需要遍历整个根文件系统，极消耗资源</p></li><li><p>查找速度快，模糊查找，非实时，搜索的是文件的全路径，可手动更新<code>updatedb</code></p></li><li><p>选项：</p><ul><li><p><code>-i</code>：不区分大小写</p></li><li><p><code>-n N</code>：只列举前N个匹配项目</p></li><li><p><code>-r</code>：使用<strong>基本</strong>正则表达式</p></li></ul></li></ul></li><li><p>实时查找：<code>find</code></p><ul><li><p>通过遍历指定路径完成文件查找</p></li><li><p>查找速度略慢，精确，实时</p></li><li><p>语法：<code>find [选项] [查找路径] [查找条件] [处理动作]</code></p><ul><li><p>选项：</p><ul><li><code>-maxdepth level</code>：最大搜索目录深度，指定目录下的文件为第1级</li><li><code>-mindepth level</code>：最小搜索目录深度</li><li><code>-depth</code>：先搜索文件，再搜索目录；不加该选项时默认为先搜目录再搜文件</li></ul></li><li><p>查找路径：默认为当前目录</p></li><li><p>查找条件：可以查找文件名，大小，类型，权限等，默认为找出指定路径的所有文件</p><ul><li><p>根据<strong>文件名和inode</strong></p><ul><li><code>-name 文件名</code>：支持文件通配符</li><li><code>-iname 文件名</code>：不区分字母大小写</li><li><code>-inum n</code>：按inode号查找</li><li><code>-samefile 文件名</code>：相同inode号的文件</li><li><code>-links n</code>：链接数为n的文件</li><li><code>-regex &#39;PATTERN&#39;</code>：匹配整个文件路径而非文件名</li></ul></li><li><p>根据<strong>owner,group</strong></p><ul><li><code>-user 用户名</code></li><li><code>-group 组名</code></li><li><code>-uid UID</code></li><li><code>-gid GID</code></li><li><code>-nouser</code>：比如某个用户被删除，但其文件还存在</li><li><code>-nogroup</code></li></ul></li><li><p>根据<strong>文件类型</strong></p><ul><li><code>-type TYPE</code>：TYPE包括<code>f,d,l,s,b,c,p</code></li><li>空文件或目录：<code>-empty</code>，例如<code>find /usr -type d -empty</code></li></ul></li><li><p>根据<strong>文件大小</strong></p><ul><li><code>-size SIZE</code>，常用单位k,M,G</li><li>对于SIZE的写法，<code>-6k</code>代表[0,5k]，<code>6k</code>代表(5k,6k]，<code>+6k</code>代表(6k,+∞)</li></ul></li><li><p>根据<strong>时间</strong></p><ul><li><code>-atime</code>/<code>-mtime</code>/<code>-ctime</code></li><li><code>-amin</code>/<code>-mmin</code>/<code>-cmin</code></li><li><code>find ./ -mtime -3</code>，代表[0,3）天内被修改，<code>find ./ -mtime 3</code>代表第3天被修改，<code>find ./ -mtime +3</code>代表被修改3天以上。</li></ul></li><li><p>根据<strong>权限</strong></p><ul><li><code>-perm (/|-) MODE</code>0配<ul><li>MODE：精确权限匹配</li><li>/MODE：u,g,o中只要匹配到一个即可</li><li>-MODE：u,g,o必须同时满足指定权限</li><li>例如<code>find ./ -perm -222</code>指u,g,o均要有写权限才满足条件</li></ul></li></ul></li><li><p>不想搜索某目录时：使用<code>-path &#39;目录&#39; -a -prune</code>，例如<code>find / -path &#39;/etc&#39; -a -prune -o -name passwd</code>在根目录下除<code>/etc</code>外搜索文件名为<code>passwd</code>的文件。</p></li><li><p>组合条件：与：<code>-a</code>；或：<code>-o</code>；非：<code>-not</code>/<code>!</code>。即将以上各种条件组合使用查找。当需要使用括号时要转义。例如<code>find /usr \(-name &quot;f*&quot; -o -type f\) -ls</code>。</p></li></ul></li><li><p>处理动作：对符合条件的文件做操作，默认输出至屏幕</p><ul><li><code>-print</code>：默认的处理动作，显示至屏幕</li><li><code>-ls</code>：类似于对查找到的文件执行<code>ls -l</code>命令</li><li><code>-delete</code>：删除查找到的文件</li><li><code>-fls file</code>：查找到的所有文件的长格式信息保存至指定文件中。等价于<code>-ls &gt; file</code></li><li><code>-ok cmd {} \;</code>：对查找到的每个文件执行由<code>cmd</code>指定的命令，对于每个文件执行命令之前，都会交互式要求用户确认</li><li><code>-exec cmd {} \;</code>：对查找到的每个文件执行由<code>cmd</code>指定的命令</li><li><code>{}</code>用于引用查找到的文件名称自身，包含路径名。</li></ul></li><li><p><code>xargs</code>：<code>cmd1 | xargs [选项] cmd2</code></p><ul><li>xargs 是给命令传递参数的一个过滤器，也是组合多个命令的一个工具。</li><li>xargs 可以将管道或标准输入（stdin）数据转换成命令行参数，也能够从文件的输出中读取数据。</li><li>xargs 也可以将单行或多行文本输入转换为其他格式，例如多行变单行，单行变多行。</li><li>xargs 默认的命令是 echo，这意味着通过管道传递给 xargs 的输入将会包含换行和空白，不过通过 xargs 的处理，换行和空白将被空格取代。</li><li>xargs 是一个强有力的命令，它能够捕获一个命令的输出，然后传递给另外一个命令。</li><li>之所以能用到这个命令，关键是由于很多命令不支持|管道来传递参数，而日常工作中有有这个必要，所以就有了 xargs 命令</li><li>具体选项见man帮助</li><li>举例：<code>find linux-5.1.4/ -name &quot;*.c&quot; | xargs -n1 cat | wc -l</code>统计出linux内核一共有多少行c代码；<code>cat `find linux-5.1.4/ -name &quot;*.c&quot;`|wc -l</code>实际运行更快。</li></ul></li></ul></li></ul></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;文件查找&quot;&gt;&lt;a href=&quot;#文件查找&quot; class=&quot;headerlink&quot; title=&quot;文件查找&quot;&gt;&lt;/a&gt;文件查找&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;在文件系统上查找符合条件的文件&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;非实时查找（数据库查找）：&lt;code&gt;lo
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shell编程</title>
    <link href="http://thmasterplan.cn/shell%E7%BC%96%E7%A8%8B/Shell%E7%BC%96%E7%A8%8B/"/>
    <id>http://thmasterplan.cn/shell%E7%BC%96%E7%A8%8B/Shell%E7%BC%96%E7%A8%8B/</id>
    <published>2019-11-20T09:05:48.000Z</published>
    <updated>2019-11-23T13:23:43.860Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、shell脚本基础"><a href="#一、shell脚本基础" class="headerlink" title="一、shell脚本基础"></a>一、shell脚本基础</h3><ul><li>shell：解释型语言</li><li>在脚本首行需注释使用的解释器类型，比如<code>#!/bin/bash</code>，<code>#!/usr/bin/python</code>等。</li><li><code>bash -n xxx.sh</code>：执行语法检查</li><li><code>bash -x xxx.sh</code>：解释执行的同时一边执行一边打印执行结果。</li><li>变量不用事先声明，可随时改变类型；不同数据类型之间可直接运算而不用做类型转换；常用类型为字符，整型，浮点型。</li><li>变量命名规则：<ul><li>只能使用数字、字母及下划线，且不能以数字开头。</li><li>shell中命名建议：<ul><li>变量名大写</li><li>局部变量小写</li><li>函数名小写</li></ul></li></ul></li><li>显示已定义的所有变量：<code>set</code></li><li>注意脚本中定义别名不生效。</li></ul><h3 id="二、特殊位置变量"><a href="#二、特殊位置变量" class="headerlink" title="二、特殊位置变量"></a>二、特殊位置变量</h3><ul><li><code>pstree -p</code>：查看进程树</li><li><code>getent</code>：查看系统数据库的相关记录，例如<code>getent passwd root</code>，查看passwd库中root的信息。</li><li><code>变量BASHPID</code>：当前bash进程的pid</li><li><code>(命令列表)</code>：该语法的作用，小括号会开启一个subbash，其中的命令和变量只是<strong>临时生效</strong>，当命令列表执行完毕，将会退出subbash。要想退出当前进程，则需使用<code>{命令列表}</code>。</li><li><p>环境变量：子进程，父进程均可访问</p><ul><li>定义方式：<code>export NAME=abc</code>、<code>declare -x NAME=abc</code></li><li>变量引用：<code>$NAME</code>、<code>${NAME}</code></li><li>显示所有环境变量：<code>env</code>、<code>export</code>、<code>declare -x</code>、<code>printenv</code></li><li>删除变量：<code>unset</code></li><li>子进程更改环境变量，父进程访问相同环境变量不变。</li></ul></li><li><p>只读和位置变量：</p><ul><li><p>只读变量（常量）：只能声明，但不能修改和删除</p><ul><li>声明：<code>readonly NAME</code>、<code>declare -r NAME</code></li><li>查看：<code>readonly -p</code></li><li>退出当前bash自动删除</li></ul></li><li><p>位置变量：</p><ul><li><code>$1</code>代表脚本的第一个参数，<code>$2</code>代表脚本的第二个参数。。。</li><li><code>$*或者$@</code>：脚本的所有参数；前者全部参数合为一个字符串，后者每个参数为独立字符串。</li><li><code>$#</code>：脚本的参数个数</li><li><code>$0</code>：脚本的路径及脚本名</li><li><code>set --</code>：清空所有位置变量</li><li>例如<code>rm a b c</code>：则<code>$1</code>在脚本中代表a；<code>$*</code>为a，b，c；<code>$#</code>为3。</li></ul></li></ul></li><li><p>退出状态：进程使用退出状态来报告成功或失败，0代表成功，1-255代表失败。<code>$?</code>变量保存最近的命令退出状态。 </p></li></ul><h3 id="三、算术逻辑运算和条件测试"><a href="#三、算术逻辑运算和条件测试" class="headerlink" title="三、算术逻辑运算和条件测试"></a>三、算术逻辑运算和条件测试</h3><ul><li><p>算术运算：<code>+,-,*,/,%,**（乘方）</code>，乘法符号有些场景需要转义。</p><ul><li><code>let var=算术表达式</code></li><li><code>var=$[算术表达式]</code></li><li><code>var=$((算术表达式))</code></li><li><code>var=$(expr arg1 arg2 arg3...)</code></li><li><code>declare -i var = xxx</code></li><li><code>echo &#39;算术表达式&#39;|bc</code></li></ul></li><li><p><code>RANDOM</code>：系统随机数变量，随机生成0-32767之间的数。</p></li><li><p>逻辑运算：</p><ul><li>短路与：<code>cmd1 &amp;&amp; cmd2</code>：如果<code>cmd1</code>结果失败，不执行<code>cmd2</code>；如果<code>cmd1</code>成功，执行<code>cmd2</code>。</li><li>短路或：<code>cmd1 || cmd 2</code>：如果<code>cmd1</code>成功，不执行<code>cmd2</code>；如果<code>cmd1</code>失败，执行<code>cmd2</code>。</li><li><code>cmd1 &amp;&amp; cmd2 || cmd3</code>，<code>cmd1</code>失败，则执行<code>cmd3</code>；<code>cmd1</code>成功，则执行<code>cmd2</code>，根据<code>cmd2</code>的结果进一步判断是否执行<code>cmd3</code>，一般来说<code>cmd2</code>是执行成功的所有不会再进一步执行<code>cmd3</code>，因而该写法类似于其他语言中的<code>x ? y : z</code>。</li></ul></li><li><p>条件测试：</p><ul><li><code>test EXPRESSION</code>或者<code>[ EXPRESSION ]</code>或者<code>[[ EXPRESSION ]]</code>，<code>EXPRESSION</code><strong>前后必须要有空格</strong>，其中<strong><code>[[]]</code>语法支持正则表达式</strong>。</li><li><p><code>help test</code>：查看相关选项</p></li><li><p>脚本练习：查看磁盘最大使用率</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">var=`df | grep '/dev/sda' | sort -rn | head -1 | tr -s ' ' % | cut -d% -f5`</span><br><span class="line">test $var -gt 80 &amp;&amp; echo "disk is almost full" || echo "the use rate of the disk is $var"</span><br></pre></td></tr></table></figure></li><li><p>bash的数值测试：</p><ul><li><code>-v VAR</code>：变量VAR是否设置</li><li><code>-gt</code>：是否&gt;</li><li><code>-ge</code>：是否&gt;=</li><li><code>-eq</code>：是否=</li><li><code>-ne</code>：是否!=</li><li><code>-lt</code>：是否&lt;</li><li><code>-le</code>：是否&lt;=</li></ul></li><li><p>bash的字符串测试：</p><ul><li><code>=</code>：是否等于</li><li><code>&gt;</code>：ASCII码值是否大于</li><li><code>&lt;</code></li><li><code>!=</code></li><li><code>=~</code>：左侧字符串是否能够被右侧的PATTERN所匹配，例如<code>[[ &#39;abcde&#39; =~ [[:digit:]] ]]</code>，返回<code>false</code>，因为左侧字符串不包含数字。</li></ul></li><li><p>bash的组合测试条件</p><ul><li>判断某文件是否是<code>.sh</code>结尾并且可执行，<code>file=./test.sh; [[ $file =~ \.sh$ ]] &amp;&amp; [ -x $file ]</code> ，也可以这样写<code>[ &quot;$file =~ \.sh$&quot; -a &quot;-x $file&quot; ]</code>即使用<code>-a</code>选项。</li><li><code>[ EXPRESSION1 -a EXPRESSION2 ]</code>表示与，<code>[ EXPRESSION1 -o EXPRESSION2 ]</code>表示或。</li></ul></li></ul></li><li><p><code>read</code>：从标准输入读一行，例如<code>read -p &quot; Please input your name&quot; NAME</code>，则用户输入的值赋给<code>NAME</code>变量。</p><ul><li><code>-p</code>：指定要显示的提示</li><li><code>-s</code>：静默输入，一般用于密码</li><li><code>-n N</code>：指定输入的字符长度N</li><li><code>-d &#39;字符&#39;</code>：输入中出现该字符即结束输入。</li><li><code>-t N</code>：超时时长N秒</li></ul></li></ul><h3 id="四、条件分支"><a href="#四、条件分支" class="headerlink" title="四、条件分支"></a>四、条件分支</h3><ul><li><p>```<br>if [ EXPRESSION ];then</p><pre><code>条件为真的分支代码</code></pre><p>else</p><pre><code>条件为假的分支代码</code></pre><p>fi</p><h1 id="或者"><a href="#或者" class="headerlink" title="或者"></a>或者</h1><p>if [  ];then<br>   xxxxx<br>elif [  ];then<br>   xxxxx<br>elif [  ];then<br>   xxxxx<br>…….<br>else<br>   yyyyy<br>fi</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- ```shell</span><br><span class="line">  case $NUM in</span><br><span class="line">  1|3|5)</span><br><span class="line">     cmd1</span><br><span class="line">     ;;</span><br><span class="line">  2|4|6)</span><br><span class="line">     cmd2</span><br><span class="line">     ;;</span><br><span class="line">  ...</span><br><span class="line">  *)</span><br><span class="line">     cmdN</span><br><span class="line">     ;;</span><br><span class="line">  esac</span><br></pre></td></tr></table></figure></li></ul><h3 id="五、脚本安全"><a href="#五、脚本安全" class="headerlink" title="五、脚本安全"></a>五、脚本安全</h3><ul><li><code>set -u</code>：在脚本前加上该语句，在引用一个未设置的变量时，显示错误信息，并且不执行含有未设置变量的语句。</li><li><code>set -e</code>：如果一个命令执行失败就退出脚本。</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;一、shell脚本基础&quot;&gt;&lt;a href=&quot;#一、shell脚本基础&quot; class=&quot;headerlink&quot; title=&quot;一、shell脚本基础&quot;&gt;&lt;/a&gt;一、shell脚本基础&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;shell：解释型语言&lt;/li&gt;
&lt;li&gt;在脚本首行需注
      
    
    </summary>
    
    
      <category term="shell编程" scheme="http://thmasterplan.cn/categories/shell%E7%BC%96%E7%A8%8B/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
      <category term="shell编程" scheme="http://thmasterplan.cn/tags/shell%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="http://thmasterplan.cn/regex/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://thmasterplan.cn/regex/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</id>
    <published>2019-11-20T07:16:10.000Z</published>
    <updated>2019-11-23T13:25:39.521Z</updated>
    
    <content type="html"><![CDATA[<h3 id="元字符分类：字符匹配、匹配次数、位置锚定、分组"><a href="#元字符分类：字符匹配、匹配次数、位置锚定、分组" class="headerlink" title="元字符分类：字符匹配、匹配次数、位置锚定、分组"></a>元字符分类：字符匹配、匹配次数、位置锚定、分组</h3><h4 id="字符匹配"><a href="#字符匹配" class="headerlink" title="字符匹配"></a>字符匹配</h4><ul><li><code>.</code>：匹配任意单个字符</li><li><code>\</code>：转义字符，例如<code>\.</code>表示匹配<code>.</code>本身而非任意单个字符。</li><li><code>[]</code>：匹配指定范围内任意<strong>单个</strong>字符</li><li><code>[^]</code>：匹配指定范围外的任意<strong>单个</strong>字符</li><li><code>[:alnum:]</code>：字母和数字</li><li><code>[:alpha:]</code>：任何英文大小写字符</li><li><code>[:lower:]</code>：小写字母</li><li><code>[:upper:]</code>：大写字母</li><li><code>[:digit:]</code>：十进制数字</li><li><code>[:xdigit:]</code>：十六进制数字</li><li><code>[:blank:]</code>：空白字符（空格和制表符）</li><li><code>[:space:]</code>：水平和垂直的空白字符</li><li><code>[:cntrl:]</code>：不可打印的控制字符（退格、删除等）</li><li><code>[:graph:]</code>：可打印的非空白字符</li><li><code>[:print:]</code>：可打印字符</li><li><code>[:punct:]</code>：标点符号</li></ul><h4 id="匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数"><a href="#匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数" class="headerlink" title="匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数"></a>匹配次数：用在用指定次数的字符后面，指定前面的字符出现的次数</h4><ul><li><code>*</code>：匹配前面的字符0或多次。注意与文件名通配符里<code>*</code>的区别。</li><li><code>.*</code>：任意长度的任意字符。</li><li><code>\?</code>：匹配前面的字符0或1次。</li><li><code>\+</code>：匹配前面的字符至少1次。</li><li><code>\{n\}</code>：匹配前面的字符n次。</li><li><code>\{m,n\}</code>：匹配前面的字符至少m次，至多n次。</li><li><code>\{,n\}</code>：匹配前面的字符至多n次。</li><li><code>\{n,\}</code>：匹配前面的字符至少n次。</li></ul><h4 id="位置锚定：定位出现的位置"><a href="#位置锚定：定位出现的位置" class="headerlink" title="位置锚定：定位出现的位置"></a>位置锚定：定位出现的位置</h4><ul><li><code>^</code>：行首锚定，用于模式的最左侧。例如<code>grep ^[^#] xxx</code>表示显示xxx中所有非#开头的行，即显示非注释行。</li><li><code>$</code>：行尾锚定，用于模式的最右侧。 </li><li><code>^PATTERN$</code>：用于模式匹配整行。<code>^$</code>可表示空行。</li><li><code>\b</code>：词首或词尾锚定，用于单词模式的左/右侧。</li></ul><h4 id="分组："><a href="#分组：" class="headerlink" title="分组：\(\)"></a>分组：<code>\(\)</code></h4><ul><li><code>\(string\)</code>：其中<code>string</code>会被正则表达式引擎记录与内部的变量中，这些变量的命名方式为：<code>\1,\2,\3,...</code>。</li><li>示例：<code>\(string1\(string2\)\)</code>：<code>\1</code>：<code>string1\(string2\)</code>；<code>\2</code>：<code>string2</code>。</li><li>例如：<code>\(root\)\{1,3\}</code>：可匹配1-3个<code>root</code>字符串。</li></ul><h4 id="扩展的正则表达式：-去掉"><a href="#扩展的正则表达式：-去掉" class="headerlink" title="扩展的正则表达式： 去掉\"></a>扩展的正则表达式： 去掉<code>\</code></h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;元字符分类：字符匹配、匹配次数、位置锚定、分组&quot;&gt;&lt;a href=&quot;#元字符分类：字符匹配、匹配次数、位置锚定、分组&quot; class=&quot;headerlink&quot; title=&quot;元字符分类：字符匹配、匹配次数、位置锚定、分组&quot;&gt;&lt;/a&gt;元字符分类：字符匹配、匹配次数、位
      
    
    </summary>
    
    
      <category term="regex" scheme="http://thmasterplan.cn/categories/regex/"/>
    
    
      <category term="regex" scheme="http://thmasterplan.cn/tags/regex/"/>
    
  </entry>
  
  <entry>
    <title>常见文本处理命令</title>
    <link href="http://thmasterplan.cn/Linux/%E5%B8%B8%E8%A7%81%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/"/>
    <id>http://thmasterplan.cn/Linux/%E5%B8%B8%E8%A7%81%E6%96%87%E6%9C%AC%E5%A4%84%E7%90%86%E5%91%BD%E4%BB%A4/</id>
    <published>2019-11-19T11:49:20.000Z</published>
    <updated>2019-11-26T14:20:37.984Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p>查看文本内容：</p><ul><li><p><code>cat</code>：适合查看小文本</p><ul><li><code>-E</code>：显示行结束符<code>$</code></li><li><code>-n</code>：对显示的每一行编号</li><li><code>-A</code>：显示所有控制符</li></ul></li><li><p><code>tac</code>：从最后一行向前反向显示</p></li><li><code>rev</code>：每一行都是反向显示</li><li><code>more、less</code>：分页查看</li></ul></li><li><p>文本截取：</p><ul><li><code>head</code><ul><li><code>-c#</code>：获取前<code>#</code>字节</li><li><code>-#</code>：获取前<code>#</code>行</li></ul></li><li><code>tail</code><ul><li><code>-c#</code>：获取后<code>#</code>字节</li><li><code>-#</code>：获取后<code>#</code>行</li><li><code>-f</code>：可用于日志监控，例如<code>tail -f /var/log/messages</code>，即时显示日志追加文本的变化。</li></ul></li></ul></li><li><p>按列抽取：</p><ul><li><code>cut</code>：<code>cut -d# -f1,3</code>：以<code>#</code>作为分隔符，截取第1列和第3列<ul><li><code>-d</code>：指明分隔符</li><li><code>-f</code>：指明字段</li></ul></li><li>练习：获取网卡ip地址：<code>ifconfig ens33  | head -2 | tail -1 | tr -s &quot; &quot; | cut -d&quot; &quot; -f3</code></li></ul></li><li><p>排序和统计：</p><ul><li><p>文本排序<code>sort</code>：把排序后的文本显示在STDOUT，不改变原始文件</p><ul><li><code>-n</code>：按照数字大小排序</li><li><code>-r</code>：反向排序</li><li><p><code>-u</code>：删除重复行</p></li><li><p><code>-t#</code>：<code>#</code>作为字段界定符</p></li><li><code>-kX</code>：选项按照使用<code>#</code>分隔的第<code>X</code>列来排序</li></ul></li><li><p><code>uniq</code>：删除连续重复的行</p><ul><li><code>-c</code>：显示重复出现的行的次数，常与<code>sort</code>命令一起使用；<code>sort a.txt| uniq -c</code>。</li></ul></li><li><p>文本数据统计<code>wc</code>：</p><ul><li><code>wc test.txt</code>：依次输出行数，单词数，字节数</li><li><code>-l</code>：只计数行数</li><li><code>-w</code>：只计数单词数</li><li><code>-c</code>：只计数字节数</li><li><code>-m</code>：只计数字符总数</li><li><code>-L</code>：显示文件中最长行的长度</li></ul></li><li><p>比较文件：<code>diff和patch</code></p></li></ul></li><li><p>按关键字抽取：</p><ul><li><code>grep</code>：<code>grep [选项] 模式 file</code>文本搜索工具，根据指定<code>模式[由正则表达式字符及文本字符所编写的过滤条件]</code>对目标文本逐行进行匹配检查，打印匹配到的行。</li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ul&gt;
&lt;li&gt;&lt;p&gt;查看文本内容：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;cat&lt;/code&gt;：适合查看小文本&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;-E&lt;/code&gt;：显示行结束符&lt;code&gt;$&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;-n&lt;/code&gt;：对显示的
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://thmasterplan.cn/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>java位运算</title>
    <link href="http://thmasterplan.cn/JAVA/java%E4%BD%8D%E8%BF%90%E7%AE%97/"/>
    <id>http://thmasterplan.cn/JAVA/java%E4%BD%8D%E8%BF%90%E7%AE%97/</id>
    <published>2019-11-19T10:25:55.000Z</published>
    <updated>2019-11-24T12:45:33.112Z</updated>
    
    <content type="html"><![CDATA[<h3 id="JAVA位运算符"><a href="#JAVA位运算符" class="headerlink" title="JAVA位运算符"></a>JAVA位运算符</h3><ol><li>&amp; ：按位与。同时为1才为1，否则为0。</li><li>| ：按位或。有一个为1则为1。</li><li>~ ：按位取反。例如3：补码：0b00000000000000000000000000000011。~3—&gt;得:0b11111111111111111111111111111100。(依旧为补码)。减一后取反得原码(原码-&gt;补码的逆运算)：0b1000000000000000000000000000100。故3取反后为-4。</li><li>^ ：按位异或。不同为1，相同为0。<ul><li>一个数据对相同的数据异或两次，值不变,常应用于加密。即a^b^b == a。</li><li>使用异或实现两个变量值交换。a = a^b; b = a^b; a = a^b。</li></ul></li><li>&lt;&lt; ：左移。左操作数乘以2的n次幂。n是右操作数，即左移的位数。右边空出两位补0，左边两位被挤掉。</li><li><strong>&gt;&gt;</strong> ：右移。左操作数除以2的n次幂。n是右操作数，即右移的位数。左边空出两位用符号位填充，右边两位被挤掉。<ul><li>例如：-32 &gt;&gt; 2 ：原码：10000000000000000000000000100000，反码：11111111111111111111111111011111，补码：11111111111111111111111111100000。右移后为：11111111111111111111111111111000。求得原码为：10000000000000000000000000001000。得-8。</li></ul></li><li><strong>&gt;&gt;&gt;</strong> ：<strong>无符号右移</strong>。左边空出的位置用0补全。例如-32 &gt;&gt;&gt; 2变成一个很大的正数。</li><li>位运算均针对<strong>补码</strong>进行。正数的符号位为0，原、反、补码均为其本身；负数的符号位为1，其反码为对原码除符号位其余所有位求反，补码为对反码+1。</li><li>对于有符号数，计算机中存储的是<strong>补码</strong>。</li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;JAVA位运算符&quot;&gt;&lt;a href=&quot;#JAVA位运算符&quot; class=&quot;headerlink&quot; title=&quot;JAVA位运算符&quot;&gt;&lt;/a&gt;JAVA位运算符&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;&amp;amp; ：按位与。同时为1才为1，否则为0。&lt;/li&gt;
&lt;li&gt;| ：按位或
      
    
    </summary>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/categories/JAVA/"/>
    
    
      <category term="JAVA" scheme="http://thmasterplan.cn/tags/JAVA/"/>
    
  </entry>
  
</feed>
